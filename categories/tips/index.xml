<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tips on dotstudio（ドットスタジオ）</title><link>https://dotstud.io/categories/tips/</link><description>Recent content in tips on dotstudio（ドットスタジオ）</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>© 2018 dotstudio inc.</copyright><lastBuildDate>Tue, 12 Feb 2019 12:20:03 +0900</lastBuildDate><atom:link href="/categories/tips/" rel="self" type="application/rss+xml"/><item><title>CloudflareのAPIをNode.js+GitLab CIから実行してキャッシュクリアしてみよう</title><link>https://dotstud.io/blog/cloudflare-cache-clear-nodejs/</link><pubDate>Tue, 12 Feb 2019 12:20:03 +0900</pubDate><guid>https://dotstud.io/blog/cloudflare-cache-clear-nodejs/</guid><description>&lt;p>こんにちは、&lt;a href="https://dotstud.io/members/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>過去にも書いているように、dotstudioでは&lt;a href="https://cloudflare.com">Cloudflare&lt;/a>を使っています。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>無料で使えて便利なのですが、&lt;!-- raw HTML omitted -->キャッシュが強くて中々更新されないといった現象&lt;!-- raw HTML omitted -->があります。&lt;/p>
&lt;p>調べてみるとCloudflareのAPIでキャッシュクリアが出来るみたいだったのでNode.jsで叩きつつデプロイ時のCIタスクに乗せてみました。&lt;/p>
&lt;h2 id="heading">今回の環境&lt;/h2>
&lt;p>参考までに今回の筆者の環境です。&lt;/p>
&lt;ul>
&lt;li>macOS 10.14 Mojave&lt;/li>
&lt;li>Node.js v11.9.0&lt;/li>
&lt;li>npm 6.7.0&lt;/li>
&lt;/ul>
&lt;h2 id="cloudflare">Cloudflareでのキャッシュクリア方法&lt;/h2>
&lt;p>APIを使わない場合は、ページから直接削除できます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/242/1.png" alt="">&lt;/p>
&lt;p>Custom Purgeのボタンを押すと、モーダルウィンドウが出てくるのでキャッシュクリアしたいドメインやページを指定しましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/242/2.png" alt="">&lt;/p>
&lt;p>こんな感じの指定が出来ます。&lt;/p>
&lt;ul>
&lt;li>&lt;code>https://dotstud.io&lt;/code>のようにメインドメイン指定が出来ます。&lt;/li>
&lt;li>&lt;code>https://hogehoge.dotstud.io&lt;/code>のようにサブドメインでも大丈夫です。&lt;/li>
&lt;li>&lt;code>https://hogehoge.dotstud.io/hoge.html&lt;/code>のようにファイル指定も可能です。&lt;/li>
&lt;/ul>
&lt;p>記述したら&lt;code>Purge&lt;/code>ボタンを押してキャッシュクリアです。&lt;/p>
&lt;p>確認する際ですが、ブラウザ側のキャッシュが残ってしまってる可能性もあるので、ブラウザのシークレットモードなどでページを開いてあげると確実だと思います。&lt;/p>
&lt;h2 id="apicloudflare">API経由でCloudflareのキャッシュをクリア&lt;/h2>
&lt;p>デプロイ時にキャッシュクリアをしたいので、API経由でキャッシュクリアをしてみましょう。&lt;/p>
&lt;h3 id="cloudflareapi-">CloudflareのAPI キーの取得&lt;/h3>
&lt;p>まずはAPIキーを取得します。右上のユーザーアイコンから&lt;code>My Profile&lt;/code>を選択し、ページ下部のAPI Keysの箇所を確認します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/242/3.png" alt="">&lt;/p>
&lt;p>Global API KeyのViewボタンを押すとパスワード入力を求められるので、パスワードを入力するとAPIキーが表示されます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/242/4.png" alt="">&lt;/p>
&lt;h3 id="apicurl">APIキーを使ってcurlでキャッシュクリアをしてみる&lt;/h3>
&lt;p>参考記事を元に試してみます。最初からNode.jsでやりたい人はスキップでOKです。&lt;/p>
&lt;blockquote>
&lt;p>参考: &lt;a href="https://blog.mosuke.tech/entry/2017/05/29/how_to_use_cloudflare_api/">CloudFlare APIを使ってキャッシュを削除する&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>CloudflareのAPIの呼び出しはヘッダーには&lt;code>X-Auth-Email&lt;/code>と&lt;code>X-Auth-Key&lt;/code>の指定、&lt;code>Content-Type: application/json&lt;/code>の指定をする必要があります。&lt;/p>
&lt;p>手順としては大きく分けて2つSTEPです。&lt;/p>
&lt;ul>
&lt;li>STEP1. ZONE IDと呼ばれるIDを取得&lt;/li>
&lt;li>STEP2. ZONE IDを使ってキャッシュクリア&lt;/li>
&lt;/ul>
&lt;p>以下のコマンドをターミナルなどで実行してみましょう。&lt;/p>
&lt;h4 id="step1-zone-idid">STEP1. ZONE IDと呼ばれるIDを取得&lt;/h4>
&lt;p>まずはZONE　IDの取得です。以下のコマンドで取得できます。&lt;/p>
&lt;p>&lt;code>curl -s -X GET &amp;quot;https://api.cloudflare.com/client/v4/zones?name=&amp;lt;MY DOMAIN&amp;gt;&amp;quot; -H &amp;quot;X-Auth-Email: &amp;lt;MY EMAIL&amp;gt;&amp;quot; -H &amp;quot;X-Auth-Key: &amp;lt;MY API KEY&amp;gt;&amp;quot; -H &amp;quot;Content-Type: application/json&amp;quot;&lt;/code>&lt;/p>
&lt;p>&lt;strong>&lt;code>&amp;lt;MY DOMAIN&amp;gt;&lt;/code>、&lt;code>&amp;lt;MY EMAIL&amp;gt;&lt;/code>、&lt;code>&amp;lt;MY API KEY&amp;gt;&lt;/code>の箇所を適宜変更して実行して下さい。&lt;/strong>&lt;/p>
&lt;p>それぞれ、自分が管理しているドメイン、登録しているメールアドレス、先ほど取得したAPIキーです。&lt;/p>
&lt;ul>
&lt;li>実行例&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>curl -s -X GET &amp;quot;https://api.cloudflare.com/client/v4/zones?name=dotstud.io&amp;quot; \
-H &amp;quot;X-Auth-Email: hogehoge@gmail.com&amp;quot; \
-H &amp;quot;X-Auth-Key: xxxxxxxxxxxxxxxx&amp;quot; \
-H &amp;quot;Content-Type: application/json&amp;quot;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>ZONE ID&lt;/li>
&lt;/ul>
&lt;p>コマンドを実行してエラーがなければ、JSONがかえってきます。ここのidの値がZONE IDになります。&lt;/p>
&lt;pre>&lt;code>{&amp;quot;result&amp;quot;:[{&amp;quot;id&amp;quot;:&amp;quot;yyyyyyyyyyyyyyyyyyyy&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;dotstud.io&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;active&amp;quot;,&amp;quot;paused&amp;quot;:false,&amp;quot;type&amp;quot;:&amp;quot;full&amp;quot;, (......以下省略)
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://dotstud.io/img/blog/242/5.png" alt="">&lt;/p>
&lt;h4 id="step2-zone-id">STEP2. ZONE IDを使ってキャッシュクリア&lt;/h4>
&lt;p>次にZONE IDを使ってキャッシュクリアです。&lt;/p>
&lt;p>&lt;code>curl -X DELETE &amp;quot;https://api.cloudflare.com/client/v4/zones/&amp;lt;ZONE ID&amp;gt;/purge_cache&amp;quot; -H &amp;quot;Content-Type:application/json&amp;quot; -H &amp;quot;X-Auth-Key: &amp;lt;MY EMAIL&amp;gt;&amp;quot; -H &amp;quot;X-Auth-Email: &amp;lt;MY API KEY&amp;gt;&amp;quot; --data '{&amp;quot;files&amp;quot;:[&amp;quot;&amp;lt;TARGET&amp;gt;&amp;quot;]}'&lt;/code>&lt;/p>
&lt;p>先ほどと同様に適宜変更します。&lt;/p>
&lt;p>&lt;strong>&lt;code>&amp;lt;ZONE ID&amp;gt;&lt;/code>、&lt;code>&amp;lt;MY EMAIL&amp;gt;&lt;/code>、&lt;code>&amp;lt;MY API KEY&amp;gt;&lt;/code>、&lt;code>&amp;lt;TARGET&amp;gt;&lt;/code>の箇所を適宜変更して実行して下さい。&lt;/strong>&lt;/p>
&lt;p>&lt;code>&amp;lt;ZONE ID&amp;gt;&lt;/code>はSTEP1で取得したZONE IDで、&lt;code>&amp;lt;TARGET&amp;gt;&lt;/code>はキャッシュクリアさせたいドメインやファイル名の指定です。最初にAPI利用なしでCloudflareのサイト上でキャッシュクリアをした時に指定したときと同様の指定ができます。&lt;/p>
&lt;ul>
&lt;li>実行例&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>curl -X DELETE &amp;quot;https://api.cloudflare.com/client/v4/zones/yyyyyyyyyyyyyyyyyyyy/purge_cache&amp;quot; \
-H &amp;quot;Content-Type:application/json&amp;quot; \
-H &amp;quot;X-Auth-Key: xxxxxxxxxxxxxxxx&amp;quot; \
-H &amp;quot;X-Auth-Email: hogehoge@gmail.com&amp;quot; \
--data '{&amp;quot;files&amp;quot;:[&amp;quot;https://hogehoge.dotstud.io/&amp;quot;]}'
&lt;/code>&lt;/pre>&lt;p>成功すると以下のようなレスポンスがあり、キャッシュがクリアされます。&lt;/p>
&lt;pre>&lt;code>{&amp;quot;result&amp;quot;:{&amp;quot;id&amp;quot;:&amp;quot;yyyyyyyyyyyyyyyyyyyy&amp;quot;},&amp;quot;success&amp;quot;:true,&amp;quot;errors&amp;quot;:[],&amp;quot;messages&amp;quot;:[]}%
&lt;/code>&lt;/pre>&lt;h3 id="nodejsapi">Node.jsでAPIを叩いてみる&lt;/h3>
&lt;p>まずはフォルダやファイルの準備をしましょう。
mycfフォルダ内に&lt;code>purge_cache.js&lt;/code>というファイルを作成します。&lt;/p>
&lt;pre>&lt;code>mkdir mycf
cd mycf
touch purge_cache.js
&lt;/code>&lt;/pre>&lt;p>HTTPリクエストを利用する為に&lt;a href="https://www.npmjs.com/package/axios">axios&lt;/a>をインストールします。&lt;/p>
&lt;pre>&lt;code>npm init -y
npm i axios
&lt;/code>&lt;/pre>&lt;p>&lt;code>purge_cache.js&lt;/code>に以下の内容をコピペして、&lt;code>YOUREMAIL&lt;/code>、&lt;code>APIKEY&lt;/code>、&lt;code>PURGE_TARGETS&lt;/code>を適宜書き換えましょう。&lt;/p>
&lt;pre>&lt;code>'use strict';
const YOUREMAIL = `hogehoge@gmail.com`; //Cloudflareに登録してるメールアドレス
const APIKEY = `xxxxxxxxxxxxxxxxx`; //CloudflareのAPI KEY
const PURGE_TARGETS = [`https://hogehoge.dotstud.io`]; //消す対象ページ
const axiosBase = require('axios');
const axios = axiosBase.create({
baseURL: `https://api.cloudflare.com/client/v4/zones`,
headers: {
'Content-Type': 'application/json',
'X-Auth-Key': APIKEY,
'X-Auth-Email': YOUREMAIL
}
})
const main = async() =&amp;gt; {
try {
//STEP1. ZoneIDの取得
let res = await axios.get('/');
const zoneid = res.data.result[0].id;
//STEP2. キャッシュ削除
res = await axios.delete(`/${zoneid}/purge_cache`,{
data: {
files: PURGE_TARGETS
}
});
console.log(res.data);
} catch (error) {
console.log(error.response.data)
}
}
main();
&lt;/code>&lt;/pre>&lt;p>実行します。エラーが出なければこれでキャッシュクリアされます。&lt;/p>
&lt;pre>&lt;code>node purge_cache.js
&lt;/code>&lt;/pre>&lt;p>これでNode.jsからCloudflareのキャッシュクリアをすることが出来ました。&lt;/p>
&lt;h2 id="gitlab-ci">GitLab CIのタスクで実行する&lt;/h2>
&lt;p>実際にデプロイした際にキャッシュクリアされるようにしたいのでGitLab CIのタスクに入れ込みました。&lt;/p>
&lt;h3 id="heading-1">ソースコードの変更&lt;/h3>
&lt;p>先ほどソースコード上に書いていた&lt;code>YOUREMAIL&lt;/code>などの値は環境変数から取得するように&lt;code>purge_cache.js&lt;/code>を変更しました。また、最後(STEP3)にDiscordにデプロイ成功を通知する処理も追加しています。&lt;/p>
&lt;pre>&lt;code>'use strict';
if(!process.env.YOUREMAIL || !process.env.APIKEY || !process.env.PURGE_TARGET){
console.log('環境変数が足りません');
return;
}
const YOUREMAIL = process.env.YOUREMAIL; //Cloudflareに登録してるメールアドレス
const APIKEY = process.env.APIKEY; //CloudflareのAPI KEY
const PURGE_TARGETS = [process.env.PURGE_TARGET]; //消す対象ページ
const axiosBase = require('axios');
const axios = axiosBase.create({
baseURL: `https://api.cloudflare.com/client/v4/zones`,
headers: {
'Content-Type': 'application/json',
'X-Auth-Key': APIKEY,
'X-Auth-Email': YOUREMAIL
}
})
const main = async() =&amp;gt; {
try {
//STEP1. ZoneIDの取得
let res = await axios.get('/');
const zoneid = res.data.result[0].id;
//STEP2. キャッシュ削除
res = await axios.delete(`/${zoneid}/purge_cache`,{
data: {
files: PURGE_TARGETS
}
});
console.log(res.data);
//STEP3. Discordへ通知
res = await axiosBase.post(process.env.DISCORD_WEBHOOK_URL,{
content: 'デプロイ成功 &amp;amp; キャッシュクリア'
});
console.log(res.data);
} catch (error) {
console.log(error.response.data)
}
}
main();
&lt;/code>&lt;/pre>&lt;h3 id="packagejson">package.jsonの変更&lt;/h3>
&lt;p>また、先日書いた記事にもあるような、VuePressのデプロイフローに今回のタスクを乗せていきます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;code>package.json&lt;/code>に&lt;code>ci:purge_cache&lt;/code>を追加して&lt;code>purge_cache.js&lt;/code>を実行するスクリプトを追加します。&lt;/p>
&lt;pre>&lt;code>(省略)
&amp;quot;scripts&amp;quot;: {
&amp;quot;dev&amp;quot;: &amp;quot;vuepress dev docs&amp;quot;,
&amp;quot;build&amp;quot;: &amp;quot;vuepress build docs&amp;quot;,
&amp;quot;ci:purge_cache&amp;quot;: &amp;quot;node purge_cache.js&amp;quot;,
},
(省略)
&lt;/code>&lt;/pre>&lt;h3 id="gitlab-ciyml">.gitlab-ci.ymlの変更&lt;/h3>
&lt;p>GitLab CIの挙動として&lt;code>.gitlab-ci.yml&lt;/code>の記述は以下のようにしています。&lt;/p>
&lt;p>&lt;code>after_script&lt;/code>の箇所で&lt;code>npm run ci:purge_cache&lt;/code>をすることで、デプロイが終わった後に&lt;code>purge_cache.js&lt;/code>が実行されてキャッシュクリアがされます。&lt;/p>
&lt;pre>&lt;code>image: node:current-alpine
pages:
cache:
paths:
- node_modules/
before_script:
- node -v
- npm i
script:
- npm run build
- cp docs/robots.txt docs/.vuepress/dist #限定公開の場合
- cp -pr docs/.vuepress/dist public
after_script:
- npm run ci:purge_cache #Cloudflareのキャッシュクリア &amp;amp; Discordへ通知
artifacts:
paths:
- public
only:
- master
&lt;/code>&lt;/pre>&lt;h3 id="heading-2">環境変数の登録&lt;/h3>
&lt;p>GitLabのリポジトリから環境変数を追加することができます。&lt;/p>
&lt;p>リポジトリの&lt;code>Settings&amp;gt;CI/CD&lt;/code>から&lt;code>Environment variables&lt;/code>の箇所を開きます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/242/6.png" alt="">&lt;/p>
&lt;p>各値を名前をソースコードに記述した変数名と一致させつつ設定しましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/242/7.png" alt="">&lt;/p>
&lt;h2 id="heading-3">まとめ&lt;/h2>
&lt;p>ここまでの手順が出来るとデプロイするたびに、Cloudflareのキャッシュがクリアされて、なかなか更新されない問題が解消できると思います。&lt;/p>
&lt;p>これでもページが更新されない場合はブラウザ側でキャッシュされている可能性が高いのでシークレットモードなどで確認したり、ブラウザを変えてみるのがベターだと思います。&lt;/p>
&lt;p>キャッシュコントロールをしてCloudflareをもっと便利に使っていきましょう。&lt;/p>
&lt;p>それでは！&lt;/p></description></item><item><title>VuePressのブログをカスタムドメイン+SSL対応させたGitLab Pagesにデプロイする</title><link>https://dotstud.io/blog/gitlab-vuepress-custom-domain/</link><pubDate>Wed, 30 Jan 2019 10:47:09 +0900</pubDate><guid>https://dotstud.io/blog/gitlab-vuepress-custom-domain/</guid><description>&lt;p>こんにちは、最近スパにハマっている&lt;a href="https://twitter.com/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>今日はタイトル通り&lt;strong>VuePressで作ったブログをGitLab Pagesに乗せてカスタムドメイン+SSL対応していきます。&lt;/strong> 2019年1月時点版です。UIなどはガンガン変わっていくと思いますので適宜読み替えましょう。&lt;/p>
&lt;p>過去に書いたこの記事とは別のサイトの運用話です。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>気持ち的にHugoブログもVuePressに移行したいと思っている感じですね。&lt;/p>
&lt;h2 id="gitlab-pages">GitLab Pagesの基本&lt;/h2>
&lt;p>GitLab PagesはGitLabで利用できる無料ホスティング環境です。&lt;/p>
&lt;p>GitHub PagesのGitLab版って認識で大丈夫です。&lt;/p>
&lt;h3 id="gitlab-pages-1">GitLab Pagesでサイト公開の仕方&lt;/h3>
&lt;ul>
&lt;li>publicフォルダを作成します。&lt;/li>
&lt;/ul>
&lt;p>リポジトリのルートに&lt;code>public&lt;/code>フォルダを作成して、その中にindex.htmlや関連するcssやjsファイルなどを入れていきます。基本的には&lt;code>public/index.html&lt;/code>がプロジェクトのトップページとして認識されます。&lt;/p>
&lt;ul>
&lt;li>.gitlab-ci.ymlを作成します。&lt;/li>
&lt;/ul>
&lt;p>リポジトリのルート（&lt;code>public&lt;/code>フォルダと同じ階層）に&lt;code>.gitlab-ci.yml&lt;/code>を作成します。&lt;/p>
&lt;pre>&lt;code>pages:
stage: deploy
script:
- echo 'Nothing to do...'
artifacts:
paths:
- public
only:
- master
&lt;/code>&lt;/pre>&lt;p>あとはGitLabのリポジトリにプッシュするだけです。
この場合masterブランチにプッシュすると更新されます。&lt;/p>
&lt;p>ファイル構成はイメージはこんな感じです。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/1.png" alt="">&lt;/p>
&lt;p>&lt;code>.gitlab-ci.yml&lt;/code>がある状態でGitLabのリポジトリにプッシュするとCIが動いてごにょごにょやってくれます。&lt;/p>
&lt;ul>
&lt;li>https://&amp;lt;ユーザー名&amp;gt;.gitlab.io/&amp;lt;リポジトリ名&amp;gt; にアクセス&lt;/li>
&lt;/ul>
&lt;p>&lt;code>https://&amp;lt;ユーザー名&amp;gt;.gitlab.io/&amp;lt;リポジトリ名&amp;gt;&lt;/code>が公開URLです。&lt;/p>
&lt;p>GitLabのリポジトリのURLが&lt;code>https://gitlab.com/&amp;lt;ユーザー名&amp;gt;/&amp;lt;リポジトリ名&amp;gt;&lt;/code>となっているので適宜読み替えましょう。&lt;/p>
&lt;p>&lt;strong>例えば、リポジトリのURLが&lt;code>https://gitlab.com/n0bisuke/akihabara&lt;/code>だとしたら、公開用のGitLab PagesのURLは&lt;code>https://n0bisuke.gitlab.io/akihabara&lt;/code>になります。&lt;/strong>&lt;/p>
&lt;p>プッシュしてから更新まで数分時間が掛かることがあるので少し経ってからまた確認してみましょう。&lt;/p>
&lt;p>うまくいかない場合は&lt;code>https://gitlab.com/&amp;lt;ユーザー名&amp;gt;/&amp;lt;リポジトリ名&amp;gt;/-/jobs&lt;/code>に行くとジョブの確認が出来るので、エラーなどを確認してみましょう。&lt;/p>
&lt;h2 id="vuepressgitlab-pages">VuePressをGitLab Pagesにデプロイ&lt;/h2>
&lt;p>先ほどの利用したGitLab CIを利用します。&lt;/p>
&lt;p>&lt;a href="https://vuepress.vuejs.org/">VuePress&lt;/a>はVue.jsの作者が作ったVue.js製の静的サイトジェネレータです。&lt;/p>
&lt;p>公式のドキュメントに、&lt;a href="https://vuepress.vuejs.org/guide/deploy.html#gitlab-pages-and-gitlab-ci">VuePressをGitLab PagesとGitLab CIにデプロイする方法&lt;/a>が載っていますが、個人的には以下の2ステップだけで問題ないと思います。&lt;/p>
&lt;h3 id="1-vuepressconfigjs">1. VuePressのconfig.jsの設定&lt;/h3>
&lt;p>&lt;code>docs/.vuepress/config.js&lt;/code>の中に&lt;code>base&lt;/code>というキーがあります。
ここにリポジトリ名をパスとして設定してあげます。&lt;/p>
&lt;p>例えば&lt;code>https://gitlab.com/n0bisuke/hogehoge&lt;/code>というリポジトリで&lt;code>https://n0bisuke.gitlab.io/hogehoge&lt;/code>という公開URLになる場合は、&lt;code>base&lt;/code>の箇所を&lt;code>/hogehoge/&lt;/code>にしましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/2.png" alt="">&lt;/p>
&lt;p>後述しますが、もし、この後の手順のカスタムドメインまでを設定するならばここの&lt;code>base&lt;/code>は&lt;code>/&lt;/code>の設定のままで大丈夫です。&lt;/p>
&lt;h3 id="2-gitlab-ciyml">2. &lt;code>.gitlab-ci.yml&lt;/code>の記述&lt;/h3>
&lt;p>以下のyml記述だけで完了です。プッシュして&lt;code>https://n0bisuke.gitlab.io/hogehoge&lt;/code>(自分の環境に読み替え)などにアクセスして確認しましょう。&lt;/p>
&lt;pre>&lt;code>image: node:current-alpine
pages:
cache:
paths:
- node_modules/
before_script:
- node -v
- npm i
script:
- npm run docs:build
- cp -pr docs/.vuepress/dist public
artifacts:
paths:
- public
only:
- master
&lt;/code>&lt;/pre>&lt;p>デフォルトのチュートリアル通りだとビルドのコマンドが&lt;code>npm run docs:build&lt;/code>になっているはずなので、プッシュするとCI環境側で&lt;code>npm run docs:build&lt;/code>でビルドして、ビルド後のdistフォルダをpublicフォルダにコピー、その後publicフォルダをGitLab Pagesとしてデプロイします。&lt;/p>
&lt;p>公式ドキュメントにはビルド先のフォルダをdistではなくpublicにする設定などがありましたが、この記述でも問題ないです。&lt;/p>
&lt;h2 id="--ssl">カスタムドメインの利用 &amp;amp; SSL対応&lt;/h2>
&lt;p>現状で、&lt;code>https://n0bisuke.gitlab.io/hogehoge&lt;/code>というアドレスが公開URLになっているものを&lt;code>https://hogehoge.dotstud.io&lt;/code>でアクセスさせるようにしていきます。&lt;/p>
&lt;p>&lt;a href="https://www.cloudflare.com/">Cloudflare&lt;/a>を利用します。&lt;/p>
&lt;p>&lt;a href="https://letsencrypt.org/">Let's Encrypt&lt;/a>を利用する手もあるのですが、更新の手間があるのと既にdotstud.ioでCloudflareを使ってDNSやSSL設定をしていたので&lt;strong>Cloudflareを利用してのGitLab Pagesのカスタムドメイン&amp;amp;SSL対応を紹介&lt;/strong>します。&lt;/p>
&lt;p>GitLab公式の&lt;a href="https://about.gitlab.com/2017/02/07/setting-up-gitlab-pages-with-cloudflare-certificates/">Setting up GitLab Pages with CloudFlare Certificates&lt;/a>を見ながら試してみました。&lt;/p>
&lt;p>&lt;strong>DNSのAレコードをGitLab Pagesに向けることも出来るみたいですが、今回はCNAMEでサブドメインをリダイレクトさせる形にします。&lt;/strong>&lt;/p>
&lt;h3 id="1-">1. 証明書の作成&lt;/h3>
&lt;p>CloudflareのCrypto画面を開きます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/3.png" alt="">&lt;/p>
&lt;p>&lt;code>Origin Certificates&lt;/code>の項目にある&lt;code>Create Certificate&lt;/code>(証明書の作成)の青いボタンを押します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/4.png" alt="">&lt;/p>
&lt;p>モーダルウィンドウが開かれますが、&lt;code>List the hostnames&lt;/code>の箇所だけ変更して、利用したいドメイン名を記述して、NEXTボタンで進みましょう。&lt;/p>
&lt;p>今回は&lt;code>https://hogehoge.dotstud.io&lt;/code>でアクセスしたいので、ここには&lt;code>hogehoge.dotstud.io&lt;/code>などのドメイン名だけを入力しておきます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/5.png" alt="">&lt;/p>
&lt;p>これで証明書の文字列が生成されます。
&lt;code>Ker format&lt;/code>はデフォルトの&lt;code>PEM&lt;/code>のままで大丈夫です。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/6.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Origin certificate&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Private key&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>この二種類の文字列をあとで使うのでコピーしておきましょう。&lt;/strong>&lt;/p>
&lt;h3 id="2-gitlab-pages">2. GitLab Pagesに設定する&lt;/h3>
&lt;p>GitLabのリポジトリ設定画面からPagesの設定画面に行きます。&lt;/p>
&lt;p>&lt;code>https://gitlab.com/&amp;lt;ユーザー名&amp;gt;/&amp;lt;リポジトリ名&amp;gt;/pages&lt;/code>が設定画面です。&lt;/p>
&lt;p>ここから&lt;code>New Domain&lt;/code>ボタンを押してカスタムドメインの設定をします。&lt;/p>
&lt;p>また、この際に&lt;code>Force domains with SSL certificates to use HTTPS&lt;/code>のチェックがありますが、SSL対応させるのでデフォルトのままチェックしておきましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/7.png" alt="">&lt;/p>
&lt;p>&lt;code>Domain&lt;/code>の項目に設定したいカスタムドメイン（今回は&lt;code>hogehoge.dotstud.io&lt;/code>）を設定します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/8.png" alt="">&lt;/p>
&lt;p>以下の二箇所には先ほどのCloudflareで生成した証明書文字列を指定します。&lt;/p>
&lt;ul>
&lt;li>Certificate (PEM): &lt;code>Origin certificate&lt;/code>の文字列&lt;/li>
&lt;li>Key (PEM): &lt;code>Private key&lt;/code>の文字列&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;code>----BEGIN CERTIFICATE----&lt;/code>などの文字を含めて全部コピペしましょう。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/9.png" alt="">&lt;/p>
&lt;p>ここにさらにCloudflareの証明書の文字列が必要になります。&lt;a href="https://support.cloudflare.com/hc/en-us/articles/218689638">CloudFlare's Origin CA — RSA Root&lt;/a>というらしいです。&lt;/p>
&lt;p>以下の文字列(CloudFlare's Origin CA)をコピーしましょう。&lt;/p>
&lt;pre>&lt;code>-----BEGIN CERTIFICATE-----
MIID/DCCAuagAwIBAgIID+rOSdTGfGcwCwYJKoZIhvcNAQELMIGLMQswCQYDVQQG
EwJVUzEZMBcGA1UEChMQQ2xvdWRGbGFyZSwgSW5jLjE0MDIGA1UECxMrQ2xvdWRG
bGFyZSBPcmlnaW4gU1NMIENlcnRpZmljYXRlIEF1dGhvcml0eTEWMBQGA1UEBxMN
U2FuIEZyYW5jaXNjbzETMBEGA1UECBMKQ2FsaWZvcm5pYTAeFw0xNDExMTMyMDM4
NTBaFw0xOTExMTQwMTQzNTBaMIGLMQswCQYDVQQGEwJVUzEZMBcGA1UEChMQQ2xv
dWRGbGFyZSwgSW5jLjE0MDIGA1UECxMrQ2xvdWRGbGFyZSBPcmlnaW4gU1NMIENl
cnRpZmljYXRlIEF1dGhvcml0eTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzETMBEG
A1UECBMKQ2FsaWZvcm5pYTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AMBIlWf1KEKR5hbB75OYrAcUXobpD/AxvSYRXr91mbRu+lqE7YbyyRUShQh15lem
ef+umeEtPZoLFLhcLyczJxOhI+siLGDQm/a/UDkWvAXYa5DZ+pHU5ct5nZ8pGzqJ
p8G1Hy5RMVYDXZT9F6EaHjMG0OOffH6Ih25TtgfyyrjXycwDH0u6GXt+G/rywcqz
/9W4Aki3XNQMUHNQAtBLEEIYHMkyTYJxuL2tXO6ID5cCsoWw8meHufTeZW2DyUpl
yP3AHt4149RQSyWZMJ6AyntL9d8Xhfpxd9rJkh9Kge2iV9rQTFuE1rRT5s7OSJcK
xUsklgHcGHYMcNfNMilNHb8CAwEAAaNmMGQwDgYDVR0PAQH/BAQDAgAGMBIGA1Ud
EwEB/wQIMAYBAf8CAQIwHQYDVR0OBBYEFCToU1ddfDRAh6nrlNu64RZ4/CmkMB8G
A1UdIwQYMBaAFCToU1ddfDRAh6nrlNu64RZ4/CmkMAsGCSqGSIb3DQEBCwOCAQEA
cQDBVAoRrhhsGegsSFsv1w8v27zzHKaJNv6ffLGIRvXK8VKKK0gKXh2zQtN9SnaD
gYNe7Pr4C3I8ooYKRJJWLsmEHdGdnYYmj0OJfGrfQf6MLIc/11bQhLepZTxdhFYh
QGgDl6gRmb8aDwk7Q92BPvek5nMzaWlP82ixavvYI+okoSY8pwdcVKobx6rWzMWz
ZEC9M6H3F0dDYE23XcCFIdgNSAmmGyXPBstOe0aAJXwJTxOEPn36VWr0PKIQJy5Y
4o1wpMpqCOIwWc8J9REV/REzN6Z1LXImdUgXIXOwrz56gKUJzPejtBQyIGj0mveX
Fu6q54beR89jDc+oABmOgg==
-----END CERTIFICATE-----
&lt;/code>&lt;/pre>&lt;p>&lt;strong>この&lt;code>CloudFlare's Origin CA&lt;/code>をコピーしたら、先ほど&lt;code>Certificate (PEM)&lt;/code>のフォームに入れ込んだ文字列の後ろに改行をいれて、&lt;code>CloudFlare's Origin CA&lt;/code>を貼り付けます。&lt;/strong>&lt;/p>
&lt;p>この画面のような感じです。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/10.png" alt="">&lt;/p>
&lt;p>ここまで出来たら、ページ下部の&lt;code>Create New Domain&lt;/code>のボタンを押して進みましょう。&lt;/p>
&lt;h3 id="3-dns">3. DNSの設定&lt;/h3>
&lt;p>無事に作成出来ると、以下のような確認画面になります。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/11.png" alt="">&lt;/p>
&lt;p>この画面の指示にしたがってCloudflareのDNS設定画面でCNAMEとTXTレコードを設定してあげる必要があります。&lt;/p>
&lt;h4 id="cname">CNAMEレコード設定&lt;/h4>
&lt;p>まずはCNAMEレコードです。 以下のように設定します。&lt;/p>
&lt;ul>
&lt;li>Type: CNAME&lt;/li>
&lt;li>Name: 利用したいカスタムドメイン名&lt;/li>
&lt;li>Value: &amp;lt;ユーザー名&amp;gt;.gitlab.io&lt;/li>
&lt;/ul>
&lt;p>例えば&lt;code>https://hogehoge.dotstud.io&lt;/code>にしたい場合は&lt;strong>Name&lt;/strong>を&lt;code>hogehoge&lt;/code>にし、元々のGitLabリポジトリが&lt;code>https://n0bisuke.gitlab.io/hogehoge&lt;/code>などであれば,&lt;strong>Value&lt;/strong>を&lt;code>n0bisuke.gitlab.io&lt;/code>にします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/12.png" alt="">&lt;/p>
&lt;p>これで&lt;code>https://hogehoge.dotstud.io&lt;/code>にアクセスした際に&lt;code>https://n0bisuke.gitlab.io&lt;/code>側にリダイレクトされるようになります。&lt;/p>
&lt;h4 id="txt">TXTレコード設定（所有者確認）&lt;/h4>
&lt;p>GitLab側から見ると&lt;code>hogehoge.dotstud.io&lt;/code>をそのユーザーが所有しているか分からないため、所有権の確認作業が発生します。&lt;/p>
&lt;p>GitLabの設定画面に&lt;code>Verification status&lt;/code>の箇所に&lt;code>_gitlab-pages-verification-code.hogehoge.dotstud.io TXT gitlab-pages-verification-code=xxxxxxxxxxxxxxxxxx&lt;/code>などの文字列が表示されていることが分かります。この情報をCloudflareに登録してあげればOKです。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/13.png" alt="">&lt;/p>
&lt;p>登録が出来たら、おそらく赤くなっているUnverifiedのボタンを押して確認しましょう。
上手くいくとこんな感じで&lt;code>Successfully verified&lt;/code>などの文字が表示されます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/14.png" alt="">&lt;/p>
&lt;h3 id="4-ssl">4. SSLの設定&lt;/h3>
&lt;p>CloudflareのCrypto画面からSSLの設定が出来ます。&lt;code>Full&lt;/code>もしくは&lt;code>Full(strict)&lt;/code>にしておきましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/239/14.png" alt="">&lt;/p>
&lt;p>あとは、ドメインが浸透したりするのを少し待ちましょう。&lt;/p>
&lt;p>&lt;code>https://hogehoge.dotstud.io&lt;/code>にアクセすると&lt;code>https://n0bisuke.gitlab.io/hogehoge&lt;/code>に内部的にリダイレクトされるようになりました。&lt;/p>
&lt;h3 id="5-vuepress">5. VuePressの設定を戻す&lt;/h3>
&lt;p>先ほどの紹介で、VuePressをGitLab Pagesで公開する際に&lt;code>docs/.vuepress/config.js&lt;/code>の&lt;code>base&lt;/code>キーを&lt;code>/リポジトリ名/&lt;/code>とする紹介がありましたが、カスタムドメインまでやった人は&lt;code>base&lt;/code>キーを&lt;code>/&lt;/code>に戻しておいてください。&lt;/p>
&lt;p>&lt;strong>ここの設定を間違えるとCSSやJSが上手く読み込まれなくなってしまいます。&lt;/strong>&lt;/p>
&lt;h2 id="heading">まとめ&lt;/h2>
&lt;p>如何でしょう。GitLab Pagesや周辺ツール/サービスを活用して無料でカスタムドメイン+SSLのVuePressブログを作ることが出来ました。&lt;/p>
&lt;p>この辺のことを試す際の参考になれば幸いです。&lt;/p></description></item><item><title>Hugo+GitHub Pagesで作ってるブログ運用をGitLabからCircle CI+GitHubに切り替えました。</title><link>https://dotstud.io/blog/circleci-hugo-github-pages/</link><pubDate>Tue, 22 Jan 2019 12:27:36 +0900</pubDate><guid>https://dotstud.io/blog/circleci-hugo-github-pages/</guid><description>&lt;p>こんにちは、代表の&lt;a href="https://dotstud.io/members/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>タイトル通り、dotstudioのブログの構成を変更したのでメモを残しておこうとおもいます。&lt;/p>
&lt;h2 id="heading">今までの構成とデプロイの流れ&lt;/h2>
&lt;p>基本は静的サイトジェネレーターの&lt;a href="https://gohugo.io/">Hugo&lt;/a>を利用しています。&lt;/p>
&lt;p>基本はHugoで手元でビルドして&lt;a href="https://pages.github.com/">GitHub Pages&lt;/a>でデプロイするという流れです。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/8512cf9fd941dc733f9e6611f8863cd0.png" alt="">&lt;/p>
&lt;p>CIを特に利用しないでやってて大変さがありました。&lt;/p>
&lt;h2 id="gitlab-ci">GitLab CIの限界があった&lt;/h2>
&lt;p>GitLabを内部では利用していたので、GitLab CIでビルドをいい感じにしようかとしていたらハマりました。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/a58d60565109438f7d9356a9e83bddae.png" alt="">&lt;/p>
&lt;pre>&lt;code>Running with gitlab-runner 11.7.0-rc1 (6e20bd76)
on docker-auto-scale ed2dce3a
Using Docker executor with image monachus/hugo ...
Pulling docker image monachus/hugo ...
Using docker image sha256:a76936cdfb56aa7587fb4839d92e1e5964a2a42f8f1034d46378c4d4e7705e1f for monachus/hugo ...
Running on runner-ed2dce3a-project-10358631-concurrent-0 via runner-ed2dce3a-srm-1547609018-d23d2aef...
Cloning repository...
Cloning into '/builds/n0bisuke/web'...
Checking out ca3fd857 as master...
Updating/initializing submodules recursively...
$ hugo
Building sites …
| JA
+------------------+------+
Pages | 470
Paginator pages | 14
Non-page files | 0
Static files | 2839
Processed images | 0
Aliases | 22
Sitemaps | 1
Cleaned | 0
Total in 36971 ms
Uploading artifacts...
public: found 4092 matching files
ERROR: Uploading artifacts to coordinator... too large archive id=146361688 responseStatus=413 Request Entity Too Large status=413 Request Entity Too Large token=ALM-jHM4
FATAL: Too large
ERROR: Job failed: exit code 1
&lt;/code>&lt;/pre>&lt;p>&lt;code>Maximum artifacts size (MB)&lt;/code>って設定があるみたいですが、&lt;a href="https://github.com/sameersbn/docker-gitlab/issues/1726">413 Request Entity Too Large #1726&lt;/a>などを見て調べていくと、どうやらサービス版の&lt;a href="https://gitlab.com">GitLab.com&lt;/a>ではCIのサーバー設定が出来ず、&lt;a href="https://gitlab.com/gitlab-org/gitlab-ce">GitLab CE&lt;/a>など自分のサーバーにインストールする方式じゃないと設定が出来なさそうでした。&lt;/p>
&lt;h2 id="circlecigithub">CircleCIに乗り換えとGitHubのプライベートリポジトリ無償化&lt;/h2>
&lt;p>ということで&lt;a href="https://circleci.com/">CircleCI&lt;/a>に乗り換えしようと思ったんですけど、&lt;/p>
&lt;p>ちなみに、有名どころで&lt;a href="https://travis-ci.org/">Travis CI&lt;/a>と一瞬悩みましたが&lt;strong>大学の研究室の先輩の&lt;a href="https://twitter.com/ganezasan">伊藤マネージャー(@ganezasan)&lt;/a>がCircleCIに転職した&lt;/strong>という話を先日聞いたのでCircleCIを選びました。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ちなみにマネージャーというアダ名だったのですが現職でマネージャーではないそうです（笑）&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>ツール選びで悩んだ時に、近くに聞ける人がいるのはすごく大事だと思ってます。&lt;/p>
&lt;h3 id="circlecigitlab">CircleCIはGitLabから叩けない&lt;/h3>
&lt;p>現時点(2019年1月)でCircleCIはGitHubとBitbucketからのみ叩ける模様です。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/6cb3b835660849ea4bf2a91c64477700.png" alt="">&lt;/p>
&lt;p>ちなみにこれは仲がいいので個人的に聞いてますが、みんなこれやっちゃうと彼をパンクさせてしまうので&lt;a href="https://support.circleci.com/hc/ja/requests/new">問い合わせ&lt;/a>から質問しましょうね。&lt;/p>
&lt;p>内部でGitLabを使ってたのでぐぬぬって感じでしたが&amp;hellip;&amp;hellip;&lt;/p>
&lt;h3 id="github">GitHubプライベードリポジトリ無償化&lt;/h3>
&lt;p>GitLabを採用していた理由は無料でプライベートリポジトリが使えて高機能だったってところだったんですけど、 &lt;strong>&lt;a href="https://gigazine.net/news/20190108-github-private-repositories/">GitHubの無料ユーザーもプライベートリポジトリを無制限で使用可能に&lt;/a>のニュース&lt;/strong>がありましたよね。&lt;/p>
&lt;p>リポジトリにアクセスできるメンバー数は3人までと少ないのですが、現状の編集フローを考えると全然問題なかったので &lt;strong>内部で利用するリポジトリをGitHubのプライベードに切り替えてCircleCI利用をする方向に&lt;/strong>しました。&lt;/p>
&lt;h2 id="circlecihugogithub-pages">CircleCIでHugoをビルドしてGitHub Pagesにデプロイ&lt;/h2>
&lt;p>ということでこんな構成が出来ました。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/7697772135a0b0f9dfa4adbd1b040220.png" alt="">&lt;/p>
&lt;p>自動デプロイいいですね。楽しい。&lt;/p>
&lt;p>参考までにデプロイ部分の&lt;code>config.yml&lt;/code>を載せておきます。&lt;/p>
&lt;p>流れとしては&lt;/p>
&lt;ul>
&lt;li>hugoが動くdocker imageで起動&lt;/li>
&lt;li>内部用GitHubリポジトリにPushしたリポジトリにチェックアウト&lt;/li>
&lt;li>publicフォルダを一旦削除&lt;/li>
&lt;li>公開用GitHub PagesリポジトリをCloneしてpublicフォルダとして保存&lt;/li>
&lt;li>hugoでビルド(&amp;ndash;minifyオプション付き)してpublicフォルダを更新&lt;/li>
&lt;li>GitHub Pages用のCNAMEファイルを作成&lt;/li>
&lt;li>Gitの設定をしてadd&amp;amp;commit&amp;amp;push&lt;/li>
&lt;li>成功したらLINE Notifyに通知&lt;/li>
&lt;li>失敗したらDiscordに通知&lt;/li>
&lt;/ul>
&lt;p>といった流れです。&lt;/p>
&lt;pre>&lt;code>defaults: &amp;amp;defaults
working_directory: ~/repo
docker:
- image: monachus/hugo
version: 2.1
jobs:
deploy:
&amp;lt;&amp;lt;: *defaults
steps:
- checkout
- run: pwd
- run: echo $USERNAME
- run:
name: Print the Current Time
command: date
- run:
name: Hugo Version Check
command: hugo version
- run: rm -rf public
- run:
name: Git Clone
command: git clone --depth 1 https://$TEAMNAME:$GITHUB_TOKEN@github.com/$TEAMNAME/$TEAMNAME.github.io.git public
- run:
name: Hugo Build
command: hugo --minify
- run: cd public &amp;amp;&amp;amp; touch CNAME &amp;amp;&amp;amp; echo &amp;quot;$DOMAIN&amp;quot; &amp;gt; CNAME
- run: cd public &amp;amp;&amp;amp; pwd
- run: cd public &amp;amp;&amp;amp; git config user.email &amp;quot;$EMAIL&amp;quot;
- run: cd public &amp;amp;&amp;amp; git config user.name &amp;quot;$USERNAME&amp;quot;
- run: cd public &amp;amp;&amp;amp; git add -A
- run: cd public &amp;amp;&amp;amp; git commit -m &amp;quot;deploy from CI&amp;quot;
- run: cd public &amp;amp;&amp;amp; git push origin master
- run:
name: Deploy Success Notification to DISCORD
command: |
curl -d &amp;quot;{\&amp;quot;content\&amp;quot;:\&amp;quot;デプロイが失敗しました。\&amp;quot;}&amp;quot; $DISCORD_URL -H 'Content-Type:application/json'
when: on_fail
- run:
name: Deploy Success Notification to LINE
command: |
curl -X POST -H &amp;quot;Authorization: Bearer $LINE_NOTIFY_TOKEN&amp;quot; -F &amp;quot;message=デプロイ成功&amp;quot; https://notify-api.line.me/api/notify
workflows:
version: 2.1
build:
jobs:
- deploy:
filters:
branches:
only: master
&lt;/code>&lt;/pre>&lt;p>以下の記事が参考になりました。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://hori-ryota.com/blog/create-blog-with-hugo-and-circleci/">HugoとCircleCIでGitHub PagesにBlogを公開してみた&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.to/ardianta/deploy-hugo-from-gitlab-ci-to-github-pages-5aml">Deploy Hugo from Gitlab CI to Github Pages&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ganezasan/shumatsu.github.io/blob/master/.circleci/config.yml">伊藤マネージャーのJekyllサンプル&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>また、workflowsの設定でmasterブランチにプッシュしたときだけdeployジョブが動くように出来るのでこれも利用しています。&lt;/p>
&lt;pre>&lt;code>・
・
(省略)
・
・
- deploy:
filters:
branches:
only: master
&lt;/code>&lt;/pre>&lt;p>色々なトークン周りはCircleCIの環境変数に詰め込みましょう。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/6525eeb67ec16f9340fb5eae83e26b83.png" alt="">&lt;/p>
&lt;p>ちなみに、GitHubのアクセストークンは&lt;a href="https://github.com/settings/tokens">こちら&lt;/a>から取得できます。&lt;/p>
&lt;h2 id="heading-1">まとめ&lt;/h2>
&lt;p>CircleCI導入することでかなり作業量減った感じがします。感謝。&lt;/p>
&lt;p>そもそもがCI導入出来てなかったってのもあるとは思いますが（苦笑）それはまぁ生ぬるい目で見てやって下さい。&lt;/p>
&lt;p>他にもブログの画像の最適化などのジョブも埋め込んだりとやれること色々と自動化進めています。&lt;/p></description></item><item><title>macOS MojaveとiOSの連携カメラが使えない時のトラブルシューティング</title><link>https://dotstud.io/blog/macos-mojave-ios-camera/</link><pubDate>Tue, 09 Oct 2018 11:50:42 +0900</pubDate><guid>https://dotstud.io/blog/macos-mojave-ios-camera/</guid><description>&lt;p>こんにちは、&lt;a href="https://dotstud.io/members/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>先日MacのバージョンをアップグレードしてMojaveにしてみました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Mojaveのダークモードにも慣れてきてけっこう快適なMacライフを送っています。&lt;/p>
&lt;p>連携カメラ機能がかなり優秀なんですけどたまに使えない時があって挙動を調べてみました。&lt;/p>
&lt;h2 id="continuity-camera">連携カメラ（Continuity Camera）&lt;/h2>
&lt;p>&lt;a href="https://www.apple.com/jp/macos/mojave/">Mojaveのサイト&lt;/a>にも乗っていますがMacとiPhoneを連動させて、iPhoneで撮影した写真を即座にMacで利用することができます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/49f5868118a7d628f31bd735a9eef1ea.jpg" alt="">&lt;/p>
&lt;h2 id="heading">使ってみた&lt;/h2>
&lt;p>デスクトップやKeynote上で右クリックを押すとiPhoneで写真を撮る選択肢が出てきます。&lt;/p>
&lt;p>選択するとiPhone側でカメラが起動するの撮影して「写真を使用」を選択するだけです。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/d1ff48f1acf47b56882ee1da3f743eb5.gif" alt="">&lt;/p>
&lt;p>使ってみるとこんな感じです。&lt;/p>
&lt;p>&lt;strong>転送めちゃ早いですよね。&lt;/strong>&lt;/p>
&lt;h2 id="heading-1">使えない時のトラブルシューティング&lt;/h2>
&lt;p>通常はデスクトップやKeynote上で右クリックを押すとiPhoneで写真を撮る選択肢が出てきますが、グレーアウトして選択できない場合があります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/e35cf3e811144774761eacd429b4da37.png" alt="">&lt;/p>
&lt;h3 id="mojave--ios12">Mojave &amp;amp; iOS12になっていないと使えない&lt;/h3>
&lt;p>この機能はmacOS MojaveとiOS12以上じゃないと利用できません。&lt;/p>
&lt;ul>
&lt;li>Macのバージョンを確認しましょう&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.gyazo.com/b79ffcadc6e4d1e6b3da8aa3f6701c41.png" alt="">&lt;/p>
&lt;ul>
&lt;li>iOSのバージョンも確認しましょう&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.gyazo.com/6fc7c466986e4e725bcf02314f95cc9b.png" alt="">&lt;/p>
&lt;h3 id="mac--iosicloudapple-id">Mac &amp;amp; iOSが同じiCloud（Apple ID）でサインインしている必要がある&lt;/h3>
&lt;p>MacとiPhoneを連携するために同じアカウントでそれぞれの端末にサインインしている必要があります。&lt;/p>
&lt;p>&lt;strong>逆にサインインさえしておけばよく、iCloud Driveやフォトストリームなどの連携はオフにしていても問題ないです。&lt;/strong> 最初うまくいかないときにこれを疑ってiCloud Driveをオンにしてみたりしましたが関係ありませんでした（笑）&lt;/p>
&lt;ul>
&lt;li>Mac側でiCloudにサインインしておきます&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.gyazo.com/5d5b30a445c7b124ca0cb16b535f6e74.png" alt="">&lt;/p>
&lt;ul>
&lt;li>iOS側でも同じアカウントでサインインしておきましょう&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.gyazo.com/2460370ca57c66f14562e2e9195dd600.png" alt="">&lt;/p>
&lt;h3 id="wi-fi--bluetooth">Wi-Fi &amp;amp; Bluetoothが両端末でオンになってないと使えない&lt;/h3>
&lt;p>この機能はAirDropと同様で &lt;strong>Wi-FiとBluetoothがオンになってないと利用できません。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>参考: &lt;a href="https://news.mynavi.jp/article/20150510-iphone_why1/">「AirDrop」はなぜBluetoothとWi-Fiの両方が必要なの? - いまさら聞けないiPhoneのなぜ&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>ざっくり言うとBluetoothでデバイスを検索し、Wi-Fiでデータを送る仕様になっているようです。&lt;/p>
&lt;p>iPhoneとMacのそれぞれのWi-FiとBluetoothをオンにしておきましょう。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/f0836287a49153cfd59ee91d3ea1225e.png" alt="">&lt;/p>
&lt;p>オンにするだけで問題なく、特定のアクセスポイントに接続しておく必要はないです。&lt;/p>
&lt;h4 id="macbluetooth">・MacのBluetoothがオフの場合&lt;/h4>
&lt;p>MacのBluetoothがオフの場合はデバイスの検索ができずグレーアウトになります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/aa571b80c3768e03705e541bc5d105b4.png" alt="">&lt;/p>
&lt;h4 id="macwi-fibluetooth">・MacのWi-FiがオフでBluetoothがオンの場合&lt;/h4>
&lt;p>MacのBluetoothがオンになっているのでデバイスの検索は出来ますが、Wi-Fiがオフになっているとデバイスとのデータ通信が出来ずタイムアウトになります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/8d1bc4cb4cbadafa2c4e8fbb8544f5a6.png" alt="">&lt;/p>
&lt;h4 id="iphonebluetooth">・iPhoneのBluetoothがオフの場合&lt;/h4>
&lt;p>Mac側でWi-FiとBluetoothがオンになっていてもiPhone側でBluetoothがオンになっていないとタイムアウトになります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/8d1bc4cb4cbadafa2c4e8fbb8544f5a6.png" alt="">&lt;/p>
&lt;h4 id="iphonewi-fi">・iPhoneのWi-Fiがオフの場合&lt;/h4>
&lt;p>Mac側でWi-FiとBluetoothがオンになっていてもiPhone側でWi-Fiがオンになっていないと「デバイスでWi-Fiが有効になっていません」とエラーが出ます。これは分かりやすいですね。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/42154f84e23618717b62040cab805ea4.png" alt="">&lt;/p>
&lt;h2 id="heading-2">勘違いしてた内容&lt;/h2>
&lt;p>ちなみに、MacとiPhoneの連携なので使えないときに以下を疑っていましたが全くもって関係ないです。&lt;/p>
&lt;h3 id="heading-3">ケーブルでつなげる必要はない&lt;/h3>
&lt;p>MacとiPhoneをライトニングケーブルなどで物理的に接続する必要性はないです。&lt;/p>
&lt;h3 id="wi-fi">同一のWi-Fiに繋げる必要もない&lt;/h3>
&lt;p>MacとiPhoneを同一ネットワークに接続する必要もないです。&lt;/p>
&lt;h3 id="bluetooth">Bluetoothで接続する必要もない&lt;/h3>
&lt;p>MacとiPhoneをBluetoothでペアリングなどをする必要もないです。&lt;/p>
&lt;h2 id="heading-4">まとめ&lt;/h2>
&lt;p>連携カメラ（Continuity Camera）が使えないときはiCloudもしくはWi-Fi&amp;amp;Bluetoothを疑うと良さそうです。&lt;/p>
&lt;p>それでもダメな場合はMacの再起動をしてみるとうまくいく時があるようです。&lt;/p>
&lt;p>この機能すごく便利なので&lt;a href="https://dotstud.io/blog/macos-mojave-update-process">前回の記事&lt;/a>の画像編集などと組み合わせると編集やライターさんはかなり重宝すると思います！&lt;/p>
&lt;p>それでは！&lt;/p></description></item><item><title>人柱覚悟でさっそくmacOS Mojaveにしてみました。</title><link>https://dotstud.io/blog/macos-mojave-update-process/</link><pubDate>Tue, 25 Sep 2018 05:46:01 +0900</pubDate><guid>https://dotstud.io/blog/macos-mojave-update-process/</guid><description>&lt;p>こんにちは、&lt;a href="https://dotstud.io/members/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>macOS Mojaveが出ましたね。前にSierraのアップデートをした時も初日くらいにやってみたので今回もアップデートしてみたいと思います。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>ちなみに今回は「実際にmacOS Mojaveにアップデートしてみたレポート」ですので、試す際にもしトラブルが発生しても当メディアでは責任は負いません。&lt;/strong>&lt;/p>
&lt;p>結論から先に言うと &lt;strong>Sierraのときはそこまでアップデートしなくてもよいかもなぁって感じの〆だったんですけど、Mojaveは（今のところは）積極的にオススメしたいアップデートだと思っています。&lt;/strong> 記事書く人にはオススメポイントが多いです。&lt;/p>
&lt;h2 id="macos-mojave-">macOS Mojave （モハベ）&lt;/h2>
&lt;p>&lt;img src="https://i.gyazo.com/4ddc01da4d7dd237928e955545b624a5.jpg" alt="">&lt;/p>
&lt;p>**「モハベ」**と読むみたいです。モジャべじゃないよ！&lt;/p>
&lt;p>macOSの新しいやつですね。 新機能などは他のメディアで色々紹介されてるので見てみると良いと思います。&lt;/p>
&lt;p>バージョンは10.14でHigh Sierraの後続版です。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.gizmodo.jp/2018/09/darkmode-macos-mojave-release.html">ダークモードがやってきた！ ｢macOS Mojave｣正式リリース&lt;/a>
&lt;a href="https://applech2.com/archives/20180921-before-upgrade-macos-10-14-mojave.html">macOS 10.14 Mojaveへアップグレードする前の注意点まとめ。&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>ダークモードが使えるようになったよ！ってのが大きい気がします。&lt;/p>
&lt;p>詳細は&lt;a href="https://ja.wikipedia.org/wiki/MacOS_Mojave">Wikipedia&lt;/a>なども見てみましょう。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/e74d7131d56f3a275fcd41b1216471a3.png" alt="">&lt;/p>
&lt;h2 id="macbook">アップデートする僕のMacBookのマシンスペック&lt;/h2>
&lt;ul>
&lt;li>MacBook Pro （Retina 13-inch、 Early2015）&lt;/li>
&lt;li>macOS High Sierra v10.13&lt;/li>
&lt;/ul>
&lt;h2 id="heading">では人柱覚悟でアップデートしていきます&lt;/h2>
&lt;p>&lt;a href="https://www.apple.com/jp/macos/mojave/">公式サイト&lt;/a>からアップデートしてみます。&lt;/p>
&lt;p>**「パワーに満ちたシンプル。」**というキャッチコピーはすごくツッコミ入れたいですがスルーして右上の「今すぐアップグレード」からアップグレードします。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/8deca35f31807137d53ec5cfacc3e340.jpg" alt="">&lt;/p>
&lt;p>App StoreのWeb版が開かれて、App Storeアプリで開きますかと聞かれるので開きましょう。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/b2db8ec54b706e1fb17c64a96b703408.png" alt="">&lt;/p>
&lt;p>App Storeアプリが起動するのでまずはダウンロードします。 ネットワーク環境にもよると思いますが、15分くらいかかった印象です。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/3a83f39b45e0d77a9eaf3f3fdc16c5b6.jpg" alt="">&lt;/p>
&lt;p>ダウンロードが完了するとインストーラーが起動します。&lt;/p>
&lt;p>「続ける」を押して進みます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/41a0a7ba691b1e564495bb1693024517.png" alt="">&lt;/p>
&lt;p>規約画面になります。「同意する」で進みます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/7626ed2f4bdddd6adcc20455470ea629.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/65bc8dcb6cf4c205c63fd51fed9772cb.png" alt="">&lt;/p>
&lt;p>インストールするディスクを選択します。このときディスクの空き領域が無いとインストールできないので空き領域の確保をしておきましょう。僕は全然空いてなくて詰まりました苦笑&lt;/p>
&lt;p>ちなみに、セーフモードで再起動すると容量確保出来る場合が多いです。キャッシュが容量を喰ってる場合が多いのですが、再起動してshiftを押しっぱなしで起動することでセーフモード起動になります。大体の場合はこれでキャッシュがクリアされて容量が劇的に削減出来ます。 僕の場合は10GBほど削減できました。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/76a1366f2c5e54b2a6bb8b8147429de9.png" alt="">&lt;/p>
&lt;p>容量確保が出来たらハードディスクのアイコンがアクティブになり「インストール」ボタンが押せる状態になります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/55669f85f995f6ea45d5301e17110bd2.png" alt="">&lt;/p>
&lt;p>スタートすると残り時間などが表示されるので少し待ちましょう。 僕の場合は17分と表示されましたが、実際はもっと早く終わった気がします。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/ee68b983019fd74e9777bc399efc2559.png" alt="">&lt;/p>
&lt;p>インストールする準備ができました。と表示されたら再起動ボタンで再起動しましょう。何回か再起動することもあります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/ff083cef222998991d6321dd5abfbd80.png" alt="">&lt;/p>
&lt;p>再起動中です。 40分くらいかかった印象です。ご飯でも食べて戻ってくるとちょうどよいかもしれません。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/de6217ddbcd2b8f2fb479adad1b7c9c7.png" alt="">&lt;/p>
&lt;p>しばらくして起動しました！&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/320e7c9449a4d5f249ca3187c0fba164.jpg" alt="">&lt;/p>
&lt;h3 id="mojava">Mojavaの初期設定&lt;/h3>
&lt;p>Mojavaの初期設定でApple IDでサインインします。
ちなみに、ここの画面撮り忘れたのでSierraのときのキャプチャです。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/022/08_image.png" alt="">&lt;/p>
&lt;p>iCloudキーチェーンの設定です。あとで設定しても大丈夫だと思います。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/80782a5bbec79762ed6fe450ec3247a9.jpg" alt="">&lt;/p>
&lt;p>解析ログの提供チェックです。チェックしなくても問題無いです。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/5b7f08971e8ff1486112666f44024b35.jpg" alt="">&lt;/p>
&lt;p>ここの最後でやっとダークモードの選択肢が出てきました。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/d9d7e78c1ee29f3c714bbab6c51649f1.jpg" alt="">&lt;/p>
&lt;p>ダークを選択するとウィンドウが黒基調になります。かっこいい。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/94dd59c13387880d3f2640d3ceb9eb22.jpg" alt="">&lt;/p>
&lt;p>これで完了です。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/488a451308d535eda27068fad694d7f1.jpg" alt="">&lt;/p>
&lt;p>起動すると無事にバージョンが上がっていることが分かります。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/b79ffcadc6e4d1e6b3da8aa3f6701c41.png" alt="">&lt;/p>
&lt;p>そしてFinderなども黒い。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/8cb8e22ace2cb6150cf99f0f2d18182d.png" alt="">&lt;/p>
&lt;p>もちろんそのままライトテーマで利用することもできます。&lt;/p>
&lt;h2 id="heading-1">新機能を試してみる&lt;/h2>
&lt;p>少し新機能を試してみます。&lt;/p>
&lt;h3 id="heading-2">デスクトップをダイナミックデスクトップに&lt;/h3>
&lt;p>時間帯によってデスクトップ画像の風景が変わるダイナミックデスクトップが追加されています。&lt;/p>
&lt;p>システム環境設定の「デスクトップとスクリーンセーバー」から設定しましょう。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/7c3725fdb0bd0723f9394af17b716c33.png" alt="">&lt;/p>
&lt;h3 id="heading-3">クイックアクション&lt;/h3>
&lt;p>個人的には &lt;strong>めちゃ便利です。&lt;/strong>&lt;/p>
&lt;p>アプリを開かなくてもFinderからそのまま処理を実行できます。&lt;/p>
&lt;p>例えば画像をプレビューアプリで編集したい場合などは今まではアプリが起動して編集する流れになっていましたがFinderから編集用のウィンドウが出てきてシュッと編集できます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/74a47bbca1477a1a9e767108bb37fc8f.gif" alt="">&lt;/p>
&lt;p>&lt;strong>編集者やライターさんはかなり重宝する機能な気がします。&lt;/strong>&lt;/p>
&lt;h3 id="heading-4">スクリーンショットのプレビュー&amp;amp;編集&lt;/h3>
&lt;p>これも &lt;strong>めちゃ便利&lt;/strong> です。&lt;/p>
&lt;p>今まではスクリーンショットを撮影したらそのまま保存されてましたが、プレビューが右下に出てきて、そこをクリックするとそのまま編集して保存したり、保存しないっていう選択肢も選択できます。&lt;/p>
&lt;p>ちなみにこの画像自体もプレビュー&amp;amp;編集で作ってます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/be73658467a0094f93db5a9608ed251f.jpg" alt="">&lt;/p>
&lt;p>これ、最近のiPhoneだと使える機能なんですけどMacでも早く使いたいなぁと思ってました。&lt;/p>
&lt;p>これも &lt;strong>編集者やライターさんはかなり重宝する機能な気がします。&lt;/strong>&lt;/p>
&lt;h3 id="heading-5">スクリーンショットの強化&amp;amp;画面収録&lt;/h3>
&lt;p>command+shift+5で起動するスクリーンショットが範囲選択や保存先のフォルダ変更など歯がゆい部分が強化されています。&lt;/p>
&lt;p>また同じコマンドから画面収録もそのままやれるようになっています。
今まではQuick Time Playerの機能などを使ってましたが圧倒的にこっちの方が楽です。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/3ca9f6c7528e2bc36573bde86ed7240e.gif" alt="">&lt;/p>
&lt;p>これも &lt;strong>編集者やライターさんはかなり重宝する機能な気がします。&lt;/strong>&lt;/p>
&lt;h2 id="heading-6">気になる不具合など&lt;/h2>
&lt;p>今のところ大きな不具合はないですが恒例な感じでGitが動かなくなりました。&lt;/p>
&lt;p>その他発見したら追記していきます。&lt;/p>
&lt;h3 id="git">Git問題&lt;/h3>
&lt;p>&lt;a href="https://qiita.com/n0bisuke/items/1c60084c8c07b690d693">macOS MojaveにしたらGitコマンドが動かなくなった&lt;/a>に書きましたが&lt;/p>
&lt;pre>&lt;code>xcode-select --install
&lt;/code>&lt;/pre>&lt;p>で入れ直すと直ります。&lt;/p>
&lt;h3 id="heading-7">パフォーマンスなどは?&lt;/h3>
&lt;p>むしろ快適になった気がしています。もしかしたら直前のキャッシュクリアの影響なのかもしれないですが文章書いている程度ですが前よりもスムーズPCが動いてる気がしています。&lt;/p>
&lt;h2 id="heading-8">まとめ&lt;/h2>
&lt;p>こんな感じでアップデートできました。&lt;/p>
&lt;p>今回のアップデートですが、画像を扱う人たちにはすごくよい機能アップデートな気がしました。
あと、 &lt;strong>ダークモードはなんかカッコいい&lt;/strong>のでおすすめです笑&lt;/p>
&lt;p>iPhoneのカメラの写真がそのまま取り込まれる機能もあるみたいですがまだ試せて無いのでそのうち試してみたいと思います。これもまた &lt;strong>編集者やライターさんはかなり重宝する機能な気がします。&lt;/strong>&lt;/p>
&lt;p>Sierraのときはそこまでアップデートしなくてもよいかもなぁって感じの〆だったんですけど、Mojaveは（今のところは）積極的にオススメしたいアップデートだと思っています。&lt;/p>
&lt;p>使っていくうちに不具合出てきそうですが笑&lt;/p>
&lt;p>僕は問題ありませんでしたが、ハードウェア的な問題などでデータが消えてしまうとかもあるかもしれないので、アップデートする方はくれぐれもお気をつけて自己責任でお願いします！&lt;/p></description></item><item><title>無料で手軽！コマンド一つで静的サイトホスティングできるSurgeを試してみた。</title><link>https://dotstud.io/blog/static-site-hosting-surge/</link><pubDate>Sun, 09 Sep 2018 04:58:49 +0900</pubDate><guid>https://dotstud.io/blog/static-site-hosting-surge/</guid><description>&lt;p>こんにちは、&lt;a href="https://dotstud.io/members/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>最近VuePressを触っていて、簡単に静的サイトホスティングできるサービスを探していました。&lt;/p>
&lt;p>そこで発見した&lt;strong>Surge（サージ）というサービスがすごく簡単だった&lt;/strong>ので紹介します。&lt;/p>
&lt;p>（日本語記事なさそうだったので勢いで書いておこう）&lt;/p>
&lt;h2 id="surge">Surgeとは&lt;/h2>
&lt;p>静的サイトホスティングが無料で行えるサービスです。&lt;/p>
&lt;p>&lt;strong>コマンド一発でデプロイが出来る&lt;/strong>のが特徴で、&lt;strong>使い方がすごくシンプルで感動&lt;/strong>しました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>ちなみにサージって読むっぽいです。有料プランもありますがその辺は割愛して無料でできるところを紹介します。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.npmjs.com/package/surge">surge - npm&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>無料でどこまで使えるの？って気になる人は&lt;a href="https://surge.sh/help/why-is-surge-free">Why is Surge free?&lt;/a>という記事もあるので読んでみましょう。&lt;/p>
&lt;h2 id="surge-1">Surgeのインストールと使い方&lt;/h2>
&lt;h3 id="heading">インストール&lt;/h3>
&lt;pre>&lt;code>npm i -g surge
&lt;/code>&lt;/pre>&lt;h3 id="heading-1">デプロイ&lt;/h3>
&lt;pre>&lt;code>surge
&lt;/code>&lt;/pre>&lt;p>&lt;strong>&lt;!-- raw HTML omitted -->以上!!! &lt;!-- raw HTML omitted -->めちゃ簡単ですね。&lt;/strong>&lt;/p>
&lt;p>でも本当にこれだけなので驚きです。&lt;code>now.sh&lt;/code>に似た使い勝手。&lt;/p>
&lt;p>初めて使うときはメールアドレスとパスワードの入力をターミナル上で求められるのでそこでユーザー登録出来るのも個人的には好きです。&lt;strong>ターミナルだけで完結します&lt;/strong>。&lt;/p>
&lt;p>デプロイすると&lt;strong>&lt;code>xxxxxxx.surge.sh&lt;/code>&lt;/strong>という形式のURLが発行されるので、アクセスすればOKです。&lt;/p>
&lt;h2 id="heading-2">もう少し詳しく&lt;/h2>
&lt;p>surgeコマンドは、今いる場所を起点にそのままホスティングします。&lt;/p>
&lt;p>例えばmysiteフォルダ内部に&lt;code>index.html&lt;/code>を置いてたとします。&lt;/p>
&lt;pre>&lt;code>$ cd mysite
$ ls
index.html
&lt;/code>&lt;/pre>&lt;p>mysiteフォルダ内にいる状態で&lt;/p>
&lt;pre>&lt;code>surge ./
&lt;/code>&lt;/pre>&lt;p>とすればmysiteフォルダをまるっとホスティングできます。&lt;/p>
&lt;h3 id="heading-3">場所を指定してデプロイ&lt;/h3>
&lt;p>&lt;code>surge &amp;lt;フォルダの場所&amp;gt;&lt;/code>という形でデプロイできます。&lt;/p>
&lt;pre>&lt;code>surge ~/myblog/.vuepress/dist
&lt;/code>&lt;/pre>&lt;p>vuepressを使ったデプロイだとこんな感じでした&lt;/p>
&lt;h3 id="heading-4">場所とドメインを指定してデプロイ&lt;/h3>
&lt;p>さらにドメインを指定してデプロイができます。&lt;/p>
&lt;p>通常のデプロイだと、surgeコマンドでデプロイするたびに新しいドメインが生成されるので、更新性のあるサイトだと使い勝手が良くないです。&lt;/p>
&lt;p>&lt;code>surge &amp;lt;フォルダの場所&amp;gt; &amp;lt;ドメイン&amp;gt;&lt;/code>という形でデプロイすれば&lt;strong>毎回同じドメインにデプロイできます。&lt;/strong>&lt;/p>
&lt;pre>&lt;code>surge ~/myblog/.vuepress/dist hogehoge.surge.sh
&lt;/code>&lt;/pre>&lt;p>このコマンドを何回実行しても&lt;code>hogehoge.surge.sh&lt;/code>にデプロイされるので更新しても安心です。&lt;/p>
&lt;p>確か&lt;code>now.sh&lt;/code>だと毎回ドメインが発行されてaliasを貼り直さないといけない感じだったのでそこが少し手間だなぁと感じてました。この辺は後述します。&lt;/p>
&lt;h2 id="heading-5">カスタムドメインも無料で使える&lt;/h2>
&lt;p>無料でカスタムドメインを利用できます。&lt;/p>
&lt;p>「&lt;a href="https://surge.sh/help/adding-a-custom-domain">Adding a custom domain - surge&lt;/a>」を見るとやり方が書いてるのですが、利用しているドメイン事業者の管理画面で&lt;code>cname&lt;/code>の値に&lt;code>na-west1.surge.sh&lt;/code>を指定しましょう。&lt;/p>
&lt;p>&lt;code>grasping.studio&lt;/code>というドメインをお名前.comで管理しているので、&lt;code>hogehoge.graspin.studio&lt;/code>を利用したい場合は以下のように設定します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/9e316c5d1c6eeeebab84fb08819bdd37.png" alt="">&lt;/p>
&lt;p>更新してしばらく経つ（体感5~10分程度）と&lt;code>hogehoge.graspin.studio&lt;/code>に対してデプロイできるようになります。&lt;/p>
&lt;pre>&lt;code>$ surge ~/myblog/.vuepress/dist hogehoge.graspin.studio
&lt;/code>&lt;/pre>&lt;h2 id="heading-6">その他使い方&lt;/h2>
&lt;p>surgeコマンドのサブコマンドもいくつかあるので紹介します。&lt;/p>
&lt;h3 id="surge-list---">&lt;code>surge list&lt;/code> - アプリケーション一覧&lt;/h3>
&lt;pre>&lt;code>$ surge list
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://i.gyazo.com/904da5a62e40457539116e012d101418.png" alt="">&lt;/p>
&lt;h3 id="surge-teardown---">&lt;code>surge teardown&lt;/code> - アプリケーション削除&lt;/h3>
&lt;p>&lt;code>teardown&lt;/code>ってあんまり聞かないですけど他のサービスで言うところのrmとかremoveとかと同じような意味合いです。&lt;/p>
&lt;pre>&lt;code>$ surge teardown &amp;lt;アプリケーションのドメイン&amp;gt;
&lt;/code>&lt;/pre>&lt;h3 id="surge-whoami---">&lt;code>surge whoami&lt;/code> - アカウント情報の確認&lt;/h3>
&lt;p>ログインしているアカウントのメールアドレスが表示されます。&lt;/p>
&lt;pre>&lt;code>$ surge whoami
&lt;/code>&lt;/pre>&lt;h3 id="surge-logout---">&lt;code>surge logout&lt;/code> - アカウントからログアウトする&lt;/h3>
&lt;pre>&lt;code>$ surge logout
&lt;/code>&lt;/pre>&lt;h3 id="surge-login---">&lt;code>surge login&lt;/code> - ログインしなおす&lt;/h3>
&lt;pre>&lt;code>$ surge login
&lt;/code>&lt;/pre>&lt;h2 id="heading-7">他のメンバーと共同でデプロイする&lt;/h2>
&lt;p>&lt;code>--add&lt;/code>というオプションをつけてデプロイするとアプリケーションに指定したメールアドレスのユーザーもデプロイ出来るようになります。&lt;/p>
&lt;p>ユーザー&lt;code>hogehoge@gmail.com&lt;/code>さんをアプリケーション&lt;code>hogehoge.graspin.studio&lt;/code>へのデプロイ権限を渡しつつ、&lt;code>public&lt;/code>フォルダをデプロイする。&lt;/p>
&lt;pre>&lt;code>surge --add hogehoge@gmail.com public hogehoge.graspin.studio
&lt;/code>&lt;/pre>&lt;p>この辺りもコマンドラインからやれて便利ですね。&lt;/p>
&lt;p>&lt;code>surge --remove&lt;/code>でユーザーの権限を削除することもできます。&lt;/p>
&lt;h2 id="heading-8">他のサービスと比較してどうか?&lt;/h2>
&lt;p>無料で使えるその他のホスティングサービスとの比較です。主観です。&lt;/p>
&lt;p>この辺、実は違う！みたいな話あれば@n0bisukeまでコメントください〜。&lt;/p>
&lt;h3 id="netlfy">Netlfy&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.netlify.com/">https://www.netlify.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>フォルダをドラッグ&amp;amp;ドロップでデプロイ出来るのは個人的に結構好きですが、毎回URLが再発行されてしまうのが少し手間がある印象です。&lt;/p>
&lt;p>netlfyのcliツールもあるみたいですが手順がsurgeよりはある模様&lt;/p>
&lt;h3 id="heroku">heroku&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="http://heroku.com/">http://heroku.com/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>サーバーサイドのプログラムを含めてデプロイするときには良さそうです。
僕もよく使います。&lt;/p>
&lt;p>デバッグなどでけっこう詰まるのと、surgeほどの手軽さではないです。&lt;/p>
&lt;p>とはいえサーバーサイドプログラムまで利用したかったら選択肢になります。&lt;/p>
&lt;h3 id="github-pages--bitbucket-pages">GitHub Pages &amp;amp; Bitbucket Pages&lt;/h3>
&lt;p>GitHub PagesとBitbucket Pagesは使い勝手はほぼ同じ印象で、git pushするだけで公開できます。&lt;/p>
&lt;p>Webエンジニアなら当たり前のように使いますが、SSHやGitコマンドは最初少しハードルがあるかも。&lt;/p>
&lt;p>更新されるまでに少し時間がかかること、GitHubだとソースコードが（無料だと）公開されてしまうのでそこに抵抗感がある人がいるかも。&lt;/p>
&lt;p>静的サイトなのでどっちにしても公開されているようなものだけどなんとなく。&lt;/p>
&lt;h3 id="gitlab-pages">GitLab Pages&lt;/h3>
&lt;p>CIを動かして作るのでCIの記述になれてないと最初少しハマるかもしれません。&lt;/p>
&lt;p>その分やれることも多いので個人的には注目してます。&lt;/p>
&lt;h3 id="now">now&lt;/h3>
&lt;p>&lt;a href="https://www.now.sh/">https://www.now.sh/&lt;/a>&lt;/p>
&lt;p>これはめちゃ便利で&lt;code>now&lt;/code>コマンドだけでデプロイできて&lt;code>surge&lt;/code>とほぼ同じ使い勝手です。更新のたびに毎回URLが変わってしまうのでそこを解消できたら良いなぁと思うのと、同時に無料プランだと作れるアプリケーションの制限があって現状だと毎回削除していくのも結構手間があるなぁという印象です。&lt;/p>
&lt;p>（&lt;code>now&lt;/code>はもしかしたら設定でなんとかなるのかも??）&lt;/p>
&lt;h2 id="heading-9">まとめ&lt;/h2>
&lt;p>&lt;code>Surge&lt;/code>どうでしょう？&lt;/p>
&lt;p>コマンド一発で出来るので、サクッと作成したWebサイトを誰かにシェアしたり、
ハンズオンや授業などでも使いやすいと思います。&lt;/p>
&lt;p>僕も昨日知ったばかりですが今の所すごく良い印象です。&lt;/p>
&lt;p>ぜひ使ってみてください。&lt;/p></description></item><item><title>【取材がこないので自分にインタビューした】未経験からWebエンジニアになったちゃんとく氏がIoTを仕事に選んだ理由</title><link>https://dotstud.io/blog/self-interview-chantoku-chantoku/</link><pubDate>Fri, 31 Aug 2018 03:16:15 +0900</pubDate><guid>https://dotstud.io/blog/self-interview-chantoku-chantoku/</guid><description>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>こんにちは、&lt;a href="https://dotstud.io/members/chantoku">ちゃんとく&lt;/a>です。Webエンジニアから転身し、&lt;strong>技術中心の取材や記事執筆&lt;/strong>を生業としています。&lt;/p>
&lt;p>はい。取材することが多いんですよ。&lt;/p>
&lt;p>取材することが多いんです。&lt;/p>
&lt;p>取材。&lt;/p>
&lt;p>・・・・・・・・・
&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->私への取材、まだですかね？？？？？？？&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>24時間365日受け付けています。雨でも風でも山の上でもお受けします。嘘ですけど。&lt;/p>
&lt;p>待てど暮らせど取材の申し込みがこないので、痺れを切らして&lt;strong>自分自身で取材を行うことにしました&lt;/strong>。&lt;/p>
&lt;p>ちゃんとくの魅力、全国へ届けーっ☆&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->※内容はいたって真面目に書いています。エンジニアを志す人、キャリアに悩む人の後押しになれると幸いです。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h2 id="heading">嗅覚を信じて突き進む。ちゃんとく氏の自由すぎるキャリアパス&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>いまはIoT領域（※）で教育事業を進めている&lt;a href="https://dotstud.io/">&lt;strong>dotstudio株式会社&lt;/strong>&lt;/a>という会社で、ライター業を中心に活動しています。とはいえ、エンジニアさんにフォーカスした取材や、技術ナレッジを紹介する、&lt;strong>技術記事限定のテクニカルライター&lt;/strong>です。&lt;/p>
&lt;p>加えて、授業・研修などの講師や技術イベントの主催、育成中の&lt;a href="https://dotstud.io/">オウンドメディア&lt;/a>の舵取りや開発など、&lt;!-- raw HTML omitted -->**「モノ作りは楽しい」ということを伝えるための手段**&lt;!-- raw HTML omitted -->をいろいろと試行錯誤している感じです。いまは会社の人数が少ないので自分の仕事の営業、会社の広報や労務周りも一応私が担当しています。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>自分でも思い切った選択をしているな、とは思います（笑）。「あ、こうしたい！」と一度思ったら、後先考えずに実行してしまうタイプなんですよね。でも、エンジニア職も現職もすごく楽しんでますし、&lt;strong>結構自分の嗅覚を信用していて&lt;/strong>、思うままに突き進んでいます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ dotstudio株式会社 メディア事業部 テクニカルライター/エンジニア ちゃんとく氏&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>学生の頃は技術職に就くという選択肢はまったく頭になくて、違う世界線の話でした。就活でも銀行や商社、好きだった鉄鋼系の企業を受けたりして。でも、「なんとなく肌に合うなあ」って感じて最終的に決めた会社はIT系ベンチャー企業だったんです。&lt;/p>
&lt;p>そこで内定者研修を受けているうちにエンジニア職の紹介を拝見して、「作れる人かっこいいなー、私も作りたいな……。&lt;strong>あ、エンジニアになりたい！&lt;/strong>」と思ってしまったんです。その後大学を留年したこともあって、就活をし直してエンジニア職につける企業を選びました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>もともと6歳の頃からネットサーフィンしていたり、ネトゲ廃人だったりで、パソコン自体を触ることは好きでした。でも&lt;strong>プログラミングに関する知識はまったくなかった&lt;/strong>ので、最初はもう大変でした（笑）「ローカルとサーバーってなんですか？環境構築？JavaとJavaScriptって違うんですか？」って。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>初めは飛び交う言葉についていけず、折れそうなこともありました。でも腐らずにやれたのは、1社目のときの&lt;strong>上司と先輩が手厚くサポートしてくれたことが大きい&lt;/strong>です。今でも定期的に飲みに行ってます（笑）。&lt;/p>
&lt;h2 id="heading-1">コミュニティ参加で形成された「技術を楽しむ力」&lt;/h2>
&lt;p>一社目の先輩が&lt;strong>技術を楽しむ方法を教えてくれたこと&lt;/strong>は、キャリア選択に大きな影響を与えたと思います。技術書と睨めっこしているだけでは、ここまで続けられなかったと思いますね。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>大きく分けると2つ、&lt;strong>技術記事とコミュニティ&lt;/strong>です。初めに衝撃を受けたのはQiitaさんが毎年やっている&lt;a href="https://qiita.com/advent-calendar">&lt;strong>Advent Calendar&lt;/strong>&lt;/a>ですね。特に&lt;a href="https://qiita.com/advent-calendar/2015/ouch-hack">おうちハック2015&lt;/a>がお気に入りで、当時は記事の探し方もあまりわからなかったので、同じ記事を穴があくほど読んでいました。……いま気づいたんですけど、社長ののびすけも書いてますね（笑）。ここから、&lt;!-- raw HTML omitted -->**「個人でモノを作って発信している人」が憧れの対象になった**&lt;!-- raw HTML omitted -->と思います。&lt;/p>
&lt;p>それから、「同じくらいのレベルのエンジニア仲間を作った方がいい」という先輩のススメで、&lt;strong>勉強会・コミュニティに参加するようになった&lt;/strong>ことも大きいです。実は初めて参加したイベントは、のびすけが主催していた「&lt;a href="https://mlkcca.connpass.com/event/27083/">&lt;strong>Milkcocoa&lt;/strong>&lt;/a>」というBaaSのイベントだったんです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ ちゃんとく氏とのびすけ氏が初対面だったMilkcocoaオジサン。での集合写真&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>当時はBaaSもわからず、「名前が可愛いから」って理由でなんとなく選んだだけだったんですけどね（笑）。Milkcocoaや、&lt;a href="https://techplay.jp/community/techplay">dots.女子部&lt;/a>（現TECH PLAY女子部）という女性エンジニアコミュニティでの活動を始めて、新人エンジニアの仲間ができて、技術の会話を楽しめるようになりました。そこでエンジニアに不可欠な知識とか、新しい情報をキャッチアップする方法が身についていったと思います。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>エンジニア間の常識っぽいことって、&lt;strong>独学で体系的に学ぶことが難しい&lt;/strong>と思うんです。なので同じ界隈で活動している人たちと話すことは大事だと思っていて、今でもコミュニティ参加はできるだけするようにしています。&lt;strong>勉強会に参加したからといって業務に直結するわけではないので、バランス感覚は大事&lt;/strong>だとは思いますけどね。&lt;/p>
&lt;h2 id="heading-2">作れる幅は広いほどいい。モノ作りの枠の捉え方&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;p>ざっくり言うと、&lt;strong>モノ作りの幅を広げたくなった&lt;/strong>という気持ちの変化でしょうか。Webエンジニアの仕事を退職してフリーランスでちまちま記事を書いているところをのびすけに拾われた経緯があるので、後付けもありますが（笑）。ジョインを決めたのはdotstudioが自分の方向性と合致していると感じたからですけどね。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>時系列を辿って話すと、Webエンジニアの時代から&lt;a href="https://iotlt.connpass.com/event/94678/">IoTLT&lt;/a>というIoT系コミュニティによく参加していたんです。IoTという縛り以外は無しで、参加者が作ったモノや調べたことを各5分でLTするだけのイベントです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>勉強会なんですけど、毎回参加者の方がみなさん本当にモノ作りを楽しんでいるのが伝わってくるんですよね。「&lt;strong>大の大人がこんなに楽しんでいていいのか&lt;/strong>」ってくらい、みなさん楽しんでいて（笑）。参加するうちに、私自身もWeb技術に留まらずソフトウェア、ハードウェアと興味を持って、もっと幅広い分野でモノ作りをしたいなという気持ちが強くなりました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ 「もはやLT芸人なんです」と自身で語るほど、LT参加の多いちゃんとく氏（写真はVUILT）&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>法学部を選んだのも、Webエンジニアという職を選んだのも、&lt;strong>その時々で自分が解決できる手段をできるだけ多くしていたい&lt;/strong>という気持ちがあるからなんです。いざ、という時、自分の力で解決できるようにしておきたいんですね。&lt;/p>
&lt;p>インターネットは世界中に届きますから自分の中では圧倒的に強い解決手段だったんですけど、&lt;strong>物理でモノを作れてそれがインターネットに繋がったらもっと強くなるなと&lt;/strong>。そんな単純な理由です。今はIoTという領域ですけど、もし人間の生活の中心がVRに移ったらVRの仕事をするんだと思います。&lt;/p>
&lt;h2 id="heading-3">伝えたいことは「モノ作りの楽しさ」だけ&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;p>自分自身が初心者からWebエンジニア、ソフトウェアからハードウェアと移る経験の中で、&lt;strong>学習のハードルが高いシーンがたくさんあった&lt;/strong>んです。私は周りの人やコミュニティの力を借りてやってこれましたが、そこで諦めてしまう人がいたら悲しいなと。&lt;/p>
&lt;p>自分で手を動かしてモノを作っているときが一番楽しいですけど、教えてくれる人がいなかったり、発表の場がなかったりしたら成り立たない部分も多いです。&lt;strong>楽しんで作って、発表したり知見を書き残したりして、次にモノ作りを楽しみたい人の支えになって&lt;/strong>。そういう循環があると最高ですよね。&lt;/p>
&lt;p>なので、&lt;strong>できるだけ多くの人にモノ作りを楽しんでいてほしい&lt;/strong>んです。だから、作ったら面白いかもと思える記事を書いたり、話したり、キッカケとなるようなイベントや授業をしたりしています。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ IoTハンズオンの講師を務めるちゃんとく氏&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>そうですね。できるだけ楽しいことが伝わるよう、ハードルを低く低くして、全力で変なモノを作ることに取り組んでいます（笑）。少しでも誰かのキッカケになれていれば嬉しいですね。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>私は論理的に考えるのが得意な方ではないし、苦手でやりたくない仕事もたくさんあったし、「エンジニア向いてない！」と思うことはたくさんありました。でも、&lt;strong>手を動かしてモノを作って、動いたときの感動から離れられない&lt;/strong>んですよね。今はライターやイベント開催なども仕事にしていますけど、自分の原点は&lt;strong>モノ作りを楽しむエンジニア&lt;/strong>だと思っています。最高に楽しんでいるという意味で、天職だと思ってます（笑）。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>（取材・執筆: ちゃんとく / 撮影: のびすけ）&lt;/p>
&lt;hr>
&lt;p>&lt;!-- raw HTML omitted -->
いかがでしたでしょうか。ちゃんとくの魅力、伝わりましたか？&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->伝わりましたよね？？？&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>**ぼく・わたしの方がもっとちゃんとくの魅力を引き出せるぜ！**という方は、ぜひ取材のお申し込みお待ちしております。なにとぞ！なにとぞ！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->
さらに、**おれ・わたしも魅力的な記事を書いてdotstudioに寄稿してやるよ！**という方もぜひご連絡ください。ライター大募集中です。なにとぞ！なにとぞ！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->
また、ちゃんとくは過去にはこんな記事の執筆を行いました。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://codezine.jp/author/1693">CodeZine&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://html5experts.jp/tokutoku393/">HTML5Experts.js&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kohgakusha.co.jp/io/">月刊I/O&lt;/a>（雑誌）&lt;/li>
&lt;li>&lt;a href="http://www.itmedia.co.jp/author/218745/">@IT&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://next.rikunabi.com/journal/tag/line/">LINEエンジニア対談企画&lt;/a>（リンク先一部）&lt;/li>
&lt;li>&lt;a href="http://edge.tsumug.com/">TsumugEdge&lt;/a>（リンク先一部）&lt;/li>
&lt;/ul>
&lt;p>エンジニアバックグラウンドを活かした技術系のインタビュー、初心者向け技術ナレッジ記事を得意としていますので、&lt;strong>執筆のご依頼もお待ちしております&lt;/strong>！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>そんなわけで色んなPR記事でした！茶番にお付き合いいただきありがとうございます。&lt;/p>
&lt;p>じゃあの！&lt;/p>
&lt;p>※ちなみに表紙は某記事のパロディでした。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>MacのWi-Fi設定をコマンドラインで！面倒な設定を簡潔に済まして快適なMac生活</title><link>https://dotstud.io/blog/macos-wifi-setup-command/</link><pubDate>Wed, 29 Aug 2018 09:40:49 +0900</pubDate><guid>https://dotstud.io/blog/macos-wifi-setup-command/</guid><description>&lt;p>こんにちは、代表の&lt;a href="https://dotstud.io/members/n0bisuke">n0bisuke&lt;/a>です。&lt;/p>
&lt;p>今日はMacのWi-Fi設定をコマンドラインから行う方法を紹介します。&lt;/p>
&lt;h2 id="macwi-fi">MacのWi-Fiの再接続はけっこう時間がかかる&lt;/h2>
&lt;p>通常はこんな感じで再接続になりますが、 &lt;strong>実際30秒くらい&lt;/strong> はかかってました。
（このGIFでは途中カットしてます）&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/9e71e7ca2c6f1c7c5e0bca0a57a21159.gif" alt="">&lt;/p>
&lt;h2 id="heading">コマンドからやるとかなり速い&lt;/h2>
&lt;p>&lt;strong>コマンドから実行すると6秒くらい&lt;/strong>で再接続できました！&lt;/p>
&lt;p>驚きです。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/9f2043a45286942d16335b621a8f900a.gif" alt="">&lt;/p>
&lt;p>Macのターミナルアプリから&lt;code>networksetup&lt;/code>コマンドで実行できます。以下の３つの実行例があればかなり役に立つと思います。&lt;/p>
&lt;h3 id="wi-fi">Wi-Fiをオンにする&lt;/h3>
&lt;pre>&lt;code>sudo networksetup -setairportpower en0 on
&lt;/code>&lt;/pre>&lt;h3 id="wi-fi-1">Wi-Fiをオフにする&lt;/h3>
&lt;pre>&lt;code>sudo networksetup -setairportpower en0 off
&lt;/code>&lt;/pre>&lt;h3 id="wi-fissid">指定したWi-FiのSSIDに接続する&lt;/h3>
&lt;pre>&lt;code>sudo networksetup -setairportnetwork en0 &amp;lt;SSID&amp;gt; &amp;lt;PASSWORD&amp;gt;
&lt;/code>&lt;/pre>&lt;p>結構簡単ですね。&lt;/p>
&lt;p>上のGIFでは、オンにするコマンドとSSIDに接続するコマンドを二つ実行しています。&lt;/p>
&lt;h2 id="iot">IoT機器への接続にも役立つ&lt;/h2>
&lt;p>単純に接続するまでの時間が短縮できるメリットもありますが、Nefry BTやM5StackといったIoTデバイスのWi-Fi設定をする際に、デバイスが発信するアクセスポイントにMacから接続するときにも役立ちます。。&lt;/p>
&lt;p>&lt;a href="https://dotstud.io/docs/nefrybt-wifi-setup/">Nefry BTのWi-Fiセットアップ&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/810321bedd5c1d3991c60d9d51704fb1.png" alt="">&lt;/p>
&lt;p>この際に、会場のWi-Fiの混雑状況によってはうまく繋がらない場合も多いのですが、コマンドから直接指定してあげるとスムーズに接続できる確率があがります。&lt;/p>
&lt;pre>&lt;code>sudo networksetup -setairportnetwork en0 NefryBT-XXXX
&lt;/code>&lt;/pre>&lt;p>などで試してみましょう。&lt;/p>
&lt;h2 id="heading-1">まとめ&lt;/h2>
&lt;p>IoT周りで動いてる人でも意外と知らない知見なのかなと思い書いてみました。&lt;/p>
&lt;p>とくにハンズオンや授業をやる際には重宝するテクニックだと思います。&lt;/p>
&lt;p>それでは！&lt;/p></description></item><item><title>NodeSchoolでNode.jsの学習を始めよう！#2 - 問題1〜3の解答と解説</title><link>https://dotstud.io/blog/node-school-1-3/</link><pubDate>Fri, 18 May 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/node-school-1-3/</guid><description>&lt;p>こんにちは、ちゃんとくです！&lt;/p>
&lt;p>前回の記事で、&lt;strong>NodeSchoolの概要と基本の解き方&lt;/strong>を紹介しました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>今回はカリキュラム「&lt;strong>learnyounode&lt;/strong>」の問題1〜3の解答を解説付きで紹介したいと思います！&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->※筆者はMacユーザのため、基本的にMacに沿った説明になっています。Windows向けの説明も書いていますが、わからないときは適宜調べてみてください。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;/blockquote>
&lt;h2 id="heading">はじめに&lt;/h2>
&lt;p>さっそく問題を解いていきましょう。インストール方法や基本の解き方は前回記事をチェック！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code>$ cd /your/working/directory
&lt;/code>&lt;/pre>&lt;p>まずは解答用のファイルを作成するディレクトリに移動します。パスはご自身のものに置き換えてください。&lt;/p>
&lt;p>おさらいですが、&lt;strong>&lt;code>$&lt;/code>マークはコマンドラインであることを表しているので不要&lt;/strong>ですよ！&lt;/p>
&lt;pre>&lt;code>$ learnyounode
&lt;/code>&lt;/pre>&lt;p>「&lt;strong>learnyounode&lt;/strong>」コマンドでNodeSchoolのカリキュラムを起動します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>こんな画面が立ち上がりましたか？カーソルキーで問題を選択します。1問目の「&lt;strong>こんにちは世界&lt;/strong>」からやっていきましょう！&lt;/p>
&lt;h2 id="1">問題1「こんにちは世界」&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;p>問題の「コンソール」とは&lt;strong>今表示しているコマンドラインツール&lt;/strong>、「アプリ」とはここでは「&lt;strong>Node.jsのプログラム&lt;/strong>」を意味しています。&lt;/p>
&lt;p>この問題は「&lt;!-- raw HTML omitted -->実行するとコマンドラインに&amp;quot;こんにちは世界&amp;quot;と表示させるプログラムを書いてみましょう&lt;!-- raw HTML omitted -->」ということです。&lt;/p>
&lt;p>ヒントを読んでみると、&lt;/p>
&lt;blockquote>
&lt;p>Node.jsのアプリを作るためには .jsという拡張子を持つファイルを新規に作ってJavaScriptを書くだけです。&lt;/p>
&lt;/blockquote>
&lt;p>とあるので、&lt;code>.js&lt;/code>という拡張子のファイルを作りましょう。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>今回は1.jsというファイルを作ったので、エディタでファイルを開き、編集していきます。（操作がよくわからないという方は&lt;a href="https://dotstud.io/blog/node-school-before-learn/">前回記事&lt;/a>を確認！）&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>さらにヒントを読んでいくと、&lt;code>console.log(&amp;quot;text&amp;quot;)&lt;/code>と書くとコンソールに出力できます、とありますね。&lt;/p>
&lt;p>&lt;code>console.log()&lt;/code>は「&lt;strong>渡したものをコンソールに表示してね&lt;/strong>」という命令です。関数の&lt;code>()&lt;/code>に入れたものは「&lt;strong>引数&lt;/strong>」と呼ばれ、関数に渡されます。&lt;/p>
&lt;p>上記は&lt;code>console.log()&lt;/code>というメソッドに、&lt;code>&amp;quot;text&amp;quot;&lt;/code>という引数を渡している状態です。&lt;/p>
&lt;p>&lt;code>&amp;quot;&amp;quot;&lt;/code>（または&lt;code>''&lt;/code>）は、型が「&lt;strong>文字列&lt;/strong>」であることを表しています（その他の型は今後登場します）。&lt;/p>
&lt;p>つまり「こんにちは世界」という文字列を表示させたい場合は、&lt;code>console.log()&lt;/code>の引数に&lt;code>&amp;quot;こんにちは世界&amp;quot;&lt;/code>を渡してあげればよいですね！&lt;/p>
&lt;h3 id="heading-1">解答&lt;/h3>
&lt;pre>&lt;code>console.log(&amp;quot;こんにちは世界&amp;quot;);
&lt;/code>&lt;/pre>&lt;p>解答用のファイルに、上記のプログラムを書き込みましょう。&lt;/p>
&lt;pre>&lt;code>$ node 1.js
&lt;/code>&lt;/pre>&lt;p>Node.jsでファイルを実行して試してみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>こんにちは世界、と表示されました。これで良さそうですね！&lt;/p>
&lt;pre>&lt;code>$ learnyounode verify 1.js
&lt;/code>&lt;/pre>&lt;p>上記コマンドを実行して答え合わせをします。正解したら次の問題へ進みましょう！&lt;/p>
&lt;h2 id="2">問題2「ベイビーステップ」&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;p>ちょっとレベルが上がりました。先ほどは関数に直接引数を渡しましたが、「&lt;strong>コマンドライン引数&lt;/strong>」は、コマンドラインからプログラムに渡すものを指します。&lt;/p>
&lt;blockquote>
&lt;p>コマンドライン引数を読むためにはグローバル変数の process というオブジェクトが使えます。process には argv という配列のプロパティがあります。その配列の中には全てのコマンドライン引数が入っています。&lt;/p>
&lt;/blockquote>
&lt;p>とヒントに書いてあります。&lt;/p>
&lt;p>まず&lt;code>process.argv&lt;/code>の挙動を探るため、&lt;code>console.log()&lt;/code>を使って表示させてみましょう。&lt;/p>
&lt;pre>&lt;code>console.log(process.argv);
&lt;/code>&lt;/pre>&lt;p>上記のようなプログラムを書いた&lt;code>.js&lt;/code>ファイルを作成します（&lt;code>2.js&lt;/code>というファイルにしました）。&lt;/p>
&lt;pre>&lt;code>$ node 2.js &amp;quot;hello&amp;quot;
&lt;/code>&lt;/pre>&lt;p>プログラムに&lt;code>&amp;quot;hello&amp;quot;&lt;/code>という文字列を渡してみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>こんな感じの答えが返ってきました。&lt;code>[]&lt;/code>は「&lt;strong>配列&lt;/strong>」を表していて、&lt;code>,&lt;/code>で区切られた3つの要素が入っています。&lt;/p>
&lt;p>1つ目の要素の&lt;code>/Users/yuka/.nodebrew/node/v9.3.0/bin/node&lt;/code>は皆さんのNode.jsがインストールされているパス、2つ目の要素の&lt;code>/Users/yuka/workspace/nodeschool/learnyounode/2.js&lt;/code>は今実行したファイルのパス、3つ目の要素には&lt;strong>渡したコマンドライン引数&lt;/strong>が入っています。&lt;/p>
&lt;p>コマンドライン引数を表示させるには、&lt;strong>&lt;code>process.argv&lt;/code>の3つ目の要素&lt;/strong>を取り出してあげると良さそうです！&lt;/p>
&lt;p>試しにこんなプログラムを書いてみましょう。&lt;/p>
&lt;pre>&lt;code>console.log(process.argv[2]);
&lt;/code>&lt;/pre>&lt;p>配列の中身の位置を指定して取り出すには、&lt;code>[]&lt;/code>を使います。配列の序列は0から始まるので、3つ目の要素は「0,1,2」で「2」となります。&lt;/p>
&lt;p>このファイルに、先ほどと同様&lt;code>&amp;quot;hello&amp;quot;&lt;/code>を渡してみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>コマンドライン引数だけを表示することができました！&lt;/p>
&lt;p>では&lt;strong>いくつかの引数を渡して足し算するプログラム&lt;/strong>を書いてみます。&lt;/p>
&lt;pre>&lt;code>console.log(process.argv[2]+process.argv[3]);
&lt;/code>&lt;/pre>&lt;p>こんなプログラムを書いてみます。&lt;/p>
&lt;pre>&lt;code>$ node 2.js 1 1
&lt;/code>&lt;/pre>&lt;p>実行して試してみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「2」となって欲しいところ、「11」となってしまいました。&lt;/p>
&lt;p>これは、「1」という文字列と「1」という文字列をくっつけた結果になってしまっています（ちょっとわからない、という人は&lt;code>$ node 2.js &amp;quot;hel&amp;quot; &amp;quot;lo&amp;quot;&lt;/code>など実行してみてください）。&lt;/p>
&lt;p>&lt;code>process.argv&lt;/code>の要素は全て文字列になるので、プログラムには「&lt;strong>これは数字だよ！&lt;/strong>」と教えてあげないと、わかってくれないんですね。&lt;/p>
&lt;p>ヒントを読んでみると、数字に変換する方法が書いてあります。&lt;/p>
&lt;blockquote>
&lt;p>変換するには、数字の前に + を書きます。Number()を使う方法もあります。&lt;/p>
&lt;/blockquote>
&lt;p>数字の前に&lt;code>+&lt;/code>をつけるか、&lt;/p>
&lt;pre>&lt;code>console.log(+process.argv[2] + +process.argv[3]);
&lt;/code>&lt;/pre>&lt;p>&lt;code>Number()&lt;/code>という関数を使って文字列を数字に変換してあげます。&lt;/p>
&lt;pre>&lt;code>console.log(Number(process.argv[2]) + Number(process.argv[3]));
&lt;/code>&lt;/pre>&lt;p>エラーが出てしまった人は、&lt;code>Number()&lt;/code>の頭文字が大文字になっているか、()の数が合っているかなど確認してみてくださいね。&lt;/p>
&lt;h2 id="3io">問題3「初めてのI/O！」&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>3問目です。この問題は少し難しいので、「ファイルの中身を取り出す」ステップと、「改行を数える」ステップに分けてみます。&lt;/p>
&lt;h3 id="heading-2">ファイルの中身を取り出す&lt;/h3>
&lt;p>「&lt;strong>同期処理？ファイルシステムの関数？？？&lt;/strong>」となりますね。&lt;/p>
&lt;p>Node.jsには、あらかじめ色々な関数を用意してくれているモジュール（パッケージのようなもの）があります。その一つが&lt;code>fs&lt;/code>（file system）というモジュールです。&lt;/p>
&lt;p>&lt;code>fs&lt;/code>には、ファイルを扱うためのいろいろな関数が用意されています。&lt;/p>
&lt;pre>&lt;code>var fs = require('fs');
&lt;/code>&lt;/pre>&lt;p>モジュールを呼び出すためには、上記のように記述します。&lt;/p>
&lt;p>&lt;code>var&lt;/code>は、「&lt;strong>変数の宣言&lt;/strong>」です（最近は&lt;code>var&lt;/code>ではなく&lt;code>const&lt;/code>が推奨）。&lt;code>var fs&lt;/code>の&lt;code>fs&lt;/code>は「&lt;strong>変数名&lt;/strong>」で、任意の名前を付けられます。「fs」という名前の箱に、&lt;code>require('fs')&lt;/code>の結果を収納しているイメージです。&lt;/p>
&lt;p>&lt;code>require()&lt;/code>は&lt;strong>モジュールを呼び出す関数&lt;/strong>、引数には文字列で&lt;strong>モジュールの名前&lt;/strong>を渡します。&lt;/p>
&lt;pre>&lt;code>var fs = require('fs');
console.log(fs.readFileSync(process.argv[2]));
&lt;/code>&lt;/pre>&lt;p>&lt;code>3.js&lt;/code>というファイルを作って、上記のようなプログラムで&lt;code>fs&lt;/code>の機能を試してみましょう。ヒントによると&lt;code>fs.readFileSync()&lt;/code>の引数には読み込むファイルのパスを指定するので、コマンドライン引数で渡すようにしてみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>読み込みを試す用に、&lt;code>sample.txt&lt;/code>というテキストファイルを作ってみました。&lt;/p>
&lt;pre>&lt;code>$ node 3.js ./sample.txt
&lt;/code>&lt;/pre>&lt;p>実行して試してみます（&lt;code>./&lt;/code>は現在の位置です）。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>こんな結果が出ました。「なんじゃこりゃ！」ですね&lt;/p>
&lt;p>&lt;code>readFileSync()&lt;/code>は「Bufferオブジェクト」という形式でファイルの中身を返します。これを文字列に変換するには、&lt;code>toString()&lt;/code>という関数を使います。&lt;/p>
&lt;pre>&lt;code>var fs = require('fs');
var buf = fs.readFileSync(process.argv[2]);
var text = buf.toString();
console.log(text);
&lt;/code>&lt;/pre>&lt;p>取り出したものを変換してから&lt;code>console.log()&lt;/code>してみましょう。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>文字列として取り出すことができました！&lt;/p>
&lt;h3 id="heading-3">改行を数える&lt;/h3>
&lt;p>改行を数えるには、ヒントのように&lt;code>split()&lt;/code>を使ってみます。&lt;/p>
&lt;blockquote>
&lt;p>JavaScriptの String は .split() 関数を使って分割出来ます。\n を区切り文字として使えば String を1行ずつに分割した Array を受け取ることが出来ます。ただし、ファイルの最後の改行には気をつけてください。&lt;/p>
&lt;/blockquote>
&lt;p>下記のようなプログラムで、文字列を&lt;code>\n&lt;/code>で分割してみます（&lt;code>\n&lt;/code>は改行を表しています）。&lt;/p>
&lt;pre>&lt;code>var fs = require('fs');
var buf = fs.readFileSync(process.argv[2]);
var text = buf.toString();
var array = text.split('\n');
console.log(array);
&lt;/code>&lt;/pre>&lt;p>実行してみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>ファイルの中身を&lt;code>\n&lt;/code>で区切ることができました！&lt;/p>
&lt;p>ただし、ヒントにあるように、最後に意図しない&lt;code>''&lt;/code>が入っていますね。これはファイルの最後には改行が入るようになっているためです。&lt;/p>
&lt;p>なので、改行の数を数えるには「要素の数 - 1」をしてあげればよさそうです。&lt;/p>
&lt;p>「こんな関数使いたい！」というときは「JavaScript 配列 要素 数える」などと検索してみましょう。配列の要素を数えるためには、&lt;code>Array.length&lt;/code>というプロパティを使います。&lt;/p>
&lt;pre>&lt;code>var fs = require('fs');
var buf = fs.readFileSync(process.argv[2]);
var text = buf.toString();
var array = text.split('\n');
var n_num = array.length - 1;
console.log(n_num);
&lt;/code>&lt;/pre>&lt;p>上記のように、&lt;code>配列.length&lt;/code>で要素数を数え、最後の改行分の1を引いてみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>意図した数字になりました！&lt;/p>
&lt;p>&lt;code>$ learnyounode verify 3.js&lt;/code>で答え合わせです。&lt;/p>
&lt;h2 id="heading-4">まとめ&lt;/h2>
&lt;p>これで「learnyounode」の1〜3問目は終了です。&lt;strong>お疲れ様でした！&lt;/strong>&lt;/p>
&lt;p>プログラミングを初めて学ぶ方は、新しい情報が多く難しく感じたかもしれません。でも問題を解きながら変数や関数に慣れていけば、&lt;strong>「おっ、こういうことか」とわかる瞬間&lt;/strong>がくるはずです！&lt;/p>
&lt;p>めげずにNode.js勉強頑張っていきましょう！&lt;/p></description></item><item><title>NodeSchoolでNode.jsの学習を始めよう！インストール手順から基本操作までステップ別解説</title><link>https://dotstud.io/blog/node-school-before-learn/</link><pubDate>Fri, 20 Apr 2018 14:00:26 +0900</pubDate><guid>https://dotstud.io/blog/node-school-before-learn/</guid><description>&lt;p>こんにちは、ちゃんとくです。&lt;strong>みなさんNode.jsしてますかー！&lt;/strong>&lt;/p>
&lt;p>dotstudioでは何度も紹介していますが、Node.jsは&lt;!-- raw HTML omitted -->超超ざっくり言うとサーバサイドで動くJavaScript&lt;!-- raw HTML omitted -->ですね。&lt;/p>
&lt;p>これからNode.jsを学びたい！という人も多いと思うのですが、初めてNode.jsを学びたいときにピッタリな「&lt;strong>NodeSchool&lt;/strong>」をご存知でしょうか。&lt;/p>
&lt;p>&lt;a href="https://nodeschool.io/">&lt;img src="https://dotstud.io/img/blog/156/nodeschool.png" alt="">&lt;/a>
NodeSchoolは&lt;strong>JavaScriptに関するいろいろな授業を集めた学校のようなもの&lt;/strong>で、コードを書いて問題を解いていくことで学習を進められます。&lt;/p>
&lt;p>世界各国のさまざまな言語に対応していて、日本語に対応した「&lt;a href="https://nodeschool.io/tokyo/">NodeSchool Tokyo&lt;/a>」のページもあります。&lt;/p>
&lt;p>みんなで集まって授業を進めるハンズオンイベントも盛んで、ちょうど&lt;!-- raw HTML omitted -->5月21日にNodeSchool Tokyoが開催&lt;!-- raw HTML omitted -->されるようです！
&lt;a href="https://nodejs.connpass.com/event/82742/">&lt;img src="https://dotstud.io/img/blog/156/link.png" alt="">&lt;/a>&lt;/p>
&lt;p>今回は、そもそも「コードを書くのもコマンドラインも初めて」という人向けに、&lt;strong>NodeSchoolを始めるまで&lt;/strong>を紹介してみたいと思います。&lt;/p>
&lt;p>CLIの操作方法、Node.jsの環境構築から解説していきますが、「コマンドライン使えるよ、もうNode.js入ってるよ」という人は「&lt;a href="https://dotstud.io/blog/node-school-before-learn/#nodeschool%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">NodeSchoolのインストール&lt;/a>」の章から進めましょう！&lt;/p>
&lt;p>それではやって行こう！&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->※筆者はMacユーザのため、基本的にMacに沿った説明になっています。Windows向けの説明も書いていますが、わからないときは適宜調べてみてください。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;/blockquote>
&lt;h2 id="nodeschool">NodeSchoolを始める前に&lt;/h2>
&lt;h3 id="cli">コマンドラインインタフェース（CLI）の操作&lt;/h3>
&lt;p>NodeSchoolは、自身のPCのコマンドライン上（コマンドラインインタフェース、CLI）で進めるツールです。学習を始めるにあたって、基本の操作を覚えておきましょう！&lt;/p>
&lt;p>（↓長くなっちゃったので別記事にしました）&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="nodejs">Node.jsのインストール&lt;/h3>
&lt;p>NodeSchoolはNode.jsで動きます。NodeSchoolを動かすために、自身のPCにNode.js環境を準備をします。&lt;/p>
&lt;p>まずNode.jsがインストールされているかは、下記コマンドで確認してみてください。&lt;/p>
&lt;pre>&lt;code>$ node -v
&lt;/code>&lt;/pre>&lt;p>インストールされている場合はインストールされているバージョン、されていない場合は &lt;code>command not found&lt;/code> といったエラーが出ます。&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->※2018年4月20日時点の最新版はv9.11.1、安定板はv8.11.1です。新しめのバージョンを使うのがオススメです（v6、v7辺りで大きめの変更がありました）。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://nodejs.org/ja/">Node.js公式サイト&lt;/a>からインストーラを使ってインストールしてもよいのですが、Node.jsはバージョンアップが多いので、&lt;!-- raw HTML omitted -->Node.jsのバージョンを管理できるツールと一緒にインストールするのがオススメ&lt;!-- raw HTML omitted -->です。&lt;/p>
&lt;p>バージョン管理ツールには「nodebrew」や「nvm」、Windowsの方は「nodist」などがあります。&lt;/p>
&lt;p>「nodebrew」を使ったインストール方法をまとめたので、こちらを参考にインストールしてみてください！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="nodeschool-1">NodeSchoolのインストール&lt;/h2>
&lt;p>さて、Node.js環境の準備ができたら、&lt;strong>いよいよNodeSchoolをインストール&lt;/strong>しましょう。&lt;/p>
&lt;p>NodeSchoolは「npm」というパッケージ管理ツールで配布されているので、npmコマンドでインストールします（Node.jsと一緒にインストールされるのでとりあえず深く考えなくてOK）。&lt;/p>
&lt;p>&lt;a href="https://nodeschool.io/ja/index.html">&lt;img src="https://dotstud.io/img/blog/156/class.png" alt="">&lt;/a>
NodeSchoolには上記のようにいくつかの授業があるので、今回は「&lt;strong>learnyounode&lt;/strong>」という授業を入れてみます。下記コマンドを実行しましょう。&lt;/p>
&lt;pre>&lt;code>$ npm install -g learnyounode
&lt;/code>&lt;/pre>&lt;p>問題なくインストールされたか確認してみます。下記コマンドを実行しましょう。&lt;/p>
&lt;pre>&lt;code>$ learnyounode
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://dotstud.io/img/blog/156/learnyounode.png" alt="">
こんな画面が開いたでしょうか？&lt;/p>
&lt;p>これがNodeSchoolの実行画面で、ここから学習を進めていきます。&lt;strong>インストールお疲れ様でした！&lt;/strong>&lt;/p>
&lt;h2 id="nodeschool-2">NodeSchoolの基本操作&lt;/h2>
&lt;p>まず、「&lt;strong>とりあえずこの画面閉じたい！&lt;/strong>」というときは&lt;code>control+c&lt;/code>で終了できます。&lt;/p>
&lt;p>基本は十字キーの↑↓で移動し、エンターで選択します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/language.png" alt="">
「英語表示になっちゃってるよ！」という人は、まずは言語設定を日本語にしましょう。矢印キーで「CHOOSE LANGUAGE」に移動し、エンターで選択します。&lt;/p>
&lt;h2 id="heading">問題を解く方法&lt;/h2>
&lt;h3 id="heading-1">問題画面の見方&lt;/h3>
&lt;p>さてNodeSchoolを始める準備ができましたが、問題を解く方法も少し癖があります。試しに1問解いてみましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/helloworld.png" alt="">
十字キーで移動し、「こんにちは世界」を選んでエンターします（いわゆる&amp;quot;Hello, world&amp;quot;ですが、日本語訳するとやや不自然ですね）。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/question.png" alt="">
するとこんな文章が表示されます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/detail.png" alt="">
大きくわけると、3つの要素で構成されています。&lt;/p>
&lt;p>日本語なので、落ち着いて問題とヒントを読み進めましょう。&lt;/p>
&lt;h3 id="heading-2">ヒントを読んで進める&lt;/h3>
&lt;p>NodeSchoolでは、自分でNode.js実行ファイルを作り、実際に実行させて答え合わせをして進めていきます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/question_detail.png" alt="">
この問題は、&lt;!-- raw HTML omitted -->コンソール（ここではターミナル上）に「こんにちは世界」と表示するNode.jsスクリプトを書いてください&lt;!-- raw HTML omitted -->という意味です。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/hint1.png" alt="">
ヒントをみると、「&lt;code>.js&lt;/code>拡張子のファイルを作って、&lt;code>$ node xxx.js&lt;/code> を実行すればOKです」と書いてありますね。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/hint2.png" alt="">
そして 「&lt;code>console.log(&amp;quot;text&amp;quot;)&lt;/code> と記述するとコンソールに出力できます」とあります。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/hint3.png" alt="">
答え合わせ方法は「&lt;code>$ learnyounode verify xxx.js&lt;/code>でテストする」とあります。&lt;/p>
&lt;p>その通りにやってみましょう！&lt;/p>
&lt;h3 id="nodejs-1">Node.js実行ファイルを作る&lt;/h3>
&lt;p>問題を解くとき、この問題文＆ヒントを見ながら進めたいですよね。&lt;/p>
&lt;p>そこで操作画面をもう一つ開きます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/terminal.png" alt="">
Macの場合はツールバーの「シェル」から「新規ウィンドウ」または「新規タブ」で開くことができます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/iterm.png" alt="">
前述の記事でオススメしたiTermを使っている場合は、画面分割機能がオススメです。ツールバーの「Shell」から「Split&amp;hellip;」を選ぶか、「⌘+D」で横に分割、「⌘+Shift+D」で縦に分割できます（使用頻度が高いので覚えておくのがオススメです）。&lt;/p>
&lt;p>問題を解くファイルは、あとで見つけやすいようにひとところにまとめておきましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/work_dir.png" alt="">
ちゃんとくはこんな感じで、ホームディレクトリ（開いた場所/cdを実行した移動先）の下に &lt;code>/workspace/nodeschool/learnyounode/&lt;/code>というディレクトリを作り、その下に実行ファイルを作っています。&lt;/p>
&lt;p>好みはそれぞれなので、自分がわかりやすい場所であればなんでもOKです。&lt;/p>
&lt;p>それではファイルを作成して、実行スクリプトを書きましょう！Macの場合は&lt;code>touch&lt;/code>コマンドで新規ファイルを作成できます。&lt;/p>
&lt;pre>&lt;code>$ touch 1.js
&lt;/code>&lt;/pre>&lt;p>ファイル名も、自分がわかればOKです。どの問題かわかるように番号や問題タイトルなどをつけておくのがオススメです。&lt;/p>
&lt;h3 id="heading-3">エディタでスクリプトを書く&lt;/h3>
&lt;p>それでは「こんにちは世界」用のファイルにスクリプトを書いていきます。&lt;/p>
&lt;p>&lt;code>vi&lt;/code>コマンドなどでターミナル上で開いてもよいのですが、プログラミング向けエディタ（IDE）を使うのがオススメです。無料エディタでは&lt;a href="https://www.microsoft.com/ja-jp/dev/products/code-vs.aspx">Visual Studio Code&lt;/a>や、軽量な&lt;a href="https://atom.io/">Atomエディタ&lt;/a>などが流行りです（ちゃんとくはAtom）。&lt;/p>
&lt;p>&lt;code>$ open ./&lt;/code>というコマンド（Windowsの人は&lt;code>explore&lt;/code>）でファイルの場所を開いてみましょう。（&lt;code>./&lt;/code>は今いるディレクトリを表しています。）&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/open.png" alt="">
ファイルの場所がファインダーで表示されました。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/select_editor.png" alt="">
編集したいファイルを右クリックすると開くアプリを選択できるので、エディタで開きましょう。&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->※この「CLIからエディタでファイルを開く操作」は、エディタをカスタマイズしてコマンドで実行することもできます。Atomの場合は&lt;code>$ atom ./&lt;/code>など（後日記事にしてみたいと思います）。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/example.png" alt="">
ヒントを参考に、&lt;code>console.log(&amp;quot;text&amp;quot;)&lt;/code>コマンドを書いてみます。エディタで「⌘+s」などで保存して、試しに実行してみましょう。&lt;/p>
&lt;p>&lt;code>$ node xxx.js&lt;/code>でファイルを実行します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/script.png" alt="">
上記のような実行結果になったでしょうか？&lt;/p>
&lt;p>&lt;code>console.log()&lt;/code>というコマンドに&lt;code>&amp;quot;text&amp;quot;&lt;/code>を渡したら、「text」と表示されました。&lt;/p>
&lt;p>「こんにちは世界」と表示するには……もう分かったでしょうか？（ちょっと意地悪ですが、頑張って解いてみてください！）&lt;/p>
&lt;h3 id="heading-4">答え合わせ&lt;/h3>
&lt;p>さて、これだ！というスクリプトが書けたら答え合わせをします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/verify.png" alt="">
ヒントのとおり、&lt;code>$ learnyounode verify xxx.js&lt;/code>を実行します（learnyounodeとかファイル名とか記述するの長いなあってときは、途中まで書いてTabを押すといいことがあります）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->※CLIに慣れてくると雰囲気がわかりますが、&lt;code>$ モジュール名 命令 引数&lt;/code>という風にコマンドを実行しています。引数とはプログラムに渡すモノです。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/verify_detail.png" alt="">
答え合わせの結果画面です。自分の書いたスクリプトの実行結果と、想定回答（求められている答え）が表示されます。&lt;/p>
&lt;p>&lt;strong>無事に正解していると褒められます。&lt;/strong>&lt;/p>
&lt;p>回答例も表示されるので、確認してみましょう。&lt;/p>
&lt;p>無事に解けたら、また「&lt;a href="https://dotstud.io/blog/node-school-before-learn/#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F%E6%96%B9%E6%B3%95">問題を解く方法&lt;/a>」のように&lt;code>$ learnyounode&lt;/code> を実行して問題ファイルを開き、進めていきましょう。&lt;/p>
&lt;p>&lt;strong>NodeSchoolデビューお疲れ様でした！&lt;/strong>&lt;/p></description></item><item><title>【Mac向け】「黒い画面」の苦手意識を克服しよう！コマンドラインインタフェースの基本操作</title><link>https://dotstud.io/blog/how-to-use-cli/</link><pubDate>Mon, 09 Apr 2018 14:00:26 +0900</pubDate><guid>https://dotstud.io/blog/how-to-use-cli/</guid><description>&lt;p>こんにちは、ちゃんとくです。&lt;/p>
&lt;p>これからプログラミングの学習を始めたいと思っているみなさん、「&lt;strong>コマンドラインインタフェース&lt;/strong>」はご存知ですか？&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/illust.png" alt="">
いわゆるプログラマーなイメージの、「&lt;strong>黒い画面&lt;/strong>」ってやつですね。&lt;/p>
&lt;p>苦手意識を持つ方も多いと思いますが、プログラミングの学習を進めるにあたっては必須となっていきます。&lt;/p>
&lt;p>基本を覚えれば簡単なので、今回はコマンドラインインタフェースの基本操作を覚えていきましょう！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="cli">コマンドラインインタフェース（CLI）とは&lt;/h2>
&lt;p>コマンドラインインタフェースとは、簡単に言うとPC上で行う操作を&lt;!-- raw HTML omitted -->キーボード入力（コマンド）だけで操作する画面&lt;!-- raw HTML omitted -->のことです。&lt;strong>CLI&lt;/strong>（Comand Line Interface）と呼ばれ、逆に通常マウスなどでPCを扱う画面を&lt;strong>GUI&lt;/strong>（Grafical User Interface）と呼びます。&lt;/p>
&lt;p>Macの人は「ターミナル」を開いてみましょう。
&lt;img src="https://dotstud.io/img/blog/156/cli.png" alt="">
こういう画面です。いわゆる「黒い画面」（画像は白いけど）ってやつです。この画面は「&lt;strong>自分のPC&lt;/strong>」を表示しています。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/cli_pwd.png" alt="">
上記のように、「&lt;strong>pwd&lt;/strong>」と打ってエンターしてみてください。&lt;/p>
&lt;p>&lt;code>/Users/xxx&lt;/code> のように表示されたと思います。これは&lt;code>pwd&lt;/code>という「&lt;strong>現在のディレクトリを教えて&lt;/strong>」というコマンドを打ったので、現在いる場所が表示された状態です。（※ディレクトリ…PC上の住所。フォルダ的なもの。）&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/gui.png" alt="">
&lt;code>/Users/xxx&lt;/code> はちょっと聞きなれないディレクトリですが、ファインダーなどで「ユーザ/xxx」を開いていることと同じことを表しています。このファインダーで表示している画面が「GUI」です。&lt;/p>
&lt;p>ちなみに「pwd」は「&lt;!-- raw HTML omitted -->present working directory&lt;!-- raw HTML omitted -->」の略で、それぞれのコマンドは英語に基づいているので合わせて覚えると簡単ですね。&lt;/p>
&lt;h2 id="heading">基本のコマンドいくつか&lt;/h2>
&lt;p>ターミナルを開いたときにいる&lt;!-- raw HTML omitted -->デフォルトの場所を「ホームディレクトリ」&lt;!-- raw HTML omitted -->と言います。「cd」というコマンドを打つことでここに戻れます。&lt;/p>
&lt;p>続いて「ls」と打ってみてください。
&lt;img src="https://dotstud.io/img/blog/156/cli_ls.png" alt="">
「ls」は「list」という意味で、現在のディレクトリ直下にあるディレクトリとファイルが表示されました。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/gui_ls.png" alt="">
この場所を見ている状態と同じです。英語と日本語ですが、同じものが表示されていますね！&lt;/p>
&lt;p>ではコマンドライン上で新しいディレクトリを作り、その中へ移動してみます。
&lt;img src="https://dotstud.io/img/blog/156/cli_mkdir.png" alt="">
「mkdir 任意のディレクトリ名」と打ち、そのあと「cd ディレクトリ名/」と打ちます。（nodeschool説明記事と一緒に書いているので、nodeschool用フォルダを作っています笑）&lt;/p>
&lt;p>※mkdir…make directory / cd…change directory&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/156/gui_mkdir.png" alt="">
これは「ファインダー上で右クリックでファイルを新規作成、ダブルクリックして開く」と同じことです。&lt;/p>
&lt;p>コマンドのあとにディレクトリ名などを指定した部分は、「&lt;strong>引数&lt;/strong>」と言います。コマンドに「こういう名前で作ってね」「ここに移動してね」と渡す部分です。&lt;/p>
&lt;h2 id="heading-1">コマンドライン操作の表し方&lt;/h2>
&lt;p>「このようにコマンドを打ってみてください」というのを、大抵下記のように表します。&lt;/p>
&lt;pre>&lt;code>$ mkdir nodeschool
$ cd nodeschool/
&lt;/code>&lt;/pre>&lt;p>「$」マークはコマンドラインの操作だよーということを表しているので、打つときは不要です。&lt;/p>
&lt;h2 id="heading-2">便利なターミナルアプリ&lt;/h2>
&lt;p>Macにデフォルトで入っている「ターミナル」で進めてもよいのですが、いろいろと便利なターミナルアプリを入れておくのがオススメです。&lt;/p>
&lt;p>よく使われているのは「&lt;a href="https://www.iterm2.com/">iTerm&lt;/a>」です。（ちゃんとくの画面もこれ。）&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/158/separate.png" alt="">
いくつかの操作を並行したいときにこんな感じで画面を分割できたり、進めていく上でなにかと便利なカスタマイズができたりします。&lt;/p>
&lt;h2 id="heading-3">まとめ&lt;/h2>
&lt;p>このような感じで、コマンドでPCを操作する雰囲気が掴めたでしょうか。&lt;/p>
&lt;p>「&lt;strong>なんでわざわざ難しいコマンドで操作するの？&lt;/strong>」という感じもしますが、&lt;!-- raw HTML omitted -->ゆくゆくプログラムを管理したり書いたりしていく上で便利になっていく&lt;!-- raw HTML omitted -->ので覚えておきましょう！&lt;/p>
&lt;p>もっとコマンドを知りたい！という人は「&lt;strong>UNIXコマンド&lt;/strong>」を調べてみてください！&lt;/p></description></item><item><title>Google公式ライブラリを利用してNode.jsからGmailの送受信をしてみよう</title><link>https://dotstud.io/blog/gmail-api-from-nodejs/</link><pubDate>Wed, 21 Feb 2018 17:43:26 +0900</pubDate><guid>https://dotstud.io/blog/gmail-api-from-nodejs/</guid><description>&lt;p>こんにちは、のびすけです。&lt;/p>
&lt;p>Node.jsでGmailを制御する方法は、過去に色々な記事が出ているのですが、全体的に記事が古く、&lt;a href="https://developers.google.com/gmail/api/quickstart/nodejs?hl=ja">Gmail API Node.js Quickstart&lt;/a>のチュートリアルも割とわかりにくいなぁという印象です。英語しかないし。&lt;/p>
&lt;p>また、勝手ライブラリも多いのですがメンテナンスされてなく利用していく際の不安も多いです。&lt;/p>
&lt;p>ということで、今日はNode.jsでGmailを使う方法の紹介です。&lt;/p>
&lt;p>以前書いたSpreadSheets記事も同様のGoogle APIライブラリを利用しているので基本的な手順は同じです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="gmail-api">Gmail APIの有効化とクライアントシークレットの取得&lt;/h2>
&lt;p>&lt;a href="https://console.developers.google.com/start/api?id=gmail&amp;amp;hl=ja">こちらのリンク&lt;/a>からウィザード開始します。ログインしているGoogleアカウントが利用するGmailのアカウントになるので複数のGoogleやG Suiteのアカウントを持っている人は注意しましょう。&lt;/p>
&lt;p>チェックをして進みます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/7aa9886c3113712265ee866ed58f6658.png" alt="">&lt;/p>
&lt;p>少し待つとAPIが有効になるので進みます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/2babe62f7ce826080545439c3c2675d9.png" alt="">&lt;/p>
&lt;p>認証情報に進みますが&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>&lt;strong>例によってこの画面は何もせずに&lt;code>キャンセル&lt;/code>ボタンを押しましょう。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/1934915770a80c6fab94ee9818f9cf65.png" alt="">&lt;/p>
&lt;p>このダッシュボード画面になりますが、&lt;code>OAuth同意画面&lt;/code>のタブを選択します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/7f28a9c626ea9f2ecd0b4691ef337859.png" alt="">&lt;/p>
&lt;p>&lt;code>ユーザーに表示するサービス名&lt;/code>の箇所に任意の名前を入力して、保存を押して進みます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/b93e391525943007cddd5de87a22acbf.png" alt="">&lt;/p>
&lt;p>認証情報タブに戻り、&lt;code>認証情報を作成&lt;/code> -&amp;gt; &lt;code>OAuthクライアントID&lt;/code>を選択します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/57b7c424a42dd9fedaed483ebbf5d84b.png" alt="">&lt;/p>
&lt;p>クライアントID作成画面では&lt;code>その他&lt;/code>を選択し、任意の名前を入力します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/124eeda9adf92739b1eff9b1e3afcb42.png" alt="">&lt;/p>
&lt;p>作成すると最初のダッシュボード画面に戻りますが、作成したクライアントIDが表示されています。ここの右下のダウンロードボタンを押すとクライアントシークレットが保存されたJSONファイルがダウンロードされます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/64db51910795b26e05aef6cb9918c33f.png" alt="">&lt;/p>
&lt;p>任意の場所に&lt;code>client_secret.json&lt;/code>という名前にリネームして保存しましょう。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/8a4b65dfb3319eee11ddea1d0e7d407d.png" alt="">&lt;/p>
&lt;p>これで、 &lt;strong>クライアントシークレットの保存が出来ました。&lt;/strong>&lt;/p>
&lt;h2 id="nodejs">Node.jsプロジェクトの準備&lt;/h2>
&lt;p>Node.jsはv9.5.0です。&lt;/p>
&lt;pre>&lt;code>mkdir gmail
cd gmail
npm init -y
&lt;/code>&lt;/pre>&lt;p>先ほどの&lt;code>client_secret.json&lt;/code>をこのディレクトリに移動します。&lt;/p>
&lt;pre>&lt;code>ls
package.json client_secret.json
&lt;/code>&lt;/pre>&lt;p>ライブラリのインストールをすれば準備完了です。google-auth-libraryのバージョンは1.3.1になります。&lt;/p>
&lt;pre>&lt;code>$ npm i googleapis google-auth-library --save
&lt;/code>&lt;/pre>&lt;p>これで準備完了です。&lt;/p>
&lt;h2 id="heading">アクセストークンの保存&lt;/h2>
&lt;p>本家とは少し違うやり方です。&lt;/p>
&lt;p>本家のコードだとアクセストークンの作成&amp;amp;保存作業と実際のAPI呼び出しが一緒になったコードですがトークンの作成&amp;amp;保存は最初のみ行えば良いので手順を分けて紹介します。&lt;/p>
&lt;p>&lt;code>getAndStoreToken.js&lt;/code>を作成します。&lt;/p>
&lt;p>&lt;a href="https://dotstud.io/blog/google-spreadsheets-from-nodejs/">前回の記事のコード&lt;/a>とほぼ同様ですが、APIライブラリのバージョンの違いにより、呼び出し方が少し異なります。注意しましょう。&lt;/p>
&lt;pre>&lt;code>//getAndStoreToken.js
'use strict';
const fs = require('fs');
const readline = require('readline');
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});
const {promisify} = require('util');
const {google} = require('googleapis');
const {OAuth2Client} = require('google-auth-library');
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);
const SCOPES = ['https://www.googleapis.com/auth/gmail.send','https://www.googleapis.com/auth/gmail.readonly'];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+'/gmail-nodejs-quickstart.json';
const main = async () =&amp;gt; {
const content = await readFileAsync(__dirname+'/client_secret.json');
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
//get new token
const authUrl = oauth2Client.generateAuthUrl({
access_type: 'offline',
scope: SCOPES
});
console.log('Authorize this app by visiting this url: ', authUrl);
rl.question('Enter the code from that page here: ', (code) =&amp;gt; {
rl.close();
oauth2Client.getToken(code, async (err, token) =&amp;gt; {
if (err) {
console.log('Error while trying to retrieve access token', err);
return;
}
oauth2Client.credentials = token;
try {
fs.mkdirSync(TOKEN_DIR);
} catch (err) {
if (err.code != 'EEXIST') throw err;
}
await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
console.log('Token stored to ' + TOKEN_PATH);
});
});
};
main();
&lt;/code>&lt;/pre>&lt;p>ここで&lt;code>'https://www.googleapis.com/auth/gmail.readonly','https://www.googleapis.com/auth/gmail.send'&lt;/code>の二つのスコープを指定していますが、表示用のgmail.readonlyとメール送信用のgmail.sendとなっています。表示だけしたい場合や送信だけしたい場合などで使い分けましょう。スコープについては&lt;a href="https://developers.google.com/gmail/api/auth/scopes">
Choose Auth Scopes&lt;/a>で細かく確認できます。&lt;/p>
&lt;p>では、このプログラムを実行しましょう。&lt;/p>
&lt;pre>&lt;code>node getAndStoreToken.js
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png" alt="">&lt;/p>
&lt;p>&lt;code>https://accounts.google.com/~&lt;/code>で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png" alt="">&lt;/p>
&lt;p>アカウント選択画面になります。 複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/c5f18901079fc0f4c0362cb0213e89c6.png" alt="">&lt;/p>
&lt;p>許可で進みます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png" alt="">&lt;/p>
&lt;p>認証用のコードが発行されるので、ターミナルの&lt;code>Enter the code from that page here:&lt;/code>と書いてある箇所にコピぺしてEnterで進みます。&lt;/p>
&lt;pre>&lt;code>Token stored to /Users/path/to/myapp/gmail-nodejs-quickstart.json
&lt;/code>&lt;/pre>&lt;p>などの表示が出て、&lt;code>gmail-nodejs-quickstart.json&lt;/code>が保存されます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/4fc90f71b3520a01ce2c568eb28e005f.png" alt="">&lt;/p>
&lt;p>これでアクセストークンの保存が完了しました。&lt;/p>
&lt;h2 id="4-gmail">4. いよいよGmailにアクセス&lt;/h2>
&lt;p>いよいよGmailにアクセスします。&lt;/p>
&lt;h3 id="heading-1">ラベル一覧の取得&lt;/h3>
&lt;p>本家チュートリアルを参考に、ラベルの一覧を取得します。
&lt;code>getLabels.js&lt;/code>を作成します。&lt;/p>
&lt;p>ここから先に出てくる&lt;code>userId: 'me'&lt;/code>の&lt;code>me&lt;/code>は指定されている文字列らしく、自分のメアドやアカウント名をあえて指定する必要はなくそのまま&lt;code>me&lt;/code>と書いておけば問題なさそうです。&lt;/p>
&lt;pre>&lt;code>//getLabels.js
'use strict';
const fs = require('fs');
const {promisify} = require('util');
const {google} = require('googleapis');
const {OAuth2Client} = require('google-auth-library');
const gmail = google.gmail('v1');
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const gmailListLabesAsync = promisify(gmail.users.labels.list); //Gmailのラベル一覧
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + '/gmail-nodejs-quickstart.json'; //アクセストークンのファイルを指定
const main = async () =&amp;gt; {
//クレデンシャル情報の取得
const content = await readFileAsync(__dirname+'/client_secret.json'); //クライアントシークレットのファイルを指定
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
const token = await readFileAsync(TOKEN_PATH);
oauth2Client.credentials = JSON.parse(token);
//API経由でシートにアクセス
const response = await gmailListLabesAsync({
auth: oauth2Client,
userId: 'me',
});
//結果を表示
console.log(response.data);
};
main();
&lt;/code>&lt;/pre>&lt;p>Async/Awaitで利用できるように&lt;code>const gmailListLabesAsync = promisify(gmail.users.labels.list); &lt;/code>の箇所でPromisifyを利用してプロミス化しています。&lt;/p>
&lt;p>実行するとラベル一覧が取得できます。&lt;/p>
&lt;pre>&lt;code>node getLabels.js
{ labels:
[ { id: 'Label_125',
name: '研修/青山学院大学',
messageListVisibility: 'show',
labelListVisibility: 'labelShow',
type: 'user',
color: [Object] },
{ id: 'Label_40',
name: '取引/養老乃瀧',
messageListVisibility: 'show',
labelListVisibility: 'labelShow',
type: 'user',
color: [Object] },
・
・
・
&lt;/code>&lt;/pre>&lt;p>会社のメールの内容なので出せるところだけ笑&lt;/p>
&lt;h3 id="heading-2">メールの内容を取得&lt;/h3>
&lt;p>メールの内容は&lt;code>Users.messages: list&lt;/code>と&lt;code>Users.messages: get&lt;/code>を利用します。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://developers.google.com/gmail/api/v1/reference/users/messages/get">https://developers.google.com/gmail/api/v1/reference/users/messages/get&lt;/a>
&lt;a href="https://developers.google.com/gmail/api/v1/reference/users/messages/list">https://developers.google.com/gmail/api/v1/reference/users/messages/list&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>必要な箇所だけ抜粋しますが、&lt;code>gmail.users.messages.list()&lt;/code>と&lt;code>gmail.users.messages.get()&lt;/code>というメソッドがあるので利用します。
Async/Awaitで利用できるように、先ほど同様Promisifyします。&lt;/p>
&lt;pre>&lt;code>const gmailGetMessagesAsync = promisify(gmail.users.messages.get);
const gmailListMessagesAsync = promisify(gmail.users.messages.list);
&lt;/code>&lt;/pre>&lt;p>メッセージリストを取得し、メッセージごとのIDを取得します。メッセージIDをもとにメッセージ本文を取得。
最後に本文はBase64変換されてるのでデコードして表示します。&lt;/p>
&lt;pre>&lt;code>省略
//メッセージリストの取得
let res = await gmailListMessagesAsync({
auth: oauth2Client,
userId: 'me'
});
const newestMessageId = res.messages[0].id; //最新のメッセージID
//メッセージの取得
res = await gmailGetMessagesAsync({
auth: oauth2Client,
userId: 'me',
id: newestMessageId
});
//結果を表示
const base64mailBody = res.payload.parts[0].body.data; //parts[0]がテキスト、parts[1]がHTMLメールっぽい(?)
const mailBody = new Buffer(base64mailBody, 'base64').toString(); //メール本文はBase64になってるので変換
console.log(mailBody);//やっとメール本文が表示される
省略
&lt;/code>&lt;/pre>&lt;h3 id="heading-3">メールの送信&lt;/h3>
&lt;p>送信が割と大変でした。&lt;/p>
&lt;p>&lt;code>Users.messages: send&lt;/code>を利用します。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://developers.google.com/gmail/api/v1/reference/users/messages/send">https://developers.google.com/gmail/api/v1/reference/users/messages/send&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>gmail.users.messages.send()&lt;/code>のメソッドを利用します。
先ほどと同様にPromisifyします。&lt;/p>
&lt;pre>&lt;code>const gmailSendMessagesAsync = promisify(gmail.users.messages.send);
&lt;/code>&lt;/pre>&lt;p>次にメール送信時の処理です。&lt;/p>
&lt;pre>&lt;code>省略
const makeBody = (params) =&amp;gt; {
params.subject = new Buffer(params.subject).toString(&amp;quot;base64&amp;quot;); //日本語対応
const str = [
`Content-Type: text/plain; charset=\&amp;quot;UTF-8\&amp;quot;\n`,
`MIME-Version: 1.0\n`,
`Content-Transfer-Encoding: 7bit\n`,
`to: ${params.to} \n`,
`from: ${params.from} \n`,
`subject: =?UTF-8?B?${params.subject}?= \n\n`,
params.message
].join('');
return new Buffer(str).toString(&amp;quot;base64&amp;quot;).replace(/\+/g, '-').replace(/\//g, '_');
}
const messageBody = `
XXXX 様
商品のご購入、誠にありがとうございます。
・Nefry BT x 1
の商品を本日発送しましたのでご連絡差し上げます。
こちらから配送状況をご確認頂けます。
(このメール送信の時点では反映されていない可能性もあります)
https://trackings.post.japanpost.jp/xxxxxxxxxx`;
const raw = makeBody({
to: '相手のメールアドレス',
from: '送信者のメールアドレス',
subject: '件名(日本語可)',
message: messageBody
});
const res = await gmailSendMessagesAsync({
auth: oauth2Client,
userId: 'me',
resource: {
raw: raw
}
});
console.log(res.data);
省略
&lt;/code>&lt;/pre>&lt;p>&lt;code>sendMail.js&lt;/code>などを作成し、この内容で実行するとメールが送信できます。&lt;/p>
&lt;pre>&lt;code>node sendMail.js
{ id: 'xxxxxxxxxxxxxxxxx',
threadId: 'xxxxxxxxxxxxxxxx',
labelIds: [ 'SENT' ] }
&lt;/code>&lt;/pre>&lt;p>Gmail側で受信確認をすると、しっかりと送られてきています。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/3ad5f4729e90c9523e2e6e5cb972349b.png" alt="">&lt;/p>
&lt;p>また、暗号化もされているようで、&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://support.google.com/mail/answer/6330403?authuser=2&amp;amp;visit_id=1-636548034928176578-836942562&amp;amp;p=tls&amp;amp;hl=ja&amp;amp;rd=1">送受信時のメールの暗号化 - Gmailヘルプ&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;img src="https://i.gyazo.com/247eb44de5f0b635d52fd2b0c06a4de3.png" alt="">&lt;/p>
&lt;/blockquote>
&lt;p>Node.jsのメール送信ライブラリはいくつかあって、いくつか試したときに暗号化されてない場合も多かった印象です。暗号化無しだと、この赤いアラートっぽいメール表示になります。&lt;/p>
&lt;p>今回のやり方はGoogle公式のライブラリで、特に意識せずに暗号化も行われているので暗号化に対するアラートなども受け取り手には表示されないので迷惑メールなどに振り分けられてしまう心配もたぶん少ないのでは。
（Gmailの迷惑メールアルゴリズムは色々な要素がありそうなので断言は出来ないですが）&lt;/p>
&lt;h2 id="heading-4">所感&lt;/h2>
&lt;p>実装途中の感想ですが、メール送信が割と苦労した印象です。&lt;/p>
&lt;p>メール送信のNode.jsサンプルが無かったので、&lt;a href="https://developers.google.com/gmail/api/v1/reference/users/messages/send#examples">JavaScript Sample&lt;/a>を見ると、送信パラメータに&lt;code>email RFC 5322 formatted String.&lt;/code>という記述があってRFCのフォーマットを確認する必要がありました。&lt;/p>
&lt;p>この手のライブラリだと&lt;/p>
&lt;pre>&lt;code>const params = {
to: '',
from: '',
subject: '',
body: ''
}
&lt;/code>&lt;/pre>&lt;p>みたいな形式のObjectを突っ込めばいい感じにやってくれる印象があったので&amp;hellip;&amp;hellip;苦笑&lt;/p>
&lt;p>Stack Over Flowの&lt;a href="https://stackoverflow.com/questions/34546142/gmail-api-for-sending-mails-in-node-js">Gmail API for sending mails in Node.js&lt;/a>がかなり参考になりました。&lt;/p>
&lt;p>また、日本語でのSubject送信に&lt;code>=?文字コード?メソッド?Base64変換した文字列?=&lt;/code>という形式で渡すなどは&lt;a href="http://hogem.hatenablog.com/entry/20100122/1264169093">メールのSubjectヘッダのエンコード&lt;/a>の記事が参考になりました。&lt;/p>
&lt;p>とはいえ、問題なくメール送信出来たので、この記事を参考に使ってみてください。&lt;/p>
&lt;p>それでは！&lt;/p>
&lt;h2 id="-">補足: 本家のチュートリアルのエラー&lt;/h2>
&lt;p>今回紹介した手順では問題ないですが、もともとのチュートリアルのコードだと以下の二つのエラーが出ました。(2018年2月時点)&lt;/p>
&lt;h3 id="googlegmail-is-not-a-function">google.gmail is not a function&lt;/h3>
&lt;pre>&lt;code>google.gmail() is giving an error TypeError: google.gmail is not a function?
&lt;/code>&lt;/pre>&lt;p>ってエラーが出ました。&lt;/p>
&lt;p>Stack Over Flowの&lt;a href="https://stackoverflow.com/questions/48762090/google-gmail-is-giving-an-error-typeerror-google-gmail-is-not-a-function">google.gmail() is giving an error TypeError: google.gmail is not a function?&lt;/a>を参考に&lt;/p>
&lt;pre>&lt;code>var google = require('googleapis');
&lt;/code>&lt;/pre>&lt;p>これを↓に変更するとエラー解消されます。&lt;/p>
&lt;pre>&lt;code>var {google} = require('googleapis');
&lt;/code>&lt;/pre>&lt;h3 id="googleauth-is-not-a-constructor">GoogleAuth is not a constructor&lt;/h3>
&lt;p>こちらはIssueがあがっていて&lt;a href="https://github.com/google/google-auth-library-nodejs/issues/251">GoogleAuth is not a constructor #251&lt;/a>を見ると、&lt;/p>
&lt;p>呼び出し方が変更されてて、以下の修正が必要です。&lt;/p>
&lt;pre>&lt;code>const { GoogleAuth } = require('google-auth-library');
&lt;/code>&lt;/pre>&lt;p>↓&lt;/p>
&lt;pre>&lt;code>const { OAuth2Client } = require('google-auth-library');
&lt;/code>&lt;/pre>&lt;p>また、今の変更に伴いOAuthの処理も変更が必要です。&lt;/p>
&lt;pre>&lt;code>const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
&lt;/code>&lt;/pre>&lt;p>↓&lt;/p>
&lt;pre>&lt;code>//const auth = new googleAuth();
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
&lt;/code>&lt;/pre>&lt;p>これで問題なく利用できるようになりました。&lt;/p></description></item><item><title>Node.jsを始めよう！nodebrewを使って5分で環境構築</title><link>https://dotstud.io/blog/nodejs-install-use-nodebrew/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://dotstud.io/blog/nodejs-install-use-nodebrew/</guid><description>&lt;p>この記事は&lt;a href="https://qiita.com/advent-calendar/2017/nodejs2">Node.js Advent Calendar 2017&lt;/a>に参加しています！&lt;/p>
&lt;p>こんにちは、エンジニアのちゃんとくです。「これからNode.jsを始めたい！」という人向けに導入記事をまとめていきたいと思います。まずは環境構築からはじめましょう！&lt;/p>
&lt;p>今回はNode.jsのバージョンを管理できる「&lt;strong>nodebrew&lt;/strong>」を使ったインストール手順を紹介します。&lt;/p>
&lt;h2 id="heading">普通のダウンロードじゃダメなの？&lt;/h2>
&lt;p>&lt;a href="https://nodejs.org/ja/">&lt;img src="https://dotstud.io/img/blog/136/1.png" alt="">&lt;/a>
&lt;a href="https://nodejs.org/ja/">Node.js公式ページ&lt;/a>にアクセスすると、どーんとダウンロードボタンがありますね。これをクリックすると、表記のバージョンのNode.jsパッケージが降ってきます。&lt;/p>
&lt;p>&lt;strong>しかし！&lt;/strong>&lt;/p>
&lt;p>Node.jsはバージョンアップの頻度が高く、その都度ダウンロードし直すのは大変ですよね。&lt;/p>
&lt;p>プロジェクトによっては古いバージョンを使いたかったり、プロジェクトごとにバージョンを変えたかったりしたいときもあります。&lt;/p>
&lt;p>&lt;strong>そこで役に立つのがNode.jsのバージョン管理ツールです&lt;/strong>！&lt;/p>
&lt;p>今回紹介する&lt;strong>nodebrew&lt;/strong>以外にも、世界的に利用者の多い&lt;strong>NVM&lt;/strong>（Node Version Manager）やWindows向けの&lt;strong>nodist&lt;/strong>などがあります。&lt;/p>
&lt;p>今回は日本人コミッタが多く困ったときにも質問しやすいnodebrewでやってみます！&lt;/p>
&lt;h2 id="nodebrew">nodebrewをインストール&lt;/h2>
&lt;p>さっそくnodebrewをインストールしましょう！以下のコマンドを実行します。（&lt;code>$&lt;/code>マークはCLIであることを表しているのでコピペの際は不要です！）&lt;/p>
&lt;pre>&lt;code>$ curl -L git.io/nodebrew | perl - setup
&lt;/code>&lt;/pre>&lt;p>完了するとこんなことを言われます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/136/2.png" alt="">&lt;/p>
&lt;p>「&lt;code>~/.nodebrew&lt;/code>にインストールしたからPATH通してね！」というようなことを言っています。&lt;/p>
&lt;p>&lt;code>~/.bash_profile&lt;/code>などの設定ファイルに&lt;code>export PATH=$HOME/.nodebrew/current/bin:$PATH&lt;/code>を追加しましょう。&lt;/p>
&lt;p>追記したらターミナルを開き直すか&lt;code>source&lt;/code>コマンドで更新します。&lt;/p>
&lt;pre>&lt;code>$ source ~/.bash_profile
&lt;/code>&lt;/pre>&lt;p>nodebrewコマンドが使えるか確認してみます。&lt;code>command not found&lt;/code>が出なければOKです。&lt;/p>
&lt;pre>&lt;code>$ nodebrew help
nodebrew 0.9.8
Usage:
…
&lt;/code>&lt;/pre>&lt;h2 id="nodebrewnodejs">nodebrewでNode.jsをインストール&lt;/h2>
&lt;p>まずは&lt;code>nodebrew ls-remote&lt;/code>コマンドでダウンロード可能なNode.jsのバージョンを確認してみます。&lt;/p>
&lt;p>Node.jsは偶数のバージョンがLTS（安定板）、奇数のバージョンが最新版となっています。&lt;/p>
&lt;pre>&lt;code>$ nodebrew ls-remote
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://dotstud.io/img/blog/136/3.png" alt="">
実行するとべろーっとバージョンが出てきますね。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/136/4.png" alt="">
下の方まで見ると2017年12月15日現在はLTSがv8.9.3、最新がv9.3.0であることがわかりました。（io.jsはNode.jsのForkですが、一旦気にしなくてOK）&lt;/p>
&lt;p>今回は最新版のv9.3.0をインストールしてみます。&lt;code>nodebrew install-binary&lt;/code>コマンドを利用します。&lt;/p>
&lt;pre>&lt;code>$ nodebrew install-binary v9.3.0
&lt;/code>&lt;/pre>&lt;p>1分くらいでインストールは完了します。（ダメ回線なので、もっと速いかもしれません）&lt;/p>
&lt;p>&lt;code>nodebrew ls&lt;/code>コマンドで状態を確認します。&lt;/p>
&lt;pre>&lt;code>$ nodebrew ls
v9.3.0
current: none
&lt;/code>&lt;/pre>&lt;p>使用するバージョンの&lt;code>current&lt;/code>がnoneになっているので指定します。&lt;/p>
&lt;pre>&lt;code>$ nodebrew use v9.3.0
$ node -v
v9.3.0
&lt;/code>&lt;/pre>&lt;p>これでNode.jsのインストールは完了です！&lt;/p>
&lt;h2 id="heading-1">バージョン切り替え&lt;/h2>
&lt;p>別のバージョンを使いたくなったら、nodebrewでバージョンを切り替えてみましょう。&lt;/p>
&lt;p>試しにLTSのv8.9.3を使えるようにしてみます。まずはインストール。&lt;/p>
&lt;pre>&lt;code>$ nodebrew install-binary v8.9.3
&lt;/code>&lt;/pre>&lt;p>v8.9.3とv9.3.0が使えるようになりましたが、まだ&lt;code>current&lt;/code>はv9.3.0のままです。&lt;/p>
&lt;pre>&lt;code>$ nodebrew list
v8.9.3
v9.3.0
current: v9.3.0
&lt;/code>&lt;/pre>&lt;p>&lt;code>nodebrew use&lt;/code>でv8.9.3を指定します。&lt;/p>
&lt;pre>&lt;code>$ nodebrew use v8.9.3
$ nodebrew list
v8.9.3
v9.3.0
current: v8.9.3
&lt;/code>&lt;/pre>&lt;p>これでバージョンが切り替えられました！listにあるバージョンは再インストールすることなく切り替えられます。&lt;/p>
&lt;h2 id="heading-2">まとめ&lt;/h2>
&lt;p>ここまで特にむずかしいところなく環境構築できたのではないかと思います！はじめるまでの手軽さもNode.jsの魅力のひとつですよね。&lt;/p>
&lt;p>次回はNode.jsをはじめたばかりの人向けチュートリアルをやってみたいと思います。&lt;/p>
&lt;p>それではまた！&lt;/p></description></item><item><title>【予測変換】Macで日本語の変換ウィンドウが消えなくなったときの対処法【邪魔】</title><link>https://dotstud.io/blog/mac-nihongo-window-error/</link><pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate><guid>https://dotstud.io/blog/mac-nihongo-window-error/</guid><description>&lt;p>こんにちは、エンジニア兼ライターのちゃんとくです。日々たくさんのコードや文字を書き続けているわけですが、&lt;strong>突然消えなくなるアレ&lt;/strong>に悩まされています。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/137/1.png" alt="">
これ。&lt;/p>
&lt;p>クリックしてもEscapeしてもQuitしても消えなくて本当に邪魔ですよね。&lt;/p>
&lt;p>わりと起こる頻度が高いのでそのたびに再起動するのも面倒です。&lt;/p>
&lt;h2 id="heading">日本語入力のプロセスをキルする&lt;/h2>
&lt;p>タイトルが全てですが、日本語入力のプロセスを終了すると消すことができます。&lt;/p>
&lt;p>［アクテビティモニタ］を開いて［日本語入力］を探します。
&lt;img src="https://dotstud.io/img/blog/137/2.png" alt="">&lt;/p>
&lt;p>ダブルクリックするとウィンドウが開くので［終了］をクリックします。
&lt;img src="https://dotstud.io/img/blog/137/3.png" alt="">&lt;/p>
&lt;p>平和がおとずれましたね。&lt;/p>
&lt;h2 id="heading-1">まとめ&lt;/h2>
&lt;p>Adventやら原稿やらガリガリ書いているときに邪魔でしょうがないので紹介してみました。&lt;/p>
&lt;p>El Capitanからアップデートしたらなおるのかなぁ。。&lt;/p></description></item><item><title>Node.jsでGoogle SpreadSheetsを操作してみよう。【GAS不使用】</title><link>https://dotstud.io/blog/google-spreadsheets-from-nodejs/</link><pubDate>Mon, 04 Dec 2017 13:14:41 +0900</pubDate><guid>https://dotstud.io/blog/google-spreadsheets-from-nodejs/</guid><description>&lt;p>こんにちは、代表ののびすけです。&lt;/p>
&lt;p>この記事は&lt;a href="https://qiita.com/advent-calendar/2017/nodejs">Node.jsアドベントカレンダー2017&lt;/a>の記事になります。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://developers.google.com/apps-script/">GAS&lt;/a>じゃなくてNode.jsから直接スプレッドシートにアクセスしたい！&lt;/strong>&lt;/p>
&lt;p>そう思って調べると&lt;a href="https://developers.google.com/sheets/api/quickstart/nodejs">Node.js Quickstart | Sheets API | Google Developers&lt;/a>が出て来ますが、JS記述も古いし英語なので少しとっつきにくいです。&lt;/p>
&lt;p>ということでちょっと試して記録残そうと思います。&lt;/p>
&lt;h2 id="google-sheets-api">Google Sheets API&lt;/h2>
&lt;p>&lt;a href="https://developers.google.com/sheets/guides/concepts?hl=ja">Google Sheets API&lt;/a>はスプレッドシートにアクセスできるようになるAPIです。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/81dd3461cd263ea7e4d63f06fef54747.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>Google Sheets API を使用すると、スプレッドシートの要素を読み取って変更できます。 スプレッドシートは多くの設定を備えており、美しく機能的なシートを作成することができます。&lt;/p>
&lt;/blockquote>
&lt;p>普段慣れている言語でスプレッドシートにアクセス出来まるので、簡単な操作であれば、GASを使う必要もないです。&lt;/p>
&lt;p>今回のサンプルは&lt;a href="https://github.com/n0bisuke/google-spread-sheet-node.js-sample">こちら&lt;/a>に置いておきます。&lt;/p>
&lt;h3 id="heading">環境&lt;/h3>
&lt;ul>
&lt;li>Node.js v9.2.0&lt;/li>
&lt;li>macOS High Sierra&lt;/li>
&lt;/ul>
&lt;p>参考までに今回の僕の環境です。&lt;/p>
&lt;p>では実際に作っていきます。&lt;/p>
&lt;h2 id="1-google-sheets-api">1. Google Sheets APIを使えるようにする&lt;/h2>
&lt;p>ちなみに2017年12月時点でのウィザードです。こういうのはアップデートによって画面遷移変わるので適宜読み替えてください。&lt;/p>
&lt;blockquote>
&lt;p>Use this wizard to create or select a project in the Google Developers Console and automatically turn on the API. Click Continue, then Go to credentials.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://console.developers.google.com/start/api?id=sheets.googleapis.com">こちらのリンク&lt;/a>からディベロッパーコンソールにいき、&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/31e8011951d1552b8f7126eb459da474.png" alt="">&lt;/p>
&lt;p>&lt;code>新機能のお知らせ、パフォーマンスに関するアドバイス、フィードバック調査、特典に関する最新情報をメールで受け取ります。&lt;/code>の質問はいいえでもたぶん大丈夫です。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/60c5bf6a1e772473dc9fc6d4d7526077.png" alt="">&lt;/p>
&lt;p>&lt;code>認証情報に進む&lt;/code>を選択&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/848f8f79460aac991b46956111f0da07.png" alt="">&lt;/p>
&lt;p>この画面が出ますが、&lt;code>キャンセル&lt;/code>を選択します。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/e827d6ab-d728-1016-d22a-76cef4e4972e.png" alt="スクリーンショット 2017-12-03 21.00.17.png" title="スクリーンショット 2017-12-03 21.00.17.png">&lt;/p>
&lt;p>&lt;code>OAuth同意画面&lt;/code>のタブを選択し、メールアドレスを確認し、&lt;code>ユーザーに表示するサービス名&lt;/code>を入力します。&lt;/p>
&lt;p>&lt;code>保存&lt;/code>を選択しましょう。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/1ca3a2d5-b639-bb6c-9508-225d162c96ff.png" alt="スクリーンショット 2017-12-03 21.01.07.png" title="スクリーンショット 2017-12-03 21.01.07.png">&lt;/p>
&lt;p>次に、&lt;code>認証情報&lt;/code>のタブを選択し、 &lt;code>認証情報を作成&lt;/code> -&amp;gt; &lt;code>OAuthクライアントID&lt;/code>を選択します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/3d5b6da9cf3086b11c728cdc31307268.png" alt="">&lt;/p>
&lt;p>&lt;code>その他&lt;/code>を選択し、任意の名前をつけて&lt;code>作成&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/a8a25dd3-a194-d4a3-ac57-909f8d7712e0.png" alt="スクリーンショット 2017-12-03 21.06.47.png" title="スクリーンショット 2017-12-03 21.06.47.png">&lt;/p>
&lt;p>&lt;code>OK&lt;/code>で進みます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/93c1e777-682e-434e-444d-a3aa8659bd54.png" alt="スクリーンショット 2017-12-03 21.07.25.png" title="スクリーンショット 2017-12-03 21.07.25.png">&lt;/p>
&lt;p>&lt;code>client_secret_xxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com.json&lt;/code>のようなファイルがダウンロードされます。&lt;/p>
&lt;p>&lt;strong>これを&lt;code>client_secret.json&lt;/code>にリネームしましょう。&lt;/strong>&lt;/p>
&lt;h2 id="2-nodejs">2. Node.jsプロジェクトの準備&lt;/h2>
&lt;p>任意のディレクトリを作成して移動します。&lt;/p>
&lt;p>&lt;code>sheetstest&lt;/code>としました。&lt;/p>
&lt;pre>&lt;code>mkdir sheetstest
cd sheetstest
&lt;/code>&lt;/pre>&lt;p>&lt;code>npm init -y&lt;/code>で&lt;code>package.json&lt;/code>を作成します。&lt;/p>
&lt;pre>&lt;code>npm init -y
&lt;/code>&lt;/pre>&lt;p>このディレクトリに先ほどの&lt;code>client_secret.json&lt;/code>を移動させます。&lt;/p>
&lt;pre>&lt;code>ls
package.json client_secret.json
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://i.gyazo.com/3d796ef0005ef28b914a83517772c65e.png" alt="">&lt;/p>
&lt;p>こんな感じです。&lt;/p>
&lt;p>利用するモジュールを追加します。&lt;/p>
&lt;pre>&lt;code>npm i googleapis google-auth-library --save
&lt;/code>&lt;/pre>&lt;h2 id="3--">3. トークンの作成&amp;amp;保存 (最初だけ)&lt;/h2>
&lt;p>本家とは少し違うやり方です。&lt;/p>
&lt;p>本家のコードだと&lt;code>トークンの作成&amp;amp;保存&lt;/code>作業と実際のAPI呼び出しが一緒になったコードですが&lt;code>トークンの作成&amp;amp;保存&lt;/code>は最初のみ行えば良いので手順を分けて紹介します。&lt;/p>
&lt;p>&lt;code>getAndStoreToken.js&lt;/code>を作成します。&lt;/p>
&lt;pre>&lt;code>//getAndStoreToken.js
'use strict';
const fs = require('fs');
const readline = require('readline');
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});
const {promisify} = require('util');
const google = require('googleapis');
const googleAuth = require('google-auth-library');
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);
const SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly'];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+'/sheets.googleapis.com-nodejs-quickstart.json';
const main = async () =&amp;gt; {
const content = await readFileAsync(__dirname+'/client_secret.json');
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
//get new token
const authUrl = oauth2Client.generateAuthUrl({
access_type: 'offline',
scope: SCOPES
});
console.log('Authorize this app by visiting this url: ', authUrl);
rl.question('Enter the code from that page here: ', (code) =&amp;gt; {
rl.close();
oauth2Client.getToken(code, async (err, token) =&amp;gt; {
if (err) {
console.log('Error while trying to retrieve access token', err);
return;
}
oauth2Client.credentials = token;
try {
fs.mkdirSync(TOKEN_DIR);
} catch (err) {
if (err.code != 'EEXIST') throw err;
}
await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
console.log('Token stored to ' + TOKEN_PATH);
});
});
};
main();
&lt;/code>&lt;/pre>&lt;p>このプログラムを実行します。&lt;/p>
&lt;pre>&lt;code>node getAndStoreToken.js
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png" alt="">&lt;/p>
&lt;p>&lt;code>https://accounts.google.com/~&lt;/code>で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png" alt="スクリーンショット 2017-12-04 11.52.54.png" title="スクリーンショット 2017-12-04 11.52.54.png">&lt;/p>
&lt;p>アカウント選択画面になります。
複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/18729d60-e4a6-8996-9519-f9f4750ae1f4.png" alt="スクリーンショット 2017-12-04 11.53.02.png" title="スクリーンショット 2017-12-04 11.53.02.png">&lt;/p>
&lt;p>&lt;code>許可&lt;/code>で進みます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png" alt="スクリーンショット 2017-12-04 11.53.09.png" title="スクリーンショット 2017-12-04 11.53.09.png">&lt;/p>
&lt;p>認証用のコードが発行されます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/fd612d7c-0b45-3d09-64ab-c1e02315fe81.png" alt="スクリーンショット 2017-12-04 11.53.27.png" title="スクリーンショット 2017-12-04 11.53.27.png">&lt;/p>
&lt;p>これをコピーしてターミナルに貼り付けてエンターキーで進みます。&lt;/p>
&lt;pre>&lt;code>Token stored to /Users/n0bisuke/dotstudio/playground/sheetstest/sheets.googleapis.com-nodejs-quickstart.json
&lt;/code>&lt;/pre>&lt;p>などと表示されてjsonファイルが保存されます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/35387/830452dc-ad36-83ef-8cf8-8c80bc9637dd.png" alt="スクリーンショット 2017-12-04 11.57.50.png" title="スクリーンショット 2017-12-04 11.57.50.png">&lt;/p>
&lt;p>&lt;code>sheets.googleapis.com-nodejs-quickstart.json&lt;/code>がフォルダ内に確認できればOKです。&lt;/p>
&lt;h2 id="4-">4. いよいよシートにアクセス&lt;/h2>
&lt;p>さて最後の手順です。&lt;/p>
&lt;p>&lt;code>getSheetsData.js&lt;/code>を作成しましょう。&lt;/p>
&lt;pre>&lt;code>//getSheetsData.js
'use strict';
const fs = require('fs');
const {promisify} = require('util');
const google = require('googleapis');
const googleAuth = require('google-auth-library');
const sheets = google.sheets('v4');
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const ssValuesGetAsync = promisify(sheets.spreadsheets.values.get);
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + '/sheets.googleapis.com-nodejs-quickstart.json';
const main = async () =&amp;gt; {
//クレデンシャル情報の取得
const content = await readFileAsync(__dirname+'/client_secret.json');
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
const token = await readFileAsync(TOKEN_PATH);
oauth2Client.credentials = JSON.parse(token);
//API経由でシートにアクセス
const apiOptions = {
auth: oauth2Client,
spreadsheetId: '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms',
range: 'Class Data!A2:E',
};
const response = await ssValuesGetAsync(apiOptions);
//結果を表示
console.log(response);
};
main();
&lt;/code>&lt;/pre>&lt;p>これを実行します。&lt;/p>
&lt;pre>&lt;code>$ node getSheetsData.js
{ range: '\'Class Data\'!A2:E101',
majorDimension: 'ROWS',
values:
[ [ 'Alexandra', 'Female', '4. Senior', 'CA', 'English' ],
[ 'Andrew', 'Male', '1. Freshman', 'SD', 'Math' ],
[ 'Anna', 'Female', '1. Freshman', 'NC', 'English' ],
[ 'Becky', 'Female', '2. Sophomore', 'SD', 'Art' ],
[ 'Benjamin', 'Male', '4. Senior', 'WI', 'English' ],
[ 'Carl', 'Male', '3. Junior', 'MD', 'Art' ],
[ 'Carrie', 'Female', '3. Junior', 'NE', 'English' ],
[ 'Dorothy', 'Female', '4. Senior', 'MD', 'Math' ],
[ 'Dylan', 'Male', '1. Freshman', 'MA', 'Math' ],
[ 'Edward', 'Male', '3. Junior', 'FL', 'English' ],
[ 'Ellen', 'Female', '1. Freshman', 'WI', 'Physics' ],
[ 'Fiona', 'Female', '1. Freshman', 'MA', 'Art' ],
[ 'John', 'Male', '3. Junior', 'CA', 'Physics' ],
[ 'Jonathan', 'Male', '2. Sophomore', 'SC', 'Math' ],
[ 'Joseph', 'Male', '1. Freshman', 'AK', 'English' ],
[ 'Josephine', 'Female', '1. Freshman', 'NY', 'Math' ],
[ 'Karen', 'Female', '2. Sophomore', 'NH', 'English' ],
[ 'Kevin', 'Male', '2. Sophomore', 'NE', 'Physics' ],
[ 'Lisa', 'Female', '3. Junior', 'SC', 'Art' ],
[ 'Mary', 'Female', '2. Sophomore', 'AK', 'Physics' ],
[ 'Maureen', 'Female', '1. Freshman', 'CA', 'Physics' ],
[ 'Nick', 'Male', '4. Senior', 'NY', 'Art' ],
[ 'Olivia', 'Female', '4. Senior', 'NC', 'Physics' ],
[ 'Pamela', 'Female', '3. Junior', 'RI', 'Math' ],
[ 'Patrick', 'Male', '1. Freshman', 'NY', 'Art' ],
[ 'Robert', 'Male', '1. Freshman', 'CA', 'English' ],
[ 'Sean', 'Male', '1. Freshman', 'NH', 'Physics' ],
[ 'Stacy', 'Female', '1. Freshman', 'NY', 'Math' ],
[ 'Thomas', 'Male', '2. Sophomore', 'RI', 'Art' ],
[ 'Will', 'Male', '4. Senior', 'FL', 'Math' ] ] }
&lt;/code>&lt;/pre>&lt;p>このサンプルでは&lt;a href="https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit#gid=0">こちらのワークブック&lt;/a>へアクセスして情報を取得しています。&lt;/p>
&lt;p>ちなみに用語的には&lt;/p>
&lt;ul>
&lt;li>ワークブック＝Googleスプレッドシートの１ファイル&lt;/li>
&lt;li>シート＝ワークブック内のタブ、シート&lt;/li>
&lt;/ul>
&lt;p>というニュアンスです。&lt;/p>
&lt;pre>&lt;code>//省略
const apiOptions = {
auth: oauth2Client,
spreadsheetId: '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms',
range: 'Class Data!A2:E',
};
//省略
&lt;/code>&lt;/pre>&lt;p>ほかのワークブックにアクセスする場合は&lt;code>https://docs.google.com/spreadsheets/d/&lt;/code>の後に続くIDを&lt;code>spreadsheetId&lt;/code>に指定して実行しましょう。&lt;code>range&lt;/code>は&lt;code>シート名:取得する範囲&lt;/code>という形式で指定して、指定したシートの指定した範囲からセルの情報を取得します。&lt;/p>
&lt;h2 id="heading-1">おわりに&lt;/h2>
&lt;p>これで次回以降は4番目の手順だけでスプレッドシートにアクセスできます。&lt;/p>
&lt;p>&lt;code>client_secret.json&lt;/code>や&lt;code>sheets.googleapis.com-nodejs-quickstart.json&lt;/code>をコピーしてサーバー設置しておけば自動更新する仕組みなども作れます。&lt;/p>
&lt;p>スプレッドシートは色々な場面で利用されているツールなので是非システム連携などに活用してみて下さい。&lt;/p>
&lt;p>応用としてはこちらの内容で使っています。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://qiita.com/n0bisuke/items/3313a64c56317932919e">勉強会( #IoTLT )の登壇者管理でHeadless Chromeを利用している話&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>それでは！&lt;/p></description></item></channel></rss>