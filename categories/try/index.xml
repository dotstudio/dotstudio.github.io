<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Try on dotstudio（ドットスタジオ）</title>
    <link>https://dotstud.io/categories/try/index.xml</link>
    <description>Recent content in Try on dotstudio（ドットスタジオ）</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© 2016 dotstudio inc.</copyright>
    <atom:link href="/categories/try/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Nefry BT（ESP32）からBLEでNode.jsにデータを送ってみよう</title>
      <link>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</link>
      <pubDate>Fri, 12 Jan 2018 23:58:16 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</guid>
      
      <description>

&lt;p&gt;こんにちは、代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。Nefry BTを使ってBluetooth / BLEを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、検証してませんが他のESP32系のボードでも動作すると思います。&lt;/p&gt;

&lt;h2 id=&#34;bleについて&#34;&gt;BLEについて&lt;/h2&gt;

&lt;p&gt;BLEには大きく分け&lt;strong&gt;Peripheral （ペリフェラル）&lt;/strong&gt;と&lt;strong&gt;Central（セントラル）&lt;/strong&gt;という二つの役割があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Peripheral: 発信側端末、ビーコンやBLEタグなど受信端末に対して情報を送る側&lt;/li&gt;
&lt;li&gt;Central: 受信側端末、iPhoneやMacなどBLEデバイスの情報を探して受け取る側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTは書き込むコードによって、PeripheralにもCentralにもなることができます。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;peripheralの作成&#34;&gt;Peripheralの作成&lt;/h2&gt;

&lt;p&gt;情報発信側のPeripheralをNefry BTで作成します。&lt;/p&gt;

&lt;h3 id=&#34;uuidの作成&#34;&gt;UUIDの作成&lt;/h3&gt;

&lt;p&gt;BLEを利用するためには&lt;strong&gt;SERVICE（サービス）&lt;/strong&gt;と&lt;strong&gt;CHARACTERISTIC（キャラクタリスティック）&lt;/strong&gt;という各機能を司るUUIDを設定する必要があります。プログラミングでいうクラスとメソッドの関係だと思うと良いかもしれません。&lt;/p&gt;

&lt;p&gt;BLEデバイスは部屋の中やカフェ、駅などいたるところに存在するのでそれらのデバイスと自分が所持しているデバイスのIDが競合しないようにユニークな値にする必要があります。そこでUUIDを作成し、設定する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.uuidgenerator.net/&#34;&gt;https://www.uuidgenerator.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このサイトでUUIDが作成出きるので各自作成しましょう。&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;大元のコードはnkolban氏の&lt;a href=&#34;https://github.com/nkolban/ESP32_BLE_Arduino/blob/f8fe9d7cdfb20caa54b70849826d1ac6e375ff78/examples/BLE_notify/BLE_notify.ino&#34;&gt;こちらのコード&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#define SERVICE_UUID&lt;/code&gt;の箇所と&lt;code&gt;#define CHARACTERISTIC_UUID&lt;/code&gt;の箇所に先ほど作成したUUIDを指定します。&lt;/p&gt;

&lt;p&gt;また&lt;code&gt;BLEDevice::init(&amp;quot;&amp;quot;);&lt;/code&gt;の箇所にBLEデバイスの名前を設定できます。
以下のコードではNefryBT-n0bisukeという名前を指定しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;BLEDevice.h&amp;gt;
#include &amp;lt;BLEServer.h&amp;gt;
#include &amp;lt;BLEUtils.h&amp;gt;
#include &amp;lt;BLE2902.h&amp;gt;

BLECharacteristic *pCharacteristic;
bool deviceConnected = false;
uint8_t value = 0;

// See the following for generating UUIDs:
// https://www.uuidgenerator.net/

#define SERVICE_UUID        &amp;quot;D5875408-FA51-4763-A75D-7D33CECEBC31&amp;quot;
#define CHARACTERISTIC_UUID &amp;quot;A4F01D8C-A037-43B6-9050-1876A8C23584&amp;quot;

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
    }
};

void setup() {
  Serial.begin(115200);

  // Create the BLE Device
  BLEDevice::init(&amp;quot;NefryBT-n0bisuke&amp;quot;);

  // Create the BLE Server
  BLEServer *pServer = BLEDevice::createServer();
  pServer-&amp;gt;setCallbacks(new MyServerCallbacks());

  // Create the BLE Service
  BLEService *pService = pServer-&amp;gt;createService(SERVICE_UUID);

  // Create a BLE Characteristic
  pCharacteristic = pService-&amp;gt;createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ   |
                      BLECharacteristic::PROPERTY_WRITE  |
                      BLECharacteristic::PROPERTY_NOTIFY |
                      BLECharacteristic::PROPERTY_INDICATE
                    );

  // https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml
  // Create a BLE Descriptor
  pCharacteristic-&amp;gt;addDescriptor(new BLE2902());

  // Start the service
  pService-&amp;gt;start();

  // Start advertising
  pServer-&amp;gt;getAdvertising()-&amp;gt;start();
  Serial.println(&amp;quot;Waiting a client connection to notify...&amp;quot;);
}

void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイルエラーが出ないで書き込みが出来ればOKです。&lt;/p&gt;

&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;

&lt;p&gt;デバッグには&lt;a href=&#34;https://itunes.apple.com/jp/app/lightblue/id639944780?mt=12&#34;&gt;LightBlue&lt;/a&gt;などのBLEデバッグ用のアプリケーションを利用することをお勧めします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTが起動すると先ほど指定した&lt;strong&gt;NefryBT-n0bisuke&lt;/strong&gt;という名前でBLEデバイスが検出されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SERVICEのUUIDやCHARACTERISTICのUUIDも先ほど指定したものが表示されていると思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これで問題なく、Nefry BTから情報が発信されていることが確認出来ました。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;centralの作成&#34;&gt;Centralの作成&lt;/h2&gt;

&lt;p&gt;次は受信側のCentralを作成していきます。
データの確認だけであれば先ほどのLightBlueなどのアプリで確認でも良いのですが、自分のサービスに組み込む際には何かしらのプログラミング言語でアクセスできた方が都合が良いです。&lt;/p&gt;

&lt;h3 id=&#34;nobleの利用&#34;&gt;nobleの利用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sandeepmistry/noble&#34;&gt;noble&lt;/a&gt;はNode.js向けのBLEライブラリです。MacやWindows、Raspberry PiなどのデバイスをBLEのCentralにすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ble_central
cd ble_central
touch app.js
npm init -y
npm i --save noble
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで準備とnobleのインストールが完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;に以下を記述します。SERVICE_UUIDやCHARACTERISTIC_UUIDは自分で作成したNefry BT側に書き込んだUUIDと同様のものを指定しましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[WIP] Async/Awaitに書き換えたい。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const noble = require(&#39;noble&#39;);
const serviceuuid = `d5875408fa514763a75d7d33cecebc31`;
const charauuid = `a4f01d8ca03743b690501876a8c23584`;

//キャラクタリスティックにアクセスしてデータやりとり
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}


//discovered BLE device
const discovered = (peripheral) =&amp;gt; {
    console.log(`BLE Device Found: ${peripheral.advertisement.localName}(${peripheral.uuid}) RSSI${peripheral.rssi}`);

    if(peripheral.advertisement.localName === &#39;NefryBT-n0bisuke&#39;){
        noble.stopScanning();
        console.log(&#39;device found&#39;);
        console.log(`service discover...`);
        
        peripheral.connect(error =&amp;gt; {
            if (error) {
                console.log(&amp;quot;connection error:&amp;quot;, error)
            } else {
                console.log(&amp;quot;device connected&amp;quot;);
            }
            
            peripheral.discoverServices([],(err, services) =&amp;gt; {
                if (error) {
                    console.log(&amp;quot;discover service error&amp;quot;, error)
                }
                console.log(&#39;discover service&#39;);               
                services.forEach(service =&amp;gt; {
                    if(service.uuid === serviceuuid){
                        service.discoverCharacteristics([], (error, charas) =&amp;gt; {
                            console.log(&#39;discover chara&#39;);
                            charas.forEach(chara =&amp;gt; {
                                if(chara.uuid === charauuid){
                                    console.log(&amp;quot;found chara: &amp;quot;, chara.uuid)
                                    accessChara(chara);
                                }
                            });
                        });
                    }
                });
            });
        });
    }
}

//BLE scan start
const scanStart = () =&amp;gt; {
    noble.startScanning();
    noble.on(&#39;discover&#39;, discovered);
}

if(noble.state === &#39;poweredOn&#39;){
    scanStart();
}else{
    noble.on(&#39;stateChange&#39;, scanStart);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実行&#34;&gt;実行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で実行します。この時、先ほどのLightBlueなどのアプリでNefryBTにBLEアクセスしていると上手くいかないのでアプリ側の接続は解除しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/5.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mac側のNode.jsのログはこんな感じで表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BLE Device Found: LED(59aa15c3a3274ed7b11d334b5c0d0900) RSSI-68
BLE Device Found: NefryBT-n0bisuke(d0b77d4611f54380b8b63e6d05765ad6) RSSI-49
device found
service discover...
device connected
discover service
discover chara
found chara:  a4f01d8ca03743b690501876a8c23584
-----Start GATT Access-----
listen notif
{ val: 147 }
{ val: 148 }
・
・
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解説&#34;&gt;解説&lt;/h3&gt;

&lt;p&gt;NefryBT側ではデバイスにアクセスがありCentralとのコネクションが確立すると、&lt;code&gt;変数value&lt;/code&gt;の値をセット(pCharacteristic-&amp;gt;setValue)して送信（pCharacteristic-&amp;gt;notify）し、valueの値をインクリメントします。&lt;/p&gt;

&lt;p&gt;これを2秒ごとに行うので2秒間隔でNefryBTからMacのNode.jsに情報が送信されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
(省略)
・
・
void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js（noble）側では、PERIPHERAL -&amp;gt; SERVICE -&amp;gt; CHARACTERISTICと階層的にアクセスしていき、CHARACTERISTICまでアクセスが出きると、accessChara関数が呼ばれます。&lt;/p&gt;

&lt;p&gt;この中の&lt;code&gt;chara.on(&#39;data&#39;)&lt;/code&gt;の箇所でデータが送られてくるたびにイベントが発火して、データの中身を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
・
(省略)
・
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}
・
・
(省略)
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTでBLEを利用する方法を紹介しました。
Nefry BTでセンサーのデータを取得し、Centralに送信する方法なども応用して作れそうですね。&lt;/p&gt;

&lt;p&gt;これを参考にNefry BTとBLEデバイスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;今回はNefry BTをPeripheralにする実装でしたが、別の機会でCentralにする方法も紹介できればと思っています。&lt;/p&gt;

&lt;p&gt;それでは！&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;今回の実装ですが色々と途中でのハマりが多いかつ、調べてもまだまだESP32のBLE利用をArduinoでやってる事例は少なくけっこう大変でした。この辺の大変だった知見はQiitaなどでまとめらたらと思っています。お疲れ様です笑&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title>
      <link>https://dotstud.io/blog/raspberry-pi-case-making/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong&gt;ラズパイにはまってしまったラズパイ女子です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p&gt;

&lt;p&gt;しかしなかなか可愛いいケースがない……。&lt;strong&gt;ないなら、作ってしまえばいい！！！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p&gt;

&lt;h2 id=&#34;レーザーカッターを使える場所を探そう&#34;&gt;レーザーカッターを使える場所を探そう&lt;/h2&gt;

&lt;p&gt;今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong&gt;工作機械を気軽に利用できるFabスペース&lt;/strong&gt;を利用してみましょう！&lt;/p&gt;

&lt;p&gt;レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p&gt;

&lt;p&gt;何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p&gt;

&lt;h3 id=&#34;レーザーカッターが使える初心者向けオススメfabスペース&#34;&gt;レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3&gt;

&lt;p&gt;初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p&gt;

&lt;h4 id=&#34;fabcafe-https-fabcafe-com-tokyo&#34;&gt;&lt;a href=&#34;https://fabcafe.com/tokyo/&#34;&gt;◆FabCafe&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p&gt;

&lt;h4 id=&#34;iotlab-https-cami-jp-iotlab&#34;&gt;&lt;a href=&#34;https://cami.jp/iotlab/&#34;&gt;◆IoTLab&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p&gt;

&lt;h4 id=&#34;techshop-http-www-techshop-jp&#34;&gt;&lt;a href=&#34;http://www.techshop.jp/&#34;&gt;◆TechShop&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p&gt;

&lt;h2 id=&#34;ケースの形について調べてみよう&#34;&gt;ケースの形について調べてみよう&lt;/h2&gt;

&lt;p&gt;一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/1.png&#34; alt=&#34;&#34; /&gt;
「Raspberry Pi  ケース」を検索
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ケースの形によってはかなり難易度が高そうです……。&lt;/p&gt;

&lt;h3 id=&#34;初心者にも作りやすいケースの形&#34;&gt;初心者にも作りやすいケースの形&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li&gt;
&lt;li&gt;ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/2.png&#34; alt=&#34;&#34; /&gt;
上蓋と下蓋を支柱で支えるタイプのケース　　
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;部材を集めよう&#34;&gt;部材を集めよう&lt;/h2&gt;

&lt;h3 id=&#34;かわいいアクリルで作れば-かわいいケースになる-はず&#34;&gt;かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;かわいいアクリルで作ればかわいいケースになる&lt;/strong&gt;と信じて、素敵なアクリルを用意しましょう。&lt;/p&gt;

&lt;p&gt;アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong&gt;実際に店舗に行ってみるのがオススメ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href=&#34;https://www.miyukiacryl.tokyo/tokyo-acryl&#34;&gt;デザインアクリル専門店 ミユキアクリル&lt;/a&gt;」さんのような&lt;strong&gt;デザインアクリル専門店&lt;/strong&gt;もあるので、興味のある方は覗いてみましょう！&lt;/p&gt;

&lt;p&gt;※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/3.png&#34; alt=&#34;&#34; /&gt;
自分好みのアクリルを選ぼう
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p&gt;

&lt;p&gt;厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p&gt;

&lt;p&gt;好みのアクリルがない場合は、&lt;strong&gt;UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong&gt;という手もあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/4.png&#34; alt=&#34;&#34; /&gt;
UVプリンターでイラストや写真を転写
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p&gt;

&lt;h3 id=&#34;ネジやスペーサーなどのパーツ&#34;&gt;ネジやスペーサーなどのパーツ&lt;/h3&gt;

&lt;p&gt;支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/5.png&#34; alt=&#34;&#34; /&gt;
上：真鍮黒ネジ、シルバーの六角スペーサー の組み合わせ&lt;br /&gt;
下：プラネジ、白のプラスチックのスペーサー&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;必要なパーツ一覧&#34;&gt;必要なパーツ一覧&lt;/h3&gt;

&lt;p&gt;好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li&gt;
&lt;li&gt;ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li&gt;
&lt;li&gt;アクリル板固定・ネジ M3（8mm）8本&lt;/li&gt;
&lt;li&gt;アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li&gt;
&lt;li&gt;アクリル（今回は厚さ3mmのもの）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/parts.png&#34; alt=&#34;&#34; /&gt;
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;h3 id=&#34;step1-型の準備&#34;&gt;step1. 型の準備&lt;/h3&gt;

&lt;p&gt;Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p&gt;

&lt;p&gt;ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href=&#34;https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y&#34;&gt;&lt;strong&gt;こちらのaiデータ&lt;/strong&gt;&lt;/a&gt;をそのまま使うこともできます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/6.png&#34; alt=&#34;&#34; /&gt;
左：下蓋 / 右：上蓋
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラ：幅0.9mm × 高さ28mm&lt;/li&gt;
&lt;li&gt;GPIO：幅55mm × 高さ12mm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/7.png&#34; alt=&#34;&#34; /&gt;
上蓋にカメラとGPIOの部分を追加
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;レーザーカッターには切る順番があり、「&lt;strong&gt;彫刻 → 穴 → 切り落とし&lt;/strong&gt;」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p&gt;

&lt;p&gt;これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p&gt;

&lt;h3 id=&#34;step2-アクリルを裁断&#34;&gt;step2. アクリルを裁断&lt;/h3&gt;

&lt;p&gt;今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step3-組み立てる&#34;&gt;step3. 組み立てる&lt;/h3&gt;

&lt;p&gt;まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/9.png&#34; alt=&#34;&#34; /&gt;
短いスペーサーでラズパイを下蓋に固定
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p&gt;

&lt;h3 id=&#34;完成&#34;&gt;完成&lt;/h3&gt;

&lt;p&gt;自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src=&#34;https://dotstud.io/img/blog/142/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/12.png&#34; alt=&#34;&#34; /&gt;
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p&gt;

&lt;p&gt;日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong&gt;どこに連れて行ってもかわいいと言ってもらえる&lt;/strong&gt;ので作りがいがありました。何より愛着がわきますね〜！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）でMQTTを使ってみよう Subscribe編</title>
      <link>https://dotstud.io/blog/nefry-bt-connect-mqtt/</link>
      <pubDate>Sat, 06 Jan 2018 14:28:04 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-bt-connect-mqtt/</guid>
      
      <description>

&lt;p&gt;あけましておめでとうございます。 代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;Nefry BTを使ってMQTTを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;今回はMQTTでNefry BTに情報を送信してみます。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、ESP32系の他のボードを利用している人の参考にもなると思います。&lt;/p&gt;

&lt;h2 id=&#34;mqttの登場人物&#34;&gt;MQTTの登場人物&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Broker - 通信のサーバー&lt;/li&gt;
&lt;li&gt;Publisher - 情報の送信側&lt;/li&gt;
&lt;li&gt;Subscriber - 情報の受信側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebSocketではサーバーとクライアントだけで双方向通信をしますが、MQTTではサーバーはBrocker、クライアント側が送信者のPublisherと受信者のSubscriberに分かれます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回はNefry BTをSubscriber（受信者）にして、外部からNefry BTに情報を送ってみたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subscriberの作成&#34;&gt;Subscriberの作成&lt;/h2&gt;

&lt;h3 id=&#34;arduino向けのmqttライブラリをインストール&#34;&gt;Arduino向けのMQTTライブラリをインストール&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knolleary/pubsubclient&#34;&gt;knolleary/pubsubclient&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;zipファイルをダウンロードしたら、 &lt;code&gt;スケッチ &amp;gt; ライブラリのインポート &amp;gt; .ZIP形式のライブラリをインストール&lt;/code&gt;からArduino IDEにライブラリをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;ブローカーは&lt;a href=&#34;https://mosquitto.org/&#34;&gt;Mosquitto&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;mosquitto.org&amp;rdquo;の&amp;rdquo;n0bisuke&amp;rdquo;という名前のトピックに情報が送信されたら受信します。&lt;/p&gt;

&lt;p&gt;MQTTはデフォルト1883ポートを利用するので、1883ポートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;

WiFiClient httpsClient;
PubSubClient mqttClient(httpsClient);

#define TOPIC &amp;quot;n0bisuke&amp;quot;
#define QOS 0
#define URL &amp;quot;mosquitto.org&amp;quot;
#define PORT 1883

void setup() {
  mqttClient.setServer(URL, PORT);
  mqttClient.setCallback(callback);
}

void loop() {
  if(!mqttClient.connected()) {
    if (mqttClient.connect(TOPIC)) {
      Serial.println(&amp;quot;Connected.&amp;quot;);    
      mqttClient.subscribe(TOPIC, QOS);
      Serial.println(&amp;quot;Subscribed.&amp;quot;);
    }
    else {
      errorReport();
    }
  }
  
  mqttClient.loop();
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print(&amp;quot;Message arrived [&amp;quot;);
  Serial.print(topic);
  Serial.print(&amp;quot;] &amp;quot;);
  for (int i = 0; i &amp;lt; length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();
}

void errorReport(){
  Serial.print(&amp;quot;Failed. Error state = &amp;quot;);
  
  switch (mqttClient.state()) {
    case MQTT_CONNECT_UNAUTHORIZED:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAUTHORIZED&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CREDENTIALS:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CREDENTIALS&amp;quot;);
      break;
    case MQTT_CONNECT_UNAVAILABLE:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAVAILABLE&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CLIENT_ID:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CLIENT_ID&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_PROTOCOL:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_PROTOCOL&amp;quot;);
      break;
    case MQTT_CONNECTED:
      Serial.println(&amp;quot;MQTT_CONNECTED&amp;quot;);
      break;
    case MQTT_DISCONNECTED:
      Serial.println(&amp;quot;MQTT_DISCONNECTED&amp;quot;);
      break;
    case MQTT_CONNECT_FAILED:
      Serial.println(&amp;quot;MQTT_CONNECT_FAILED&amp;quot;);
      break;
    case MQTT_CONNECTION_LOST:
      Serial.println(&amp;quot;MQTT_CONNECTION_LOST&amp;quot;);
      break;
    case MQTT_CONNECTION_TIMEOUT:
      Serial.println(&amp;quot;MQTT_CONNECTION_TIMEOUT&amp;quot;);
      break;
  }
      
  delay(5000); // Wait 5 seconds before retrying
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publisherの作成&#34;&gt;Publisherの作成&lt;/h2&gt;

&lt;p&gt;情報の送信側であるPublisherは手元のMac Book上のNode.jsで作成しました。&lt;/p&gt;

&lt;p&gt;Node.jsでMQTTを利用する場合は&lt;a href=&#34;https://www.npmjs.com/package/mqtt&#34;&gt;mqtt.js&lt;/a&gt;を利用するのが手頃です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir mqtt-test
cd mqtt-test
npm init -y
npm i --save mqtt
touch publisher.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//publisher.js
&#39;use strict&#39;;

const mqtt = require(&#39;mqtt&#39;);
const client = mqtt.connect(&#39;mqtt://mosquitto.org&#39;);

client.on(&#39;connect&#39;, () =&amp;gt; console.log(&#39;publisher.connected.&#39;));

setInterval(() =&amp;gt; {
    const message = Date.now().toString();
    client.publish(&#39;n0bisuke&#39;, message);
    console.log(&#39;publisher.publish:&#39;, message);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行すると、以下のように時間の情報をパブリッシュ（送信）し始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node publisher.js

publisher.publish: 1515219086876
publisher.publish: 1515219087879
publisher.publish: 1515219088880
publisher.publish: 1515219089882
・
・
・
(省略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;思ってたより簡単に実装出来ました。
これを参考にNefry BTとWebサービスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mosca.io/&#34;&gt;Mosca&lt;/a&gt;などを使うとBrokerも自分で作成することが出来るので試してみると良いかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>オフィス移転したらインターホンがなかったのでRaspbeerry Piでカメラ付きインターホン作ってみた</title>
      <link>https://dotstud.io/blog/office-new-door-notification/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/office-new-door-notification/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioモノづくり担当・うこです。&lt;/p&gt;

&lt;p&gt;dotstudioは&lt;a href=&#34;https://dotstud.io/blog/office-relocation-for-akihabara/&#34;&gt;&lt;strong&gt;めでたく新オフィスに移転したのですが&lt;/strong&gt;&lt;/a&gt;、インターホンがついておらず不便なんですよね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/10.png&#34; alt=&#34;&#34; /&gt;
代表・のびすけ「&lt;strong&gt;うこ先生、これRaspberry Piでインターホン作れない？&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/1.png&#34; alt=&#34;&#34; /&gt;
僕「&lt;strong&gt;秒でいけます&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;ということで作ってみました！&lt;/p&gt;

&lt;h2 id=&#34;全体の構成&#34;&gt;全体の構成&lt;/h2&gt;

&lt;p&gt;今回は&lt;strong&gt;ボタンを押したら室内のスピーカに音がなる機能&lt;/strong&gt;に加えて、&lt;strong&gt;押した人の姿が見えるカメラ機能&lt;/strong&gt;も搭載してみました。&lt;/p&gt;

&lt;p&gt;全体の構成はこんな感じです。
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/116011/a7707b67-176f-8dc6-cf32-8323a56e860c.png&#34; alt=&#34;いんたーほん.png&#34; title=&#34;いんたーほん.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Raspberry Pi 3（以下ラズパイ）をベースにして、Grove接続されたタッチセンサに触れると室内のBluetoothスピーカー（今回はBASE EGG）から音が流れる仕組みを作ります。&lt;/p&gt;

&lt;p&gt;さらに、ラズパイカメラをドアの外に出して、外の様子がオフィス内のモニタから見られるようにします。&lt;/p&gt;

&lt;h3 id=&#34;使ったもの&#34;&gt;使ったもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3&lt;/li&gt;
&lt;li&gt;Raspberry Pi カメラモジュール&lt;/li&gt;
&lt;li&gt;Grove タッチセンサ&lt;/li&gt;
&lt;li&gt;Bluetoothオーディオトランスミッタ&lt;/li&gt;
&lt;li&gt;Bluetoothスピーカー（今回はBASS EGG）&lt;/li&gt;
&lt;li&gt;スピーカー（100円）&lt;/li&gt;
&lt;li&gt;オーディオ分岐プラグ（100円）&lt;/li&gt;
&lt;li&gt;マグネット付きプラスチックケース（100円）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;呼び鈴の製作&#34;&gt;呼び鈴の製作&lt;/h2&gt;

&lt;h3 id=&#34;ハードウェア部分&#34;&gt;ハードウェア部分&lt;/h3&gt;

&lt;p&gt;まずはじめに、&lt;strong&gt;来客者がボタンを押すと室内で音が鳴って訪問を知らせるようにする機能&lt;/strong&gt;を作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/12.png&#34; alt=&#34;&#34; /&gt;
ラズパイはマグネット付きのプラスチックケースに入れて、金属製のドアの内側に貼り付けます。ケースはケーブルが引き出せるように適宜加工します。&lt;/p&gt;

&lt;p&gt;次にGroveタッチセンサですが、そのままだとラズパイに接続できないためジャンパワイヤを3本用意します。接続するピンは以下のとおりです。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;タッチセンサのピン&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ラズパイGPIO&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;VCC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3.3V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;GND&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ground&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;NC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SIG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ラズパイGPIOのピン番号と位置については、以下の公式ページにある2番目の図を参照してください。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.raspberrypi.org/documentation/usage/gpio-plus-and-raspi2/&#34;&gt;GPIO: MODELS A+, B+, RASPBERRY PI 2 B AND RASPBERRY PI 3 B&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;次に、100円程度で売られているオーディオ出力分岐器をラズパイのオーディオ出力に接続し、さらにBluetoothのオーディオトランスミッタと小型のスピーカーに接続します。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/133/11.png&#34; alt=&#34;&#34; /&gt;
実証の結果、「押した人にも音が鳴ったことがわかる」ことが必要とわかった
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;オーディオトランスミッタは室内に来客を知らせるスピーカーを鳴らす用、小型スピーカーはドアの外に出して来客者に「呼び鈴が鳴った」ことを知らせる用です。USB接続のアンプ付きスピーカーなどで大きな音が出せるのならそれで代用することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/5.png&#34; alt=&#34;&#34; /&gt;
最後に電源を近くのコンセントからUSBアダプタ経由で接続してハードウェア部分は完了です！&lt;/p&gt;

&lt;h3 id=&#34;ソフトウェア部分&#34;&gt;ソフトウェア部分&lt;/h3&gt;

&lt;p&gt;まず、適当なインターフォンの音となるmp3を用意しましょう。簡単なピンポン音でも、ネタのような効果音でもいいです。dotstudioでは、「ファミマ入店音」が好評だったため採用しました。&lt;/p&gt;

&lt;p&gt;mp3が用意できたら、&lt;code&gt;/home/pi&lt;/code&gt;などのディレクトリに&lt;code&gt;sounds&lt;/code&gt;というフォルダを作ってその中にmp3を入れましょう。&lt;/p&gt;

&lt;p&gt;次に、&lt;code&gt;sudo apt-get install mpg321&lt;/code&gt;を実行し、サウンド再生用のソフトウェア「mpg321」をインストールします。&lt;code&gt;mpg321 sounds/サウンド.mp3&lt;/code&gt;などと実行して、スピーカーから音が出ていればOKです。もしここで音が小さい場合は、&lt;code&gt;alsamixer&lt;/code&gt;コマンドを実行すると音量調整ができますので、矢印キーで大きくしておきます。&lt;/p&gt;

&lt;p&gt;音の再生が確認できたら、以下のPythonプログラムを&lt;code&gt;sounds&lt;/code&gt;ディレクトリと同じ場所に保存して実行します。タッチセンサを触ると同時に、音が鳴ってターミナル上に&amp;rsquo;Ping-pon!&amp;lsquo;と表示されれば成功です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-/home/pi/interphone.py&#34;&gt;#!/usr/bin/python

import RPi.GPIO as GPIO
import glob
import subprocess
from time import sleep
from random import shuffle

GPIO.setmode(GPIO.BCM)
GPIO.setup(24, GPIO.IN)

# mp3が保存されているディレクトリは適宜変更してください
soundlist = glob.glob(&amp;quot;./sounds/*.mp3&amp;quot;)

while True:
    if GPIO.input(24) == GPIO.HIGH:
        shuffle(soundlist)
        print(&#39;Ping-pon!&#39;)
        subprocess.call(&amp;quot;mpg321 -q &amp;quot;+soundlist[0], shell=True)
    else:
        sleep(0.01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、再起動しても動くように、&lt;code&gt;/etc/rc.local&lt;/code&gt;ファイルの末尾に&lt;code&gt;/usr/bin/python /home/pi/interphone.py &amp;amp;&lt;/code&gt;と追記しておきましょう。
ちなみにですが、上記のコードでは&lt;code&gt;sounds&lt;/code&gt;ディレクトリ内に複数のmp3が入っているとランダムで再生されるような仕組みにしています。&lt;/p&gt;

&lt;h2 id=&#34;監視カメラ部分の製作&#34;&gt;監視カメラ部分の製作&lt;/h2&gt;

&lt;p&gt;監視カメラはラズパイ専用カメラを使用します。接続はとても簡単で、HDMI端子とオーディオ端子の間にある細長い端子にケーブルを差し込むだけです。&lt;code&gt;sudo raspi-config&lt;/code&gt;コマンドで、カメラを使うことができるように設定を変更しておきましょう。&lt;code&gt;raspistill -p&lt;/code&gt;コマンドを実行し、特にエラーが出なければ正常に接続されています。&lt;/p&gt;

&lt;p&gt;今回はカメラと呼び鈴部分は連動させず、カメラは&lt;a href=&#34;https://github.com/ccrisan/motioneye/wiki&#34;&gt;motionEye&lt;/a&gt;というオープンソースウェアを使って単独で動作させます。
motionEyeのインストールは以下を参考にしました。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://qiita.com/mt08/items/96207abfba91954b50d4&#34;&gt;らずぱい motionEye (Web UIベースのカメラサーバ) - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こちらのページにも書かれていますが、ラズパイのカメラモジュールを使用するので、以下のコマンドを実行しておくのを忘れないようにしましょう。
&lt;code&gt;grep bcm2835-v4l2 /etc/modules || echo bcm2835-v4l2 | sudo tee -a /etc/modules&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/4.png&#34; alt=&#34;&#34; /&gt;
インストールが完了して、室内に常設してあるPCのブラウザからアクセスしてみました。
ばっちりドアの外が撮影されていますね！
1秒おきに更新されていますが、python上で動作しているためか、少々重たいようです。&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/7.png&#34; alt=&#34;&#34; /&gt;
インターホンを押すと……&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/4W4pJ0bZVGY&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;入店っぽい音が流れます！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/13.png&#34; alt=&#34;&#34; /&gt;
旧スタイルに比べるとだいぶ未来になりました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は数時間ほどでこのシステムを作ることができました。カメラと呼び鈴が独立してしまっていますが、可能ならば「呼び鈴を押した瞬間の画像を保存してhipchatにアップロード」するような仕組みを作ってみたいです。
&lt;img src=&#34;https://dotstud.io/img/blog/133/3.png&#34; alt=&#34;&#34; /&gt;
次は何をつくってやろうか……。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>フェスでテンあげ☆ 光るカセットテープ</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-led-cassette/</link>
      <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-led-cassette/</guid>
      
      <description>

&lt;p&gt;みなさん、チョリおつ！ギャル電きょうこです。ギャルによるギャルのための電子工作をテクノロジーを提案するユニット、ギャル電で活動しておりまっす。今回は、フェスに相性ピッタリの光りものアクセの作り方を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;何を光らせたらエモいのか-問題&#34;&gt;何を光らせたらエモいのか?!問題&lt;/h2&gt;

&lt;p&gt;光るとモテる！
でも、なんでも光らせただけでかっこよくなるわけではないのです。
ギャル電も&lt;strong&gt;とりあえず光らせてみたけど全然ぐっと来ないものを作ってしまう&lt;/strong&gt;ことがよくあります。
&lt;img src=&#34;https://dotstud.io/img/blog/129/1.png&#34; alt=&#34;&#34; /&gt;
今回は、まずとりあえず首からさげられる形で単純にＬＥＤテープを貼り付けたものをつくってみましたが&lt;strong&gt;ときめきがゼロ！！！！
こんなもの！！！！！&lt;/strong&gt; 泣きながら窓から投げ捨てて、そっとあとで拾いに行きました。&lt;/p&gt;

&lt;p&gt;そのあと、おやつをたべながらテンションを上げるために&lt;strong&gt;スピードコア&lt;/strong&gt;（めっちゃテンポの速いナイスなミュージック）と&lt;strong&gt;バニラのテーマソング&lt;/strong&gt;を交互に聴いていたら&lt;/p&gt;

&lt;p&gt;天啓が下りてきました。&lt;/p&gt;

&lt;p&gt;「&lt;strong&gt;カセットテープなら、首から下げる光もののケースにジャストフィット！！そしてエモい&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;ありがとう、スピードコアの神よ！
みんなもアイデアに詰まったときはスピードコア聴くといいよ。&lt;/p&gt;

&lt;h2 id=&#34;材料を揃えよう&#34;&gt;材料を揃えよう&lt;/h2&gt;

&lt;p&gt;今回の材料は、基板や配線以外はだいたい100均で揃えることができます。&lt;/p&gt;

&lt;p&gt;ボードは超小型ボード&lt;strong&gt;Digispark互換機&lt;/strong&gt;を使用しています。最初のセットアップは少し面倒ですが、安くて小さいので気軽に電子工作を作ることができます。&lt;/p&gt;

&lt;h3 id=&#34;材料&#34;&gt;材料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;カセットテープ（光を通すように透明なものか乳白色で透けるものがおすすめです）&lt;/li&gt;
&lt;li&gt;LEDテープ（1m60個ＬＥＤついてるテープを10LED分）&lt;/li&gt;
&lt;li&gt;ひも（ストラップはお好みで。わたしは柄がかわいい靴ひもを使いました）&lt;/li&gt;
&lt;li&gt;リング（事務用品コーナーに売ってる簡単な鉄の輪っか）&lt;/li&gt;
&lt;li&gt;Digispark互換機（amazonとかでこの名前で検索すると買えます）&lt;/li&gt;
&lt;li&gt;線材（普通の電線でOKですが、コネクタは付いてるとプログラムを入れなおすときとかにちょっと便利です）&lt;/li&gt;
&lt;li&gt;インシロック&lt;/li&gt;
&lt;li&gt;両面テープ（超強力）&lt;/li&gt;
&lt;li&gt;ニッパー&lt;/li&gt;
&lt;li&gt;ワイヤストリッパー&lt;/li&gt;
&lt;li&gt;はんだごて&lt;/li&gt;
&lt;li&gt;はんだ線&lt;/li&gt;
&lt;li&gt;ピンバイスまたはハンドドリル（本体穴あけ用）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ledのケース用にカセットテープを加工する&#34;&gt;LEDのケース用にカセットテープを加工する&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずはカセットテープの四隅のねじを外して分解します。
このとき、&lt;strong&gt;ねじが超小さいのでなくさないようになんか入れ物にいれたりマスキングテープに貼り付けておく&lt;/strong&gt;と便利です。&lt;/p&gt;

&lt;p&gt;また、&lt;strong&gt;分解する前に元の形がわかるように写真を撮っておくとあとですごい役立つのでおすすめ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;磁気テープ部分は今回は使わないので軸からはさみで切り離して外します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/3.png&#34; alt=&#34;&#34; /&gt;
配線を通すため2.5センチくらいカセットテープの上端をカットして穴をあけておきます。
磁気テープ以外は、&lt;strong&gt;ディテールとしてエモいので元の位置に収まるように戻して使用&lt;/strong&gt;します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/4.png&#34; alt=&#34;&#34; /&gt;
リングを通すための穴をカットしたほうとは逆の上端にピンバイスであけておきます。&lt;/p&gt;

&lt;p&gt;以上でカセットテープの加工は完了です。&lt;strong&gt;後でさみしい気持ちになってしまうので、ねじは絶対に無くさないように注意です&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ledと基板のはんだ付け&#34;&gt;LEDと基板のはんだ付け&lt;/h2&gt;

&lt;p&gt;カセットテープにおさまるように、LEDテープを半分（LED5個ずつ）にカットして使用します。
&lt;img src=&#34;https://dotstud.io/img/blog/129/5.png&#34; alt=&#34;&#34; /&gt;
写真の丸がついてるところを何も接続しない状態ではんだづけします。
予備はんだってやつで、やっておくとあとで配線と部品をはんだ付けするのがスムーズになります。&lt;/p&gt;

&lt;p&gt;Digispark基板（おもて）は、5V、GND、P0と書いてある穴の上に予備はんだをします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/6.png&#34; alt=&#34;&#34; /&gt;
Digispark基板の裏と9V電池用のスナップ配線も予備はんだをします。
Digispark基板（うら）は、VIN、GNDを予備はんだします。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※裏側の配線を間違えて5V,GNDで接続すると基板めっちゃ熱くなってなんか焦げたにおいして超ビビるので要注意です。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/7.png&#34; alt=&#34;&#34; /&gt;
予備ハンダ作業が終わったら、まずはDigispark基板の裏側と9V電池用スナップをはんだ付けします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VIN － 赤い配線（電池プラス）&lt;/li&gt;
&lt;li&gt;GND － 黒い配線（電池マイナス）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;をそれぞれ接続します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/8.png&#34; alt=&#34;&#34; /&gt;
次は、LEDに接続するための3本の線をDigispark基板の表側にはんだ付けします。
LEDに接続したときに、以下のように配線がつながるようにします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;5V － （LED側）5V：今回の作例では赤い配線&lt;/li&gt;
&lt;li&gt;GND － （LED側）GND：今回の作例では白い配線&lt;/li&gt;
&lt;li&gt;P0 － （LED側）DIN：今回の作例では緑の配線&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/9.png&#34; alt=&#34;&#34; /&gt;
2本のLEDテープの間もはんだ付けでつなげます。
このとき、LEDテープの進行方向の矢印の向きを間違えないように注意します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/10.png&#34; alt=&#34;&#34; /&gt;
全体図はこんな感じです。
これで、LED配線のはんだ付けは完了でっす。&lt;/p&gt;

&lt;h2 id=&#34;プログラムの書き込み準備&#34;&gt;プログラムの書き込み準備&lt;/h2&gt;

&lt;p&gt;ここからは、初心者にはちょっと気合いのいる作業になります。&lt;/p&gt;

&lt;p&gt;でも、だいたい大丈夫！
わからない単語が出てきたら&lt;strong&gt;速攻ググるとわりとわかるようになります&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;つらくなったときは、光ってモテる近い将来を想像したりスピードコア聴いて気分転換したりご飯食べたり寝たりしてのりこえていきましょう。&lt;/p&gt;

&lt;p&gt;まずは、Digisparkボードにプログラムを書き込むためにArduino IDEというソフトウェアをPCにインストールします。&lt;/p&gt;

&lt;p&gt;下記リンクはMacでの説明なので、Windowsユーザーはダウンロードするファイルを選択するときに、Windowsのリンクを選んでダウンロードしてインストールを行ってください。&lt;/p&gt;

&lt;p&gt;【参考】&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;Arduino IDEをPCにインストール&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;arduinoideでdigisparkのボードを書き込めるように設定する&#34;&gt;ArduinoIDEでDigisparkのボードを書き込めるように設定する&lt;/h3&gt;

&lt;p&gt;英語のページになりますが、以下のページを参考にインストールを行いました。
&lt;a href=&#34;http://digistump.com/wiki/Digispark/tutorials/connecting&#34;&gt;http://digistump.com/wiki/Digispark/tutorials/connecting&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;※環境はWindows10（64bit）、ArduinoIDE 1.8.3にて動作を確認しました。&lt;/p&gt;

&lt;p&gt;大雑把にいうとWindowsの場合には、&lt;/p&gt;

&lt;p&gt;①ドライバをダウンロードしてインストールする
&lt;a href=&#34;https://github.com/digistump/DigistumpArduino/tree/master/tools&#34;&gt;https://github.com/digistump/DigistumpArduino/tree/master/tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;②ArduinoIDEを起動し、ファイル→環境設定→「追加のボードマネージャのURL」に
&lt;code&gt;http://digistump.com/package_digistump_index.json&lt;/code&gt;
をコピペで追加して「OK」ボタンで環境設定を閉じる&lt;/p&gt;

&lt;p&gt;③ツール→ボード→ボードマネージャをクリック&lt;/p&gt;

&lt;p&gt;④検索窓をクリックし、タイプの項目で「提供された」を選択。
「Digistump AVR Boards」を検索し、検索結果をクリックして「インストール」をクリック&lt;/p&gt;

&lt;p&gt;⑤インストール後、ツールから
「ボード：Digispark(Default - 16.5mhz)」
をクリックで選択&lt;/p&gt;

&lt;p&gt;上記手順で書き込み準備は完了です。&lt;/p&gt;

&lt;p&gt;プログラムは、以下のものをコピーしてArduinoIDEにペーストします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#ifdef __AVR__
  #include &amp;lt;avr/power.h&amp;gt;
#endif

//neopixcel用の設定部分

//neopixelを接続するPINを設定
#define PIN_LED 0

//neopixelのLEDの数を設定
#define NUM_LEDS 10

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN_LED, NEO_GRB + NEO_KHZ800);

bool oldState = HIGH;
int showType = 0;

void showStrip() {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.show();
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   FastLED.show();
 #endif
}

void setPixel(int Pixel, byte red, byte green, byte blue) {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.setPixelColor(Pixel, strip.Color(red, green, blue));
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   leds[Pixel].r = red;
   leds[Pixel].g = green;
   leds[Pixel].b = blue;
 #endif
}

void setAll(byte red, byte green, byte blue) {
  for(int i = 0; i &amp;lt; 17; i++ ) {
    setPixel(i, red, green, blue);
  }
  showStrip();
}

// ここからNeoPixelのアニメーション設定


void FadeInOut(byte red, byte green, byte blue){
  float r, g, b;

  for(int k = 0; k &amp;lt; 256; k=k+1) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }

  for(int k = 255; k &amp;gt;= 0; k=k-2) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }
}

void Strobe(byte red, byte green, byte blue, int StrobeCount, int FlashDelay, int EndPause){
  for(int j = 0; j &amp;lt; StrobeCount; j++) {
    setAll(red,green,blue);
    showStrip();
    delay(FlashDelay);
    setAll(0,0,0);
    showStrip();
    delay(FlashDelay);
  }

 delay(EndPause);
}

void Twinkle(byte red, byte green, byte blue, int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),red,green,blue);
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}
void TwinkleRandom(int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),random(0,255),random(0,255),random(0,255));
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}

//

void setup()
{
    pinMode(PIN_LED, OUTPUT);
    digitalWrite(PIN_LED, LOW);
   #if defined (__AVR_ATtiny85__)

   if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  strip.begin();
  strip.show();
}

void loop()
{
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    Twinkle(0xff, 40, 99, 10, 50, false);
    Twinkle(0xff, 40, 99, 10, 50, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースコードはこの解説を書くのにちょっと疲れちゃったので光る大五郎のコードをセルフコピペしました。同じプログラムで光ります。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;書き込むときの注意ポイント&#34;&gt;書き込むときの注意ポイント&lt;/h4&gt;

&lt;p&gt;PCにDigisparkを差し込まない状態で、ArduinoIDEで「→（マイコンボードに書き込み）」をクリック
以下のメッセージが表示されたらPCにDigisparkを差し込む
&lt;img src=&#34;https://dotstud.io/img/blog/129/ide1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下記のメッセージが表示されたら書き込み完了！
&lt;img src=&#34;https://dotstud.io/img/blog/129/ide2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;※うまく書き込みができないときには、「Digispark 互換 Windows10(またはMacとか自分の使ってるPCのOS)」のワードとかで検索するといいよ&lt;/p&gt;

&lt;h2 id=&#34;カセットテープとled配線を合体して組み立てよう&#34;&gt;カセットテープとLED配線を合体して組み立てよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/11.png&#34; alt=&#34;&#34; /&gt;
写真のように、配線用に穴をあけたほうのカセットテープ部品にLEDテープを貼ります。
カセットテープの元々の部品を組み込んで、ねじを締めてケースを閉じます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/12.png&#34; alt=&#34;&#34; /&gt;
後ろの配線はフィーリングでまとめて、真ん中の穴にインシロックを通して9V電池を固定します。電池の裏側とDigisparkの裏側に両面テープを貼っておくと、&lt;strong&gt;フェスでテンションが上がりすぎて激しく動いても部品が落ちません&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;LEDの電源を入れるときには、9V電池のスナップをつけて消したいときには外します。
つまり、スナップのつけ外し以外に特にスイッチはありません。&lt;/p&gt;

&lt;p&gt;光り方のプログラムによって、電池の消費量は変わります。
今回のプログラムだとだいたい連続使用で３時間程度で電池がなくなる感じです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/13.png&#34; alt=&#34;&#34; /&gt;
ピンバイスで開けた穴に、無理やりリングを通して好きなひもやストラップをつければ完成です！
やったね！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/14.png&#34; alt=&#34;&#34; /&gt;
この光るカセットテープ、ギャル電は&lt;strong&gt;無人島フェスやULTRAJAPANで実際に使ってみたけどやっぱめっちゃモテた&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;光るとめっちゃ楽しいから、みんなも作っていろんなところに遊びに行ってみてね☆&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.jsとNefry BTで監視システムを作ろう！ for Pepper #iotlt</title>
      <link>https://dotstud.io/blog/nefrybt-pepper-monitoring-system/</link>
      <pubDate>Thu, 21 Sep 2017 18:40:38 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefrybt-pepper-monitoring-system/</guid>
      
      <description>

&lt;p&gt;こんにちは、のびすけです。&lt;/p&gt;

&lt;p&gt;IoTLT vol31で話をしたNefry BT（ESP32系ボード）を使ってネットワークカメラを作ってみたいと思います。&lt;/p&gt;

&lt;p&gt;発表資料もご参照ください。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;a4d673e00b57428ebe22543efda38f6f&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/n0bisuke/pepperlian-xi-falsejian-shi-sisutemu-number-iotlt&#34;&gt;Pepper連携の監視システム? #iotlt by n0bisuke&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstudio.connpass.com/event/61189/&#34;&gt;Nefry BTのハンズオン&lt;/a&gt;も開催しますので合わせてご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;やりたいこと&#34;&gt;やりたいこと&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Pepperを監視したい。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;謎ですが、Pepperを監視したいです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://iotlt.connpass.com/event/65379/&#34;&gt;IoTLT vol31&lt;/a&gt;で話をした内容ですが、Pepperが動いてくれないので、Pepperがいつ動き出しても大丈夫なように&lt;strong&gt;Pepperを見守り&lt;/strong&gt;します。&lt;/p&gt;

&lt;p&gt;巷では「Pepperが見守り」だったり、「Pepperが防犯」みたいな先進的な取り組みがありますが、僕は&lt;strong&gt;あえてPepperを見守ります。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;完成イメージ&#34;&gt;完成イメージ&lt;/h2&gt;

&lt;p&gt;こんな感じで見守ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/c3fa7c7bb7dbdd5bba505e7a3de3b54b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そして、外からでもブラウザでPepperを見守るストリーミングサービスっぽいものを作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/09e912583e26710a13f0d49f4a866b55.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;使うもの&#34;&gt;使うもの&lt;/h2&gt;

&lt;p&gt;デバイスはNefry BTとGroveカメラの二つです。
（ちょっとジャンパワイヤ使います。）&lt;/p&gt;

&lt;h3 id=&#34;nefry-bt&#34;&gt;Nefry BT&lt;/h3&gt;

&lt;p&gt;ESP32ベースのArduino互換開発ボードです。
&lt;a href=&#34;http://sengoku.co.jp/mod/sgk_cart/detail.php?code=EEHD-55W8&#34;&gt;千石電商さん&lt;/a&gt;でも購入できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/d43d9926b0e5293b1045890bdd7fbc6c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;grove-シリアルカメラキット&#34;&gt;Grove シリアルカメラキット&lt;/h3&gt;

&lt;p&gt;Grove対応のカメラです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1626/&#34;&gt;スイッチサイエンスさん&lt;/a&gt;などで購入できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/99ad24d2ffcfd62c8407d7db7fb753c5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;構成イメージ&#34;&gt;構成イメージ&lt;/h2&gt;

&lt;p&gt;カメラで撮影した画像をNefry BT経由でサーバーにアップロードします。
アップロードされた画像はNode.jsで立てたサーバーで受け取り、WebSocket(Socket.io)でブラウザに配信します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/bfdd4f3e37898144268c2edd086320dc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;p&gt;3つに分けて紹介します。&lt;/p&gt;

&lt;p&gt;デバイス（Nefry BT）で撮影した画像をサーバーに送りサーバーからブラウザに配信します。&lt;/p&gt;

&lt;p&gt;データの流れ的に&lt;code&gt;デバイス -&amp;gt; サーバー -&amp;gt; ブラウザ&lt;/code&gt;という流れです。&lt;/p&gt;

&lt;p&gt;全体のコードは&lt;a href=&#34;https://github.com/dotstudio/nefrybt_camera_server&#34;&gt;こちらのGitHubリポジトリ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h3 id=&#34;デバイス側-arduino&#34;&gt;デバイス側 - Arduino&lt;/h3&gt;

&lt;p&gt;デバイス側は&lt;a href=&#34;http://wiki.seeed.cc/Grove-Serial_Camera_Kit/&#34;&gt;Grove - Serial Camera Kitの公式Wiki&lt;/a&gt;にあるサンプルコードをもとに作っています。&lt;/p&gt;

&lt;p&gt;dotstudioの&lt;a href=&#34;https://dotstud.io/members/ukkz/&#34;&gt;ものづくりアーティストうこ&lt;/a&gt;さんがメインで作ってくれました。&lt;/p&gt;

&lt;p&gt;少し長いので&lt;a href=&#34;https://github.com/dotstudio/nefrybt_camera_server/blob/master/nefry/nefrybt_grove_camera/nefrybt_grove_camera.ino&#34;&gt;GitHubのリポジトリ&lt;/a&gt;を参照しましょう。&lt;/p&gt;

&lt;p&gt;このプログラムをNefry BTに書き込みましょう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;host&lt;/code&gt;の箇所に画像アップロード先のサーバーを指定します。&lt;/p&gt;

&lt;h4 id=&#34;配線&#34;&gt;配線&lt;/h4&gt;

&lt;p&gt;配線はD3,D4に繋ぎます。&lt;/p&gt;

&lt;p&gt;プログラム的には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define SEREAL_RX 19 //Nefry BT D3
#define SEREAL_TX 18 //Nefry BT D4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の部分が該当します。NefryBTの&lt;a href=&#34;https://drive.google.com/file/d/0B_mvDQF8yaQRLVprUHl4WTFLWVE/view&#34;&gt;仕様書&lt;/a&gt;を見ると分かりますが、ESP32のGPIO 19番がNefryBTのD3にあたり、18番がD4になります。&lt;/p&gt;

&lt;h3 id=&#34;サーバー側-node-js&#34;&gt;サーバー側 - Node.js&lt;/h3&gt;

&lt;p&gt;Node.jsで画像を受信するサーバーを作ります。&lt;/p&gt;

&lt;p&gt;無難にSocket.ioとexpressを使います。 Node.jsのバージョンは8.4です。
7系以前だと動かない可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i --save socket.io express
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//server.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const app = require(&#39;express&#39;)();
const http = require(&#39;http&#39;).Server(app);
const io = require(&#39;socket.io&#39;)(http);
const express = require(&#39;express&#39;);
const PORT = process.env.PORT || 3000;
app.use(express.static(__dirname));

const {promisify} = require(&#39;util&#39;);
const writeFileAsync = promisify(fs.writeFile);

io.on(&#39;connection&#39;, (socket) =&amp;gt; console.log(&#39;a user connected&#39;)); //socket.ioのコネクション

app.get(&#39;/&#39;, (req, res) =&amp;gt; res.sendFile(&#39;./index.thml&#39;));
app.post(&#39;/&#39;, (req, res) =&amp;gt; {
    let buffers = [];
    let cur = 0;
    const len = parseInt(req.headers[&#39;content-length&#39;], 10);

    req.on(&#39;data&#39;, (chunk) =&amp;gt; {
        buffers.push(chunk);
        cur += chunk.length;
        console.log(`Downloading...${(100.0 * cur / len).toFixed(2)}%`);
    });

    req.on(&#39;end&#39;, async () =&amp;gt; {
        console.log(`\n[done] Image upload`);
        req.rawBody = Buffer.concat(buffers);
        const base64image = req.rawBody.toString(&#39;base64&#39;); //base64変換
        await writeFileAsync(&#39;./img.jpeg&#39;, req.rawBody, &#39;utf-8&#39;)
        console.log(`[done] Image Save`);
        io.sockets.emit(&#39;new image&#39;,base64image); //画像送信
    });
    
});
 
http.listen(PORT, () =&amp;gt; console.log(`listening on *:${PORT}`));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常Expressを使う際に&lt;a href=&#34;https://github.com/expressjs/body-parser&#34;&gt;body-parser&lt;/a&gt;をよく使いますが、今回はあえて使わずに、&lt;code&gt;dataイベント&lt;/code&gt;で&lt;code&gt;chunk&lt;/code&gt;を拾って画像アップロードのプログレス表示を実装しています。&lt;/p&gt;

&lt;p&gt;Nefry BTも含めてこういったマイコンボードはスマートフォンやPCに比べるとCPUパワーが弱いため、画像アップロードに時間がかかることがあります。&lt;/p&gt;

&lt;p&gt;サーバー側でどれくらいのデータ送信が完了しているのかの進捗が分かると安心して開発できます。
画像を受信したら&lt;code&gt;toString(&#39;base64&#39;)&lt;/code&gt;でBase64の文字列に変換をしています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.sockets.emit()&lt;/code&gt;の箇所では変換した文字列をSocket.io経由でブラウザに配信しています。&lt;/p&gt;

&lt;h3 id=&#34;ブラウザ側-javascript&#34;&gt;ブラウザ側 - JavaScript&lt;/h3&gt;

&lt;p&gt;ブラウザ側では、文字列で送られた画像データを受け取り、Canvasに流し込みます。
HTML側では&lt;code&gt;id=&amp;quot;myCanvas&amp;quot;&lt;/code&gt;のcanvasを作り、&lt;code&gt;socket.io&lt;/code&gt;の読み込みと以下で作る&lt;code&gt;app.js&lt;/code&gt;の読み込みをします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Nefry BT Camera&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body style=&amp;quot;background-color:#D0D0D0;&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;myCanvas&amp;quot; width=&amp;quot;640&amp;quot; height=&amp;quot;480&amp;quot; style=&amp;quot;background-color:#FFFFFF;&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;script src=&amp;quot;/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;/public/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;draw()&lt;/code&gt;では、canvasに&lt;code&gt;drawImage()&lt;/code&gt;で画像を描画します。
Base64の場合はsrcが画像パスではなく&lt;code&gt;data:image/jpeg;base64,~~~~~&lt;/code&gt;という指定方法です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /public/app.js
&#39;use strict&#39;;

const socket = io();

const draw = (imageData = &#39;&#39;) =&amp;gt; {
    const canvas = document.getElementById(&#39;myCanvas&#39;);
    const ctx = canvas.getContext(&#39;2d&#39;);
    const img = new Image();
    img.src = `data:image/jpeg;base64,${imageData}`; //基本base64の文字列
    if(imageData === &#39;init&#39;) img.src = `./img.jpeg`; //初期実行時のみサーバーのimg.jpegを取得
    img.onload = () =&amp;gt; {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0, 640, 480);
    }
    console.log(`update ${new Date()}`);
}

socket.on(&#39;new image&#39;, draw); //画像更新時
draw(&#39;init&#39;); //初期実行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;socket.on(&#39;new image&#39;, draw)&lt;/code&gt;でサーバーからデータが送られてくるたびに&lt;code&gt;draw()&lt;/code&gt;を実行します。&lt;/p&gt;

&lt;h2 id=&#34;使ってみた感想&#34;&gt;使ってみた感想&lt;/h2&gt;

&lt;p&gt;1週間ほど動かしていますが、問題なくずっと稼働写真を送り続けてくれるので意外と&lt;strong&gt;ラズパイなどで作るシステムより安定しているかも&lt;/strong&gt;しれません。&lt;/p&gt;

&lt;p&gt;あと、発表のオチだったのですが、Pepperの調子が悪く被写体が動かないので成功してるのか分かりにくいです苦笑&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/b2fb0a60f31c12e61e99b51d442dd563.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTとNode.jsを使ってネットワークカメラを作ることができました。&lt;/p&gt;

&lt;p&gt;GroveのカメラとNefry V2を使って過去に&lt;a href=&#34;https://am-our.com/love/110/13945/&#34;&gt;【大島薫×IoT】浮気男を社会的に制裁するマシーンを作ってみた&lt;/a&gt;こともありましたが、ネットワークカメラを作りたい需要はそこそこあると思うので、その際の参考になれば幸いです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>日本上陸！littleBits cloudBitモジュールでIFTTT連携してみた！</title>
      <link>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</link>
      <pubDate>Tue, 22 Aug 2017 19:43:42 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</guid>
      
      <description>

&lt;p&gt;littleBits cloudBitモジュールの技適が通りまして、ついに日本でも使えることになったということで、早速littleBits cloudBitモジュールを購入してIFTTTと連携してみました。
&lt;img src=&#34;https://dotstud.io/img/blog/119/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;littlebits-cloudbitモジュールとは&#34;&gt;littleBits cloudBitモジュールとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/2.png&#34; alt=&#34;&#34; /&gt;
littleBits cloudBitモジュールは、磁石でつなげて簡単に電子工作ができる知育ブロックlittleBitsのモジュールのひとつ、littleBits Cloudが橋渡しとなってインターネットとやり取りできるモジュールです。&lt;/p&gt;

&lt;p&gt;詳しくはこちら → &lt;a href=&#34;https://littlebits.cc/cloudstart&#34;&gt;Getting Started with your CloudBit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/3.png&#34; alt=&#34;&#34; /&gt;
橋渡しとなるlittleBits Cloudは、スマートフォンやPCからWEBアクセスできる CLOUD CONTROL APP や、LITTLEBITS APIによってREST APIでさらに深いところまで操作できるプログラミングできるLITTLEBITS APIといった入り口があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/4.png&#34; alt=&#34;&#34; /&gt;
今回ご紹介するのは、もうひとつ。ノンプログラミングでインターネットのいろいろなことに接続できる&lt;a href=&#34;https://ifttt.com/login&#34;&gt;IFTTT&lt;/a&gt;とlittleBitsの連携についてお伝えします。&lt;/p&gt;

&lt;p&gt;たとえば、littleBitsモジュールでボタンを押すとメールが送られたり、SNSでいいねが押されるとlittleBitsのLEDが反応するようなIoTの仕組みをさっと作ることができます。&lt;/p&gt;

&lt;h2 id=&#34;今回の仕組み&#34;&gt;今回の仕組み&lt;/h2&gt;

&lt;p&gt;今回の仕組みはGitHubでissueが上がるとBARGRAPH LEDが点灯する仕組みです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/5.png&#34; alt=&#34;&#34; /&gt;
ですが、ただBARGRAPH LEDが光るだけだと見落としてしまうので、100円ショップで買った光で動くソーラーゆらゆら（がいこつ）にLEDを照らして動かしてよりわかりやすくします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/6.png&#34; alt=&#34;&#34; /&gt;
このような仕組みです。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;littlebitsの準備&#34;&gt;littleBitsの準備&lt;/h3&gt;

&lt;p&gt;セットアップについてはすでに行われているものとします。&lt;a href=&#34;http://www.1ft-seabass.jp/memo/2017/08/09/cloudbit-setup-step-memo/&#34;&gt;cloudBitモジュールのセットアップについてのメモ&lt;/a&gt;についてもご参考下さい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/7.png&#34; alt=&#34;&#34; /&gt;
CLOUDBITパッケージに入っているものはcloudBitモジュール関連だけなので、別途写真のようにlittleBitから入力させるボタンモジュールや、出力を反応させるBARGRAPHモジュールは別途揃えておきましょう。また今回はソーラーゆらゆら（がいこつ）へうまくつなげるためにWIREモジュールも用意しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CLOUDBITパッケージにあるもの

&lt;ul&gt;
&lt;li&gt;USB power adapter ケーブル&lt;/li&gt;
&lt;li&gt;USB POWER モジュール&lt;/li&gt;
&lt;li&gt;cloudBitモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;別途必要なもの

&lt;ul&gt;
&lt;li&gt;ボタンモジュール&lt;/li&gt;
&lt;li&gt;BARGRAPHモジュール&lt;/li&gt;
&lt;li&gt;WIREモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/8.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆらを準備します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/9.png&#34; alt=&#34;&#34; /&gt;
コンセントをつないだアダプターからUSBケーブルを差し込みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/10.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュールにUSBケーブルをつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/11.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュール→ボタンモジュール→cloudBitモジュールまでつないで、接続されるまで待ちます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/12.png&#34; alt=&#34;&#34; /&gt;
つづいて、cloudBitモジュールの先にWIREモジュールとBARGRAPH LEDモジュールをつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/13.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆら（がいこつ）のソーラーパネル部分にガッとBARGRAPH LEDモジュールを当てます。マスキングテープで補強します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/14.png&#34; alt=&#34;&#34; /&gt;
これで準備完了です。&lt;/p&gt;

&lt;h3 id=&#34;cloud-control-appの準備&#34;&gt;CLOUD CONTROL APPの準備&lt;/h3&gt;

&lt;p&gt;cloudBitを管理している CLOUD CONTROL APP ページにログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iftttの準備&#34;&gt;IFTTTの準備&lt;/h3&gt;

&lt;p&gt;IFTTTもlittleBitsとの関連付けを行うのでログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こちらで準備完了です。&lt;/p&gt;

&lt;h2 id=&#34;littlebits-cloudbitモジュールとiftttの関連付け&#34;&gt;littleBits CloudBitモジュールとIFTTTの関連付け&lt;/h2&gt;

&lt;p&gt;さきほどログインしたCLOUD CONTROL APP ページでlittleBits CloudBitモジュールとIFTTTの関連付けを行います。
&lt;img src=&#34;https://dotstud.io/img/blog/119/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下部のメニューでAUTOMATEを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AUTOMATEページに遷移するとIFTTTとのアクティベートを促されるので GO TO IFTTT.COM ボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;IFTTTのlittleBitsチャンネルに遷移するので、CONNECTを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;すでにIFTTTとCLOUD CONTROL APPがログインしてあるので、アクティベート確認ページに遷移します。AUTHORIZEボタンを押して認証します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ログインが完了します。これで、IFTTTでlittleBitsと連携することができます。&lt;/p&gt;

&lt;h2 id=&#34;githubサービスのiftttでの認証をする&#34;&gt;GitHubサービスのIFTTTでの認証をする&lt;/h2&gt;

&lt;p&gt;GitHubでもIFTTTで使えるようにしておきましょう。上部のSearchからgithubを検索します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Servicesに出てきたGitHubをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/119/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubのページに移動するのでConnectボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubのAuthrize IFTTTページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Authrize IFTTTCHannelsボタンを押して認証を済ませておきます。&lt;/p&gt;

&lt;h2 id=&#34;littlebitsのifttt連携の設定&#34;&gt;littleBitsのIFTTT連携の設定&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/28.png&#34; alt=&#34;&#34; /&gt;
右上にある自分のプロフィールメニューからNew Appletを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/29.png&#34; alt=&#34;&#34; /&gt;
New Appletをつくる画面に行きます。thisボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/30.png&#34; alt=&#34;&#34; /&gt;
Choose a serviceではgitと検索しGitHubをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/31.png&#34; alt=&#34;&#34; /&gt;
今回は自分にissueが来たときに動作するようにしたいので、Any new issueをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/32.png&#34; alt=&#34;&#34; /&gt;
つづいて動作のきっかけ this が作れたので、なにが起こるかの that を設定するため that ボタンを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/33.png&#34; alt=&#34;&#34; /&gt;
Choose action service画面になるので、littleBitsと検索し、littleBitsアクションをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/34.png&#34; alt=&#34;&#34; /&gt;
Choose action画面になるので、Set Output Levelをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/35.png&#34; alt=&#34;&#34; /&gt;
Complete action fields画面になるので以下のように設定します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Which cloudBit?

&lt;ul&gt;
&lt;li&gt;動かしたいcloudBit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Level

&lt;ul&gt;
&lt;li&gt;100&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Duration

&lt;ul&gt;
&lt;li&gt;20 seconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/36.png&#34; alt=&#34;&#34; /&gt;
設定が終わったら、下の方のCreate Actionボタンを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/37.png&#34; alt=&#34;&#34; /&gt;
Review and finish画面に来るので、設定を確認します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/38.png&#34; alt=&#34;&#34; /&gt;
問題なければ、下の方のFinishボタンを押します。&lt;/p&gt;

&lt;p&gt;これで設定は完了です。&lt;/p&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;早速試しにissueをGitHubで作ってみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/119/39.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回は適当に作ってみます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/40.png&#34; alt=&#34;&#34; /&gt;
issues発行します。&lt;/p&gt;

&lt;p&gt;多少タイムラグがあるので5～10秒ほど待ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/demo.gif&#34; alt=&#34;&#34; /&gt;
無事動きました！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ということで、技適が通り日本上陸となった、littleBits cloudBitモジュールのIFTTT連携をお伝えしました。&lt;/p&gt;

&lt;p&gt;今回はIoTでも実装に手間がかかるインターネット上の反応をlittleBitsに降ろす仕組みを軸にお伝えしましたがIFTTTとlittleBits Cloudの連携は手軽に作れますね。IoTにおけるいろいろな技術要素が裏側でしっかり作られています。&lt;/p&gt;

&lt;p&gt;もちろん、IFTTTと連携するとAmazon Dash Buttonのような、ボタンを押すとツイートがされるようなlittleBitsからインターネットを動かす仕組みについても実現可能です。&lt;/p&gt;

&lt;p&gt;littleBitsの持つブロックを組み合わせて電子工作ができる手軽さに加えて、IFTTTが組み合わさることでインターネットもあたかもブロックのように扱えてるlittleBits cloudBitモジュール、ぜひ試してみてください！&lt;/p&gt;

&lt;p&gt;※今回の図表の一部では&lt;a href=&#34;http://icooon-mono.com/&#34;&gt;アイコン素材ダウンロードサイト「icooon-mono」&lt;/a&gt;さんの画像を利用いたしました。ありがとうございます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>フォトダイオードでリモコンの信号を検出してみよう</title>
      <link>https://dotstud.io/blog/photodiode-remote-controll-signal/</link>
      <pubDate>Wed, 02 Aug 2017 16:42:19 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/photodiode-remote-controll-signal/</guid>
      
      <description>

&lt;p&gt;こんにちは、ものづくり担当のうこ（&lt;a href=&#34;https://twitter.com/harmoniko/&#34;&gt;@harmoniko&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;今回は、フォトダイオードというパーツを使ってリモコンの信号を読み取る方法を紹介します！&lt;/p&gt;

&lt;h2 id=&#34;フォトダイオードとは&#34;&gt;フォトダイオードとは？&lt;/h2&gt;

&lt;p&gt;半導体素子のひとつで、照射される光の強さによって流れる電流の強さが変化します。太陽光パネルと仕組みはほとんど同じで、光によって電流を発生しますが、非常に小さいため電源としては使用されません。&lt;/p&gt;

&lt;p&gt;一口にフォトダイオードと言っても様々な種類があります。（参考：&lt;a href=&#34;http://jp.rs-online.com/web/c/displays-optoelectronics/optocouplers-photodetectors-photointerrupters/photodiodes/&#34;&gt;RSコンポーネンツ&lt;/a&gt;。多種の取り扱いがあります。） 光を検出するセンサとしてはほかにCdSなどがありますが、応答の速さ・感度・信号強度特性・対応する波長などに優位性があり、リモコンの受光器などとして産業用途に幅広く利用されています。&lt;/p&gt;

&lt;p&gt;今回はそんなリモコンの受光器を作り、信号の中身をみてみましょう。&lt;/p&gt;

&lt;h2 id=&#34;リモコンの仕組み&#34;&gt;リモコンの仕組み&lt;/h2&gt;

&lt;p&gt;リモコンは、赤外線LEDを高速で点滅させて家電などに信号を送っています。信号の中身は、国内ではNECが開発した方式が主流で、次いで家電製品協会の方式、ソニーなどの独自方式があります。今回は、最も普及しているNEC方式を用いたリモコン信号検出システムを作ってみます。&lt;/p&gt;

&lt;p&gt;このフォーマットを採用している主なメーカーとして、NEC・東芝・日立などがあります。これらのメーカーのリモコンなどをお持ちでしたら、ぜひ作ってみてください。&lt;/p&gt;

&lt;p&gt;【参考】&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.asahi-net.or.jp/~gt3n-tnk/IR_TX1.html&#34;&gt;赤外線リモコンのフォーマット&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作ってみよう&#34;&gt;作ってみよう&lt;/h2&gt;

&lt;h3 id=&#34;準備するもの&#34;&gt;準備するもの&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Arduino Due × 1&lt;/li&gt;
&lt;li&gt;ブレッドボード × 1&lt;/li&gt;
&lt;li&gt;抵抗1kΩ × 1&lt;/li&gt;
&lt;li&gt;フォトダイオード S5971 × 1&lt;/li&gt;
&lt;li&gt;ジャンパワイヤ × 4&lt;/li&gt;
&lt;li&gt;黒画用紙(3cm×6cmぐらい)&lt;/li&gt;
&lt;li&gt;USBマイクロBケーブル&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;作り方&#34;&gt;作り方&lt;/h3&gt;

&lt;h4 id=&#34;フォトダイオードに黒画用紙を巻く&#34;&gt;フォトダイオードに黒画用紙を巻く&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;フォトダイオードには、細長く切った黒画用紙を巻き寿司のように巻きつけてテープで固定します。こうすることでフォトダイオードを常に暗い状態にし、光の誤検出を防ぎます。&lt;/p&gt;

&lt;h4 id=&#34;配線&#34;&gt;配線&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/4.png&#34; alt=&#34;&#34; /&gt;
まずはじめに、ブレッドボード上に抵抗器とフォトダイオードを、上の写真のように配置します。フォトダイオードは向きに注意してください。
&lt;img src=&#34;https://dotstud.io/img/blog/117/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、4つのジャンパワイヤを使って、ブレッドボードとArduino Dueを接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/117/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接続が終わったら、このような感じになっています。
&lt;img src=&#34;https://dotstud.io/img/blog/117/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最後に、USBのマイクロBケーブルでArduino Dueとパソコンを接続して完了です。USBは、Arduino Due側は、黒いコネクタに近い方のUSBポート「Programming Port」に接続してください。&lt;/p&gt;

&lt;h3 id=&#34;arduino-dueボード対応化&#34;&gt;Arduino Dueボード対応化&lt;/h3&gt;

&lt;p&gt;Arduino IDEでプログラムを作成し書き込んでいきます。Arduino IDEのインストールが済んでいない方は、&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;からダウンロードして進めてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/8.png&#34; alt=&#34;&#34; /&gt;
Arduino IDEのメニューから、
Tools -&amp;gt; Boards:&amp;ldquo;&amp;hellip;&amp;rdquo; -&amp;gt; Board Manager&amp;hellip;
を選択すると、小さい画面が表示されます。検索窓に「due」と打ち込むと、ひとつだけヒットするパッケージがありますので、最新版をインストールしてください。&lt;/p&gt;

&lt;p&gt;次に、
Tools -&amp;gt; Boards&amp;rdquo;&amp;hellip;&amp;rdquo;
で、&amp;rdquo;Arduino Due (Programming Port)&amp;ldquo;を選択しておきます。&lt;/p&gt;

&lt;h3 id=&#34;ソースコードを書き込む&#34;&gt;ソースコードを書き込む&lt;/h3&gt;

&lt;p&gt;以下のソースコードをコピーし、スケッチにコピーしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const int thresholdH = 30;     // フォトダイオードの閾値(Off-&amp;gt;On)
const int thresholdL = 20;     // フォトダイオードの閾値(On-&amp;gt;Off)
const int input = A0;          // フォトダイオードの入力ピン
int signalCnt = -1;            // 信号カウンタ
int level = 0;                 // フォトダイオードのanalogRead値
unsigned long offSpan;         // 信号L値持続時間(計測用)
unsigned long offTime;         // 信号Off時間(計測用)
unsigned long startTime;       // 時間計算用
unsigned long signals = 0;     // 信号保存(カスタム16bit+データ8bit+反転データ8bit)
bool now = false;              // フォトダイオード状態遷移フラグ1
bool prev = false;             // フォトダイオード状態遷移フラグ2
bool detected = false;         // リーダコード検出フラグ




// フォトダイオードからアナログ値を読んで論理値に変換
bool photoRead() {
  level = analogRead(input);
  if (level &amp;gt; thresholdH) return true;
  if (level &amp;lt; thresholdL) return false;
}


// リーダコード認識
bool leaderDetect() {
  // 積分
  unsigned long integral0 = 0;
  unsigned long integral1 = 0;
  startTime = micros();
  // 9msループ(0.1msおまけ)
  while (micros() &amp;lt; (startTime+9100)) {
    if (photoRead()) integral1++;
    else integral0++;
  }
  /*
    副搬送波38kHz変調のデューティ比は1:2である
    また信号で0を表す場合はPPM方式によりHとLがそれぞれ0.56ms(1:1)であるため
    リーダコード以外の部分でフォトダイオードで得られるOnとOffの時間比は
    Onが1に対してOffが6である
    リーダコード部分は常にHであるのでOnが1に対してOffが3である
    よってOnとOffの差がおおむね4倍以下であればリーダコードを判定することができる
  */
  if (integral1 &amp;gt; ((integral0)/4)) return true;
  else return false;
}


void setup() {
  // シリアルポートを開く
  Serial.begin(115200);
  // アナログ入力の細かさを12bit(4096段階)に設定
  analogReadResolution(12);
}


void loop() {
  // ダイオードの状態確認ループ
  while(now == prev) {
    now = photoRead();
    // 一度検出できたらループを極力回さずにディレイさせたい
    // 副搬送波のL値を誤検出しないようにするため
    if (now) {
      if (!detected) {
        // Off-&amp;gt;On遷移かつリーダコード未検出
        if (leaderDetect()) {
          Serial.println(&amp;quot;------- LEADER -------&amp;quot;);
          detected = true;
          signalCnt = -1;
        }
      }
    }
  }

  // 以下は状態変化した瞬間だけ実行される
  //
  if (detected) {
    if (now) {
      // Off-&amp;gt;On遷移かつリーダコード検出済
      offSpan = micros() - offTime;
      // 最初のリーダコードの直後のL値
      if (signalCnt &amp;lt; 0) {
        // リピートの検出(3ms未満)
        if (offSpan &amp;lt; 3000) {
          Serial.println(&amp;quot;------- REPEAT -------&amp;quot;);
          Serial.println(&amp;quot;&amp;quot;);
          signals = 0;
          signalCnt = -1;
          detected = false;
        } else {
          signalCnt++;
        }
      } else {
        // off時間が1000msより多いか少ないか
        if (offSpan &amp;lt; 1000) {
          // 1判定
          signals += 1&amp;lt;&amp;lt;(31-signalCnt);
        } else {
          // 0判定
        }
        signalCnt++;
      }
      // 570msも待てば必ずLになり次のコード先頭までHにならないので誤検出しない
      delayMicroseconds(570);
    } else {
      // On-&amp;gt;Off遷移かつリーダコード検出済
      offTime = micros();
    }
  }
  // 反転
  prev = now;

  // 最後まで読めたら表示する
  if (signalCnt &amp;gt;= 31) {
    // カスタムコード16bit
    int custom = (int)(signals&amp;gt;&amp;gt;16);
    Serial.print(&amp;quot;Custom code: &amp;quot;); Serial.println(custom,HEX);
    Serial.print(&amp;quot;    &amp;quot;); Serial.println(custom,BIN);
    // データコード8bit
    byte data1 = (byte)((signals&amp;gt;&amp;gt;8)&amp;amp;B11111111);
    Serial.println(&amp;quot;Data code:&amp;quot;);
    Serial.print(&amp;quot;    &amp;quot;); Serial.print(data1,BIN); Serial.print(&amp;quot; = &amp;quot;); Serial.println(data1,HEX);
    // データコード(反転)8bit
    byte data2 = (byte)(signals&amp;amp;B11111111);
    Serial.print(&amp;quot;    &amp;quot;); Serial.print(data2,BIN); Serial.print(&amp;quot; = &amp;quot;); Serial.println(data2,HEX);
    // データ検証
    byte vf = data1^data2;
    Serial.println(&amp;quot;Data verify: &amp;quot;);
    Serial.print(&amp;quot;    &amp;quot;); Serial.print(data1,HEX); Serial.print(&amp;quot; xor &amp;quot;); Serial.print(data2,HEX); Serial.print(&amp;quot; = &amp;quot;); Serial.println(vf,HEX);
    if (vf == 0xFF) Serial.println(&amp;quot;     [ VERIFIED ]&amp;quot;);
    else Serial.println(&amp;quot;     [ ERROR ]&amp;quot;);
    // おわり
    Serial.println(&amp;quot;------- ------ -------&amp;quot;);
    Serial.println(&amp;quot;&amp;quot;);
    signals = 0;
    signalCnt = -1;
    detected = false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみよう&#34;&gt;試してみよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/9.png&#34; alt=&#34;&#34; /&gt;
アップロードが完了したら、Tools -&amp;gt; Serial Monitor からシリアルモニタを表示させ、通信速度を「115200bps」に変更します。その状態のまま、リモコンをフォトダイオードに近づけてボタンを押すと……&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/10.png&#34; alt=&#34;&#34; /&gt;
いくつか値が表示されましたね！
点線で囲まれたブロックが信号の1セットで、中身には「Custom code」「Data code」「Data verify」が入っています。
「Custom code」は製品固有のコードで、同じリモコンだと基本的に固定の値です。&lt;/p&gt;

&lt;p&gt;色々ボタンを押していると、「Data code」が変化するようすがわかります。「Data verify」は、信号に含まれている2つのデータを照合して、信号が壊れていないかを確認するためのものです。
&lt;img src=&#34;https://dotstud.io/img/blog/117/11.png&#34; alt=&#34;&#34; /&gt;
自宅の扇風機のリモコンで試してみたところ、確かにボタンで値が変わっていることがわかりました。&lt;/p&gt;

&lt;h2 id=&#34;応用編&#34;&gt;応用編&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/12.png&#34; alt=&#34;&#34; /&gt;
Arduino IDEには「シリアルプロッタ」という、グラフを描画できる機能が備わっています。それを利用して、リモコンの信号波形を描画してみるとこんな感じになりました。規則的な波形をところどころに確認することができます。&lt;/p&gt;

&lt;p&gt;また、今回使用したマイコンボード「Arduino Due」は、USB接続の外付けマウス・外付けキーボードとして簡単に動作させることができるライブラリが備わっています。例えば、今回のプログラムにこの機能を取り入れて少し書き換えるだけで、普段使っているTVリモコンでパソコンの動画プレイヤーを制御、なんてこともすぐにできちゃいます。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;いかがでしたでしょうか？
フォトダイオードはいろんな種類がありますが、Arduinoのようなマイコンボードを使えば意外と簡単に光センサを作ることができます。この機会にぜひ作ってみては。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ライブで大活躍！音に反応して光るサバゲーマスク！</title>
      <link>https://dotstud.io/blog/gyaruden-mao-led-mask/</link>
      <pubDate>Fri, 21 Jul 2017 18:09:27 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-mao-led-mask/</guid>
      
      <description>

&lt;p&gt;どうも！dotstudio広報兼テクニカルライターのマオです。&lt;strong&gt;ギャルによるギャルのためのテクノロジーを提案していく電子工作ユニット、ギャル電&lt;/strong&gt;で活動をしてます！&lt;/p&gt;

&lt;p&gt;この記事では、LEDを音センサーに反応させる電子工作を紹介していきたいと思いまぁす！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回は音センサーを使うとのことで、ライブやフェスなどにつけていくと鬼盛れの&lt;strong&gt;”音に反応するパンクロックなマスク”&lt;/strong&gt;を作りました！&lt;/p&gt;

&lt;p&gt;では早速作り方を紹介していきたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;準備するもの&#34;&gt;準備するもの&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;電子部品類&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1399/&#34;&gt;フルカラーシリアルLEDテープ(1m)通称NeoPixel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1680/&#34;&gt;エレクトレットマイクアンプモジュールMAX4466(音センサー)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1330/&#34;&gt;FLORA(マイコン)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://item.rakuten.co.jp/3rwebshop/3r-ps2600/&#34;&gt;小型モバイルバッテリー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;工具類&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;はんだ,はんだごて&lt;/li&gt;
&lt;li&gt;フックアップワイヤー&lt;/li&gt;
&lt;li&gt;ワイヤーストリッパー&lt;/li&gt;
&lt;li&gt;ニッパ&lt;/li&gt;
&lt;li&gt;ハサミ&lt;/li&gt;
&lt;li&gt;マイクロUSB(TypeB)&lt;/li&gt;
&lt;li&gt;パソコン&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;側の部分&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サバゲーのマスク&lt;/li&gt;
&lt;li&gt;100均に売っているフェルト2枚&lt;/li&gt;
&lt;li&gt;シールフェルト（半面がシールのもの）1枚&lt;/li&gt;
&lt;li&gt;マジックテープ&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;はんだづけする前に&#34;&gt;はんだづけする前に&lt;/h3&gt;

&lt;p&gt;はんだづけ初心者または慣れていない方は、一回はんだづけのやり方を&lt;a href=&#34;http://www.murata.com/ja-jp/campaign/ads/japan/elekids/ele/craft/knack/soldering&#34;&gt;こちらのサイト&lt;/a&gt;で見てからするのをオススメします。
またはんだづけする時や電線を切断する時、飛び散ることがあります。そのため、&lt;strong&gt;安全メガネなどを装着して目を守る&lt;/strong&gt;ようにしてください。&lt;/p&gt;

&lt;p&gt;はんだづけする際は配線の準備が必要です。今回は被覆が付いているフックアップワイヤーを配線として使いました。
&lt;img src=&#34;https://dotstud.io/img/blog/114/2.png&#34; alt=&#34;&#34; /&gt;
フックアップワイヤーは被覆をワイヤーストリッパーで約2~4mm程度剥きましょう。ワイヤーストリッパーの使い方は&lt;a href=&#34;http://diytools1.com/2016/04/22/post-14009/&#34;&gt;こちら&lt;/a&gt;を参考にしてください。また、フックアップワイヤーの長さは必要に応じて調整しながら切断してください。&lt;/p&gt;

&lt;h3 id=&#34;さっそくはんだづけ&#34;&gt;さっそくはんだづけ！&lt;/h3&gt;

&lt;p&gt;今回は以下のように配線しました。
&lt;img src=&#34;https://dotstud.io/img/blog/114/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ピンの配置はこちらです。
&lt;img src=&#34;https://dotstud.io/img/blog/114/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;neopixelをはんだづけ&#34;&gt;NeoPixelをはんだづけ&lt;/h2&gt;

&lt;p&gt;合計44個のNeoPixel(LED)をはんだづけしていきます。
&lt;img src=&#34;https://dotstud.io/img/blog/114/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで注意する点としては、&lt;strong&gt;NeoPixelの向き&lt;/strong&gt;です。下のNeoPixelの画像を見てみると矢印が書いてあります。この矢印は電流が流れる方向です。この&lt;strong&gt;矢印を逆にしてはんだづけしてしまうとNeoPixelがつかなくなる&lt;/strong&gt;のでここの点は要注意してはんだづけしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで以上のようにはんだづけしたら、100均一で買った半面シールのフェルトのシール側にNeoPixelを貼ります。
&lt;img src=&#34;https://dotstud.io/img/blog/114/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;貼り終わったらFlora側と繋ぐ配線をフェルトに通します。配線を通す穴は適当に開けてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、NeoPixelの上から普通のフェルトを貼り付けてマスクの形に合わせて余計な部分を切り捨てます。
&lt;img src=&#34;https://dotstud.io/img/blog/114/9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;floraとマイクアンプ-neopixelをはんだづけ&#34;&gt;Floraとマイクアンプ、NeoPixelをはんだづけ&lt;/h2&gt;

&lt;p&gt;Flora(マイコン)とマイクアンプ(音センサー)のはんだづけをします。&lt;/p&gt;

&lt;p&gt;最後に先ほどフェルトに通したNeoPixelの配線をFloraにはんだづけしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これで光らせる部分完成です！&lt;/p&gt;

&lt;h3 id=&#34;プログラミングするための環境設定&#34;&gt;プログラミングするための環境設定&lt;/h3&gt;

&lt;p&gt;次にプログラミングするために環境設定を行います。&lt;/p&gt;

&lt;p&gt;今回使うFloraはArduino互換ボードなのでプログラミングする際に&lt;strong&gt;ArduinoIDE&lt;/strong&gt;というソフトウェアを使います。
このArduinoIDEはフリーソフトです。&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;から各自のパソコンにダウンロードしてください。&lt;/p&gt;

&lt;p&gt;また、Windowsユーザーの方は Floraの開発元のAdafruit社による「Windows Driver」をインストールする必要があります。&lt;a href=&#34;https://learn.adafruit.com/getting-started-with-flora/windows-setup&#34;&gt;こちらのサイト&lt;/a&gt;を参照して進めてください。（Mac・Linuxのユーザーの方はインストールする必要はありません）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;マイコンボードのインストレーション&#34;&gt;マイコンボードのインストレーション&lt;/h4&gt;

&lt;p&gt;ArduinoIDEを立ち上げてまだすぐプログラミングはできません。
まず、AduinoIDEにFloraというマイコンボードを知ってもらうためボードのインストールをします。&lt;/p&gt;

&lt;p&gt;Arduino &amp;gt; Preferences をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://www.adafruit.com/package_adafruit_index.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上記のAdafruitのURLをコピーして、追加のボードマネージャーのURLに貼り、OKをクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コピー＆ペーストが完了したら、ツール &amp;gt; マイコンボード &amp;gt; ボードマネージャーをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/114/13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;すると、このような画面が表示されます。検索欄に「Adafruit AVR Boards」を入力し、インストールしましょう。ここまでで、ボードのインストレーションは終わりです。
&lt;img src=&#34;https://dotstud.io/img/blog/114/14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;ライブラリのインストール&#34;&gt;ライブラリのインストール&lt;/h4&gt;

&lt;p&gt;次に、NeoPixel を光らせるために必要なライブラリをインストールします。スケッチ &amp;gt; ライブラリをインクルード &amp;gt; ライブラリを管理 をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;画面が表示されるので、検索欄に「Neopixel」と入力しましょう。下記のようになります。「Adafruit Neopixel by Adafruit」を選択してインストールしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;プログラミングを書き込む&#34;&gt;プログラミングを書き込む！&lt;/h3&gt;

&lt;p&gt;以下のプログラムをArduinoIDEにコピー&amp;amp;ペーストしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;

#define N_PIXELS  44  //　LEDの個数
#define MIC_PIN    9  // Floraに接続しているマイクロフォンのGPIO
#define LED_PIN    6  // NeoPixel LEDがFloraに接続しているGPIO
#define DC_OFFSET  0  // マイクロフォンのDCオフセット信号 - わからない場合0に設定
#define NOISE     100  // マイクロフォン信号のNoise/hum/interference
#define SAMPLES   60  // ダイナミックレベルの調整のためのバッファーの長さ
#define TOP       (N_PIXELS +1) // ドットをスケールから少し外れるようにする

byte
  peak      = 0,      
  dotCount  = 0,      
  volCount  = 0;     

int
  vol[SAMPLES],       
  lvl       = 10,    
  minLvlAvg = 0,      
  maxLvlAvg = 512;

Adafruit_NeoPixel  strip = Adafruit_NeoPixel(N_PIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);

void setup() {

  memset(vol,0,sizeof(int)*SAMPLES);//Thanks Neil!
  strip.begin();
}
void loop() {
  uint8_t  i;
  uint16_t minLvl, maxLvl;
  int      n, height;
  n   = analogRead(MIC_PIN);                 
  n   = abs(n - 512 - DC_OFFSET);            
  n   = (n &amp;lt;= NOISE) ? 0 : (n - NOISE);      
  lvl = ((lvl * 7) + n) &amp;gt;&amp;gt; 3;   


  height = TOP * (lvl - minLvlAvg) / (long)(maxLvlAvg - minLvlAvg);

  if(height &amp;lt; 0L)       height = 0;      
  else if(height &amp;gt; TOP) height = TOP;
  if(height &amp;gt; peak)     peak   = height;


  uint8_t bright = 255;   
#ifdef POT_PIN            
   bright = analogRead(POT_PIN);  

#endif
  strip.setBrightness(bright);   

  for(i=0; i&amp;lt;N_PIXELS; i++) {  
    if(i &amp;gt;= height)               
       strip.setPixelColor(i,   0,   0, 0);
    else
       strip.setPixelColor(i,Wheel(map(i,0,strip.numPixels()-1,30,150)));
    }

   strip.show();

  vol[volCount] = n;                      
  if(++volCount &amp;gt;= SAMPLES) volCount = 0;


  minLvl = maxLvl = vol[0];
  for(i=1; i&amp;lt;SAMPLES; i++) {
    if(vol[i] &amp;lt; minLvl)      minLvl = vol[i];
    else if(vol[i] &amp;gt; maxLvl) maxLvl = vol[i];
  }

  if((maxLvl - minLvl) &amp;lt; TOP) maxLvl = minLvl + TOP;
  minLvlAvg = (minLvlAvg * 63 + minLvl) &amp;gt;&amp;gt; 6;
  maxLvlAvg = (maxLvlAvg * 63 + maxLvl) &amp;gt;&amp;gt; 6;
}


uint32_t Wheel(byte WheelPos) {
  if(WheelPos &amp;lt; 85) {
   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  } else if(WheelPos &amp;lt; 170) {
   WheelPos -= 85;
   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else {
   WheelPos -= 170;
   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、ArduinoIDEのツールに行きボードを&amp;rdquo;Adafuit Flora&amp;rdquo;に選択してください。
次にシリアルポートを(Adafruit Flora)に選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、コンパイル（検証）ボタンをクリックし、プログラムに問題がないかチェックします。OKならば、書き込みのボタンをクリックするとプログラムがFLORAマイコンに書き込まれます。赤いランプの点滅が終わると書き込みが終了した状態なので、そうなったらケーブルを外しても大丈夫です。&lt;/p&gt;

&lt;h3 id=&#34;仕上げ&#34;&gt;仕上げ&lt;/h3&gt;

&lt;p&gt;NeoPixelの裏側にある、Floraとマイクアンプ側の面をフェルトを適当な形に切って、覆います。
ここで覆ったフェルトとFlora側のフェルトが付け剥がしできるようにマジックテープなどで固定します。
&lt;img src=&#34;https://dotstud.io/img/blog/114/19.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/114/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最後にFlora側のフェルトが内向き(口に合わせる方)になるようサバゲーマスクに貼り合わせて、モバイルバッテリーをさしたら完成です〜！
&lt;img src=&#34;https://dotstud.io/img/blog/114/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;音があるとNeoPixelが反応して光ります！
&lt;img src=&#34;https://dotstud.io/img/blog/114/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;マスクつけてライブに遊びに行ったよ&#34;&gt;マスクつけてライブに遊びに行ったよ！&lt;/h3&gt;

&lt;p&gt;さっそくマスクをつけてライブに行ってきた！みんなに&lt;strong&gt;ニンジャスレイヤーみたい&lt;/strong&gt;だと褒められてまじなんかよくわからないけど、くノ一になった気分で嬉しかったっす。
&lt;img src=&#34;https://dotstud.io/img/blog/114/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回のライブでは以前ギャル電きょうこが記事で紹介した&lt;a href=&#34;https://dotstud.io/blog/gyaruden-party-people-daigoro/&#34;&gt;&lt;strong&gt;光る大五郎&lt;/strong&gt;&lt;/a&gt;とフル装備で光りまくって&lt;strong&gt;振る舞い大五郎&lt;/strong&gt;をしてきた。ビカビカする中お酒をみんなに振る舞う感じ、&lt;strong&gt;まじサグみしかなくて超エモ&lt;/strong&gt;ってなった。
&lt;img src=&#34;https://dotstud.io/img/blog/114/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こんな感じで、&lt;strong&gt;とりま光らせてパーディーにいくとまじアゲぽよ&lt;/strong&gt;になって超楽しくなるから、みんなも&lt;strong&gt;サグい電子工作してパーティーを盛り上げよう&lt;/strong&gt;！卍
&lt;img src=&#34;https://dotstud.io/img/blog/114/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ESP8266を使って京急が遅延すると光るガジェットを作ってみた</title>
      <link>https://dotstud.io/blog/pokio-esp-keikyu-chien/</link>
      <pubDate>Tue, 13 Jun 2017 19:28:32 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/pokio-esp-keikyu-chien/</guid>
      
      <description>

&lt;p&gt;こんにちは、京急が大好きなポキオです。&lt;/p&gt;

&lt;p&gt;普段はAndroidエンジニアをやってますが、週末は趣味でArduinoやESP8266を触って心を落ち着かせています。先日、「京急が遅延すると光るガジェット」を作って&lt;a href=&#34;https://iotlt.connpass.com/&#34;&gt;IoTLT&lt;/a&gt;で発表を行ってきました。&lt;/p&gt;

&lt;p&gt;今回は、そこで発表したガジェットの作成段階や、技術的な仕組みを紹介します。（発表後に一部パーツ・コーディングを変更しています）&lt;/p&gt;

&lt;h2 id=&#34;今回作るもの&#34;&gt;今回作るもの&lt;/h2&gt;

&lt;p&gt;ESP8266というWi-Fiモジュールを搭載した開発ボード「ESPr® Developer」を使って京急のホームページから運行情報を取得し、遅延していたらLEDを光らせる仕組みを作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/01_map.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Air（13-inch、Mid 2013）&lt;/li&gt;
&lt;li&gt;OS X Yosemite（v10.10.5）&lt;/li&gt;
&lt;li&gt;Arduino IDE 1.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ESPr® DeveloperESP8266&lt;/li&gt;
&lt;li&gt;マイコン内臓RGB LED&lt;/li&gt;
&lt;li&gt;光らせたいガジェット（今回はBトレインショーティ）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;主なパーツ&#34;&gt;主なパーツ&lt;/h2&gt;

&lt;h3 id=&#34;espr-developer&#34;&gt;ESPr® Developer&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/02_esper.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://www.switch-science.com/catalog/2500/&#34;&gt;スイッチサイエンス&lt;/a&gt;さんで売られている、ESP8266というWi-Fiモジュールを搭載した開発ボードです。素のESP8266を直接触るのはハードルが高いですが、USB-シリアル変換やレギュレータ、リセットスイッチなど実装済みで、Arduino IDEでも開発できるため便利です。&lt;/p&gt;

&lt;p&gt;ただし、筆者の開発環境ではArduino IDEからコードを流し込む際に、一手間必要でした。詳しくはこちら。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://qiita.com/shanonim/items/68fab6dc28b72b31a258&#34;&gt;ESPr Developer（ESP-WROOM-02開発ボード）で &amp;ldquo;warning: espcomm_sync failed&amp;rdquo; と表示される場合の対処&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;マイコン内蔵rgb-led&#34;&gt;マイコン内蔵RGB LED&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/03_led.png&#34; alt=&#34;画像&#34; /&gt;
秋葉原の&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-08412/&#34;&gt;秋月電子通商&lt;/a&gt;さんで1個40円で売られているものを使用します。通常のLEDは足が2本ですが、こちらは足が4本。これらを制御することで、様々な色でLEDを光らせることができます。ESP8266（Arduino）向けに便利なライブラリが公開されているので、今回はこれを使ってコーディングしていきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/adafruit/Adafruit_NeoPixel&#34;&gt;Adafruit NeoPixel Library&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bトレインショーティー&#34;&gt;Bトレインショーティー&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/04_train.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://bandai-hobby.net/train/&#34;&gt;Bトレインショーティー&lt;/a&gt;はバンダイさんから発売されている、自分で組み立てるタイプの鉄道模型です。特徴は、何と言っても可愛さ。実車のディテールを表現しつつ、車両の長さをギュッと縮めてコミカルなルックスになっています。今回は（もちろん京急の）2100形をチョイス。京急の中で好きな車両の一つです。&lt;/p&gt;

&lt;h2 id=&#34;ガジェットを作ってみる&#34;&gt;ガジェットを作ってみる&lt;/h2&gt;

&lt;h3 id=&#34;京急の2100形車両の組み立て&#34;&gt;京急の2100形車両の組み立て&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/05_keikyu1.png&#34; alt=&#34;画像&#34; /&gt;
なにはともあれ、京急の車両を組み立てるところから始めます。Bトレインショーティーの京急2100形は、塗装済みで接着剤不要で組み立てができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/06_keikyu2.png&#34; alt=&#34;画像&#34; /&gt;
久しぶりのプラモデルにテンションがアガります。&lt;/p&gt;

&lt;h3 id=&#34;マイコン内蔵rgb-ledを埋め込む&#34;&gt;マイコン内蔵RGB LEDを埋め込む&lt;/h3&gt;

&lt;p&gt;出来上がった京急の車両にLEDを埋め込んでいきます。ここで便利なのがサンハヤトさんの&lt;a href=&#34;http://www.sunhayato.co.jp/material2/index.php/item?cell003=%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF%E8%A3%BD%E5%93%81&amp;amp;cell004=%E4%B8%AD%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF&amp;amp;name=%E8%96%84%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF+UB-THN01&amp;amp;id=722&amp;amp;label=1&#34;&gt;ハサミで切れるユニバーサル基板&lt;/a&gt;です。
&lt;img src=&#34;https://dotstud.io/img/blog/099/07_universal1.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;謳い文句の通り、ハサミで自由にカットができて、今回のような小さい車両にも基板を収めることができます。
&lt;img src=&#34;https://dotstud.io/img/blog/099/08_universal2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こんな感じで簡単に、そしてその場で車両ピッタリの基板ができました。
&lt;img src=&#34;https://dotstud.io/img/blog/099/09_rgb_led.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;

&lt;p&gt;マイコン内蔵RGB LEDは先述の通り足が4本あり、電源（VDD）とグラウンド（GND）に加えて、制御信号の入出力（DIN・DO）があります。DIN・DOは図のように数珠つなぎで配線します。
&lt;img src=&#34;https://dotstud.io/img/blog/099/10_rgb_led2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;電源とグラウンドは共通で、それぞれESPr® DeveloperのVOUTとGNDに接続します。大元のDINはPIN4に接続します。&lt;/p&gt;

&lt;h3 id=&#34;遅延情報の取得ロジック&#34;&gt;遅延情報の取得ロジック&lt;/h3&gt;

&lt;p&gt;WebAPI等は使用せずに、10分に一度、&lt;a href=&#34;http://unkou.keikyu.co.jp/&#34;&gt;京急の運行情報ページ&lt;/a&gt;にアクセスして情報を取得します。&lt;/p&gt;

&lt;p&gt;ESPr® Developerから運行情報の文言をHTTP-GETで取得して、その文言に&lt;strong&gt;特定の文字列&lt;/strong&gt;が含まれるかどうかで運行状態を推測します。具体的には・・・&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「&lt;strong&gt;受託&lt;/strong&gt;」という文字列が含まれていたら、他社線からの振替輸送受託のために遅延していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;見合わせ&lt;/strong&gt;」という文字列が含まれていたら、運転見合わせが発生していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;乱れ&lt;/strong&gt;」という文字列が含まれていたら、ダイヤが大幅に乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;遅れ&lt;/strong&gt;」や「&lt;strong&gt;運休&lt;/strong&gt;」が含まれていたら、ダイヤが少し乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;平常&lt;/strong&gt;」が含まれていたら、平常運転であると判断する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このような感じです。そして、運転見合わせであれば赤い点滅、ダイヤが少し乱れているときは黄色い点滅をさせるといった感じで、運行状態に応じてマイコン内蔵RGB LEDの光り方を変えることで、運行状態をひと目で把握することができます。&lt;/p&gt;

&lt;p&gt;ちなみに、他社線からの振替輸送受託が理由で京急が遅延しているときは、個人的にすこし残念な気持ちになるので、光り方を変えています（笑）&lt;/p&gt;

&lt;h3 id=&#34;espr-developerのコーディング&#34;&gt;ESPr® Developerのコーディング&lt;/h3&gt;

&lt;p&gt;かなり無理矢理ですが、こんな感じでコーディングしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;ESP8266WiFi.h&amp;gt;
#include &amp;lt;WiFiClient.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;

#define PIN 4 // DINを接続しているPIN
#define NUMLED 4 // マイコン内蔵RGB LEDの個数
#define SSID &amp;quot;（Wi-FiアクセスポイントのSSID）&amp;quot;
#define PASSWORD &amp;quot;（Wi-Fiアクセスポイントのパスワード）&amp;quot;
#define KEIKYU_PAGE &amp;quot;unkou.keikyu.co.jp&amp;quot; // 運行情報のページ
#define INTERVAL_SEC 10 * 60 // ポーリング間隔

Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMLED, PIN, NEO_RGB + NEO_KHZ800);

void setup() {
  // Serialの初期化
  Serial.begin(115200);
  Serial.println(&amp;quot;&amp;quot;);

  // マイコン内蔵RGB LEDの初期化
  pixels.begin();
}

void loop() {
  // Wi-Fi接続開始
  connectWifi();

  // 京急の運行ページから運行情報取得
  String trainInfo = getTrainInfo();

  // Wi-Fi接続終了
  disconnectWifi();

  // 「受託」という文字が含まれていたら、他社からの振替輸送受託で遅延していると判断
  if (trainInfo.indexOf(&amp;quot;受託&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;振替輸送受託！&amp;quot;);
    blinkLikePartyPeople(INTERVAL_SEC);
    return;
  }

  // 「見合わせ」という文字が含まれていたら、運転見合わせが発生していると判断
  if (trainInfo.indexOf(&amp;quot;見合わせ&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;運転見合わせ！&amp;quot;);
    blinkRed(INTERVAL_SEC);
    return;
  }

  // 「乱れ」という文字が含まれていたら、ダイヤが大幅に乱れていると判断
  if (trainInfo.indexOf(&amp;quot;乱れ&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;大幅に乱れている！&amp;quot;);
    blinkYellowAndRed(INTERVAL_SEC);
    return;
  }

  // 「遅れ」「運休」という文字が含まれていたら、ダイヤが少し乱れていると判断
  if (trainInfo.indexOf(&amp;quot;遅れ&amp;quot;) &amp;gt; 0 || trainInfo.indexOf(&amp;quot;運休&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;遅延！&amp;quot;);
    blinkYellow(INTERVAL_SEC);
    return;
  }

  // 「平常」という文字が含まれていたら、平常運転をしていると判断
  if (trainInfo.indexOf(&amp;quot;平常&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;たぶん平常通り運転！&amp;quot;);
    delay(INTERVAL_SEC * 1000);
    return;
  }

  // 運行情報取得エラーかもしれないので、10秒待ってもう一度取得する
  blinkWhite(10);
}

// Wi-Fi接続
void connectWifi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASSWORD);

  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(&amp;quot;.&amp;quot;);
    blinkWhite(3);
  }

  Serial.println(&amp;quot;Wi-Fi接続完了&amp;quot;);
}

// Wi-Fi切断
void disconnectWifi() {
  WiFi.disconnect();
  Serial.println(&amp;quot;Wi-Fi切断完了&amp;quot;);
}

// 運行情報の文字列取得
String getTrainInfo() {
  WiFiClient client;

  if ( !client.connect(KEIKYU_PAGE, 80) ) {
    // 接続エラー
    return String(&amp;quot;&amp;quot;);
  }

  // HTTP-GET
  // レスポンスのLengthが長すぎるとエラーになることがあったのでRangeを指定している
  client.print(String(&amp;quot;GET &amp;quot;) + &amp;quot;/&amp;quot; + &amp;quot; HTTP/1.1\r\n&amp;quot; +
               &amp;quot;Host: &amp;quot; + KEIKYU_PAGE + &amp;quot;\r\n&amp;quot; +
               &amp;quot;Range: bytes=8000-9000\r\n&amp;quot; +
               &amp;quot;Connection: close\r\n\r\n&amp;quot;);
  client.println();

  delay(1000);

  String body = &amp;quot;&amp;quot;;
  String trainInfo = &amp;quot;&amp;lt;!-- ======================== 運行情報 =================================== --&amp;gt;&amp;quot;;

  while (client.available()) {
    body += client.readStringUntil(&#39;\r&#39;);
  }

  // レスポンスから運行情報部分だけを切り抜く
  body = body.substring(body.indexOf(trainInfo) + trainInfo.length());
  body = body.substring(0, body.indexOf(trainInfo));

  return body;
}

// 白い点滅
void blinkWhite(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, i);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, i);
    }

    count++;
  }
}

//　黄色い点滅
void blinkYellow(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, 0);
    }

    count++;
  }
}

// 黄色と赤の点滅
void blinkYellowAndRed(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, 0, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, 0, 0);
    }

    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, 0);
    }

    count++;
    count++;
  }
}

// 赤い点滅
void blinkRed(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, 0, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, 0, 0);
    }

    count++;
  }
}

// パリピな輝き
void blinkLikePartyPeople(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 20; i++) {
      setRandomColor();
      delay(50);
    }

    count++;
  }
}

// LEDを指定した色で光らせる
void setColor(int r, int g, int b) {
  for (int i = 0 ; i &amp;lt; NUMLED; i++) {
    pixels.setPixelColor(i, pixels.Color(r, g, b));
    pixels.show();
  }
  delay(10);
}

// LEDをランダムな色で光らせる
void setRandomColor() {
  for (int i = 0 ; i &amp;lt; NUMLED; i++) {
    pixels.setPixelColor(i, pixels.Color(64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 ));
    pixels.show();
  }
  delay(10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際に光らせてみたのがこちら。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/11_setting.png&#34; alt=&#34;画像&#34; /&gt;
情報取得中に実行される白い点滅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/12_late.png&#34; alt=&#34;画像&#34; /&gt;
運転見合わせ時に実行される赤い点滅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/13_transport.png&#34; alt=&#34;画像&#34; /&gt;
最後は他社線からの振替輸送受託時に実行されるパリピ点滅。画像では少しわかりづらいですね……。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は、京急が遅延していると光るガジェットをESPr® Developerをつかって作成しました。情報の取得方法はかなり力技でしたが、WEB上の情報を簡単に可視化できたことは良かったです。&lt;/p&gt;

&lt;p&gt;実際にこのガジェットは、職場のデスクで稼働していて、いつも京急の運行情報を知らせてくれます。今後は他社線バージョンの作成を検討しています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>電子工作でパリピな夏を独り占め！サイバーパンク大五郎！！</title>
      <link>https://dotstud.io/blog/gyaruden-party-people-daigoro/</link>
      <pubDate>Thu, 08 Jun 2017 20:03:04 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-party-people-daigoro/</guid>
      
      <description>

&lt;p&gt;はじめまして、ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案する電子工作ユニット、ギャル電で活動しておりまっす。夢はドンキでアルドゥイーノが買える世の中です。&lt;/p&gt;

&lt;p&gt;この記事では、&lt;strong&gt;”Lチカ以上、IoT未満”&lt;/strong&gt; な電子工作テクニックでも楽しく作れてすぐに遊べるアイテムを紹介していきたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;今回の工作は夏フェスでパリピにめっちゃモテるやつ&#34;&gt;今回の工作は夏フェスでパリピにめっちゃモテるやつ！&lt;/h2&gt;

&lt;p&gt;夏といえば、夏フェス！夏フェスといえばパリピ！パリピといえば酒！！！です。&lt;/p&gt;

&lt;p&gt;ということで、今回はパリピに激モテな電子工作、&lt;strong&gt;甲類焼酎大五郎４ℓペットボトル&lt;/strong&gt;を作ってみました。&lt;/p&gt;

&lt;h2 id=&#34;なぜ大五郎なのか&#34;&gt;なぜ大五郎なのか&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/1.png&#34; alt=&#34;&#34; /&gt;
渋谷の街を歩いていたらセンター街で片手にスマホ、片手に4ℓの大五郎（半分減ってる）をもっているギャルをみかけました。&lt;/p&gt;

&lt;p&gt;デニムのショーパンにベアトップ、そして大五郎。強めギャルファッションにこんなにも大五郎がジャストフィットしていてエモさしかありませんでした。&lt;/p&gt;

&lt;p&gt;このエモさにさらにLEDを加えたら、絶対に最高なものができる！光る大五郎とか超未来！！なんでみんな光らせないわけ？！超機会損失してる！！！！&lt;/p&gt;

&lt;p&gt;ないなら今すぐ作るしかない！というわけで、とりあえず大五郎を光らせることにしたのです。&lt;/p&gt;

&lt;h2 id=&#34;とりあえず光らす方法&#34;&gt;とりあえず光らす方法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;材料&#34;&gt;材料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モバイルバッテリー&lt;/li&gt;
&lt;li&gt;LEDテープ（WS2812B）&lt;/li&gt;
&lt;li&gt;MicroUSBケーブル&lt;/li&gt;
&lt;li&gt;ArduinoまたはArduino互換機（今回はGR-CITRUSとAdafruit Trinket５Vを使用しました）&lt;/li&gt;
&lt;li&gt;ジャンパワイヤと電線&lt;/li&gt;
&lt;li&gt;ブレッドボード&lt;/li&gt;
&lt;li&gt;両面テープ&lt;/li&gt;
&lt;li&gt;ダクトテープ&lt;/li&gt;
&lt;li&gt;大五郎4ℓ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボードについては、わたしは小さくてUSBケーブルを差す口がもともとついているやつが好みなので、今回は&lt;strong&gt;GR-CITRUS&lt;/strong&gt;と&lt;strong&gt;Adafruit Trinket５V&lt;/strong&gt;を使ってみました。USBケーブルの口が付いたボードは、モバイルバッテリーをつなげば動くのでめっちゃ便利です。&lt;/p&gt;

&lt;p&gt;環境導入については、ボードの名前と自分の使っているPCのOSのバージョン（Windows XXとかMac OS XXとか）でググるとだいたい親切な先人の情報がみつかると思いまっす。&lt;/p&gt;

&lt;h3 id=&#34;配線は3本だからそんなに難しくない&#34;&gt;配線は3本だからそんなに難しくない&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/3.png&#34; alt=&#34;&#34; /&gt;
NeoPixel LEDテープ（WS2812B）は、GND、５V、信号（D0）の三本の線をそれぞれArduino（または互換機）のGND、５V、デジタルピンにつなぐと光らせることができます。&lt;/p&gt;

&lt;p&gt;今回の光る大五郎のように、底面とハンドルの部分だけLEDを使いたい場合は、LEDテープを光らせたい部分の長さに切ってテープとテープの間を電線で3本つなぎなおしたらオッケーです。&lt;/p&gt;

&lt;p&gt;配線に必要な電線の長さは、適当に実物において測りました。仮置きするときはマスキングテープで貼るとやりやすいです。&lt;/p&gt;

&lt;h3 id=&#34;ledを光らせるプログラムを入れる&#34;&gt;LEDを光らせるプログラムを入れる&lt;/h3&gt;

&lt;h4 id=&#34;gr-citrus&#34;&gt;GR-CITRUS&lt;/h4&gt;

&lt;p&gt;GR-CITRUSはWebコンパイラを使ってブラウザでスケッチを作成することができます。詳しい書き込み方法は下記を参照してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;http://gadget.renesas.com/ja/product/citrus_sp2.html&#34;&gt;GR-CITRUS 特設Webコンパイラでスケッチ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Adafruit_NeoPixcel.cpp&lt;/code&gt;と&lt;code&gt;Adafruit_NeoPixel.h&lt;/code&gt;の二つのファイルを下記ページからダウンロードして、GR-CITRUSで作成したプロジェクトにアップロードする必要があります。（Webコンパイラ使用時）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/adafruit/Adafruit_NeoPixel&#34;&gt;https://github.com/adafruit/Adafruit_NeoPixel&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Arduino.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#ifdef __AVR__
  #include &amp;lt;avr/power.h&amp;gt;
#endif

//neopixcel用の設定部分
//neopixelを接続するPINを設定
#define PIN_LED 12
//neopixelのLEDの数を設定
#define NUM_LEDS 12

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN_LED, NEO_GRB + NEO_KHZ800);

bool oldState = HIGH;
int showType = 0;

void showStrip() {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.show();
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   FastLED.show();
 #endif
}

void setPixel(int Pixel, byte red, byte green, byte blue) {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.setPixelColor(Pixel, strip.Color(red, green, blue));
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   leds[Pixel].r = red;
   leds[Pixel].g = green;
   leds[Pixel].b = blue;
 #endif
}

void setAll(byte red, byte green, byte blue) {
  for(int i = 0; i &amp;lt; 17; i++ ) {
    setPixel(i, red, green, blue);
  }
  showStrip();
}

// ここからNeoPixelのアニメーション設定


void FadeInOut(byte red, byte green, byte blue){
  float r, g, b;

  for(int k = 0; k &amp;lt; 256; k=k+1) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }

  for(int k = 255; k &amp;gt;= 0; k=k-2) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }
}


void Strobe(byte red, byte green, byte blue, int StrobeCount, int FlashDelay, int EndPause){
  for(int j = 0; j &amp;lt; StrobeCount; j++) {
    setAll(red,green,blue);
    showStrip();
    delay(FlashDelay);
    setAll(0,0,0);
    showStrip();
    delay(FlashDelay);
  }

 delay(EndPause);
}


void Sparkle(byte red, byte green, byte blue, int SpeedDelay) {
  int Pixel = random(NUM_LEDS);
  setPixel(Pixel,red,green,blue);
  showStrip();
  delay(SpeedDelay);
  setPixel(Pixel,0,0,0);
}

void RunningLights(byte red, byte green, byte blue, int WaveDelay) {
  int Position=0;

  for(int i=0; i&amp;lt;NUM_LEDS*2; i++)
  {
      Position++; // = 0; //Position + Rate;
      for(int i=0; i&amp;lt;NUM_LEDS; i++) {
        // sine wave, 3 offset waves make a rainbow!
        //float level = sin(i+Position) * 127 + 128;
        //setPixel(i,level,0,0);
        //float level = sin(i+Position) * 127 + 128;
        setPixel(i,((sin(i+Position) * 127 + 128)/255)*red,
                   ((sin(i+Position) * 127 + 128)/255)*green,
                   ((sin(i+Position) * 127 + 128)/255)*blue);
      }

      showStrip();
      delay(WaveDelay);
  }
}

byte * Wheel(byte WheelPos) {
  static byte c[3];

  if(WheelPos &amp;lt; 85) {
   c[0]=WheelPos * 3;
   c[1]=255 - WheelPos * 3;
   c[2]=0;
  } else if(WheelPos &amp;lt; 170) {
   WheelPos -= 85;
   c[0]=255 - WheelPos * 3;
   c[1]=0;
   c[2]=WheelPos * 3;
  } else {
   WheelPos -= 170;
   c[0]=0;
   c[1]=WheelPos * 3;
   c[2]=255 - WheelPos * 3;
  }

  return c;
}


void rainbowCycle(int SpeedDelay) {
  byte *c;
  uint16_t i, j;

  for(j=0; j&amp;lt;256*5; j++) { // 5 cycles of all colors on wheel
    for(i=0; i&amp;lt; NUM_LEDS; i++) {
      c=Wheel(((i * 256 / NUM_LEDS) + j) &amp;amp; 255);
      setPixel(i, *c, *(c+1), *(c+2));
    }
    showStrip();
    delay(SpeedDelay);
  }
}


void Twinkle(byte red, byte green, byte blue, int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),red,green,blue);
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}
void TwinkleRandom(int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),random(0,255),random(0,255),random(0,255));
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}

void setup()
{
    pinMode(PIN_LED0, OUTPUT);
    digitalWrite(PIN_LED, LOW);
   #if defined (__AVR_ATtiny85__)
   if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  strip.begin();
  strip.show();
}

void loop()
{
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    Twinkle(0xff, 40, 99, 10, 50, false);
    Twinkle(0xff, 40, 99, 10, 50, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    RunningLights(0x26,0xFF,0x7D, 50);
   RunningLights(0x26,0xFF,0x7D, 50);
    RunningLights(0x26,0xFF,0x7D, 50);
    RunningLights(0xDD,0xFF,0x33, 50);
     RunningLights(0xDD,0xFF,0x33, 50);
      RunningLights(0xDD,0xFF,0x33, 50);
    RunningLights(0xFF,0xAE,0x0D, 50);
    RunningLights(0xFF,0xAE,0x0D, 50);
    RunningLights(0xFF,0xAE,0x0D, 50);
    RunningLights(0xFF,0x21,0x21, 50);
    RunningLights(0xFF,0x21,0x21, 50);
    RunningLights(0xFF,0x21,0x21, 50);
    RunningLights(0xFF,0x54,0x93, 50);
    RunningLights(0xFF,0x54,0x93, 50);
    RunningLights(0xFF,0x54,0x93, 50);
    RunningLights(0x7A,0x7F,0xFF, 50);
    RunningLights(0x7A,0x7F,0xFF, 50);
    RunningLights(0x7A,0x7F,0xFF, 50);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    rainbowCycle(20);

  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;adafruit-trinket&#34;&gt;Adafruit Trinket&lt;/h4&gt;

&lt;p&gt;TrinketはArduino IDEでスケッチを作成し書き込みます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://learn.adafruit.com/introducing-trinket&#34;&gt;Introduction Trinket&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#ifdef __AVR__
  #include &amp;lt;avr/power.h&amp;gt;
#endif

//neopixcel用の設定部分

//neopixelを接続するPINを設定
#define PIN_LED 4

//neopixelのLEDの数を設定
#define NUM_LEDS 12

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN_LED, NEO_GRB + NEO_KHZ800);

bool oldState = HIGH;
int showType = 0;

void showStrip() {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.show();
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   FastLED.show();
 #endif
}

void setPixel(int Pixel, byte red, byte green, byte blue) {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.setPixelColor(Pixel, strip.Color(red, green, blue));
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   leds[Pixel].r = red;
   leds[Pixel].g = green;
   leds[Pixel].b = blue;
 #endif
}

void setAll(byte red, byte green, byte blue) {
  for(int i = 0; i &amp;lt; 17; i++ ) {
    setPixel(i, red, green, blue);
  }
  showStrip();
}

// ここからNeoPixelのアニメーション設定


void FadeInOut(byte red, byte green, byte blue){
  float r, g, b;

  for(int k = 0; k &amp;lt; 256; k=k+1) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }

  for(int k = 255; k &amp;gt;= 0; k=k-2) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }
}

void Strobe(byte red, byte green, byte blue, int StrobeCount, int FlashDelay, int EndPause){
  for(int j = 0; j &amp;lt; StrobeCount; j++) {
    setAll(red,green,blue);
    showStrip();
    delay(FlashDelay);
    setAll(0,0,0);
    showStrip();
    delay(FlashDelay);
  }

 delay(EndPause);
}

void Twinkle(byte red, byte green, byte blue, int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),red,green,blue);
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}
void TwinkleRandom(int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),random(0,255),random(0,255),random(0,255));
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}

//

void setup()
{
    pinMode(PIN_LED, OUTPUT);
    digitalWrite(PIN_LED, LOW);
   #if defined (__AVR_ATtiny85__)

   if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  strip.begin();
  strip.show();
}

void loop()
{
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    Twinkle(0xff, 40, 99, 10, 50, false);
    Twinkle(0xff, 40, 99, 10, 50, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TrinketはGR-CITRUS用に書いたコードをコピペしたらスケッチが大きすぎ！って怒られたのでだいぶコードを削りました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/4.png&#34; alt=&#34;&#34; /&gt;
配線のはんだ付けと動作テストが終わったら、ダクトテープで部品を大五郎に貼り付けます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/5.png&#34; alt=&#34;&#34; /&gt;
大五郎の背面に貼り付けられたバッテリーとボード、LEDテープ類。ダクトテープと両面テープがあればなんでも貼り付けられて超便利です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一般的には不審物としかいいようのない見た目&lt;/strong&gt;のため、電車や駅のトイレ等の公共の場所への置き忘れは要注意です。&lt;/p&gt;

&lt;h2 id=&#34;実際にパーティで大五郎を光らせてみよう&#34;&gt;実際にパーティで大五郎を光らせてみよう！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/6.png&#34; alt=&#34;&#34; /&gt;
作成した光る大五郎をさっそく現場(パーティ)に投入してみました。&lt;/p&gt;

&lt;p&gt;結果、&lt;strong&gt;最＆高&lt;/strong&gt;！！！！！&lt;/p&gt;

&lt;p&gt;暗いところで幻想的に光る大五郎は、インテリアとしても飲み物としても威力を発揮し新しいパーティアイテムとして流行る予感しかありませんでした。&lt;/p&gt;

&lt;p&gt;残念ながら盛り上がって飲みすぎたため、写真があまり残っていません……。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4ℓはなかなかに重い&lt;/strong&gt;ということと、&lt;strong&gt;酔っぱらったパリピにブレッドボードから配線を抜かれがち&lt;/strong&gt;ということ以外には特に問題なく使用できました。&lt;/p&gt;

&lt;p&gt;飲み終わったら、ダクトテープをはがして新しい大五郎にLEDユニットを貼るスタイルでいつでも光る大五郎が楽しめるので、改良してまた新たなパーティに出かけようと思います。&lt;/p&gt;

&lt;p&gt;みんなもさっそく作ってパーティにでかけちゃおう！パリピに超モテるよ☆&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wio NodeとIFTTTで簡単IoT！紫外線情報を取得してみよう</title>
      <link>https://dotstud.io/blog/wionode-ifttt-uv-ornament/</link>
      <pubDate>Tue, 06 Jun 2017 20:26:13 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/wionode-ifttt-uv-ornament/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioライターのゆっきん（&lt;a href=&#34;https://twitter.com/yukkin4649&#34;&gt;@yukkin4649&lt;/a&gt;）です。普段はシステムエンジニアをしています！&lt;/p&gt;

&lt;p&gt;IoTLTでのびすけさんから「電子工作でかわいいもの作ってくれ」という無茶ぶりを受けたので（笑）、女子の天敵&lt;strong&gt;紫外線指数を光って知らせてくれるオーナメント&lt;/strong&gt;を作ってみます！&lt;/p&gt;

&lt;p&gt;今回は「Wio Node」というスマホから設定できるデバイスと、ノンプログラミングでサービス連携ができる「IFTTT」というWebサービスを使います。初心者の私でも簡単にできたので是非挑戦してみてください。&lt;/p&gt;

&lt;h2 id=&#34;wio-nodeとは&#34;&gt;Wio Nodeとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/wio.png&#34; alt=&#34;&#34; /&gt;
「Wio Node」とはSeeed Studio社が開発したIoTデバイスで、Wi-Fiモジュールが初期搭載されています。対応のモジュールをさすだけで使え、スマートフォンで設定できるシンプルな設計が特徴です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.seeedstudio.com/Wio-Node-p-2637.html&#34;&gt;公式サイト&lt;/a&gt;によると&lt;strong&gt;IoTアプリケーション構築までたったの５分&lt;/strong&gt;だそうです。如何に簡単にできるのかが伺えます。&lt;/p&gt;

&lt;h2 id=&#34;iftttとは&#34;&gt;IFTTTとは&lt;/h2&gt;

&lt;p&gt;「IFTTT」では多数あるWebサービス同士を連携させ、自分好みの連携機能を作成することが出来ます。例えば【&lt;strong&gt;Twitterでお気に入りしたツイートをEvernoteに保存する&lt;/strong&gt;】等があります。&lt;/p&gt;

&lt;p&gt;他の人が作成した連携（ここではレシピと呼ぶ）も利用することができ、カスタマイズも可能。今回はこの「IFTTT」を使って紫外線取得サービスとWio Nodeを連携します。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;① Wio Node本体（&lt;a href=&#34;https://dotstud.io/shop/wionode-social-remote-control/&#34;&gt;購入ページ&lt;/a&gt;）&lt;br /&gt;
② Grove LED Bar v2.0（型番：SEEED-104020006）&lt;br /&gt;
③給電用のMicro USBケーブル&lt;br /&gt;
④ スマートフォン（iOSまたはAndroid端末）&lt;br /&gt;
⑤ グリーンオーナメント SS（100円均一で購入）&lt;br /&gt;
⑥ 紙&lt;br /&gt;
⑦ テープ&lt;br /&gt;
⑧ ペン&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Air 11-inch Early 2014&lt;/li&gt;
&lt;li&gt;OS X El Capitan　v10.11.6&lt;/li&gt;
&lt;li&gt;iPhone6（iOS 10.3.1）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/2.png&#34; alt=&#34;&#34; /&gt;
ざっくりとした構成です。IFTTTを使って「Today&amp;rsquo;s weather report」からUV値を取得し、Wio NodeのLED Barで表示させます。&lt;/p&gt;

&lt;p&gt;それでは早速作っていきましょう。&lt;/p&gt;

&lt;h3 id=&#34;1-wio-nodeの設定&#34;&gt;1. Wio Nodeの設定&lt;/h3&gt;

&lt;h4 id=&#34;インストールとセットアップ&#34;&gt;インストールとセットアップ&lt;/h4&gt;

&lt;p&gt;ここではWio Node開発用アプリのインストールと設定をしていきます。Wio NodeはPC・モバイルバッテリー等からUSBケーブルで接続し給電しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/3.png&#34; alt=&#34;&#34; /&gt;
App Store等でWio Nodeアプリを検索し、インストールします。iOSでは「Wio Link」、Androidでは「Wio」と言う名称です。&lt;/p&gt;

&lt;p&gt;本記事ではiOSの「Wio Link」の画面で説明していきます。&lt;/p&gt;

&lt;p&gt;iOS: &lt;a href=&#34;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&#34;&gt;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&lt;/a&gt;&lt;br /&gt;
Android: &lt;a href=&#34;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&#34;&gt;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/4.png&#34; alt=&#34;&#34; /&gt;
インストール後、アプリを立ち上げるとログイン画面が表示されるので〔SIGN UP〕のタブに切り替えてメールアドレスとパスワードを入力し〔SIGN UP〕のボタンを押下します。２回目以降は〔LOG IN〕タブから登録した情報を入力してログインして下さい。&lt;/p&gt;

&lt;p&gt;※他のサービスと連携が上手くいかないこともあるのでGoogleアカウントやFacebookアカウントの連携によるユーザー登録は非推奨とします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/5.png&#34; alt=&#34;&#34; /&gt;
Device Listの画面が表示されたら、右上の〔+〕又は中央の〔Add Your First Device〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/6.png&#34; alt=&#34;&#34; /&gt;
デバイスの選択画面が表示されるので〔Wio Node〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/7.png&#34; alt=&#34;&#34; /&gt;
セットアップ画面の図と同様にWio Node本体のボタンを４秒程押下します。青いライトの光り方が変わることを確認後、次の手順に移ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/8.png&#34; alt=&#34;&#34; /&gt;
iPhoneの〔設定〕アプリを起動します。〔Wi-Fi〕設定画面でWi-FiをONにし、〔Wio_XXXXXX〕を選択します。XXXXXXには割り当てられた文字列が入ります。（Android版はアプリの画面内で選択します。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/9.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeアプリに戻り、〔Goto wifi list〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/10.png&#34; alt=&#34;&#34; /&gt;
現在利用できる任意のWi-Fiを選択します。表示されない場合は右上の〔Refresh〕を押下して下さい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/11.png&#34; alt=&#34;&#34; /&gt;
選択したWi-Fiのパスワードを入力し、〔Join〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/12.png&#34; alt=&#34;&#34; /&gt;
この画面では、デバイスの名前をつけます。任意の名前を入力し、〔Start Wio-ing〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/13.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeが認識され、モジュールの設定画面に移りました。最初のセットアップは以上です。&lt;/p&gt;

&lt;p&gt;もしセットアップが上手くいかない場合は&lt;a href=&#34;https://dotstud.io/docs/wionode-wiosetup/&#34;&gt;こちら&lt;/a&gt;からセットアップしてみてください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;モジュールの設定&#34;&gt;モジュールの設定&lt;/h4&gt;

&lt;p&gt;続いて今回使うモジュールを設定していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/106/14.png&#34; alt=&#34;&#34; /&gt;
次にLED Barを取り付けます。Wio Node本体を画面と同じ向きに見た時、左側（PORT0）にLED Barを接続します。アプリ画面では、〔UART〕タブの〔LED Bar〕を選択し、〔Update Firmware〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/15.png&#34; alt=&#34;&#34; /&gt;
〔OK〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/16.png&#34; alt=&#34;&#34; /&gt;
設定が完了すると〔View API〕というリンクが表示されます。&lt;/p&gt;

&lt;p&gt;APIを試してみましょう。〔View API〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;apiを試してみる&#34;&gt;APIを試してみる&lt;/h4&gt;

&lt;p&gt;View APIのページではあらかじめ用意されているAPIを使ってWio Nodeとモジュールの挙動を試すことができます。
&lt;img src=&#34;https://dotstud.io/img/blog/106/17.png&#34; alt=&#34;&#34; /&gt;
今回利用する〔level〕APIの〔Test Request〕に「10」と入力します。〔GET〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/led.png&#34; alt=&#34;&#34; /&gt;
LED Barが10個すべて光りました！数値を変えると光るBarの個数が変わります。&lt;/p&gt;

&lt;p&gt;モジュールの設定は以上です。&lt;/p&gt;

&lt;h3 id=&#34;2-iftttの設定&#34;&gt;2. IFTTTの設定&lt;/h3&gt;

&lt;h4 id=&#34;インストールとセットアップ-1&#34;&gt;インストールとセットアップ&lt;/h4&gt;

&lt;p&gt;次にIFTTT側の設定をしていきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/18.png&#34; alt=&#34;&#34; /&gt;
最初にIFTTTのアプリをダウンロードします。&lt;strong&gt;ブラウザから設定する場合はアプリのインストールは不要&lt;/strong&gt;です。ブラウザで「IFTTT」を検索してIFTTTの画面に遷移してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/19.png&#34; alt=&#34;&#34; /&gt;
ダウンロード後、アプリを起動します。アカウントを持っていない場合は、〔Sign up〕を押下します。アカウントを既に取得している場合は、〔Sign in〕を押下してログインしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/20.png&#34; alt=&#34;&#34; /&gt;
アカウントを新規登録する場合はメールアドレスと任意のパスワードを入力し、〔Sign up〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;レシピを作成する&#34;&gt;レシピを作成する&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/21.png&#34; alt=&#34;&#34; /&gt;
それでは早速レシピを作ってみましょう。〔My Applets〕に移動し、右上の〔＋〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/22.png&#34; alt=&#34;&#34; /&gt;
IFTTTでは「if this then that」という構文を使って、サービスを連携させていきます。熊本弁で言うと「こぎゃん（こう）したら、あぎゃん（ああ）なる」みたいな感じです。&lt;/p&gt;

&lt;p&gt;まずは「こうしたら」のトリガー部分を作っていきましょう。最初に〔this〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/23.png&#34; alt=&#34;&#34; /&gt;
IFTTTでは連携に利用できるWebサービスのことをチャンネルと言います。&lt;/p&gt;

&lt;p&gt;トリガーとして利用できるチャンネルが表示されるので、「Wether Underground」チャンネルを検索し、選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/24.png&#34; alt=&#34;&#34; /&gt;
「Wether Underground」で利用できるトリガーの一覧が表示されます。今回は〔Today&amp;rsquo;s weather report〕を使うので、選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/25.png&#34; alt=&#34;&#34; /&gt;
「Today&amp;rsquo;s weather report」は今日の現在の天気情報を取得できます。この画面では取得する時間を設定します。好きな時間に設定してください。&lt;/p&gt;

&lt;p&gt;私の場合は昼休みで外に出る時の時間を設定しました。&lt;/p&gt;

&lt;p&gt;続いて「こうなる」の部分を作ります。
&lt;img src=&#34;https://dotstud.io/img/blog/106/26.png&#34; alt=&#34;&#34; /&gt;
「if this then that」の〔that〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/27.png&#34; alt=&#34;&#34; /&gt;
アクション（発動条件を満たした後の動作）として利用できるチャンネルが表示されます。〔Search services〕に「seeed」と入力して検索しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/28.png&#34; alt=&#34;&#34; /&gt;
「Seeed」チャンネルを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/29.png&#34; alt=&#34;&#34; /&gt;
〔connect〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/30.png&#34; alt=&#34;&#34; /&gt;
アカウント設定画面が表示されます。ここにWio Nodeで設定したアカウント情報を入力し、〔Sign in〕を押下します。&lt;/p&gt;

&lt;p&gt;Wio Node側でGoogleやFacebook連携でログインしていて上手く連携できない場合は、Wio Nodeのアプリからメールアドレスで登録しなおしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/31.png&#34; alt=&#34;&#34; /&gt;
「Seeed」チャンネルで利用できるアクションの一覧が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/32.png&#34; alt=&#34;&#34; /&gt;
一覧の下の方にある〔Drive any Grove〕を選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/33.png&#34; alt=&#34;&#34; /&gt;
詳細設定をしていきます。functionを選択するプルダウンでは〔level（float level）〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/34.png&#34; alt=&#34;&#34; /&gt;
次にFirst Parameterを設定します。〔Add Ingredient〕を押下すると、設定できる候補が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/35.png&#34; alt=&#34;&#34; /&gt;
今回取得するのはUV値なので〔UVindex〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/36.png&#34; alt=&#34;&#34; /&gt;
〔Next〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/37.png&#34; alt=&#34;&#34; /&gt;
タイトルが自動生成されるので、変更する場合は〔Edit title〕から編集します。最後に〔Finish〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/38.png&#34; alt=&#34;&#34; /&gt;
これでレシピは完成です！&lt;/p&gt;

&lt;h3 id=&#34;3-オーナメント作り&#34;&gt;3. オーナメント作り&lt;/h3&gt;

&lt;p&gt;最後に見せ方の部分である、オーナメント作りをしていきます。&lt;/p&gt;

&lt;p&gt;では、グリーンオーナメントにWio Nodeを巻いていきます。この時、一度Wio NodeからUSBケーブルを抜いておくと良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/39.png&#34; alt=&#34;&#34; /&gt;
購入したグリーンオーナメントにもよりますが、グリーンオーナメントの中の構成を把握してWio Nodeを取り付けるとコードが目立たないようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/40.png&#34; alt=&#34;&#34; /&gt;
今回の場合は、グリーンオーナメントの中心軸を避けたところにWio Nodeを設置し、コードを軸に這わせながら巻きつけていきます。巻きつけた後は、葉っぱでコードを隠します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/41.png&#34; alt=&#34;&#34; /&gt;
LEDもコードがなるべく見えないように周りの葉っぱで隠します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/42.png&#34; alt=&#34;&#34; /&gt;
次に目を用意します。自分の好きな目を書いてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/43.png&#34; alt=&#34;&#34; /&gt;
目を作成したら、グリーンオーナメントに装着します。両面テープや養生テープを使うと、目の位置等を簡単に変えられます。目の位置によって表情が変わるので好きな位置に取り付けましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/44.png&#34; alt=&#34;&#34; /&gt;
最後にUSBケーブルと接続します。オーナメントによりますが、USBケーブルに色が移ることもあるので気をつけてください。&lt;/p&gt;

&lt;p&gt;オーナメント作りはこれで完成です！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;カスタマイズ&#34;&gt;カスタマイズ&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/45.png&#34; alt=&#34;&#34; /&gt;
目だけでなく、ちょっとした花を付け加えるとより個性が出ます。色々試してみてください。&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;さて、一通り完成したので動作検証してみます。&lt;/p&gt;

&lt;p&gt;IFTTTの〔My Applets〕で自分の作成したアプレットが確認できます。今回はテストなので時間を12時45分にしました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/46.png&#34; alt=&#34;&#34; /&gt;
実行されるとIFTTTから通知が来ます。確認してみると正常に動いているようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/47.png&#34; alt=&#34;&#34; /&gt;
UVindexの値を確認すると「9」となっています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/48.png&#34; alt=&#34;&#34; /&gt;
LED Barは&amp;hellip;レベル9まで光っています！&lt;strong&gt;外に出る時は紫外線対策をしっかりしましょう！！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;p&gt;今回は「Wio Node」と「IFTTT」を使ってノンプログラミングでUV（紫外線）のレベルをLED Barで表示させました。初心者の方でも簡単にできたのではないでしょうか。「IFTTT」で取得する値を変えたりアクションを変えたりするともっと色んなことができそうですね。&lt;/p&gt;

&lt;p&gt;また、「IFTTT」で取得する値は0〜16ですが、現状は10以上の場合もLED Barは10までの表示です。これ以上細かい表示をする場合はプログラムを組んでみましょう。そちらの方も是非挑戦してみてください。&lt;/p&gt;

&lt;p&gt;最後まで読んで頂きありがとうございました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BTとIFTTTでスイッチを押したらLINEを送る仕組みを作ってみよう</title>
      <link>https://dotstud.io/blog/nefry-ifttt-push-line/</link>
      <pubDate>Thu, 18 May 2017 02:51:27 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-ifttt-push-line/</guid>
      
      <description>

&lt;p&gt;こんにちは。外部ライターのわみ（&lt;a href=&#34;https://twitter.com/wamisnet&#34;&gt;@wamisnet&lt;/a&gt;）です。Unirobot株式会社でロボットのソフトウェアエンジニアをやりながら、dotstudioでは私が作成しているIoTデバイス「Nefry」シリーズの販売やチュートリアル記事の執筆をしています。&lt;/p&gt;

&lt;p&gt;Nefryは、ユーザの皆様からのフィードバックを頂き成長しています。新たなWi-Fi・BLEモジュール「ESP-WROOM-32」の発売もあり、このたび&lt;strong&gt;新機能と改良を加えた次世代の「Nefry BT」を発表&lt;/strong&gt;する事になりました。&lt;/p&gt;

&lt;p&gt;今回は新しい「Nefry BT」を使って、Amazon Dash Buttonのようにスイッチを押した時にLINEに通知が行く仕組みを作ってみます。&lt;/p&gt;

&lt;h2 id=&#34;nefry-btとは&#34;&gt;Nefry BTとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/01_nefry.png&#34; alt=&#34;&#34; /&gt;
Nefryシリーズは、「&lt;strong&gt;簡単にインターネットにつながること&lt;/strong&gt;」をテーマにしたFRISKサイズのIoTデバイスです。Nefry BTからはWi-Fiに加えてBLE（Bluetooth Low Energy）に対応し、I/O機能も増えて開発の幅がさらに広がりました！&lt;/p&gt;

&lt;p&gt;ハードウェアをできるだけ意識しなくて済むよう設計され、はんだづけや複雑な接続なしで動かすことができるため、初めてハードウェアを触る方にオススメのデバイスです。&lt;/p&gt;

&lt;h2 id=&#34;作ってみる&#34;&gt;作ってみる&lt;/h2&gt;

&lt;p&gt;今回試す流れは以下です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IFTTTにレシピを作成する&lt;/li&gt;
&lt;li&gt;開発環境（Arduino IDE）を整える&lt;/li&gt;
&lt;li&gt;プログラムを書き込む&lt;/li&gt;
&lt;li&gt;Nefry BTとIFTTTを紐付ける&lt;/li&gt;
&lt;li&gt;スイッチを押してLINEにメッセージを送ってみる&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nefry BT&lt;/li&gt;
&lt;li&gt;IFTTTのアカウント&lt;/li&gt;
&lt;li&gt;LINEのアカウント&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nefry BT library Version 0.6.1&lt;/li&gt;
&lt;li&gt;Windows 10&lt;/li&gt;
&lt;li&gt;Arduino IDE 1.8.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;

&lt;p&gt;Nefry BTは開発中のため、実際のコードや画面と異なる可能性があります。&lt;/p&gt;

&lt;h3 id=&#34;iftttにレシピを作成する&#34;&gt;IFTTTにレシピを作成する&lt;/h3&gt;

&lt;p&gt;IFTTTは様々なWebサービス同士を簡単に連携できるサービスです。連携したものは「レシピ」と呼ばれ、自分で新しいレシピを作成することもできます。今回はNefry BTとLINEを連携するレシピを作ってみます。&lt;/p&gt;

&lt;p&gt;アカウントを持っていない場合は下記の記事を参考にアカウントを取得してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://liginc.co.jp/263899&#34;&gt;Webサービス同士を連携できる「IFTTT」と自作IoTデバイスを繋いで生活を便利にしてみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アカウントを取得したら、Nefry BTとLINEを連携させるレシピを登録していきましょう。&lt;/p&gt;

&lt;p&gt;IFTTTのレシピは「〇〇が起きたら△△する」というようにトリガーとアクションに分けられます。今回のトリガーは「&lt;strong&gt;Nefry BTのスイッチをクリックしたら&lt;/strong&gt;」、アクションは「&lt;strong&gt;LINEに通知する&lt;/strong&gt;」となります。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;トリガーとnefry-btを紐付けるキーの取得&#34;&gt;トリガーとNefry BTを紐付けるキーの取得&lt;/h4&gt;

&lt;p&gt;今回はトリガーとして自作のWebサービスを利用できる「Webhooks」を使います。&lt;/p&gt;

&lt;p&gt;まずはWebhooksをあとでNefry BTと紐付けるために、Secret Keyというキーを取得します。&lt;a href=&#34;https://ifttt.com/discover&#34;&gt;IFTTT公式サイト&lt;/a&gt;上部の「Search」から、Webhooksを検索しクリックしましょう。（&amp;rdquo;web&amp;rdquo;で候補に出てきます。）
&lt;img src=&#34;https://dotstud.io/img/blog/100/if1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;設定ページに移動しました。このとき初めての方はこのような認証画面が表示されます。ページ中央の「Connect」をクリックしてWebhooksを有効にしましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Settingをクリックし、移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アカウントごとに割り当てられるSecret KeyがURLのuse/以下に記載されているのでコピーしておきます。今回の例ではSecret Keyは &lt;code&gt;GnzpClq0nDwt4WEdTyTmt&lt;/code&gt; の部分です。（このSecret Keyはサンプルです。既に無効になっていますので自身で取得してください。）
&lt;img src=&#34;https://dotstud.io/img/blog/100/if4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;トリガーの作成&#34;&gt;トリガーの作成&lt;/h4&gt;

&lt;p&gt;続いてトリガーとなるWebhooksの詳細を作成します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/06_ifttt5.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://ifttt.com/create&#34;&gt;IFTTTのレシピ作成ページ&lt;/a&gt;から、「+this」のリンクをクリックします。&lt;/p&gt;

&lt;p&gt;「Choose a service」から再度Webhooksを検索しましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;WebhooksはEventという単位でトリガーとなります。今回はEvent Nameを&amp;rdquo;Nefry&amp;rdquo;とし、「Create trigger」をクリックし作成します。Event NameはあとでNefry BTにも同じ名前で入力します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;アクションの作成&#34;&gt;アクションの作成&lt;/h4&gt;

&lt;p&gt;最後に、トリガーが生じた時に起こすアクションを登録します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/09_ifttt8.png&#34; alt=&#34;&#34; /&gt;
「+that」のリンクをクリックして、検索欄からLINEを検索しましょう。ここでTwitterやGmailなどを選択すると、それぞれのサービスと連携させることが出来ます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/10_ifttt9.png&#34; alt=&#34;&#34; /&gt;
Recipientと書かれた欄にメッセージを送るLINEの送信先を選択します。&lt;/p&gt;

&lt;p&gt;Messageと書かれた欄には送信するメッセージを入力します。MessageのValueにはプログラムから値を渡すことができるので、温度センサや明るさセンサなどの値をメッセージに組み込むことが可能です。写真のURLがあれば写真を送信することもできます。&lt;/p&gt;

&lt;p&gt;入力が完了したら、Create actionをクリックして保存します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/11_ifttt10.png&#34; alt=&#34;&#34; /&gt;
最後にFinishを押し、IFTTTのレシピの作成は完了です。&lt;/p&gt;

&lt;h3 id=&#34;開発環境-arduino-ide-を整える&#34;&gt;開発環境（Arduino IDE）を整える&lt;/h3&gt;

&lt;p&gt;続いてNefy BTにプログラムを書く環境を整えます。プログラムの書き込みにはArduino IDEと呼ばれるエディタを使用します。&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;からダウンロードし、以下の手順でNefry BT用の設定を追加してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/12_program.png&#34; alt=&#34;&#34; /&gt;
Arduino IDEの「環境設定」のページから、「追加のボードマネージャのURL」に以下のリンクを入力して検索します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://nefry.studio/package_nefrybt_index.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;メニューバーの[ツール]から、[ボード] -&amp;gt; [ボードマネージャー]を選択します。選択肢に「Nefry by Nefry Community」が表示されているので、インストールします。
&lt;img src=&#34;https://dotstud.io/img/blog/100/13_library.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これでプログラムを書き込む準備が整いました。&lt;/p&gt;

&lt;h3 id=&#34;プログラムを書き込む&#34;&gt;プログラムを書き込む&lt;/h3&gt;

&lt;p&gt;以下はNefry BTに搭載されている「スイッチ」を押したときにIFTTTのEventを呼ぶプログラムです。&lt;/p&gt;

&lt;p&gt;Arduino IDEを開き、以下のコードを貼り付けます。（//以降の部分はコメントです。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp:&#34;&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;NefryIFTTT.h&amp;gt;
String Event, SecretKey;
int counter =0;                       //送信データのカウンタ

void setup() {
  Nefry.setStoreTitle(&amp;quot;SecretKey&amp;quot;,0); //Nefry DataStoreのタイトルを指定
  Nefry.setStoreTitle(&amp;quot;Event&amp;quot;,1);     //Nefry DataStoreのタイトルを指定
  SecretKey = Nefry.getStoreStr(0);   //Nefry DataStoreからデータを取得
  Event = Nefry.getStoreStr(1);       //Nefry DataStoreからデータを取得
  Nefry.enableSW();                   //SW有効化
}

void loop() {
  if (Nefry.readSW()) {               //SWを押した時
    counter++;                        //送信回数加算
    bool sendData = IFTTT.send(Event, SecretKey,&amp;quot;Nefry&amp;quot;,(String)(micros()/1000000)+&amp;quot;秒&amp;quot;,(String)counter);//IFTTTにデータを送信
                                      //Value1:Nefry,Value2:Nefryが起動してからの秒数,Value3:送信カウンタ
    if (!sendData) {//IFTTTにデータを送信が成功したか失敗したかの判定
      Nefry.setLed(255, 0, 0);        //Errの時、赤色点灯
    }
    Nefry.ndelay(1000);               //送信後1秒間待つ
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;貼り付けできたら[ツール] -&amp;gt; [ボード]から「Nefry BT」を選択します。Nefry BTとPCを繋ぎ、[ツール] -&amp;gt; [シリアルポート]でNefry BTのシリアルポートを選択しましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/14_arduinoide.png&#34; alt=&#34;&#34; /&gt;
ボードとシリアルポートを選んだらArduino IDEの左上にある「→」を押しプログラムを書き込みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/15_arduinoide2.png&#34; alt=&#34;&#34; /&gt;
「ボードへの書き込みが完了しました。」と表示されたら、Nefry BTへのプログラムの書き込みは完了です。&lt;/p&gt;

&lt;p&gt;最後にNefry BTにIFTTTとの連携情報を入力します。あと少しですので頑張っていきましょう！&lt;/p&gt;

&lt;h3 id=&#34;nefry-btとiftttを紐付ける&#34;&gt;Nefry BTとIFTTTを紐付ける&lt;/h3&gt;

&lt;p&gt;Nefry BTから&amp;rdquo;Nefry-OOOO&amp;rdquo;というWi-Fiの信号が発信されているので接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/16_wifi.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接続できたらChromeやIEなどのWebブラウザで&lt;a href=&#34;http://192.168.4.1&#34;&gt;Nefry BTのサイト&lt;/a&gt;にアクセスしましょう。&lt;code&gt;http://192.168.4.1&lt;/code&gt;にアクセスするとNefry BTの設定サイトが表示されます。このページからNefry BTに関する様々な設定ができます。
&lt;img src=&#34;https://dotstud.io/img/blog/100/17_nefry.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずは「Setup WiFi」をクリックし、Wi-Fiの設定をしましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/18_nefry.png&#34; alt=&#34;&#34; /&gt;
接続するWi-Fiを入力して「Save」をクリックすると、Nefry BTに設定を保存＆再起動します。Wi-Fiが切断したら再接続してください。&lt;/p&gt;

&lt;p&gt;設定が完了したら、トップページに戻り「Data Store」のページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/19_nefry.png&#34; alt=&#34;&#34; /&gt;
SecretKeyにはWebhooksで確認した値を、EventにはLINEと連携した際に入力したEvent Name（今回は”Nefry”）を入力します。Saveをクリックし値を保存するとNefry BTが再起動します。&lt;/p&gt;

&lt;p&gt;いよいよNefry BTについているスイッチを押してLINEにメッセージを送ってみましょう！&lt;/p&gt;

&lt;h3 id=&#34;スイッチを押してlineにメッセージを送ってみる&#34;&gt;スイッチを押してLINEにメッセージを送ってみる&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/20_nefry.gif&#34; alt=&#34;&#34; /&gt;
Nefry BTのスイッチを押すとLEDの色が変わり送信を始めます。送信が完了するとLEDが水色になり、LINEに通知されました！IFTTTのサーバ状態により応答が悪い場合もありますが、その時はIFTTTのページにてリロードをすると反応してくれます。&lt;/p&gt;

&lt;p&gt;初回は登録が多く時間がかかりますが、今後はサクっと作れるでしょう。&lt;/p&gt;

&lt;h2 id=&#34;さいごに&#34;&gt;さいごに&lt;/h2&gt;

&lt;p&gt;半田付けや複雑な設定なしで、ハードウェアをきっかけにしてLINEへメッセージを投稿する連携をサクッと試すことができました。今回紹介したNefry BTとIFTTTの連携を応用すればTwitterやGmailなどにもメッセージを送信できます。&lt;/p&gt;

&lt;p&gt;リアルタイム通信が得意な「Milkcocoa」やクラウドサービスMicrosoft AzureのIoT向け機能である「Azure IoT Hub」などを使うとより幅広い開発ができるでしょう。&lt;/p&gt;

&lt;p&gt;今後の更新で簡単に接続できるライブラリやサンプルコードを追加していく予定です。生まれたばかりでまだまだヒヨッコですが、進化していくNefry BTを応援していただけたらと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「Wio Node」で半田付けなしの電子工作！温度計作りでIoTはじめの一歩</title>
      <link>https://dotstud.io/blog/seeed-wionode-hands-on/</link>
      <pubDate>Fri, 21 Apr 2017 22:18:36 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/seeed-wionode-hands-on/</guid>
      
      <description>

&lt;p&gt;こんにちは、バックエンドエンジニアのちゃんとく（&lt;a href=&#34;https://twitter.com/tokutoku393&#34;&gt;@tokutoku393&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;今回は、難しいプログラミングや半田付けなしで簡単に試せる「Wio Node」を使って温度表示計を作ってみます！この記事は「&lt;strong&gt;&lt;a href=&#34;https://dotstudio.connpass.com/event/53388/&#34;&gt;WioNodeで始めよう！挫折しないIoT入門ハンズオン
&lt;/a&gt;&lt;/strong&gt;」の資料にもなっています。&lt;/p&gt;

&lt;p&gt;かなり長いですが、詳細な手順を載せていますので根気よく頑張りましょう！&lt;/p&gt;

&lt;h2 id=&#34;wio-nodeとは&#34;&gt;Wio Nodeとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/01_wio_node.png&#34; alt=&#34;&#34; /&gt;
今回使うWio Nodeは、中国のSeeed Studio社が開発した&lt;strong&gt;Wi-Fiモジュール初期搭載のIoTデバイス&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grove規格のモジュールをそのまま挿せるコネクタを搭載&lt;/strong&gt;していて、はんだづけなしで動かすことができます。モジュールのセットアップも&lt;strong&gt;公式のスマートフォンアプリから行うことができ&lt;/strong&gt;、電子工作初心者でも簡単に試せます。&lt;/p&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;早速Wio Nodeを動かしてみましょう。今回は、温度センサと7セグメントディスプレイを使って簡易温度計を作ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/02_map.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeに接続したモジュール同士は一見つながっているように見えますが、&lt;strong&gt;内部で連携する仕組みはありません&lt;/strong&gt;。それぞれWi-Fiを使ってAPIからインプットやアウトプットを制御します。&lt;/p&gt;

&lt;p&gt;以下の手順で作っていきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wio Nodeのセットアップ&lt;/li&gt;
&lt;li&gt;Wio Nodeにモジュールを接続する&lt;/li&gt;
&lt;li&gt;アプリからAPIを試す&lt;/li&gt;
&lt;li&gt;Node.jsでプログラムを書く&lt;/li&gt;
&lt;li&gt;試してみる&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Wio Node -&amp;gt; &lt;a href=&#34;https://dotstud.io/shop/wionode-social-remote-control/&#34;&gt;購入ページ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Micro USBケーブル&lt;/li&gt;
&lt;li&gt;Grove 温度センサ（型番: SEEED-101020015）&lt;/li&gt;
&lt;li&gt;Grove 7セグメントディスプレイ（型番: SEEED-104030003）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;類似のセンサがたくさんありますので、型番をよくご確認ください。&lt;/strong&gt;（Wio Nodeに対応していない場合があります。）&lt;/p&gt;

&lt;h4 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro（Retina 13-inch、Early 2015）&lt;/li&gt;
&lt;li&gt;OS X El Capitan（v10.11.6）&lt;/li&gt;
&lt;li&gt;iOS10.31&lt;/li&gt;
&lt;li&gt;Node.js v7.9.0&lt;/li&gt;
&lt;li&gt;npm 4.5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wio-nodeのセットアップ&#34;&gt;Wio Nodeのセットアップ&lt;/h3&gt;

&lt;p&gt;まずはWio Nodeの初期設定から進めていきます。&lt;/p&gt;

&lt;p&gt;Wio Nodeは&lt;strong&gt;モバイルバッテリ・PCなどからUSBケーブルで電源を供給しましょう&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;開発用アプリのインストール&#34;&gt;開発用アプリのインストール&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/02_wio_app.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeの開発には、公式からリリースされている「Wio Link」というアプリ（Androidの場合は「Wio」）を利用します。執筆時はiOS版は1.5.2、Android版は2.3.6がリリースされています。今回はiOS版を使っての紹介です。&lt;/p&gt;

&lt;p&gt;iOS: &lt;a href=&#34;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&#34;&gt;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&lt;/a&gt;&lt;br /&gt;
Android: &lt;a href=&#34;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&#34;&gt;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;アプリとwio-nodeの設定&#34;&gt;アプリとWio Nodeの設定&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/03_acount.png&#34; alt=&#34;&#34; /&gt;
アプリを開いたらまずはアカウントを作成しましょう。「SIGN UP」からメールアドレスとパスワードを設定し「Register」で登録します。ServerLocationはデフォルトのGlobalにしておきます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GmailやFacebookのアカウントを使った登録もできますが、他サービスとの連携でうまくいかないことがあるので非推奨です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/04_add_device.png&#34; alt=&#34;&#34; /&gt;
アカウントが作成されたらAdd Your First Deviceをタップし、Wio Nodeを選択します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wi-fi設定&#34;&gt;Wi-Fi設定&lt;/h4&gt;

&lt;p&gt;続いてWi-Fi設定をします。&lt;strong&gt;手順が少しややこしいので注意してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;まずは簡単にWio Nodeがインターネットに繋がる仕組みを整理してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/05_internet.png&#34; alt=&#34;&#34; /&gt;
デバイスがインターネットに繋がるためには、&lt;strong&gt;インターネットに繋がる媒介（=アクセスポイント）&lt;/strong&gt;が必要です。私たちは普段ルータやポケットWi-Fi（モバイルルータ）を媒介にしていますね。&lt;/p&gt;

&lt;p&gt;Wio Nodeも同様に、インターネットに繋がるために&lt;strong&gt;アクセスポイントが必要&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/06_wifi_setup.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeに&lt;strong&gt;アクセスポイントの情報を教える必要がある&lt;/strong&gt;ので、アドホックモードでWio Nodeとスマートフォンを同じ回線に繋いだ状態にします。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;スマートフォンからWio Nodeにアクセスポイント情報を教えてあげる&lt;/strong&gt;と、その後は&lt;strong&gt;Wio Node自身がアクセスポイントに繋がります&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;接続手順が複雑になりますが、この仕組みを押さえておきましょう！&lt;/p&gt;

&lt;p&gt;アクセスポイントやWAN/LANについてよくわからない方は&lt;a href=&#34;https://dotstud.io/docs/network&#34;&gt;ドキュメント&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wi-fi設定手順&#34;&gt;Wi-Fi設定手順&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/06_func.png&#34; alt=&#34;&#34; /&gt;
まずは画面の指示にしたがってFuncボタン（写真親指側）を4秒以上長押しすると、青いランプがゆらゆらと光ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/07_wio_network.png&#34; alt=&#34;&#34; /&gt;
iOSのWi-Fi選択画面から、「Wio_XXXX」というSSIDを選択します。（Androidはアプリ内での選択です。）アドホックモードで&lt;strong&gt;Wio Nodeとスマートフォンが繋がっている状態&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/08_wifi_list.png&#34; alt=&#34;&#34; /&gt;
アプリに戻ると、続いてWi-Fiの接続を促されます。ネットワークリストから、部屋や会場のWi-Fi（利用するWi-Fi）を選択してパスワードを入力しましょう。&lt;strong&gt;アクセスポイント情報を教えてあげた状態&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/09_device_connect.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeがインターネットに繋がり、登録が完了しました。デバイスに名前をつけておきます。（Android端末で認識がうまくいかない場合、&lt;strong&gt;機内モードにして試す&lt;/strong&gt;と解消することがあるようです。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;アプリからでは失敗する場合は、&lt;a href=&#34;https://dotstud.io/docs/wionode-wiosetup&#34;&gt;こちら&lt;/a&gt;を参考にWio-Setupというツールを試してみてください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;以上でWio Nodeのセットアップは完了です。同じデバイスとアクセスポイントを使う場合は、以後起動するだけで接続されるようになります！&lt;/p&gt;

&lt;h3 id=&#34;wio-nodeにモジュールを接続する&#34;&gt;Wio Nodeにモジュールを接続する&lt;/h3&gt;

&lt;p&gt;アプリから、接続するモジュールを登録します。
&lt;img src=&#34;https://dotstud.io/img/blog/095/10_display_connect.png&#34; alt=&#34;&#34; /&gt;
「PORT0」（左側）をタップして、下の「OUTPUT」から「4-Digit Display」を選択しましょう。&lt;strong&gt;似たようなモジュールがたくさんありますので、よく確認してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/11_temperature_connect.png&#34; alt=&#34;&#34; /&gt;
続いて温度センサを登録します。「PORT1」（右側）をタップして、「INPUT」から「Temperature Sensor」を選択します。&lt;/p&gt;

&lt;p&gt;アプリ画面を参考に、Wio Nodeにモジュールを接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/095/12_module_connect.png&#34; alt=&#34;&#34; /&gt;
「PORT0」に7セグメントディスプレイ、「PORT1」に温度センサを接続しましょう。&lt;/p&gt;

&lt;p&gt;接続できたら、アプリ画面下部の「Update Firmware」をタップしましょう。読み込みのあと、「View API」というAPIサンプルページが表示されるようになります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updateが失敗する場合はモジュールの接続が左右間違っていないか今一度確認してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;アプリからapiを試す&#34;&gt;アプリからAPIを試す&lt;/h3&gt;

&lt;p&gt;「View API」のページでは、手軽にモジュールを操作するAPIを試すことができます。正しく接続できているか、試してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/095/13_display_api.png&#34; alt=&#34;&#34; /&gt;
まずは7セグメントディスプレイの「display_point」というAPIを試してみます。説明部分には、「&lt;strong&gt;POSTメソッドで1を送ると&amp;rdquo;:&amp;ldquo;が表示される&lt;/strong&gt;」とありますね。「Test Request」から1を送ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/14_display_demo.png&#34; alt=&#34;&#34; /&gt;
7セグメントディスプレイに&amp;rdquo;:&amp;ldquo;が表示されました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/15_temp_api.png&#34; alt=&#34;&#34; /&gt;
続いて温度センサのAPIを試します。温度の取得には値は必要ないので、そのままGETメソッドでRequestします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/16_temp_demo.png&#34; alt=&#34;&#34; /&gt;
現在の温度が返ってきました。（かなり暑いですね（笑））&lt;/p&gt;

&lt;p&gt;挙動が確認できたら、2つのモジュールを連携させるプログラムを書いていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-getメソッドとpostメソッド&#34;&gt;memo: GETメソッドとPOSTメソッド&lt;/h4&gt;

&lt;p&gt;HTTPリクエストにはいくつかのメソッド（送信方法）があります。GET、POSTの他にもPUTメソッド、DELETEメソッドなどがあり、最近主流の「RESTful API」という考え方では&lt;strong&gt;操作する内容によってメソッドを使い分ける&lt;/strong&gt;ことになっています。&lt;/p&gt;

&lt;p&gt;今回はメソッド名だけわかればプログラミング可能ですが、詳しく知りたい方は調べてみてください！&lt;/p&gt;

&lt;h3 id=&#34;node-jsでプログラムを書く&#34;&gt;Node.jsでプログラムを書く&lt;/h3&gt;

&lt;p&gt;センサの値を取得して、室温をディスプレイに表示するプログラムを書いていきましょう。プログラムはAPIを叩ければよいので、今回は&lt;strong&gt;Node.js&lt;/strong&gt;で作成します。&lt;/p&gt;

&lt;p&gt;プログラムの仕組みを理解するために、以下の手順で説明します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node.jsのインストール&lt;/li&gt;
&lt;li&gt;プロジェクトの作成&lt;/li&gt;
&lt;li&gt;温度情報を取得する&lt;/li&gt;
&lt;li&gt;温度情報を表示したい文字列に変換する&lt;/li&gt;
&lt;li&gt;ディスプレイに温度を表示する&lt;/li&gt;
&lt;li&gt;3秒ごとに更新する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-コマンドラインの使い方&#34;&gt;memo: コマンドラインの使い方&lt;/h4&gt;

&lt;p&gt;Node.jsの実行やファイル操作はコマンドラインで行います。Macには「ターミナル」、Windowsには「コマンドプロンプト」というアプリケーションが最初から入っているので、立ち上げて使いましょう。&lt;/p&gt;

&lt;p&gt;初めてコマンドを使う方は、「ターミナル コマンド」などで検索すると基本的な使い方がわかりますよ！&lt;/p&gt;

&lt;p&gt;筆者はiTerm2というクライアントアプリにzshというシェルを入れています。（画面がちょっと違うくらいだと思ってください。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-node-jsのインストール&#34;&gt;1. Node.jsのインストール&lt;/h4&gt;

&lt;p&gt;まずはNode.jsのインストールから始めます。また&lt;code&gt;async/await&lt;/code&gt;という機能を使っているので、&lt;strong&gt;v7.6.0以上が必要&lt;/strong&gt;です。最新版をインストール済みの方は次項の「プロジェクトの作成」から始めてください。&lt;/p&gt;

&lt;p&gt;Node.jsのインストールには、簡単にバージョン管理ができる「&lt;strong&gt;nvm&lt;/strong&gt;」や「&lt;strong&gt;nodebrew&lt;/strong&gt;」を使うのが便利です。nodebrewを使ったインストール方法は下記を参照してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#node-js%E7%92%B0%E5%A2%83%E6%95%B4%E5%82%99&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;インストールが完了したら、Node.jsが正しく動くか確認してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/095/17_node_v.png&#34; alt=&#34;&#34; /&gt;
コマンドラインで&lt;code&gt;node -v&lt;/code&gt;を叩くとバージョンが出るようになったでしょうか？（v7.6.0以上ですよ！）&lt;/p&gt;

&lt;p&gt;Node.jsの環境構築はとても簡単なので、ウェブ開発が初めての方にもオススメです！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-コーディング無しで動かしてみる&#34;&gt;memo: コーディング無しで動かしてみる&lt;/h4&gt;

&lt;p&gt;サクッと試したい方は、githubの&lt;a href=&#34;https://github.com/dotstudio/wionode_handson&#34;&gt;完成プログラム&lt;/a&gt;をご覧ください。READMEの手順を進めるとコーディングなしで動かせます。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-プロジェクトの作成&#34;&gt;2. プロジェクトの作成&lt;/h4&gt;

&lt;p&gt;今回のWio Nodeのプログラムを置くプロジェクトを作成しましょう。&lt;/p&gt;

&lt;p&gt;適当なディレクトリに移動します。（私は&lt;code&gt;/Users/ユーザ名/workspace&lt;/code&gt;という作業ディレクトリを用意しています。参考まで。）
&lt;img src=&#34;https://dotstud.io/img/blog/095/18_mkdir.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;mkdir ディレクトリ名&lt;/code&gt;で新しいディレクトリを作成できます。&lt;code&gt;wio_temperature&lt;/code&gt;というディレクトリを作ってみました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/19_cd.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;cd ディレクトリ名&lt;/code&gt;で作成したディレクトリの下に移動します。&lt;/p&gt;

&lt;p&gt;Node.jsでは「npm」でモジュールを管理できます。&lt;code&gt;npm init -y&lt;/code&gt;を実行しましょう。&lt;code&gt;-y&lt;/code&gt;オプションで名前等をデフォルト値で作成してくれます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/20_npm_init.png&#34; alt=&#34;&#34; /&gt;
プロジェクト名やライブラリなどを管理する「&lt;strong&gt;package.json&lt;/strong&gt;」が作成されました。&lt;/p&gt;

&lt;p&gt;今回使用する「&lt;strong&gt;axios&lt;/strong&gt;」ライブラリをインストールします。&lt;code&gt;npm install axios --save&lt;/code&gt;を実行しましょう。&lt;code&gt;--save&lt;/code&gt;オプションをつけることでpackage.jsonに記載されます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/21_npm_install.png&#34; alt=&#34;&#34; /&gt;
axiosがインストールされ、package.jsonに追加されました。&lt;/p&gt;

&lt;p&gt;続いてプログラムを記述するファイルを作成します。&lt;code&gt;touch ファイル名&lt;/code&gt;でファイルが作成されます。（Windowsの場合はコマンドがないのでフォルダから作成してください。）
&lt;img src=&#34;https://dotstud.io/img/blog/095/22_touch.png&#34; alt=&#34;&#34; /&gt;
app.jsというファイルを作成しました。（&lt;code&gt;ls&lt;/code&gt;コマンドでカレントディレクトリのファイルが見れます。Windowsは&lt;code&gt;dir&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;以上でプロジェクトの作成は完了です。ファイルにプログラムを書いていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-ファイルの編集とエディタについて&#34;&gt;memo: ファイルの編集とエディタについて&lt;/h4&gt;

&lt;p&gt;コマンドラインからでもファイルの編集はできますが、&lt;strong&gt;インデントやコードの補完が効かず作業しづらい&lt;/strong&gt;ので、テキストエディタを使うのがオススメです。&lt;/p&gt;

&lt;p&gt;下記記事ではVisual Studio Codeのインストール方法を紹介しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#visual-studio-code&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-温度情報を取得する&#34;&gt;3. 温度情報を取得する&lt;/h4&gt;

&lt;p&gt;まずは温度を取得するプログラムを書いていきます。&lt;code&gt;BASE_URL&lt;/code&gt;はドメインが違う場合があるので、アプリから確認して自身のものに置き換えてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const TOKEN = process.argv[2] || &#39;&#39;;
const BASE_PATH = `https://us.wio.seeed.io/v1/node`; // 自身のものをアプリで確認

/**
 * 温度取得
 */
 const getTemp = () =&amp;gt; {
     const ENDPOINT = `/GroveTempA0/temp`;
     const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${TOKEN}`;
     axios.request({method: &#39;get&#39;, baseURL: BASE_URL})
     .then((resp) =&amp;gt; console.log(resp));
 }

getTemp();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;axiosに温度取得APIのURLとオプションを渡し、返ってきた値を出力しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;&lt;/code&gt;の部分は、コマンドライン引数（実行時に渡す値）を取得しています。tokenなどの人に知られたくない値は、ファイルに直接書かないのがベターです。&lt;/p&gt;

&lt;p&gt;それでは正しく動くか試してみましょう。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;というコマンドで実行します。&lt;/p&gt;

&lt;p&gt;ご自身のtokenは&lt;strong&gt;アプリのView API画面から確認してください&lt;/strong&gt;。&lt;code&gt;?access_token=&lt;/code&gt;の後の文字列がtokenです。
&lt;img src=&#34;https://dotstud.io/img/blog/095/23_temp_test.png&#34; alt=&#34;&#34; /&gt;
温度センサの情報が返ってきたでしょうか？&lt;/p&gt;

&lt;p&gt;1番下に温度情報がありますね。この情報を使ってディスプレイに表示する文字列を作っていきます。&lt;/p&gt;

&lt;p&gt;エラーが出てしまった人は、「Node.js &amp;lt;エラーメッセージ&amp;gt;」で検索すると答えが見つかりやすいです。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-温度情報を表示したい文字列に変換する&#34;&gt;4. 温度情報を表示したい文字列に変換する&lt;/h4&gt;

&lt;p&gt;取得した温度情報を、ディスプレイに表示する文字列に作り変えるfunctionを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, tempstr.length-1);
  }
  return `${temp_str}C`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;temp2digit()の引数には、先ほど受け取った情報の温度部分だけを渡します。&lt;/p&gt;

&lt;p&gt;数値を文字列に変換し、不要な&amp;rsquo;.&amp;lsquo;を取り除き、3桁にして、温度計らしく&amp;rsquo;C&amp;rsquo;を付けて返します。&lt;/p&gt;

&lt;p&gt;これを先ほど作ったgetTemp()と一緒に実行するようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const TOKEN = process.argv[2] || &#39;&#39;;
const BASE_PATH = `https://us.wio.seeed.io/v1/node`; // 自身のものをアプリで確認

/**
 * 温度取得
 */
 const getTemp = () =&amp;gt; {
     const ENDPOINT = `/GroveTempA0/temp`;
     const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${TOKEN}`;
     return axios.request({method: &#39;get&#39;, baseURL: BASE_URL}); // ここでは実行しない
 }

/**
 * 温度情報を文字列変換+Cを追加
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt;{
    let temp_str = `${temp}`;
    temp_str = temp_str.replace(&#39;.&#39;,&#39;&#39;);
    if(temp_str.length &amp;gt;= 4){
        temp_str = temp_str.substr(0,temp_str.length-1);
    }
    return `${temp_str}C`;
}

async function main(){ // async/awaitを使う
   const res = await getTemp();
   const temp = res.data.temperature;
   const text = temp2digit(temp);
   console.log(text);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではasync/awaitを使っています。awaitで指定したタスクの実行を待ってレスポンスを受け取り、asyncを付けたメソッドを一つのタスクとして処理するような機能です。Node.jsではv7.6.0から導入されました。&lt;/p&gt;

&lt;p&gt;実行を待たせるため、getTemp()では、APIの結果ではなくメソッドを返すだけに変更します。&lt;/p&gt;

&lt;p&gt;getTemp()で受け取ったobjectの子要素には&lt;code&gt;.&lt;/code&gt;でアクセスします。先ほどのレスポンスのdataの中のtemperatureが欲しいので&lt;code&gt;res.data.temperature&lt;/code&gt;となります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/24_temp2digit.png&#34; alt=&#34;&#34; /&gt;
温度計の文字列ができました！&lt;/p&gt;

&lt;p&gt;次はいよいよこの文字列をディスプレイに表示させます。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-ディスプレイに温度を表示する&#34;&gt;5. ディスプレイに温度を表示する&lt;/h4&gt;

&lt;p&gt;取得した温度の値を使って、ディスプレイに表示するAPIを叩きます。温度の区切りを表すため、最初に試した&amp;rsquo;:&amp;lsquo;を表示するAPIも使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL})
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fourDigit()のstart_posにはディスプレイ表示の開始位置、charsには表示する文字を渡します。（詳しくはAPIの説明を読んでみてください）&lt;/p&gt;

&lt;p&gt;fourDigitPoint()には表示するかどうかの0/1を渡すようになっています。&lt;/p&gt;

&lt;p&gt;これまで作ったfunctionと繋げてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const BASE_PATH = &#39;https://us.wio.seeed.io/v1/node&#39;; // 自身のものをアプリで確認
const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;

/**
 * 温度を取得
 */
const getTemp = () =&amp;gt; {
  const ENDPOINT = `/GroveTempA0/temp`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;GET&#39;, baseURL: BASE_URL});
}

/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, tempstr.length-1);
  }
  return `${temp_str}C`;
}

/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

async function main() =&amp;gt; {
  let res = getTemp();
  const temp = res.data.temperature;
  const text = temp2digit(temp);
  console.log(text);
  res = await fourDigit(0, text);
  res = await fourDigitPoint(1);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらも試してみましょう。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行です。
&lt;img src=&#34;https://dotstud.io/img/blog/095/25_comp_demo.png&#34; alt=&#34;&#34; /&gt;
温度がディスプレイに表示されました！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-3秒ごとに更新する&#34;&gt;6. 3秒ごとに更新する&lt;/h4&gt;

&lt;p&gt;今のままではコマンドを実行した時しか処理が走りません。3秒ごとに実行するようプログラムを変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const INTERVAL = 3000;

/**
 * 繰り返し実行する
 */
setInterval(() =&amp;gt; {
  main()
  .catch((e) =&amp;gt; {
    if (e.response) console.log(e.response);
  })
}, INTERVAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;update()の実行部分をsetInterval()関数で繰り返すようにします。setInterval()の第二引数にミリ秒で数値を渡すと、その間隔ごとに実行されます。あとから変更しやすいよう、定数で宣言しておきましょう。&lt;/p&gt;

&lt;p&gt;catch()はエラーが発生するとエラーレスポンスを受け取ります。&lt;/p&gt;

&lt;p&gt;完成させたコードはこちら。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const BASE_PATH = &#39;https://us.wio.seeed.io/v1/node&#39;; // 自身のものをアプリで確認
const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;
const INTERVAL = 3000;

/**
 * 温度を取得
 *
 * @return {object}
 */
const getTemp = () =&amp;gt; {
  const ENDPOINT = `/GroveTempA0/temp`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;GET&#39;, baseURL: BASE_URL});
}

/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const tempToDigit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, temp_str.length-1);
  }
  return `${temp_str}C`;
}

/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 * @return {object}
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL})
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 * @return {object}
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

/**
 * メインの処理（同期）
 */
async function main() {
  let res = await getTemp();
  const temp = res.data.temperature;
  const text = tempToDigit(temp);
  console.log(text);
  res = await fourDigit(0, text);
  res = await fourDigitPoint(1);
}

/**
 * 繰り返し実行する
 */
setInterval(() =&amp;gt; {
  main()
  .catch((e) =&amp;gt; {
    if (e.response) console.log(e.response);
  })
}, INTERVAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;試してみる&#34;&gt;試してみる&lt;/h3&gt;

&lt;p&gt;完成コードを試してみます。ドキドキ。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行です。
&lt;img src=&#34;https://dotstud.io/img/blog/095/25_comp_demo.png&#34; alt=&#34;&#34; /&gt;
現在の室温が表示されます。&lt;/p&gt;

&lt;p&gt;3秒ごとに更新されるので、変化を試すため温度センサを手で温めてみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/26_warmer.png&#34; alt=&#34;&#34; /&gt;
少し温度が上がりました。処理を止めたい場合は&lt;code&gt;controll+c&lt;/code&gt;で終了します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これでプログラムは完成です！やったー！！&lt;/strong&gt; お疲れ様でした！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;補足-完成の一歩先へ&#34;&gt;補足: 完成の一歩先へ！&lt;/h4&gt;

&lt;p&gt;「簡単であっという間だった」というあなた！&lt;strong&gt;このガジェットを使ってできることはまだまだあります！&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;例1: Azure Web AppsなどのPaaSを使って常時稼働できるようにする&lt;/li&gt;
&lt;li&gt;例2: 温度情報をAmbientなどのウェブサービスを使ってグラフ化してみる&lt;/li&gt;
&lt;li&gt;例3: 一定の温度をトリガーにTwitterやSlackへ通知を送ってみる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記はほんの一例です。Wio Node対応モジュールもたくさんありますので、ここまでの知見を使って試してみましょう！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いかがだったでしょうか？簡単と言いつつ、コマンドでの作業やウェブ開発の経験がない人には詰まる部分が多かったかもしれません。でも、これで&lt;strong&gt;InternetとThingsの連携ができるようになりました！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IoTの世界には、まだまだたくさんの楽しいデバイスやアイディアが待っています。&lt;strong&gt;作っても使っても楽しい電子工作をやっていきましょう！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最後まで読んでくださりありがとうございました！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefryで取得したセンサーデータをAmbientで簡単にグラフ化しよう！</title>
      <link>https://dotstud.io/blog/nefry-data-show-graphically/</link>
      <pubDate>Tue, 21 Mar 2017 13:48:05 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-data-show-graphically/</guid>
      
      <description>

&lt;p&gt;こんにちは、外部ライターのわみ（&lt;a href=&#34;http://twitter.com/wamisnet&#34;&gt;@wamisnet&lt;/a&gt;）です。愛知県でネットワークの勉強をしている学生です。2014年ごろから電子工作を始め、今回紹介するFRISKサイズのIoT向けデバイス「Nefry（ねふりー）」を自作しました。&lt;/p&gt;

&lt;p&gt;IoTといえば、データを取ることはもちろんですが、データの蓄積や分析が大切です。&lt;/p&gt;

&lt;p&gt;今回は、&lt;strong&gt;簡単にデータを蓄積・グラフ化してくれる「Ambient」&lt;/strong&gt; というサービスを使って、Nefryで取得したセンサーのデータをグラフ化する方法を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;nefryとは&#34;&gt;Nefryとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/059/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「Nefry（ねふりー）」は手軽にIoTに挑戦できるFRISKサイズのデバイスです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nefry.studio/&#34;&gt;公式サイト&lt;/a&gt;から、詳細なドキュメントや制作例を確認できます。&lt;/p&gt;

&lt;h3 id=&#34;wi-fiを初期搭載&#34;&gt;Wi-Fiを初期搭載&lt;/h3&gt;

&lt;p&gt;Nefryは、Wi-Fiモジュールの &lt;strong&gt;ESP-WROOM-02を初期搭載&lt;/strong&gt; しています。簡単にインターネットに接続できるので、接続に時間をとられることなくあなたのアイデア実現に集中できます。&lt;/p&gt;

&lt;h3 id=&#34;スタンドアロンで動かせる&#34;&gt;スタンドアロンで動かせる&lt;/h3&gt;

&lt;p&gt;スマートフォンで使うようなモバイルバッテリー（5V）から給電できます。&lt;strong&gt;モバイルバッテリー＋Nefryの2つで動作する&lt;/strong&gt; ので、場所を選ばずに使うことができる優れものです！&lt;/p&gt;

&lt;h3 id=&#34;外部サービス連携が簡単&#34;&gt;外部サービス連携が簡単&lt;/h3&gt;

&lt;p&gt;NefryはGroveセンサの規格に対応しています。専用のソケットを使い、はんだづけ不要で楽しめます。また、リアルタイム通信を簡単に実現できる「Milkcocoa」や、様々なWebサービス同士を連携できる「IFTTT」などとも組み合わせることもできます。&lt;/p&gt;

&lt;p&gt;実際に使ってみた例は以下をご覧ください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liginc.co.jp/263899&#34;&gt;Webサービス同士を連携できる「IFTTT」と自作IoTデバイスを繋いで生活を便利にしてみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/iotlt-vol24-chantoku-report/&#34;&gt;【大島薫×IoT】浮気男に社会的制裁を加えるマシーンを作ってみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://dotstud.io/projects/nefry-connect-internet/&#34;&gt;Nefryの購入はこちら！&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;ambientとは&#34;&gt;Ambientとは&lt;/h2&gt;

&lt;p&gt;Ambient（アンビエント）は、&lt;strong&gt;センサーデータを蓄積・グラフ化してくれるIoTに特化したクラウドサービス&lt;/strong&gt; です。&lt;/p&gt;

&lt;p&gt;Ambientから発行される「チャネルID」「ライトキー」の &lt;strong&gt;たった2つの情報をプログラムに書き込むだけ&lt;/strong&gt; で、いとも簡単にセンサーデータをグラフ化することができます！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/01_ambient.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このようなグラフを公開したり、簡単にカスタマイズしたりすることができるので、オススメのサービスです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient公式サイト&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;つくってみよう&#34;&gt;つくってみよう！&lt;/h2&gt;

&lt;p&gt;Nefryで取得したデータをグラフ化するために、今回は以下の4ステップを試します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事前準備&lt;/li&gt;
&lt;li&gt;Ambientにチャネルを作成&lt;/li&gt;
&lt;li&gt;プログラムの書き込み&lt;/li&gt;
&lt;li&gt;NefryとAmbientの連携&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;筆者の開発環境は以下です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;windows 10&lt;/li&gt;
&lt;li&gt;Nefry version 2.3.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;開発を始める前に、NefryとAmbientのセットアップをします。&lt;/p&gt;

&lt;p&gt;NefryのWi-Fi接続とAmbientのユーザ登録が完了している方は、&lt;a href=&#34;https://dotstud.io/blog/nefry-data-show-graphically/#ambientにチャネルを作成&#34;&gt;Ambientにチャネルを作成&lt;/a&gt;から開始してください。&lt;/p&gt;

&lt;h3 id=&#34;nefryのセットアップ&#34;&gt;Nefryのセットアップ&lt;/h3&gt;

&lt;p&gt;PCやスマートフォンから、Wi-FiのSSIDが &lt;strong&gt;Nefry-XXXX&lt;/strong&gt;（変更した場合はその名前）になっているものを探し、接続します。&lt;/p&gt;

&lt;p&gt;接続できるとこのようなページが表示されます。表示されない場合は &lt;a href=&#34;http://192.168.4.1&#34;&gt;http://192.168.4.1&lt;/a&gt; に接続してみてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/02_nefry_menu.png&#34; alt=&#34;&#34; /&gt;
このトップページでNefryに関するいろいろな設定ができます。まずは「Setup WiFi」をクリックして、Wi-Fiの設定をします。&lt;/p&gt;

&lt;p&gt;Setup WiFiのページはこのようになっています。
&lt;img src=&#34;https://dotstud.io/img/blog/092/03_nefry_wifi.png&#34; alt=&#34;&#34; /&gt;
接続したいWi-Fiを選び、パスワードがある場合は入力をします。入力が完了したら「Save」をクリックしてください。設定が保存され、Nefryが再起動します。&lt;/p&gt;

&lt;p&gt;おまけですが、&lt;strong&gt;Nefry library 2.3.0&lt;/strong&gt; 以降であると5つまでのWi-Fiを記憶することができ、自動的に最も強いWi-Fiに自動接続する機能を搭載しています。Nefryを持っていて &lt;strong&gt;ライブラリが古い場合は、更新することをオススメします&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;その他のセットアップや使い方の詳細は以下の記事をご覧ください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liginc.co.jp/236620&#34;&gt;自作したオリジナルIoTデバイス「Nefry」とインターネットを繋いでみた&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ambientの登録&#34;&gt;Ambientの登録&lt;/h3&gt;

&lt;p&gt;グラフ化に必要な情報を取得するために、まずAmbientに登録します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient公式サイト&lt;/a&gt;&lt;/strong&gt; の「ユーザー登録」から登録を進めます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/04_ambient_acount.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;メールアドレス認証が必要なので、各自アカウントを用意してください。&lt;/p&gt;

&lt;h2 id=&#34;ambientにチャネルを作成&#34;&gt;Ambientにチャネルを作成&lt;/h2&gt;

&lt;p&gt;Ambientでは &lt;strong&gt;チャネルという単位で送信するデーターを管理・グラフ化する&lt;/strong&gt; ため、まずはチャネルを作成します。「チャネルを作る」ボタンから作成します。
&lt;img src=&#34;https://dotstud.io/img/blog/092/05_ambient_channel.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;チャネルが無事に作成されると、先ほどのページに情報が追加されています。「チャネルID」と「ライトキー」をあとで使うので控えておきましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/092/06_ambient_list.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;プログラムの書き込み&#34;&gt;プログラムの書き込み&lt;/h2&gt;

&lt;p&gt;今回はNefryについている &lt;strong&gt;アナログ入力&lt;/strong&gt; を使ってみます。アナログ入力を扱えるセンサであればどのようなセンサでも大丈夫ですが、この記事ではGroveの明るさセンサを扱います。&lt;/p&gt;

&lt;p&gt;全体のプログラムはこちら。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://gist-it.appspot.com/github/Nefry-Community/ProgramMaster/blob/gh-pages/Nefry/Ambient/Analog/Analog.ino&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nefryにプログラムを書き込む方法は２つあります。&lt;/p&gt;

&lt;h3 id=&#34;arduino-ideを使う&#34;&gt;Arduino IDEを使う&lt;/h3&gt;

&lt;p&gt;プログラムを編集したい場合などは、Arduino IDEに上のプログラムを貼り、編集します。&lt;/p&gt;

&lt;p&gt;Arduino IDEでコンパイルしたプログラムはNefryトップページの「Upload　Sketch」からアップロードすることができます。&lt;/p&gt;

&lt;p&gt;Arduino IDEにNefryの設定を追加する方法は、以下の記事を確認してください。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.liginc.co.jp/wp-content/uploads/2016/07/20160728-nefry.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://liginc.co.jp/298161&#34;&gt;&lt;strong&gt;さくっと生活を便利にする！FRISKサイズのIoT向けデバイス「Nefry」を使ってみよう【環境構築編】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;プログラムをダウンロードして使う&#34;&gt;プログラムをダウンロードして使う&lt;/h3&gt;

&lt;p&gt;もっと簡単に試したい場合、トップページから「Web Sketch Download」のページに移動し以下を入力してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ドメイン :  program.nefry.studio&lt;/li&gt;
&lt;li&gt;URL :  /Nefry/Ambient/Analog&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/07_nefry_websketch.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://program.nefry.studio/&#34;&gt;Nefry Platform&lt;/a&gt;というサイトでは他にも様々なプログラムを公開していますので、ぜひご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;nefryとambientの連携&#34;&gt;NefryとAmbientの連携&lt;/h2&gt;

&lt;p&gt;プログラムが書き込めたら、Ambientの情報をNefryに登録します。&lt;/p&gt;

&lt;p&gt;トップページから「Setup Module」をクリックしページを移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/092/08_nefry_module.png&#34; alt=&#34;&#34; /&gt;
設定項目の中から「WriteKey」と「ChannelID」となっている欄を見つけ、そこにAmbientで取得したライトキーとチャネルIDをそれぞれ入力します。&lt;/p&gt;

&lt;p&gt;Saveをクリックすると、Nefryが再起動してAmbientにデータを送るようになります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これで準備は完了です！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;ambientでグラフを見てみよう&#34;&gt;Ambientでグラフを見てみよう&lt;/h2&gt;

&lt;p&gt;Nefryに接続した明るさセンサーの値のグラフです！
&lt;img src=&#34;https://dotstud.io/img/blog/092/09_product.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;右側がAmbientのグラフ、左側がNefryの取得したアナログ値をWebConsoleで表示しています。
&lt;img src=&#34;http://program.nefry.studio/Nefry/Ambient/pic/ambientnefry.gif&#34; alt=&#34;Ambient×Nefry.git&#34; /&gt;
Nefryにライトを当てたり遠ざけたりすると、わりと &lt;strong&gt;リアルタイムにどんどんグラフが生成されていく&lt;/strong&gt; のが分かります。&lt;a href=&#34;https://ambidata.io/ch/channel.html?id=785&#34;&gt;こちらのページ&lt;/a&gt;でで今回撮影したグラフをみることができます。&lt;/p&gt;

&lt;p&gt;Ambientでは &lt;strong&gt;グラフの自動スケールやグラフの公開機能、画像の添付&lt;/strong&gt; など、今回紹介しきれないほど様々な機能が作成されています。&lt;/p&gt;

&lt;p&gt;詳しくはAmbientの公式サイトやドキュメントを確認してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ambidata.io/docs/&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は、なんとハードウエアもWeb側も &lt;strong&gt;コードを一切書かずにグラフ化する&lt;/strong&gt; ことができました。&lt;/p&gt;

&lt;p&gt;紹介したのは折れ線グラフですが、&lt;strong&gt;棒グラフや散布図などもお手軽にグラフを作れるAmbient&lt;/strong&gt; と &lt;strong&gt;Webへの接続が簡単なNefry&lt;/strong&gt; でぜひぜひ遊んでみてください。&lt;/p&gt;

&lt;p&gt;Ambientを運営されている下島さん、記事にさせていただく許可を頂きありがとうございました。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>