<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Try on dotstudio（ドットスタジオ）</title>
    <link>https://dotstud.io/categories/try/index.xml</link>
    <description>Recent content in Try on dotstudio（ドットスタジオ）</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© 2016 dotstudio inc.</copyright>
    <atom:link href="/categories/try/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>フォトダイオードでリモコンの信号を検出してみよう</title>
      <link>https://dotstud.io/blog/photodiode-remote-controll-signal/</link>
      <pubDate>Wed, 02 Aug 2017 16:42:19 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/photodiode-remote-controll-signal/</guid>
      
      <description>

&lt;p&gt;こんにちは、ものづくり担当のうこ（&lt;a href=&#34;https://twitter.com/harmoniko/&#34;&gt;@harmoniko&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;今回は、フォトダイオードというパーツを使ってリモコンの信号を読み取る方法を紹介します！&lt;/p&gt;

&lt;h2 id=&#34;フォトダイオードとは&#34;&gt;フォトダイオードとは？&lt;/h2&gt;

&lt;p&gt;半導体素子のひとつで、照射される光の強さによって流れる電流の強さが変化します。太陽光パネルと仕組みはほとんど同じで、光によって電流を発生しますが、非常に小さいため電源としては使用されません。&lt;/p&gt;

&lt;p&gt;一口にフォトダイオードと言っても様々な種類があります。（参考：&lt;a href=&#34;http://jp.rs-online.com/web/c/displays-optoelectronics/optocouplers-photodetectors-photointerrupters/photodiodes/&#34;&gt;RSコンポーネンツ&lt;/a&gt;。多種の取り扱いがあります。） 光を検出するセンサとしてはほかにCdSなどがありますが、応答の速さ・感度・信号強度特性・対応する波長などに優位性があり、リモコンの受光器などとして産業用途に幅広く利用されています。&lt;/p&gt;

&lt;p&gt;今回はそんなリモコンの受光器を作り、信号の中身をみてみましょう。&lt;/p&gt;

&lt;h2 id=&#34;リモコンの仕組み&#34;&gt;リモコンの仕組み&lt;/h2&gt;

&lt;p&gt;リモコンは、赤外線LEDを高速で点滅させて家電などに信号を送っています。信号の中身は、国内ではNECが開発した方式が主流で、次いで家電製品協会の方式、ソニーなどの独自方式があります。今回は、最も普及しているNEC方式を用いたリモコン信号検出システムを作ってみます。&lt;/p&gt;

&lt;p&gt;このフォーマットを採用している主なメーカーとして、NEC・東芝・日立などがあります。これらのメーカーのリモコンなどをお持ちでしたら、ぜひ作ってみてください。&lt;/p&gt;

&lt;p&gt;【参考】&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.asahi-net.or.jp/~gt3n-tnk/IR_TX1.html&#34;&gt;赤外線リモコンのフォーマット&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作ってみよう&#34;&gt;作ってみよう&lt;/h2&gt;

&lt;h3 id=&#34;準備するもの&#34;&gt;準備するもの&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Arduino Due × 1&lt;/li&gt;
&lt;li&gt;ブレッドボード × 1&lt;/li&gt;
&lt;li&gt;抵抗1kΩ × 1&lt;/li&gt;
&lt;li&gt;フォトダイオード S5971 × 1&lt;/li&gt;
&lt;li&gt;ジャンパワイヤ × 4&lt;/li&gt;
&lt;li&gt;黒画用紙(3cm×6cmぐらい)&lt;/li&gt;
&lt;li&gt;USBマイクロBケーブル&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;作り方&#34;&gt;作り方&lt;/h3&gt;

&lt;h4 id=&#34;フォトダイオードに黒画用紙を巻く&#34;&gt;フォトダイオードに黒画用紙を巻く&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;フォトダイオードには、細長く切った黒画用紙を巻き寿司のように巻きつけてテープで固定します。こうすることでフォトダイオードを常に暗い状態にし、光の誤検出を防ぎます。&lt;/p&gt;

&lt;h4 id=&#34;配線&#34;&gt;配線&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/4.png&#34; alt=&#34;&#34; /&gt;
まずはじめに、ブレッドボード上に抵抗器とフォトダイオードを、上の写真のように配置します。フォトダイオードは向きに注意してください。
&lt;img src=&#34;https://dotstud.io/img/blog/117/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、4つのジャンパワイヤを使って、ブレッドボードとArduino Dueを接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/117/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接続が終わったら、このような感じになっています。
&lt;img src=&#34;https://dotstud.io/img/blog/117/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最後に、USBのマイクロBケーブルでArduino Dueとパソコンを接続して完了です。USBは、Arduino Due側は、黒いコネクタに近い方のUSBポート「Programming Port」に接続してください。&lt;/p&gt;

&lt;h3 id=&#34;arduino-dueボード対応化&#34;&gt;Arduino Dueボード対応化&lt;/h3&gt;

&lt;p&gt;Arduino IDEでプログラムを作成し書き込んでいきます。Arduino IDEのインストールが済んでいない方は、&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;からダウンロードして進めてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/8.png&#34; alt=&#34;&#34; /&gt;
Arduino IDEのメニューから、
Tools -&amp;gt; Boards:&amp;ldquo;&amp;hellip;&amp;rdquo; -&amp;gt; Board Manager&amp;hellip;
を選択すると、小さい画面が表示されます。検索窓に「due」と打ち込むと、ひとつだけヒットするパッケージがありますので、最新版をインストールしてください。&lt;/p&gt;

&lt;p&gt;次に、
Tools -&amp;gt; Boards&amp;rdquo;&amp;hellip;&amp;rdquo;
で、&amp;rdquo;Arduino Due (Programming Port)&amp;ldquo;を選択しておきます。&lt;/p&gt;

&lt;h3 id=&#34;ソースコードを書き込む&#34;&gt;ソースコードを書き込む&lt;/h3&gt;

&lt;p&gt;以下のソースコードをコピーし、スケッチにコピーしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const int thresholdH = 30;     // フォトダイオードの閾値(Off-&amp;gt;On)
const int thresholdL = 20;     // フォトダイオードの閾値(On-&amp;gt;Off)
const int input = A0;          // フォトダイオードの入力ピン
int signalCnt = -1;            // 信号カウンタ
int level = 0;                 // フォトダイオードのanalogRead値
unsigned long offSpan;         // 信号L値持続時間(計測用)
unsigned long offTime;         // 信号Off時間(計測用)
unsigned long startTime;       // 時間計算用
unsigned long signals = 0;     // 信号保存(カスタム16bit+データ8bit+反転データ8bit)
bool now = false;              // フォトダイオード状態遷移フラグ1
bool prev = false;             // フォトダイオード状態遷移フラグ2
bool detected = false;         // リーダコード検出フラグ




// フォトダイオードからアナログ値を読んで論理値に変換
bool photoRead() {
  level = analogRead(input);
  if (level &amp;gt; thresholdH) return true;
  if (level &amp;lt; thresholdL) return false;
}


// リーダコード認識
bool leaderDetect() {
  // 積分
  unsigned long integral0 = 0;
  unsigned long integral1 = 0;
  startTime = micros();
  // 9msループ(0.1msおまけ)
  while (micros() &amp;lt; (startTime+9100)) {
    if (photoRead()) integral1++;
    else integral0++;
  }
  /*
    副搬送波38kHz変調のデューティ比は1:2である
    また信号で0を表す場合はPPM方式によりHとLがそれぞれ0.56ms(1:1)であるため
    リーダコード以外の部分でフォトダイオードで得られるOnとOffの時間比は
    Onが1に対してOffが6である
    リーダコード部分は常にHであるのでOnが1に対してOffが3である
    よってOnとOffの差がおおむね4倍以下であればリーダコードを判定することができる
  */
  if (integral1 &amp;gt; ((integral0)/4)) return true;
  else return false;
}


void setup() {
  // シリアルポートを開く
  Serial.begin(115200);
  // アナログ入力の細かさを12bit(4096段階)に設定
  analogReadResolution(12);
}


void loop() {
  // ダイオードの状態確認ループ
  while(now == prev) {
    now = photoRead();
    // 一度検出できたらループを極力回さずにディレイさせたい
    // 副搬送波のL値を誤検出しないようにするため
    if (now) {
      if (!detected) {
        // Off-&amp;gt;On遷移かつリーダコード未検出
        if (leaderDetect()) {
          Serial.println(&amp;quot;------- LEADER -------&amp;quot;);
          detected = true;
          signalCnt = -1;
        }
      }
    }
  }

  // 以下は状態変化した瞬間だけ実行される
  //
  if (detected) {
    if (now) {
      // Off-&amp;gt;On遷移かつリーダコード検出済
      offSpan = micros() - offTime;
      // 最初のリーダコードの直後のL値
      if (signalCnt &amp;lt; 0) {
        // リピートの検出(3ms未満)
        if (offSpan &amp;lt; 3000) {
          Serial.println(&amp;quot;------- REPEAT -------&amp;quot;);
          Serial.println(&amp;quot;&amp;quot;);
          signals = 0;
          signalCnt = -1;
          detected = false;
        } else {
          signalCnt++;
        }
      } else {
        // off時間が1000msより多いか少ないか
        if (offSpan &amp;lt; 1000) {
          // 1判定
          signals += 1&amp;lt;&amp;lt;(31-signalCnt);
        } else {
          // 0判定
        }
        signalCnt++;
      }
      // 570msも待てば必ずLになり次のコード先頭までHにならないので誤検出しない
      delayMicroseconds(570);
    } else {
      // On-&amp;gt;Off遷移かつリーダコード検出済
      offTime = micros();
    }
  }
  // 反転
  prev = now;

  // 最後まで読めたら表示する
  if (signalCnt &amp;gt;= 31) {
    // カスタムコード16bit
    int custom = (int)(signals&amp;gt;&amp;gt;16);
    Serial.print(&amp;quot;Custom code: &amp;quot;); Serial.println(custom,HEX);
    Serial.print(&amp;quot;    &amp;quot;); Serial.println(custom,BIN);
    // データコード8bit
    byte data1 = (byte)((signals&amp;gt;&amp;gt;8)&amp;amp;B11111111);
    Serial.println(&amp;quot;Data code:&amp;quot;);
    Serial.print(&amp;quot;    &amp;quot;); Serial.print(data1,BIN); Serial.print(&amp;quot; = &amp;quot;); Serial.println(data1,HEX);
    // データコード(反転)8bit
    byte data2 = (byte)(signals&amp;amp;B11111111);
    Serial.print(&amp;quot;    &amp;quot;); Serial.print(data2,BIN); Serial.print(&amp;quot; = &amp;quot;); Serial.println(data2,HEX);
    // データ検証
    byte vf = data1^data2;
    Serial.println(&amp;quot;Data verify: &amp;quot;);
    Serial.print(&amp;quot;    &amp;quot;); Serial.print(data1,HEX); Serial.print(&amp;quot; xor &amp;quot;); Serial.print(data2,HEX); Serial.print(&amp;quot; = &amp;quot;); Serial.println(vf,HEX);
    if (vf == 0xFF) Serial.println(&amp;quot;     [ VERIFIED ]&amp;quot;);
    else Serial.println(&amp;quot;     [ ERROR ]&amp;quot;);
    // おわり
    Serial.println(&amp;quot;------- ------ -------&amp;quot;);
    Serial.println(&amp;quot;&amp;quot;);
    signals = 0;
    signalCnt = -1;
    detected = false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみよう&#34;&gt;試してみよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/9.png&#34; alt=&#34;&#34; /&gt;
アップロードが完了したら、Tools -&amp;gt; Serial Monitor からシリアルモニタを表示させ、通信速度を「115200bps」に変更します。その状態のまま、リモコンをフォトダイオードに近づけてボタンを押すと……&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/10.png&#34; alt=&#34;&#34; /&gt;
いくつか値が表示されましたね！
点線で囲まれたブロックが信号の1セットで、中身には「Custom code」「Data code」「Data verify」が入っています。
「Custom code」は製品固有のコードで、同じリモコンだと基本的に固定の値です。&lt;/p&gt;

&lt;p&gt;色々ボタンを押していると、「Data code」が変化するようすがわかります。「Data verify」は、信号に含まれている2つのデータを照合して、信号が壊れていないかを確認するためのものです。
&lt;img src=&#34;https://dotstud.io/img/blog/117/11.png&#34; alt=&#34;&#34; /&gt;
自宅の扇風機のリモコンで試してみたところ、確かにボタンで値が変わっていることがわかりました。&lt;/p&gt;

&lt;h2 id=&#34;応用編&#34;&gt;応用編&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/117/12.png&#34; alt=&#34;&#34; /&gt;
Arduino IDEには「シリアルプロッタ」という、グラフを描画できる機能が備わっています。それを利用して、リモコンの信号波形を描画してみるとこんな感じになりました。規則的な波形をところどころに確認することができます。&lt;/p&gt;

&lt;p&gt;また、今回使用したマイコンボード「Arduino Due」は、USB接続の外付けマウス・外付けキーボードとして簡単に動作させることができるライブラリが備わっています。例えば、今回のプログラムにこの機能を取り入れて少し書き換えるだけで、普段使っているTVリモコンでパソコンの動画プレイヤーを制御、なんてこともすぐにできちゃいます。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;いかがでしたでしょうか？
フォトダイオードはいろんな種類がありますが、Arduinoのようなマイコンボードを使えば意外と簡単に光センサを作ることができます。この機会にぜひ作ってみては。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ライブで大活躍！音に反応して光るサバゲーマスク！</title>
      <link>https://dotstud.io/blog/gyaruden-mao-led-mask/</link>
      <pubDate>Fri, 21 Jul 2017 18:09:27 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-mao-led-mask/</guid>
      
      <description>

&lt;p&gt;どうも！dotstudio広報兼テクニカルライターのマオです。&lt;strong&gt;ギャルによるギャルのためのテクノロジーを提案していく電子工作ユニット、ギャル電&lt;/strong&gt;で活動をしてます！&lt;/p&gt;

&lt;p&gt;この記事では、LEDを音センサーに反応させる電子工作を紹介していきたいと思いまぁす！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回は音センサーを使うとのことで、ライブやフェスなどにつけていくと鬼盛れの&lt;strong&gt;”音に反応するパンクロックなマスク”&lt;/strong&gt;を作りました！&lt;/p&gt;

&lt;p&gt;では早速作り方を紹介していきたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;準備するもの&#34;&gt;準備するもの&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;電子部品類&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1399/&#34;&gt;フルカラーシリアルLEDテープ(1m)通称NeoPixel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1680/&#34;&gt;エレクトレットマイクアンプモジュールMAX4466(音センサー)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1330/&#34;&gt;FLORA(マイコン)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://item.rakuten.co.jp/3rwebshop/3r-ps2600/&#34;&gt;小型モバイルバッテリー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;工具類&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;はんだ,はんだごて&lt;/li&gt;
&lt;li&gt;フックアップワイヤー&lt;/li&gt;
&lt;li&gt;ワイヤーストリッパー&lt;/li&gt;
&lt;li&gt;ニッパ&lt;/li&gt;
&lt;li&gt;ハサミ&lt;/li&gt;
&lt;li&gt;マイクロUSB(TypeB)&lt;/li&gt;
&lt;li&gt;パソコン&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;側の部分&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サバゲーのマスク&lt;/li&gt;
&lt;li&gt;100均に売っているフェルト2枚&lt;/li&gt;
&lt;li&gt;シールフェルト（半面がシールのもの）1枚&lt;/li&gt;
&lt;li&gt;マジックテープ&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;はんだづけする前に&#34;&gt;はんだづけする前に&lt;/h3&gt;

&lt;p&gt;はんだづけ初心者または慣れていない方は、一回はんだづけのやり方を&lt;a href=&#34;http://www.murata.com/ja-jp/campaign/ads/japan/elekids/ele/craft/knack/soldering&#34;&gt;こちらのサイト&lt;/a&gt;で見てからするのをオススメします。
またはんだづけする時や電線を切断する時、飛び散ることがあります。そのため、&lt;strong&gt;安全メガネなどを装着して目を守る&lt;/strong&gt;ようにしてください。&lt;/p&gt;

&lt;p&gt;はんだづけする際は配線の準備が必要です。今回は被覆が付いているフックアップワイヤーを配線として使いました。
&lt;img src=&#34;https://dotstud.io/img/blog/114/2.png&#34; alt=&#34;&#34; /&gt;
フックアップワイヤーは被覆をワイヤーストリッパーで約2~4mm程度剥きましょう。ワイヤーストリッパーの使い方は&lt;a href=&#34;http://diytools1.com/2016/04/22/post-14009/&#34;&gt;こちら&lt;/a&gt;を参考にしてください。また、フックアップワイヤーの長さは必要に応じて調整しながら切断してください。&lt;/p&gt;

&lt;h3 id=&#34;さっそくはんだづけ&#34;&gt;さっそくはんだづけ！&lt;/h3&gt;

&lt;p&gt;今回は以下のように配線しました。
&lt;img src=&#34;https://dotstud.io/img/blog/114/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ピンの配置はこちらです。
&lt;img src=&#34;https://dotstud.io/img/blog/114/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;neopixelをはんだづけ&#34;&gt;NeoPixelをはんだづけ&lt;/h2&gt;

&lt;p&gt;合計44個のNeoPixel(LED)をはんだづけしていきます。
&lt;img src=&#34;https://dotstud.io/img/blog/114/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで注意する点としては、&lt;strong&gt;NeoPixelの向き&lt;/strong&gt;です。下のNeoPixelの画像を見てみると矢印が書いてあります。この矢印は電流が流れる方向です。この&lt;strong&gt;矢印を逆にしてはんだづけしてしまうとNeoPixelがつかなくなる&lt;/strong&gt;のでここの点は要注意してはんだづけしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで以上のようにはんだづけしたら、100均一で買った半面シールのフェルトのシール側にNeoPixelを貼ります。
&lt;img src=&#34;https://dotstud.io/img/blog/114/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;貼り終わったらFlora側と繋ぐ配線をフェルトに通します。配線を通す穴は適当に開けてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、NeoPixelの上から普通のフェルトを貼り付けてマスクの形に合わせて余計な部分を切り捨てます。
&lt;img src=&#34;https://dotstud.io/img/blog/114/9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;floraとマイクアンプ-neopixelをはんだづけ&#34;&gt;Floraとマイクアンプ、NeoPixelをはんだづけ&lt;/h2&gt;

&lt;p&gt;Flora(マイコン)とマイクアンプ(音センサー)のはんだづけをします。&lt;/p&gt;

&lt;p&gt;最後に先ほどフェルトに通したNeoPixelの配線をFloraにはんだづけしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これで光らせる部分完成です！&lt;/p&gt;

&lt;h3 id=&#34;プログラミングするための環境設定&#34;&gt;プログラミングするための環境設定&lt;/h3&gt;

&lt;p&gt;次にプログラミングするために環境設定を行います。&lt;/p&gt;

&lt;p&gt;今回使うFloraはArduino互換ボードなのでプログラミングする際に&lt;strong&gt;ArduinoIDE&lt;/strong&gt;というソフトウェアを使います。
このArduinoIDEはフリーソフトです。&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;から各自のパソコンにダウンロードしてください。&lt;/p&gt;

&lt;p&gt;また、Windowsユーザーの方は Floraの開発元のAdafruit社による「Windows Driver」をインストールする必要があります。&lt;a href=&#34;https://learn.adafruit.com/getting-started-with-flora/windows-setup&#34;&gt;こちらのサイト&lt;/a&gt;を参照して進めてください。（Mac・Linuxのユーザーの方はインストールする必要はありません）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;マイコンボードのインストレーション&#34;&gt;マイコンボードのインストレーション&lt;/h4&gt;

&lt;p&gt;ArduinoIDEを立ち上げてまだすぐプログラミングはできません。
まず、AduinoIDEにFloraというマイコンボードを知ってもらうためボードのインストールをします。&lt;/p&gt;

&lt;p&gt;Arduino &amp;gt; Preferences をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://www.adafruit.com/package_adafruit_index.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上記のAdafruitのURLをコピーして、追加のボードマネージャーのURLに貼り、OKをクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コピー＆ペーストが完了したら、ツール &amp;gt; マイコンボード &amp;gt; ボードマネージャーをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/114/13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;すると、このような画面が表示されます。検索欄に「Adafruit AVR Boards」を入力し、インストールしましょう。ここまでで、ボードのインストレーションは終わりです。
&lt;img src=&#34;https://dotstud.io/img/blog/114/14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;ライブラリのインストール&#34;&gt;ライブラリのインストール&lt;/h4&gt;

&lt;p&gt;次に、NeoPixel を光らせるために必要なライブラリをインストールします。スケッチ &amp;gt; ライブラリをインクルード &amp;gt; ライブラリを管理 をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;画面が表示されるので、検索欄に「Neopixel」と入力しましょう。下記のようになります。「Adafruit Neopixel by Adafruit」を選択してインストールしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/114/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;プログラミングを書き込む&#34;&gt;プログラミングを書き込む！&lt;/h3&gt;

&lt;p&gt;以下のプログラムをArduinoIDEにコピー&amp;amp;ペーストしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;

#define N_PIXELS  44  //　LEDの個数
#define MIC_PIN    9  // Floraに接続しているマイクロフォンのGPIO
#define LED_PIN    6  // NeoPixel LEDがFloraに接続しているGPIO
#define DC_OFFSET  0  // マイクロフォンのDCオフセット信号 - わからない場合0に設定
#define NOISE     100  // マイクロフォン信号のNoise/hum/interference
#define SAMPLES   60  // ダイナミックレベルの調整のためのバッファーの長さ
#define TOP       (N_PIXELS +1) // ドットをスケールから少し外れるようにする

byte
  peak      = 0,      
  dotCount  = 0,      
  volCount  = 0;     

int
  vol[SAMPLES],       
  lvl       = 10,    
  minLvlAvg = 0,      
  maxLvlAvg = 512;

Adafruit_NeoPixel  strip = Adafruit_NeoPixel(N_PIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);

void setup() {

  memset(vol,0,sizeof(int)*SAMPLES);//Thanks Neil!
  strip.begin();
}
void loop() {
  uint8_t  i;
  uint16_t minLvl, maxLvl;
  int      n, height;
  n   = analogRead(MIC_PIN);                 
  n   = abs(n - 512 - DC_OFFSET);            
  n   = (n &amp;lt;= NOISE) ? 0 : (n - NOISE);      
  lvl = ((lvl * 7) + n) &amp;gt;&amp;gt; 3;   


  height = TOP * (lvl - minLvlAvg) / (long)(maxLvlAvg - minLvlAvg);

  if(height &amp;lt; 0L)       height = 0;      
  else if(height &amp;gt; TOP) height = TOP;
  if(height &amp;gt; peak)     peak   = height;


  uint8_t bright = 255;   
#ifdef POT_PIN            
   bright = analogRead(POT_PIN);  

#endif
  strip.setBrightness(bright);   

  for(i=0; i&amp;lt;N_PIXELS; i++) {  
    if(i &amp;gt;= height)               
       strip.setPixelColor(i,   0,   0, 0);
    else
       strip.setPixelColor(i,Wheel(map(i,0,strip.numPixels()-1,30,150)));
    }

   strip.show();

  vol[volCount] = n;                      
  if(++volCount &amp;gt;= SAMPLES) volCount = 0;


  minLvl = maxLvl = vol[0];
  for(i=1; i&amp;lt;SAMPLES; i++) {
    if(vol[i] &amp;lt; minLvl)      minLvl = vol[i];
    else if(vol[i] &amp;gt; maxLvl) maxLvl = vol[i];
  }

  if((maxLvl - minLvl) &amp;lt; TOP) maxLvl = minLvl + TOP;
  minLvlAvg = (minLvlAvg * 63 + minLvl) &amp;gt;&amp;gt; 6;
  maxLvlAvg = (maxLvlAvg * 63 + maxLvl) &amp;gt;&amp;gt; 6;
}


uint32_t Wheel(byte WheelPos) {
  if(WheelPos &amp;lt; 85) {
   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  } else if(WheelPos &amp;lt; 170) {
   WheelPos -= 85;
   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else {
   WheelPos -= 170;
   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、ArduinoIDEのツールに行きボードを&amp;rdquo;Adafuit Flora&amp;rdquo;に選択してください。
次にシリアルポートを(Adafruit Flora)に選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/114/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、コンパイル（検証）ボタンをクリックし、プログラムに問題がないかチェックします。OKならば、書き込みのボタンをクリックするとプログラムがFLORAマイコンに書き込まれます。赤いランプの点滅が終わると書き込みが終了した状態なので、そうなったらケーブルを外しても大丈夫です。&lt;/p&gt;

&lt;h3 id=&#34;仕上げ&#34;&gt;仕上げ&lt;/h3&gt;

&lt;p&gt;NeoPixelの裏側にある、Floraとマイクアンプ側の面をフェルトを適当な形に切って、覆います。
ここで覆ったフェルトとFlora側のフェルトが付け剥がしできるようにマジックテープなどで固定します。
&lt;img src=&#34;https://dotstud.io/img/blog/114/19.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/114/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最後にFlora側のフェルトが内向き(口に合わせる方)になるようサバゲーマスクに貼り合わせて、モバイルバッテリーをさしたら完成です〜！
&lt;img src=&#34;https://dotstud.io/img/blog/114/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;音があるとNeoPixelが反応して光ります！
&lt;img src=&#34;https://dotstud.io/img/blog/114/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;マスクつけてライブに遊びに行ったよ&#34;&gt;マスクつけてライブに遊びに行ったよ！&lt;/h3&gt;

&lt;p&gt;さっそくマスクをつけてライブに行ってきた！みんなに&lt;strong&gt;ニンジャスレイヤーみたい&lt;/strong&gt;だと褒められてまじなんかよくわからないけど、くノ一になった気分で嬉しかったっす。
&lt;img src=&#34;https://dotstud.io/img/blog/114/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回のライブでは以前ギャル電きょうこが記事で紹介した&lt;a href=&#34;https://dotstud.io/blog/gyaruden-party-people-daigoro/&#34;&gt;&lt;strong&gt;光る大五郎&lt;/strong&gt;&lt;/a&gt;とフル装備で光りまくって&lt;strong&gt;振る舞い大五郎&lt;/strong&gt;をしてきた。ビカビカする中お酒をみんなに振る舞う感じ、&lt;strong&gt;まじサグみしかなくて超エモ&lt;/strong&gt;ってなった。
&lt;img src=&#34;https://dotstud.io/img/blog/114/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こんな感じで、&lt;strong&gt;とりま光らせてパーディーにいくとまじアゲぽよ&lt;/strong&gt;になって超楽しくなるから、みんなも&lt;strong&gt;サグい電子工作してパーティーを盛り上げよう&lt;/strong&gt;！卍
&lt;img src=&#34;https://dotstud.io/img/blog/114/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ESP8266を使って京急が遅延すると光るガジェットを作ってみた</title>
      <link>https://dotstud.io/blog/pokio-esp-keikyu-chien/</link>
      <pubDate>Tue, 13 Jun 2017 19:28:32 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/pokio-esp-keikyu-chien/</guid>
      
      <description>

&lt;p&gt;こんにちは、京急が大好きなポキオです。&lt;/p&gt;

&lt;p&gt;普段はAndroidエンジニアをやってますが、週末は趣味でArduinoやESP8266を触って心を落ち着かせています。先日、「京急が遅延すると光るガジェット」を作って&lt;a href=&#34;https://iotlt.connpass.com/&#34;&gt;IoTLT&lt;/a&gt;で発表を行ってきました。&lt;/p&gt;

&lt;p&gt;今回は、そこで発表したガジェットの作成段階や、技術的な仕組みを紹介します。（発表後に一部パーツ・コーディングを変更しています）&lt;/p&gt;

&lt;h2 id=&#34;今回作るもの&#34;&gt;今回作るもの&lt;/h2&gt;

&lt;p&gt;ESP8266というWi-Fiモジュールを搭載した開発ボード「ESPr® Developer」を使って京急のホームページから運行情報を取得し、遅延していたらLEDを光らせる仕組みを作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/01_map.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Air（13-inch、Mid 2013）&lt;/li&gt;
&lt;li&gt;OS X Yosemite（v10.10.5）&lt;/li&gt;
&lt;li&gt;Arduino IDE 1.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ESPr® DeveloperESP8266&lt;/li&gt;
&lt;li&gt;マイコン内臓RGB LED&lt;/li&gt;
&lt;li&gt;光らせたいガジェット（今回はBトレインショーティ）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;主なパーツ&#34;&gt;主なパーツ&lt;/h2&gt;

&lt;h3 id=&#34;espr-developer&#34;&gt;ESPr® Developer&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/02_esper.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://www.switch-science.com/catalog/2500/&#34;&gt;スイッチサイエンス&lt;/a&gt;さんで売られている、ESP8266というWi-Fiモジュールを搭載した開発ボードです。素のESP8266を直接触るのはハードルが高いですが、USB-シリアル変換やレギュレータ、リセットスイッチなど実装済みで、Arduino IDEでも開発できるため便利です。&lt;/p&gt;

&lt;p&gt;ただし、筆者の開発環境ではArduino IDEからコードを流し込む際に、一手間必要でした。詳しくはこちら。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://qiita.com/shanonim/items/68fab6dc28b72b31a258&#34;&gt;ESPr Developer（ESP-WROOM-02開発ボード）で &amp;ldquo;warning: espcomm_sync failed&amp;rdquo; と表示される場合の対処&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;マイコン内蔵rgb-led&#34;&gt;マイコン内蔵RGB LED&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/03_led.png&#34; alt=&#34;画像&#34; /&gt;
秋葉原の&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-08412/&#34;&gt;秋月電子通商&lt;/a&gt;さんで1個40円で売られているものを使用します。通常のLEDは足が2本ですが、こちらは足が4本。これらを制御することで、様々な色でLEDを光らせることができます。ESP8266（Arduino）向けに便利なライブラリが公開されているので、今回はこれを使ってコーディングしていきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/adafruit/Adafruit_NeoPixel&#34;&gt;Adafruit NeoPixel Library&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bトレインショーティー&#34;&gt;Bトレインショーティー&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/04_train.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://bandai-hobby.net/train/&#34;&gt;Bトレインショーティー&lt;/a&gt;はバンダイさんから発売されている、自分で組み立てるタイプの鉄道模型です。特徴は、何と言っても可愛さ。実車のディテールを表現しつつ、車両の長さをギュッと縮めてコミカルなルックスになっています。今回は（もちろん京急の）2100形をチョイス。京急の中で好きな車両の一つです。&lt;/p&gt;

&lt;h2 id=&#34;ガジェットを作ってみる&#34;&gt;ガジェットを作ってみる&lt;/h2&gt;

&lt;h3 id=&#34;京急の2100形車両の組み立て&#34;&gt;京急の2100形車両の組み立て&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/05_keikyu1.png&#34; alt=&#34;画像&#34; /&gt;
なにはともあれ、京急の車両を組み立てるところから始めます。Bトレインショーティーの京急2100形は、塗装済みで接着剤不要で組み立てができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/06_keikyu2.png&#34; alt=&#34;画像&#34; /&gt;
久しぶりのプラモデルにテンションがアガります。&lt;/p&gt;

&lt;h3 id=&#34;マイコン内蔵rgb-ledを埋め込む&#34;&gt;マイコン内蔵RGB LEDを埋め込む&lt;/h3&gt;

&lt;p&gt;出来上がった京急の車両にLEDを埋め込んでいきます。ここで便利なのがサンハヤトさんの&lt;a href=&#34;http://www.sunhayato.co.jp/material2/index.php/item?cell003=%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF%E8%A3%BD%E5%93%81&amp;amp;cell004=%E4%B8%AD%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF&amp;amp;name=%E8%96%84%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF+UB-THN01&amp;amp;id=722&amp;amp;label=1&#34;&gt;ハサミで切れるユニバーサル基板&lt;/a&gt;です。
&lt;img src=&#34;https://dotstud.io/img/blog/099/07_universal1.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;謳い文句の通り、ハサミで自由にカットができて、今回のような小さい車両にも基板を収めることができます。
&lt;img src=&#34;https://dotstud.io/img/blog/099/08_universal2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こんな感じで簡単に、そしてその場で車両ピッタリの基板ができました。
&lt;img src=&#34;https://dotstud.io/img/blog/099/09_rgb_led.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;

&lt;p&gt;マイコン内蔵RGB LEDは先述の通り足が4本あり、電源（VDD）とグラウンド（GND）に加えて、制御信号の入出力（DIN・DO）があります。DIN・DOは図のように数珠つなぎで配線します。
&lt;img src=&#34;https://dotstud.io/img/blog/099/10_rgb_led2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;電源とグラウンドは共通で、それぞれESPr® DeveloperのVOUTとGNDに接続します。大元のDINはPIN4に接続します。&lt;/p&gt;

&lt;h3 id=&#34;遅延情報の取得ロジック&#34;&gt;遅延情報の取得ロジック&lt;/h3&gt;

&lt;p&gt;WebAPI等は使用せずに、10分に一度、&lt;a href=&#34;http://unkou.keikyu.co.jp/&#34;&gt;京急の運行情報ページ&lt;/a&gt;にアクセスして情報を取得します。&lt;/p&gt;

&lt;p&gt;ESPr® Developerから運行情報の文言をHTTP-GETで取得して、その文言に&lt;strong&gt;特定の文字列&lt;/strong&gt;が含まれるかどうかで運行状態を推測します。具体的には・・・&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「&lt;strong&gt;受託&lt;/strong&gt;」という文字列が含まれていたら、他社線からの振替輸送受託のために遅延していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;見合わせ&lt;/strong&gt;」という文字列が含まれていたら、運転見合わせが発生していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;乱れ&lt;/strong&gt;」という文字列が含まれていたら、ダイヤが大幅に乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;遅れ&lt;/strong&gt;」や「&lt;strong&gt;運休&lt;/strong&gt;」が含まれていたら、ダイヤが少し乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;平常&lt;/strong&gt;」が含まれていたら、平常運転であると判断する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このような感じです。そして、運転見合わせであれば赤い点滅、ダイヤが少し乱れているときは黄色い点滅をさせるといった感じで、運行状態に応じてマイコン内蔵RGB LEDの光り方を変えることで、運行状態をひと目で把握することができます。&lt;/p&gt;

&lt;p&gt;ちなみに、他社線からの振替輸送受託が理由で京急が遅延しているときは、個人的にすこし残念な気持ちになるので、光り方を変えています（笑）&lt;/p&gt;

&lt;h3 id=&#34;espr-developerのコーディング&#34;&gt;ESPr® Developerのコーディング&lt;/h3&gt;

&lt;p&gt;かなり無理矢理ですが、こんな感じでコーディングしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;ESP8266WiFi.h&amp;gt;
#include &amp;lt;WiFiClient.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;

#define PIN 4 // DINを接続しているPIN
#define NUMLED 4 // マイコン内蔵RGB LEDの個数
#define SSID &amp;quot;（Wi-FiアクセスポイントのSSID）&amp;quot;
#define PASSWORD &amp;quot;（Wi-Fiアクセスポイントのパスワード）&amp;quot;
#define KEIKYU_PAGE &amp;quot;unkou.keikyu.co.jp&amp;quot; // 運行情報のページ
#define INTERVAL_SEC 10 * 60 // ポーリング間隔

Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMLED, PIN, NEO_RGB + NEO_KHZ800);

void setup() {
  // Serialの初期化
  Serial.begin(115200);
  Serial.println(&amp;quot;&amp;quot;);

  // マイコン内蔵RGB LEDの初期化
  pixels.begin();
}

void loop() {
  // Wi-Fi接続開始
  connectWifi();

  // 京急の運行ページから運行情報取得
  String trainInfo = getTrainInfo();

  // Wi-Fi接続終了
  disconnectWifi();

  // 「受託」という文字が含まれていたら、他社からの振替輸送受託で遅延していると判断
  if (trainInfo.indexOf(&amp;quot;受託&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;振替輸送受託！&amp;quot;);
    blinkLikePartyPeople(INTERVAL_SEC);
    return;
  }

  // 「見合わせ」という文字が含まれていたら、運転見合わせが発生していると判断
  if (trainInfo.indexOf(&amp;quot;見合わせ&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;運転見合わせ！&amp;quot;);
    blinkRed(INTERVAL_SEC);
    return;
  }

  // 「乱れ」という文字が含まれていたら、ダイヤが大幅に乱れていると判断
  if (trainInfo.indexOf(&amp;quot;乱れ&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;大幅に乱れている！&amp;quot;);
    blinkYellowAndRed(INTERVAL_SEC);
    return;
  }

  // 「遅れ」「運休」という文字が含まれていたら、ダイヤが少し乱れていると判断
  if (trainInfo.indexOf(&amp;quot;遅れ&amp;quot;) &amp;gt; 0 || trainInfo.indexOf(&amp;quot;運休&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;遅延！&amp;quot;);
    blinkYellow(INTERVAL_SEC);
    return;
  }

  // 「平常」という文字が含まれていたら、平常運転をしていると判断
  if (trainInfo.indexOf(&amp;quot;平常&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;たぶん平常通り運転！&amp;quot;);
    delay(INTERVAL_SEC * 1000);
    return;
  }

  // 運行情報取得エラーかもしれないので、10秒待ってもう一度取得する
  blinkWhite(10);
}

// Wi-Fi接続
void connectWifi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASSWORD);

  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(&amp;quot;.&amp;quot;);
    blinkWhite(3);
  }

  Serial.println(&amp;quot;Wi-Fi接続完了&amp;quot;);
}

// Wi-Fi切断
void disconnectWifi() {
  WiFi.disconnect();
  Serial.println(&amp;quot;Wi-Fi切断完了&amp;quot;);
}

// 運行情報の文字列取得
String getTrainInfo() {
  WiFiClient client;

  if ( !client.connect(KEIKYU_PAGE, 80) ) {
    // 接続エラー
    return String(&amp;quot;&amp;quot;);
  }

  // HTTP-GET
  // レスポンスのLengthが長すぎるとエラーになることがあったのでRangeを指定している
  client.print(String(&amp;quot;GET &amp;quot;) + &amp;quot;/&amp;quot; + &amp;quot; HTTP/1.1\r\n&amp;quot; +
               &amp;quot;Host: &amp;quot; + KEIKYU_PAGE + &amp;quot;\r\n&amp;quot; +
               &amp;quot;Range: bytes=8000-9000\r\n&amp;quot; +
               &amp;quot;Connection: close\r\n\r\n&amp;quot;);
  client.println();

  delay(1000);

  String body = &amp;quot;&amp;quot;;
  String trainInfo = &amp;quot;&amp;lt;!-- ======================== 運行情報 =================================== --&amp;gt;&amp;quot;;

  while (client.available()) {
    body += client.readStringUntil(&#39;\r&#39;);
  }

  // レスポンスから運行情報部分だけを切り抜く
  body = body.substring(body.indexOf(trainInfo) + trainInfo.length());
  body = body.substring(0, body.indexOf(trainInfo));

  return body;
}

// 白い点滅
void blinkWhite(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, i);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, i);
    }

    count++;
  }
}

//　黄色い点滅
void blinkYellow(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, 0);
    }

    count++;
  }
}

// 黄色と赤の点滅
void blinkYellowAndRed(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, 0, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, 0, 0);
    }

    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, 0);
    }

    count++;
    count++;
  }
}

// 赤い点滅
void blinkRed(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, 0, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, 0, 0);
    }

    count++;
  }
}

// パリピな輝き
void blinkLikePartyPeople(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 20; i++) {
      setRandomColor();
      delay(50);
    }

    count++;
  }
}

// LEDを指定した色で光らせる
void setColor(int r, int g, int b) {
  for (int i = 0 ; i &amp;lt; NUMLED; i++) {
    pixels.setPixelColor(i, pixels.Color(r, g, b));
    pixels.show();
  }
  delay(10);
}

// LEDをランダムな色で光らせる
void setRandomColor() {
  for (int i = 0 ; i &amp;lt; NUMLED; i++) {
    pixels.setPixelColor(i, pixels.Color(64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 ));
    pixels.show();
  }
  delay(10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際に光らせてみたのがこちら。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/11_setting.png&#34; alt=&#34;画像&#34; /&gt;
情報取得中に実行される白い点滅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/12_late.png&#34; alt=&#34;画像&#34; /&gt;
運転見合わせ時に実行される赤い点滅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/13_transport.png&#34; alt=&#34;画像&#34; /&gt;
最後は他社線からの振替輸送受託時に実行されるパリピ点滅。画像では少しわかりづらいですね……。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は、京急が遅延していると光るガジェットをESPr® Developerをつかって作成しました。情報の取得方法はかなり力技でしたが、WEB上の情報を簡単に可視化できたことは良かったです。&lt;/p&gt;

&lt;p&gt;実際にこのガジェットは、職場のデスクで稼働していて、いつも京急の運行情報を知らせてくれます。今後は他社線バージョンの作成を検討しています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>電子工作でパリピな夏を独り占め！サイバーパンク大五郎！！</title>
      <link>https://dotstud.io/blog/gyaruden-party-people-daigoro/</link>
      <pubDate>Thu, 08 Jun 2017 20:03:04 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-party-people-daigoro/</guid>
      
      <description>

&lt;p&gt;はじめまして、ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案する電子工作ユニット、ギャル電で活動しておりまっす。夢はドンキでアルドゥイーノが買える世の中です。&lt;/p&gt;

&lt;p&gt;この記事では、&lt;strong&gt;”Lチカ以上、IoT未満”&lt;/strong&gt; な電子工作テクニックでも楽しく作れてすぐに遊べるアイテムを紹介していきたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;今回の工作は夏フェスでパリピにめっちゃモテるやつ&#34;&gt;今回の工作は夏フェスでパリピにめっちゃモテるやつ！&lt;/h2&gt;

&lt;p&gt;夏といえば、夏フェス！夏フェスといえばパリピ！パリピといえば酒！！！です。&lt;/p&gt;

&lt;p&gt;ということで、今回はパリピに激モテな電子工作、&lt;strong&gt;甲類焼酎大五郎４ℓペットボトル&lt;/strong&gt;を作ってみました。&lt;/p&gt;

&lt;h2 id=&#34;なぜ大五郎なのか&#34;&gt;なぜ大五郎なのか&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/1.png&#34; alt=&#34;&#34; /&gt;
渋谷の街を歩いていたらセンター街で片手にスマホ、片手に4ℓの大五郎（半分減ってる）をもっているギャルをみかけました。&lt;/p&gt;

&lt;p&gt;デニムのショーパンにベアトップ、そして大五郎。強めギャルファッションにこんなにも大五郎がジャストフィットしていてエモさしかありませんでした。&lt;/p&gt;

&lt;p&gt;このエモさにさらにLEDを加えたら、絶対に最高なものができる！光る大五郎とか超未来！！なんでみんな光らせないわけ？！超機会損失してる！！！！&lt;/p&gt;

&lt;p&gt;ないなら今すぐ作るしかない！というわけで、とりあえず大五郎を光らせることにしたのです。&lt;/p&gt;

&lt;h2 id=&#34;とりあえず光らす方法&#34;&gt;とりあえず光らす方法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;材料&#34;&gt;材料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モバイルバッテリー&lt;/li&gt;
&lt;li&gt;LEDテープ（WS2812B）&lt;/li&gt;
&lt;li&gt;MicroUSBケーブル&lt;/li&gt;
&lt;li&gt;ArduinoまたはArduino互換機（今回はGR-CITRUSとAdafruit Trinket５Vを使用しました）&lt;/li&gt;
&lt;li&gt;ジャンパワイヤと電線&lt;/li&gt;
&lt;li&gt;ブレッドボード&lt;/li&gt;
&lt;li&gt;両面テープ&lt;/li&gt;
&lt;li&gt;ダクトテープ&lt;/li&gt;
&lt;li&gt;大五郎4ℓ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ボードについては、わたしは小さくてUSBケーブルを差す口がもともとついているやつが好みなので、今回は&lt;strong&gt;GR-CITRUS&lt;/strong&gt;と&lt;strong&gt;Adafruit Trinket５V&lt;/strong&gt;を使ってみました。USBケーブルの口が付いたボードは、モバイルバッテリーをつなげば動くのでめっちゃ便利です。&lt;/p&gt;

&lt;p&gt;環境導入については、ボードの名前と自分の使っているPCのOSのバージョン（Windows XXとかMac OS XXとか）でググるとだいたい親切な先人の情報がみつかると思いまっす。&lt;/p&gt;

&lt;h3 id=&#34;配線は3本だからそんなに難しくない&#34;&gt;配線は3本だからそんなに難しくない&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/3.png&#34; alt=&#34;&#34; /&gt;
NeoPixel LEDテープ（WS2812B）は、GND、５V、信号（D0）の三本の線をそれぞれArduino（または互換機）のGND、５V、デジタルピンにつなぐと光らせることができます。&lt;/p&gt;

&lt;p&gt;今回の光る大五郎のように、底面とハンドルの部分だけLEDを使いたい場合は、LEDテープを光らせたい部分の長さに切ってテープとテープの間を電線で3本つなぎなおしたらオッケーです。&lt;/p&gt;

&lt;p&gt;配線に必要な電線の長さは、適当に実物において測りました。仮置きするときはマスキングテープで貼るとやりやすいです。&lt;/p&gt;

&lt;h3 id=&#34;ledを光らせるプログラムを入れる&#34;&gt;LEDを光らせるプログラムを入れる&lt;/h3&gt;

&lt;h4 id=&#34;gr-citrus&#34;&gt;GR-CITRUS&lt;/h4&gt;

&lt;p&gt;GR-CITRUSはWebコンパイラを使ってブラウザでスケッチを作成することができます。詳しい書き込み方法は下記を参照してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;http://gadget.renesas.com/ja/product/citrus_sp2.html&#34;&gt;GR-CITRUS 特設Webコンパイラでスケッチ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Adafruit_NeoPixcel.cpp&lt;/code&gt;と&lt;code&gt;Adafruit_NeoPixel.h&lt;/code&gt;の二つのファイルを下記ページからダウンロードして、GR-CITRUSで作成したプロジェクトにアップロードする必要があります。（Webコンパイラ使用時）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/adafruit/Adafruit_NeoPixel&#34;&gt;https://github.com/adafruit/Adafruit_NeoPixel&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Arduino.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#ifdef __AVR__
  #include &amp;lt;avr/power.h&amp;gt;
#endif

//neopixcel用の設定部分
//neopixelを接続するPINを設定
#define PIN_LED 12
//neopixelのLEDの数を設定
#define NUM_LEDS 12

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN_LED, NEO_GRB + NEO_KHZ800);

bool oldState = HIGH;
int showType = 0;

void showStrip() {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.show();
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   FastLED.show();
 #endif
}

void setPixel(int Pixel, byte red, byte green, byte blue) {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.setPixelColor(Pixel, strip.Color(red, green, blue));
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   leds[Pixel].r = red;
   leds[Pixel].g = green;
   leds[Pixel].b = blue;
 #endif
}

void setAll(byte red, byte green, byte blue) {
  for(int i = 0; i &amp;lt; 17; i++ ) {
    setPixel(i, red, green, blue);
  }
  showStrip();
}

// ここからNeoPixelのアニメーション設定


void FadeInOut(byte red, byte green, byte blue){
  float r, g, b;

  for(int k = 0; k &amp;lt; 256; k=k+1) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }

  for(int k = 255; k &amp;gt;= 0; k=k-2) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }
}


void Strobe(byte red, byte green, byte blue, int StrobeCount, int FlashDelay, int EndPause){
  for(int j = 0; j &amp;lt; StrobeCount; j++) {
    setAll(red,green,blue);
    showStrip();
    delay(FlashDelay);
    setAll(0,0,0);
    showStrip();
    delay(FlashDelay);
  }

 delay(EndPause);
}


void Sparkle(byte red, byte green, byte blue, int SpeedDelay) {
  int Pixel = random(NUM_LEDS);
  setPixel(Pixel,red,green,blue);
  showStrip();
  delay(SpeedDelay);
  setPixel(Pixel,0,0,0);
}

void RunningLights(byte red, byte green, byte blue, int WaveDelay) {
  int Position=0;

  for(int i=0; i&amp;lt;NUM_LEDS*2; i++)
  {
      Position++; // = 0; //Position + Rate;
      for(int i=0; i&amp;lt;NUM_LEDS; i++) {
        // sine wave, 3 offset waves make a rainbow!
        //float level = sin(i+Position) * 127 + 128;
        //setPixel(i,level,0,0);
        //float level = sin(i+Position) * 127 + 128;
        setPixel(i,((sin(i+Position) * 127 + 128)/255)*red,
                   ((sin(i+Position) * 127 + 128)/255)*green,
                   ((sin(i+Position) * 127 + 128)/255)*blue);
      }

      showStrip();
      delay(WaveDelay);
  }
}

byte * Wheel(byte WheelPos) {
  static byte c[3];

  if(WheelPos &amp;lt; 85) {
   c[0]=WheelPos * 3;
   c[1]=255 - WheelPos * 3;
   c[2]=0;
  } else if(WheelPos &amp;lt; 170) {
   WheelPos -= 85;
   c[0]=255 - WheelPos * 3;
   c[1]=0;
   c[2]=WheelPos * 3;
  } else {
   WheelPos -= 170;
   c[0]=0;
   c[1]=WheelPos * 3;
   c[2]=255 - WheelPos * 3;
  }

  return c;
}


void rainbowCycle(int SpeedDelay) {
  byte *c;
  uint16_t i, j;

  for(j=0; j&amp;lt;256*5; j++) { // 5 cycles of all colors on wheel
    for(i=0; i&amp;lt; NUM_LEDS; i++) {
      c=Wheel(((i * 256 / NUM_LEDS) + j) &amp;amp; 255);
      setPixel(i, *c, *(c+1), *(c+2));
    }
    showStrip();
    delay(SpeedDelay);
  }
}


void Twinkle(byte red, byte green, byte blue, int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),red,green,blue);
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}
void TwinkleRandom(int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),random(0,255),random(0,255),random(0,255));
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}

void setup()
{
    pinMode(PIN_LED0, OUTPUT);
    digitalWrite(PIN_LED, LOW);
   #if defined (__AVR_ATtiny85__)
   if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  strip.begin();
  strip.show();
}

void loop()
{
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    Twinkle(0xff, 40, 99, 10, 50, false);
    Twinkle(0xff, 40, 99, 10, 50, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    RunningLights(0x26,0xFF,0x7D, 50);
   RunningLights(0x26,0xFF,0x7D, 50);
    RunningLights(0x26,0xFF,0x7D, 50);
    RunningLights(0xDD,0xFF,0x33, 50);
     RunningLights(0xDD,0xFF,0x33, 50);
      RunningLights(0xDD,0xFF,0x33, 50);
    RunningLights(0xFF,0xAE,0x0D, 50);
    RunningLights(0xFF,0xAE,0x0D, 50);
    RunningLights(0xFF,0xAE,0x0D, 50);
    RunningLights(0xFF,0x21,0x21, 50);
    RunningLights(0xFF,0x21,0x21, 50);
    RunningLights(0xFF,0x21,0x21, 50);
    RunningLights(0xFF,0x54,0x93, 50);
    RunningLights(0xFF,0x54,0x93, 50);
    RunningLights(0xFF,0x54,0x93, 50);
    RunningLights(0x7A,0x7F,0xFF, 50);
    RunningLights(0x7A,0x7F,0xFF, 50);
    RunningLights(0x7A,0x7F,0xFF, 50);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    rainbowCycle(20);

  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;adafruit-trinket&#34;&gt;Adafruit Trinket&lt;/h4&gt;

&lt;p&gt;TrinketはArduino IDEでスケッチを作成し書き込みます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://learn.adafruit.com/introducing-trinket&#34;&gt;Introduction Trinket&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#ifdef __AVR__
  #include &amp;lt;avr/power.h&amp;gt;
#endif

//neopixcel用の設定部分

//neopixelを接続するPINを設定
#define PIN_LED 4

//neopixelのLEDの数を設定
#define NUM_LEDS 12

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN_LED, NEO_GRB + NEO_KHZ800);

bool oldState = HIGH;
int showType = 0;

void showStrip() {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.show();
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   FastLED.show();
 #endif
}

void setPixel(int Pixel, byte red, byte green, byte blue) {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.setPixelColor(Pixel, strip.Color(red, green, blue));
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   leds[Pixel].r = red;
   leds[Pixel].g = green;
   leds[Pixel].b = blue;
 #endif
}

void setAll(byte red, byte green, byte blue) {
  for(int i = 0; i &amp;lt; 17; i++ ) {
    setPixel(i, red, green, blue);
  }
  showStrip();
}

// ここからNeoPixelのアニメーション設定


void FadeInOut(byte red, byte green, byte blue){
  float r, g, b;

  for(int k = 0; k &amp;lt; 256; k=k+1) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }

  for(int k = 255; k &amp;gt;= 0; k=k-2) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }
}

void Strobe(byte red, byte green, byte blue, int StrobeCount, int FlashDelay, int EndPause){
  for(int j = 0; j &amp;lt; StrobeCount; j++) {
    setAll(red,green,blue);
    showStrip();
    delay(FlashDelay);
    setAll(0,0,0);
    showStrip();
    delay(FlashDelay);
  }

 delay(EndPause);
}

void Twinkle(byte red, byte green, byte blue, int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),red,green,blue);
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}
void TwinkleRandom(int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),random(0,255),random(0,255),random(0,255));
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}

//

void setup()
{
    pinMode(PIN_LED, OUTPUT);
    digitalWrite(PIN_LED, LOW);
   #if defined (__AVR_ATtiny85__)

   if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  strip.begin();
  strip.show();
}

void loop()
{
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    Twinkle(0xff, 40, 99, 10, 50, false);
    Twinkle(0xff, 40, 99, 10, 50, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TrinketはGR-CITRUS用に書いたコードをコピペしたらスケッチが大きすぎ！って怒られたのでだいぶコードを削りました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/4.png&#34; alt=&#34;&#34; /&gt;
配線のはんだ付けと動作テストが終わったら、ダクトテープで部品を大五郎に貼り付けます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/5.png&#34; alt=&#34;&#34; /&gt;
大五郎の背面に貼り付けられたバッテリーとボード、LEDテープ類。ダクトテープと両面テープがあればなんでも貼り付けられて超便利です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一般的には不審物としかいいようのない見た目&lt;/strong&gt;のため、電車や駅のトイレ等の公共の場所への置き忘れは要注意です。&lt;/p&gt;

&lt;h2 id=&#34;実際にパーティで大五郎を光らせてみよう&#34;&gt;実際にパーティで大五郎を光らせてみよう！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/109/6.png&#34; alt=&#34;&#34; /&gt;
作成した光る大五郎をさっそく現場(パーティ)に投入してみました。&lt;/p&gt;

&lt;p&gt;結果、&lt;strong&gt;最＆高&lt;/strong&gt;！！！！！&lt;/p&gt;

&lt;p&gt;暗いところで幻想的に光る大五郎は、インテリアとしても飲み物としても威力を発揮し新しいパーティアイテムとして流行る予感しかありませんでした。&lt;/p&gt;

&lt;p&gt;残念ながら盛り上がって飲みすぎたため、写真があまり残っていません……。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4ℓはなかなかに重い&lt;/strong&gt;ということと、&lt;strong&gt;酔っぱらったパリピにブレッドボードから配線を抜かれがち&lt;/strong&gt;ということ以外には特に問題なく使用できました。&lt;/p&gt;

&lt;p&gt;飲み終わったら、ダクトテープをはがして新しい大五郎にLEDユニットを貼るスタイルでいつでも光る大五郎が楽しめるので、改良してまた新たなパーティに出かけようと思います。&lt;/p&gt;

&lt;p&gt;みんなもさっそく作ってパーティにでかけちゃおう！パリピに超モテるよ☆&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wio NodeとIFTTTで簡単IoT！紫外線情報を取得してみよう</title>
      <link>https://dotstud.io/blog/wionode-ifttt-uv-ornament/</link>
      <pubDate>Tue, 06 Jun 2017 20:26:13 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/wionode-ifttt-uv-ornament/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioライターのゆっきん（&lt;a href=&#34;https://twitter.com/yukkin4649&#34;&gt;@yukkin4649&lt;/a&gt;）です。普段はシステムエンジニアをしています！&lt;/p&gt;

&lt;p&gt;IoTLTでのびすけさんから「電子工作でかわいいもの作ってくれ」という無茶ぶりを受けたので（笑）、女子の天敵&lt;strong&gt;紫外線指数を光って知らせてくれるオーナメント&lt;/strong&gt;を作ってみます！&lt;/p&gt;

&lt;p&gt;今回は「Wio Node」というスマホから設定できるデバイスと、ノンプログラミングでサービス連携ができる「IFTTT」というWebサービスを使います。初心者の私でも簡単にできたので是非挑戦してみてください。&lt;/p&gt;

&lt;h2 id=&#34;wio-nodeとは&#34;&gt;Wio Nodeとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/wio.png&#34; alt=&#34;&#34; /&gt;
「Wio Node」とはSeeed Studio社が開発したIoTデバイスで、Wi-Fiモジュールが初期搭載されています。対応のモジュールをさすだけで使え、スマートフォンで設定できるシンプルな設計が特徴です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.seeedstudio.com/Wio-Node-p-2637.html&#34;&gt;公式サイト&lt;/a&gt;によると&lt;strong&gt;IoTアプリケーション構築までたったの５分&lt;/strong&gt;だそうです。如何に簡単にできるのかが伺えます。&lt;/p&gt;

&lt;h2 id=&#34;iftttとは&#34;&gt;IFTTTとは&lt;/h2&gt;

&lt;p&gt;「IFTTT」では多数あるWebサービス同士を連携させ、自分好みの連携機能を作成することが出来ます。例えば【&lt;strong&gt;Twitterでお気に入りしたツイートをEvernoteに保存する&lt;/strong&gt;】等があります。&lt;/p&gt;

&lt;p&gt;他の人が作成した連携（ここではレシピと呼ぶ）も利用することができ、カスタマイズも可能。今回はこの「IFTTT」を使って紫外線取得サービスとWio Nodeを連携します。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;① Wio Node本体（&lt;a href=&#34;https://dotstud.io/shop/wionode-social-remote-control/&#34;&gt;購入ページ&lt;/a&gt;）&lt;br /&gt;
② Grove LED Bar v2.0（型番：SEEED-104020006）&lt;br /&gt;
③給電用のMicro USBケーブル&lt;br /&gt;
④ スマートフォン（iOSまたはAndroid端末）&lt;br /&gt;
⑤ グリーンオーナメント SS（100円均一で購入）&lt;br /&gt;
⑥ 紙&lt;br /&gt;
⑦ テープ&lt;br /&gt;
⑧ ペン&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Air 11-inch Early 2014&lt;/li&gt;
&lt;li&gt;OS X El Capitan　v10.11.6&lt;/li&gt;
&lt;li&gt;iPhone6（iOS 10.3.1）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/2.png&#34; alt=&#34;&#34; /&gt;
ざっくりとした構成です。IFTTTを使って「Today&amp;rsquo;s weather report」からUV値を取得し、Wio NodeのLED Barで表示させます。&lt;/p&gt;

&lt;p&gt;それでは早速作っていきましょう。&lt;/p&gt;

&lt;h3 id=&#34;1-wio-nodeの設定&#34;&gt;1. Wio Nodeの設定&lt;/h3&gt;

&lt;h4 id=&#34;インストールとセットアップ&#34;&gt;インストールとセットアップ&lt;/h4&gt;

&lt;p&gt;ここではWio Node開発用アプリのインストールと設定をしていきます。Wio NodeはPC・モバイルバッテリー等からUSBケーブルで接続し給電しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/3.png&#34; alt=&#34;&#34; /&gt;
App Store等でWio Nodeアプリを検索し、インストールします。iOSでは「Wio Link」、Androidでは「Wio」と言う名称です。&lt;/p&gt;

&lt;p&gt;本記事ではiOSの「Wio Link」の画面で説明していきます。&lt;/p&gt;

&lt;p&gt;iOS: &lt;a href=&#34;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&#34;&gt;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&lt;/a&gt;&lt;br /&gt;
Android: &lt;a href=&#34;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&#34;&gt;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/4.png&#34; alt=&#34;&#34; /&gt;
インストール後、アプリを立ち上げるとログイン画面が表示されるので〔SIGN UP〕のタブに切り替えてメールアドレスとパスワードを入力し〔SIGN UP〕のボタンを押下します。２回目以降は〔LOG IN〕タブから登録した情報を入力してログインして下さい。&lt;/p&gt;

&lt;p&gt;※他のサービスと連携が上手くいかないこともあるのでGoogleアカウントやFacebookアカウントの連携によるユーザー登録は非推奨とします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/5.png&#34; alt=&#34;&#34; /&gt;
Device Listの画面が表示されたら、右上の〔+〕又は中央の〔Add Your First Device〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/6.png&#34; alt=&#34;&#34; /&gt;
デバイスの選択画面が表示されるので〔Wio Node〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/7.png&#34; alt=&#34;&#34; /&gt;
セットアップ画面の図と同様にWio Node本体のボタンを４秒程押下します。青いライトの光り方が変わることを確認後、次の手順に移ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/8.png&#34; alt=&#34;&#34; /&gt;
iPhoneの〔設定〕アプリを起動します。〔Wi-Fi〕設定画面でWi-FiをONにし、〔Wio_XXXXXX〕を選択します。XXXXXXには割り当てられた文字列が入ります。（Android版はアプリの画面内で選択します。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/9.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeアプリに戻り、〔Goto wifi list〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/10.png&#34; alt=&#34;&#34; /&gt;
現在利用できる任意のWi-Fiを選択します。表示されない場合は右上の〔Refresh〕を押下して下さい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/11.png&#34; alt=&#34;&#34; /&gt;
選択したWi-Fiのパスワードを入力し、〔Join〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/12.png&#34; alt=&#34;&#34; /&gt;
この画面では、デバイスの名前をつけます。任意の名前を入力し、〔Start Wio-ing〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/13.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeが認識され、モジュールの設定画面に移りました。最初のセットアップは以上です。&lt;/p&gt;

&lt;p&gt;もしセットアップが上手くいかない場合は&lt;a href=&#34;https://dotstud.io/docs/wionode-wiosetup/&#34;&gt;こちら&lt;/a&gt;からセットアップしてみてください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;モジュールの設定&#34;&gt;モジュールの設定&lt;/h4&gt;

&lt;p&gt;続いて今回使うモジュールを設定していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/106/14.png&#34; alt=&#34;&#34; /&gt;
次にLED Barを取り付けます。Wio Node本体を画面と同じ向きに見た時、左側（PORT0）にLED Barを接続します。アプリ画面では、〔UART〕タブの〔LED Bar〕を選択し、〔Update Firmware〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/15.png&#34; alt=&#34;&#34; /&gt;
〔OK〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/16.png&#34; alt=&#34;&#34; /&gt;
設定が完了すると〔View API〕というリンクが表示されます。&lt;/p&gt;

&lt;p&gt;APIを試してみましょう。〔View API〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;apiを試してみる&#34;&gt;APIを試してみる&lt;/h4&gt;

&lt;p&gt;View APIのページではあらかじめ用意されているAPIを使ってWio Nodeとモジュールの挙動を試すことができます。
&lt;img src=&#34;https://dotstud.io/img/blog/106/17.png&#34; alt=&#34;&#34; /&gt;
今回利用する〔level〕APIの〔Test Request〕に「10」と入力します。〔GET〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/led.png&#34; alt=&#34;&#34; /&gt;
LED Barが10個すべて光りました！数値を変えると光るBarの個数が変わります。&lt;/p&gt;

&lt;p&gt;モジュールの設定は以上です。&lt;/p&gt;

&lt;h3 id=&#34;2-iftttの設定&#34;&gt;2. IFTTTの設定&lt;/h3&gt;

&lt;h4 id=&#34;インストールとセットアップ-1&#34;&gt;インストールとセットアップ&lt;/h4&gt;

&lt;p&gt;次にIFTTT側の設定をしていきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/18.png&#34; alt=&#34;&#34; /&gt;
最初にIFTTTのアプリをダウンロードします。&lt;strong&gt;ブラウザから設定する場合はアプリのインストールは不要&lt;/strong&gt;です。ブラウザで「IFTTT」を検索してIFTTTの画面に遷移してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/19.png&#34; alt=&#34;&#34; /&gt;
ダウンロード後、アプリを起動します。アカウントを持っていない場合は、〔Sign up〕を押下します。アカウントを既に取得している場合は、〔Sign in〕を押下してログインしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/20.png&#34; alt=&#34;&#34; /&gt;
アカウントを新規登録する場合はメールアドレスと任意のパスワードを入力し、〔Sign up〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;レシピを作成する&#34;&gt;レシピを作成する&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/21.png&#34; alt=&#34;&#34; /&gt;
それでは早速レシピを作ってみましょう。〔My Applets〕に移動し、右上の〔＋〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/22.png&#34; alt=&#34;&#34; /&gt;
IFTTTでは「if this then that」という構文を使って、サービスを連携させていきます。熊本弁で言うと「こぎゃん（こう）したら、あぎゃん（ああ）なる」みたいな感じです。&lt;/p&gt;

&lt;p&gt;まずは「こうしたら」のトリガー部分を作っていきましょう。最初に〔this〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/23.png&#34; alt=&#34;&#34; /&gt;
IFTTTでは連携に利用できるWebサービスのことをチャンネルと言います。&lt;/p&gt;

&lt;p&gt;トリガーとして利用できるチャンネルが表示されるので、「Wether Underground」チャンネルを検索し、選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/24.png&#34; alt=&#34;&#34; /&gt;
「Wether Underground」で利用できるトリガーの一覧が表示されます。今回は〔Today&amp;rsquo;s weather report〕を使うので、選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/25.png&#34; alt=&#34;&#34; /&gt;
「Today&amp;rsquo;s weather report」は今日の現在の天気情報を取得できます。この画面では取得する時間を設定します。好きな時間に設定してください。&lt;/p&gt;

&lt;p&gt;私の場合は昼休みで外に出る時の時間を設定しました。&lt;/p&gt;

&lt;p&gt;続いて「こうなる」の部分を作ります。
&lt;img src=&#34;https://dotstud.io/img/blog/106/26.png&#34; alt=&#34;&#34; /&gt;
「if this then that」の〔that〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/27.png&#34; alt=&#34;&#34; /&gt;
アクション（発動条件を満たした後の動作）として利用できるチャンネルが表示されます。〔Search services〕に「seeed」と入力して検索しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/28.png&#34; alt=&#34;&#34; /&gt;
「Seeed」チャンネルを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/29.png&#34; alt=&#34;&#34; /&gt;
〔connect〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/30.png&#34; alt=&#34;&#34; /&gt;
アカウント設定画面が表示されます。ここにWio Nodeで設定したアカウント情報を入力し、〔Sign in〕を押下します。&lt;/p&gt;

&lt;p&gt;Wio Node側でGoogleやFacebook連携でログインしていて上手く連携できない場合は、Wio Nodeのアプリからメールアドレスで登録しなおしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/31.png&#34; alt=&#34;&#34; /&gt;
「Seeed」チャンネルで利用できるアクションの一覧が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/32.png&#34; alt=&#34;&#34; /&gt;
一覧の下の方にある〔Drive any Grove〕を選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/33.png&#34; alt=&#34;&#34; /&gt;
詳細設定をしていきます。functionを選択するプルダウンでは〔level（float level）〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/34.png&#34; alt=&#34;&#34; /&gt;
次にFirst Parameterを設定します。〔Add Ingredient〕を押下すると、設定できる候補が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/35.png&#34; alt=&#34;&#34; /&gt;
今回取得するのはUV値なので〔UVindex〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/36.png&#34; alt=&#34;&#34; /&gt;
〔Next〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/37.png&#34; alt=&#34;&#34; /&gt;
タイトルが自動生成されるので、変更する場合は〔Edit title〕から編集します。最後に〔Finish〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/38.png&#34; alt=&#34;&#34; /&gt;
これでレシピは完成です！&lt;/p&gt;

&lt;h3 id=&#34;3-オーナメント作り&#34;&gt;3. オーナメント作り&lt;/h3&gt;

&lt;p&gt;最後に見せ方の部分である、オーナメント作りをしていきます。&lt;/p&gt;

&lt;p&gt;では、グリーンオーナメントにWio Nodeを巻いていきます。この時、一度Wio NodeからUSBケーブルを抜いておくと良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/39.png&#34; alt=&#34;&#34; /&gt;
購入したグリーンオーナメントにもよりますが、グリーンオーナメントの中の構成を把握してWio Nodeを取り付けるとコードが目立たないようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/40.png&#34; alt=&#34;&#34; /&gt;
今回の場合は、グリーンオーナメントの中心軸を避けたところにWio Nodeを設置し、コードを軸に這わせながら巻きつけていきます。巻きつけた後は、葉っぱでコードを隠します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/41.png&#34; alt=&#34;&#34; /&gt;
LEDもコードがなるべく見えないように周りの葉っぱで隠します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/42.png&#34; alt=&#34;&#34; /&gt;
次に目を用意します。自分の好きな目を書いてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/43.png&#34; alt=&#34;&#34; /&gt;
目を作成したら、グリーンオーナメントに装着します。両面テープや養生テープを使うと、目の位置等を簡単に変えられます。目の位置によって表情が変わるので好きな位置に取り付けましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/44.png&#34; alt=&#34;&#34; /&gt;
最後にUSBケーブルと接続します。オーナメントによりますが、USBケーブルに色が移ることもあるので気をつけてください。&lt;/p&gt;

&lt;p&gt;オーナメント作りはこれで完成です！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;カスタマイズ&#34;&gt;カスタマイズ&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/45.png&#34; alt=&#34;&#34; /&gt;
目だけでなく、ちょっとした花を付け加えるとより個性が出ます。色々試してみてください。&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;さて、一通り完成したので動作検証してみます。&lt;/p&gt;

&lt;p&gt;IFTTTの〔My Applets〕で自分の作成したアプレットが確認できます。今回はテストなので時間を12時45分にしました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/46.png&#34; alt=&#34;&#34; /&gt;
実行されるとIFTTTから通知が来ます。確認してみると正常に動いているようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/47.png&#34; alt=&#34;&#34; /&gt;
UVindexの値を確認すると「9」となっています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/48.png&#34; alt=&#34;&#34; /&gt;
LED Barは&amp;hellip;レベル9まで光っています！&lt;strong&gt;外に出る時は紫外線対策をしっかりしましょう！！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;p&gt;今回は「Wio Node」と「IFTTT」を使ってノンプログラミングでUV（紫外線）のレベルをLED Barで表示させました。初心者の方でも簡単にできたのではないでしょうか。「IFTTT」で取得する値を変えたりアクションを変えたりするともっと色んなことができそうですね。&lt;/p&gt;

&lt;p&gt;また、「IFTTT」で取得する値は0〜16ですが、現状は10以上の場合もLED Barは10までの表示です。これ以上細かい表示をする場合はプログラムを組んでみましょう。そちらの方も是非挑戦してみてください。&lt;/p&gt;

&lt;p&gt;最後まで読んで頂きありがとうございました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BTとIFTTTでスイッチを押したらLINEを送る仕組みを作ってみよう</title>
      <link>https://dotstud.io/blog/nefry-ifttt-push-line/</link>
      <pubDate>Thu, 18 May 2017 02:51:27 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-ifttt-push-line/</guid>
      
      <description>

&lt;p&gt;こんにちは。外部ライターのわみ（&lt;a href=&#34;https://twitter.com/wamisnet&#34;&gt;@wamisnet&lt;/a&gt;）です。Unirobot株式会社でロボットのソフトウェアエンジニアをやりながら、dotstudioでは私が作成しているIoTデバイス「Nefry」シリーズの販売やチュートリアル記事の執筆をしています。&lt;/p&gt;

&lt;p&gt;Nefryは、ユーザの皆様からのフィードバックを頂き成長しています。新たなWi-Fi・BLEモジュール「ESP-WROOM-32」の発売もあり、このたび&lt;strong&gt;新機能と改良を加えた次世代の「Nefry BT」を発表&lt;/strong&gt;する事になりました。&lt;/p&gt;

&lt;p&gt;今回は新しい「Nefry BT」を使って、Amazon Dash Buttonのようにスイッチを押した時にLINEに通知が行く仕組みを作ってみます。&lt;/p&gt;

&lt;h2 id=&#34;nefry-btとは&#34;&gt;Nefry BTとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/01_nefry.png&#34; alt=&#34;&#34; /&gt;
Nefryシリーズは、「&lt;strong&gt;簡単にインターネットにつながること&lt;/strong&gt;」をテーマにしたFRISKサイズのIoTデバイスです。Nefry BTからはWi-Fiに加えてBLE（Bluetooth Low Energy）に対応し、I/O機能も増えて開発の幅がさらに広がりました！&lt;/p&gt;

&lt;p&gt;ハードウェアをできるだけ意識しなくて済むよう設計され、はんだづけや複雑な接続なしで動かすことができるため、初めてハードウェアを触る方にオススメのデバイスです。&lt;/p&gt;

&lt;h2 id=&#34;作ってみる&#34;&gt;作ってみる&lt;/h2&gt;

&lt;p&gt;今回試す流れは以下です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IFTTTにレシピを作成する&lt;/li&gt;
&lt;li&gt;開発環境（Arduino IDE）を整える&lt;/li&gt;
&lt;li&gt;プログラムを書き込む&lt;/li&gt;
&lt;li&gt;Nefry BTとIFTTTを紐付ける&lt;/li&gt;
&lt;li&gt;スイッチを押してLINEにメッセージを送ってみる&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nefry BT&lt;/li&gt;
&lt;li&gt;IFTTTのアカウント&lt;/li&gt;
&lt;li&gt;LINEのアカウント&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nefry BT library Version 0.6.1&lt;/li&gt;
&lt;li&gt;Windows 10&lt;/li&gt;
&lt;li&gt;Arduino IDE 1.8.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;

&lt;p&gt;Nefry BTは開発中のため、実際のコードや画面と異なる可能性があります。&lt;/p&gt;

&lt;h3 id=&#34;iftttにレシピを作成する&#34;&gt;IFTTTにレシピを作成する&lt;/h3&gt;

&lt;p&gt;IFTTTは様々なWebサービス同士を簡単に連携できるサービスです。連携したものは「レシピ」と呼ばれ、自分で新しいレシピを作成することもできます。今回はNefry BTとLINEを連携するレシピを作ってみます。&lt;/p&gt;

&lt;p&gt;アカウントを持っていない場合は下記の記事を参考にアカウントを取得してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://liginc.co.jp/263899&#34;&gt;Webサービス同士を連携できる「IFTTT」と自作IoTデバイスを繋いで生活を便利にしてみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アカウントを取得したら、Nefry BTとLINEを連携させるレシピを登録していきましょう。&lt;/p&gt;

&lt;p&gt;IFTTTのレシピは「〇〇が起きたら△△する」というようにトリガーとアクションに分けられます。今回のトリガーは「&lt;strong&gt;Nefry BTのスイッチをクリックしたら&lt;/strong&gt;」、アクションは「&lt;strong&gt;LINEに通知する&lt;/strong&gt;」となります。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;トリガーとnefry-btを紐付けるキーの取得&#34;&gt;トリガーとNefry BTを紐付けるキーの取得&lt;/h4&gt;

&lt;p&gt;今回はトリガーとして自作のWebサービスを利用できる「Webhooks」を使います。&lt;/p&gt;

&lt;p&gt;まずはWebhooksをあとでNefry BTと紐付けるために、Secret Keyというキーを取得します。&lt;a href=&#34;https://ifttt.com/discover&#34;&gt;IFTTT公式サイト&lt;/a&gt;上部の「Search」から、Webhooksを検索しクリックしましょう。（&amp;rdquo;web&amp;rdquo;で候補に出てきます。）
&lt;img src=&#34;https://dotstud.io/img/blog/100/if1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;設定ページに移動しました。このとき初めての方はこのような認証画面が表示されます。ページ中央の「Connect」をクリックしてWebhooksを有効にしましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Settingをクリックし、移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アカウントごとに割り当てられるSecret KeyがURLのuse/以下に記載されているのでコピーしておきます。今回の例ではSecret Keyは &lt;code&gt;GnzpClq0nDwt4WEdTyTmt&lt;/code&gt; の部分です。（このSecret Keyはサンプルです。既に無効になっていますので自身で取得してください。）
&lt;img src=&#34;https://dotstud.io/img/blog/100/if4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;トリガーの作成&#34;&gt;トリガーの作成&lt;/h4&gt;

&lt;p&gt;続いてトリガーとなるWebhooksの詳細を作成します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/06_ifttt5.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://ifttt.com/create&#34;&gt;IFTTTのレシピ作成ページ&lt;/a&gt;から、「+this」のリンクをクリックします。&lt;/p&gt;

&lt;p&gt;「Choose a service」から再度Webhooksを検索しましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;WebhooksはEventという単位でトリガーとなります。今回はEvent Nameを&amp;rdquo;Nefry&amp;rdquo;とし、「Create trigger」をクリックし作成します。Event NameはあとでNefry BTにも同じ名前で入力します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/if6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;アクションの作成&#34;&gt;アクションの作成&lt;/h4&gt;

&lt;p&gt;最後に、トリガーが生じた時に起こすアクションを登録します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/09_ifttt8.png&#34; alt=&#34;&#34; /&gt;
「+that」のリンクをクリックして、検索欄からLINEを検索しましょう。ここでTwitterやGmailなどを選択すると、それぞれのサービスと連携させることが出来ます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/10_ifttt9.png&#34; alt=&#34;&#34; /&gt;
Recipientと書かれた欄にメッセージを送るLINEの送信先を選択します。&lt;/p&gt;

&lt;p&gt;Messageと書かれた欄には送信するメッセージを入力します。MessageのValueにはプログラムから値を渡すことができるので、温度センサや明るさセンサなどの値をメッセージに組み込むことが可能です。写真のURLがあれば写真を送信することもできます。&lt;/p&gt;

&lt;p&gt;入力が完了したら、Create actionをクリックして保存します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/11_ifttt10.png&#34; alt=&#34;&#34; /&gt;
最後にFinishを押し、IFTTTのレシピの作成は完了です。&lt;/p&gt;

&lt;h3 id=&#34;開発環境-arduino-ide-を整える&#34;&gt;開発環境（Arduino IDE）を整える&lt;/h3&gt;

&lt;p&gt;続いてNefy BTにプログラムを書く環境を整えます。プログラムの書き込みにはArduino IDEと呼ばれるエディタを使用します。&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;からダウンロードし、以下の手順でNefry BT用の設定を追加してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/12_program.png&#34; alt=&#34;&#34; /&gt;
Arduino IDEの「環境設定」のページから、「追加のボードマネージャのURL」に以下のリンクを入力して検索します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://nefry.studio/package_nefrybt_index.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;メニューバーの[ツール]から、[ボード] -&amp;gt; [ボードマネージャー]を選択します。選択肢に「Nefry by Nefry Community」が表示されているので、インストールします。
&lt;img src=&#34;https://dotstud.io/img/blog/100/13_library.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これでプログラムを書き込む準備が整いました。&lt;/p&gt;

&lt;h3 id=&#34;プログラムを書き込む&#34;&gt;プログラムを書き込む&lt;/h3&gt;

&lt;p&gt;以下はNefry BTに搭載されている「スイッチ」を押したときにIFTTTのEventを呼ぶプログラムです。&lt;/p&gt;

&lt;p&gt;Arduino IDEを開き、以下のコードを貼り付けます。（//以降の部分はコメントです。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp:&#34;&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;NefryIFTTT.h&amp;gt;
String Event, SecretKey;
int counter =0;                       //送信データのカウンタ

void setup() {
  Nefry.setStoreTitle(&amp;quot;SecretKey&amp;quot;,0); //Nefry DataStoreのタイトルを指定
  Nefry.setStoreTitle(&amp;quot;Event&amp;quot;,1);     //Nefry DataStoreのタイトルを指定
  SecretKey = Nefry.getStoreStr(0);   //Nefry DataStoreからデータを取得
  Event = Nefry.getStoreStr(1);       //Nefry DataStoreからデータを取得
  Nefry.enableSW();                   //SW有効化
}

void loop() {
  if (Nefry.readSW()) {               //SWを押した時
    counter++;                        //送信回数加算
    bool sendData = IFTTT.send(Event, SecretKey,&amp;quot;Nefry&amp;quot;,(String)(micros()/1000000)+&amp;quot;秒&amp;quot;,(String)counter);//IFTTTにデータを送信
                                      //Value1:Nefry,Value2:Nefryが起動してからの秒数,Value3:送信カウンタ
    if (!sendData) {//IFTTTにデータを送信が成功したか失敗したかの判定
      Nefry.setLed(255, 0, 0);        //Errの時、赤色点灯
    }
    Nefry.ndelay(1000);               //送信後1秒間待つ
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;貼り付けできたら[ツール] -&amp;gt; [ボード]から「Nefry BT」を選択します。Nefry BTとPCを繋ぎ、[ツール] -&amp;gt; [シリアルポート]でNefry BTのシリアルポートを選択しましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/14_arduinoide.png&#34; alt=&#34;&#34; /&gt;
ボードとシリアルポートを選んだらArduino IDEの左上にある「→」を押しプログラムを書き込みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/15_arduinoide2.png&#34; alt=&#34;&#34; /&gt;
「ボードへの書き込みが完了しました。」と表示されたら、Nefry BTへのプログラムの書き込みは完了です。&lt;/p&gt;

&lt;p&gt;最後にNefry BTにIFTTTとの連携情報を入力します。あと少しですので頑張っていきましょう！&lt;/p&gt;

&lt;h3 id=&#34;nefry-btとiftttを紐付ける&#34;&gt;Nefry BTとIFTTTを紐付ける&lt;/h3&gt;

&lt;p&gt;Nefry BTから&amp;rdquo;Nefry-OOOO&amp;rdquo;というWi-Fiの信号が発信されているので接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/16_wifi.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接続できたらChromeやIEなどのWebブラウザで&lt;a href=&#34;http://192.168.4.1&#34;&gt;Nefry BTのサイト&lt;/a&gt;にアクセスしましょう。&lt;code&gt;http://192.168.4.1&lt;/code&gt;にアクセスするとNefry BTの設定サイトが表示されます。このページからNefry BTに関する様々な設定ができます。
&lt;img src=&#34;https://dotstud.io/img/blog/100/17_nefry.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずは「Setup WiFi」をクリックし、Wi-Fiの設定をしましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/100/18_nefry.png&#34; alt=&#34;&#34; /&gt;
接続するWi-Fiを入力して「Save」をクリックすると、Nefry BTに設定を保存＆再起動します。Wi-Fiが切断したら再接続してください。&lt;/p&gt;

&lt;p&gt;設定が完了したら、トップページに戻り「Data Store」のページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/100/19_nefry.png&#34; alt=&#34;&#34; /&gt;
SecretKeyにはWebhooksで確認した値を、EventにはLINEと連携した際に入力したEvent Name（今回は”Nefry”）を入力します。Saveをクリックし値を保存するとNefry BTが再起動します。&lt;/p&gt;

&lt;p&gt;いよいよNefry BTについているスイッチを押してLINEにメッセージを送ってみましょう！&lt;/p&gt;

&lt;h3 id=&#34;スイッチを押してlineにメッセージを送ってみる&#34;&gt;スイッチを押してLINEにメッセージを送ってみる&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/100/20_nefry.gif&#34; alt=&#34;&#34; /&gt;
Nefry BTのスイッチを押すとLEDの色が変わり送信を始めます。送信が完了するとLEDが水色になり、LINEに通知されました！IFTTTのサーバ状態により応答が悪い場合もありますが、その時はIFTTTのページにてリロードをすると反応してくれます。&lt;/p&gt;

&lt;p&gt;初回は登録が多く時間がかかりますが、今後はサクっと作れるでしょう。&lt;/p&gt;

&lt;h2 id=&#34;さいごに&#34;&gt;さいごに&lt;/h2&gt;

&lt;p&gt;半田付けや複雑な設定なしで、ハードウェアをきっかけにしてLINEへメッセージを投稿する連携をサクッと試すことができました。今回紹介したNefry BTとIFTTTの連携を応用すればTwitterやGmailなどにもメッセージを送信できます。&lt;/p&gt;

&lt;p&gt;リアルタイム通信が得意な「Milkcocoa」やクラウドサービスMicrosoft AzureのIoT向け機能である「Azure IoT Hub」などを使うとより幅広い開発ができるでしょう。&lt;/p&gt;

&lt;p&gt;今後の更新で簡単に接続できるライブラリやサンプルコードを追加していく予定です。生まれたばかりでまだまだヒヨッコですが、進化していくNefry BTを応援していただけたらと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「Wio Node」で半田付けなしの電子工作！温度計作りでIoTはじめの一歩</title>
      <link>https://dotstud.io/blog/seeed-wionode-hands-on/</link>
      <pubDate>Fri, 21 Apr 2017 22:18:36 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/seeed-wionode-hands-on/</guid>
      
      <description>

&lt;p&gt;こんにちは、バックエンドエンジニアのちゃんとく（&lt;a href=&#34;https://twitter.com/tokutoku393&#34;&gt;@tokutoku393&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;今回は、難しいプログラミングや半田付けなしで簡単に試せる「Wio Node」を使って温度表示計を作ってみます！この記事は「&lt;strong&gt;&lt;a href=&#34;https://dotstudio.connpass.com/event/53388/&#34;&gt;WioNodeで始めよう！挫折しないIoT入門ハンズオン
&lt;/a&gt;&lt;/strong&gt;」の資料にもなっています。&lt;/p&gt;

&lt;p&gt;かなり長いですが、詳細な手順を載せていますので根気よく頑張りましょう！&lt;/p&gt;

&lt;h2 id=&#34;wio-nodeとは&#34;&gt;Wio Nodeとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/01_wio_node.png&#34; alt=&#34;&#34; /&gt;
今回使うWio Nodeは、中国のSeeed Studio社が開発した&lt;strong&gt;Wi-Fiモジュール初期搭載のIoTデバイス&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grove規格のモジュールをそのまま挿せるコネクタを搭載&lt;/strong&gt;していて、はんだづけなしで動かすことができます。モジュールのセットアップも&lt;strong&gt;公式のスマートフォンアプリから行うことができ&lt;/strong&gt;、電子工作初心者でも簡単に試せます。&lt;/p&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;早速Wio Nodeを動かしてみましょう。今回は、温度センサと7セグメントディスプレイを使って簡易温度計を作ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/02_map.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeに接続したモジュール同士は一見つながっているように見えますが、&lt;strong&gt;内部で連携する仕組みはありません&lt;/strong&gt;。それぞれWi-Fiを使ってAPIからインプットやアウトプットを制御します。&lt;/p&gt;

&lt;p&gt;以下の手順で作っていきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wio Nodeのセットアップ&lt;/li&gt;
&lt;li&gt;Wio Nodeにモジュールを接続する&lt;/li&gt;
&lt;li&gt;アプリからAPIを試す&lt;/li&gt;
&lt;li&gt;Node.jsでプログラムを書く&lt;/li&gt;
&lt;li&gt;試してみる&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Wio Node -&amp;gt; &lt;a href=&#34;https://dotstud.io/shop/wionode-social-remote-control/&#34;&gt;購入ページ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Micro USBケーブル&lt;/li&gt;
&lt;li&gt;Grove 温度センサ（型番: SEEED-101020015）&lt;/li&gt;
&lt;li&gt;Grove 7セグメントディスプレイ（型番: SEEED-104030003）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;類似のセンサがたくさんありますので、型番をよくご確認ください。&lt;/strong&gt;（Wio Nodeに対応していない場合があります。）&lt;/p&gt;

&lt;h4 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro（Retina 13-inch、Early 2015）&lt;/li&gt;
&lt;li&gt;OS X El Capitan（v10.11.6）&lt;/li&gt;
&lt;li&gt;iOS10.31&lt;/li&gt;
&lt;li&gt;Node.js v7.9.0&lt;/li&gt;
&lt;li&gt;npm 4.5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wio-nodeのセットアップ&#34;&gt;Wio Nodeのセットアップ&lt;/h3&gt;

&lt;p&gt;まずはWio Nodeの初期設定から進めていきます。&lt;/p&gt;

&lt;p&gt;Wio Nodeは&lt;strong&gt;モバイルバッテリ・PCなどからUSBケーブルで電源を供給しましょう&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;開発用アプリのインストール&#34;&gt;開発用アプリのインストール&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/02_wio_app.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeの開発には、公式からリリースされている「Wio Link」というアプリ（Androidの場合は「Wio」）を利用します。執筆時はiOS版は1.5.2、Android版は2.3.6がリリースされています。今回はiOS版を使っての紹介です。&lt;/p&gt;

&lt;p&gt;iOS: &lt;a href=&#34;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&#34;&gt;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&lt;/a&gt;&lt;br /&gt;
Android: &lt;a href=&#34;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&#34;&gt;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;アプリとwio-nodeの設定&#34;&gt;アプリとWio Nodeの設定&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/03_acount.png&#34; alt=&#34;&#34; /&gt;
アプリを開いたらまずはアカウントを作成しましょう。「SIGN UP」からメールアドレスとパスワードを設定し「Register」で登録します。ServerLocationはデフォルトのGlobalにしておきます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GmailやFacebookのアカウントを使った登録もできますが、他サービスとの連携でうまくいかないことがあるので非推奨です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/04_add_device.png&#34; alt=&#34;&#34; /&gt;
アカウントが作成されたらAdd Your First Deviceをタップし、Wio Nodeを選択します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wi-fi設定&#34;&gt;Wi-Fi設定&lt;/h4&gt;

&lt;p&gt;続いてWi-Fi設定をします。&lt;strong&gt;手順が少しややこしいので注意してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;まずは簡単にWio Nodeがインターネットに繋がる仕組みを整理してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/05_internet.png&#34; alt=&#34;&#34; /&gt;
デバイスがインターネットに繋がるためには、&lt;strong&gt;インターネットに繋がる媒介（=アクセスポイント）&lt;/strong&gt;が必要です。私たちは普段ルータやポケットWi-Fi（モバイルルータ）を媒介にしていますね。&lt;/p&gt;

&lt;p&gt;Wio Nodeも同様に、インターネットに繋がるために&lt;strong&gt;アクセスポイントが必要&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/06_wifi_setup.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeに&lt;strong&gt;アクセスポイントの情報を教える必要がある&lt;/strong&gt;ので、アドホックモードでWio Nodeとスマートフォンを同じ回線に繋いだ状態にします。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;スマートフォンからWio Nodeにアクセスポイント情報を教えてあげる&lt;/strong&gt;と、その後は&lt;strong&gt;Wio Node自身がアクセスポイントに繋がります&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;接続手順が複雑になりますが、この仕組みを押さえておきましょう！&lt;/p&gt;

&lt;p&gt;アクセスポイントやWAN/LANについてよくわからない方は&lt;a href=&#34;https://dotstud.io/docs/network&#34;&gt;ドキュメント&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wi-fi設定手順&#34;&gt;Wi-Fi設定手順&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/06_func.png&#34; alt=&#34;&#34; /&gt;
まずは画面の指示にしたがってFuncボタン（写真親指側）を4秒以上長押しすると、青いランプがゆらゆらと光ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/07_wio_network.png&#34; alt=&#34;&#34; /&gt;
iOSのWi-Fi選択画面から、「Wio_XXXX」というSSIDを選択します。（Androidはアプリ内での選択です。）アドホックモードで&lt;strong&gt;Wio Nodeとスマートフォンが繋がっている状態&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/08_wifi_list.png&#34; alt=&#34;&#34; /&gt;
アプリに戻ると、続いてWi-Fiの接続を促されます。ネットワークリストから、部屋や会場のWi-Fi（利用するWi-Fi）を選択してパスワードを入力しましょう。&lt;strong&gt;アクセスポイント情報を教えてあげた状態&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/09_device_connect.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeがインターネットに繋がり、登録が完了しました。デバイスに名前をつけておきます。（Android端末で認識がうまくいかない場合、&lt;strong&gt;機内モードにして試す&lt;/strong&gt;と解消することがあるようです。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;アプリからでは失敗する場合は、&lt;a href=&#34;https://dotstud.io/docs/wionode-wiosetup&#34;&gt;こちら&lt;/a&gt;を参考にWio-Setupというツールを試してみてください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;以上でWio Nodeのセットアップは完了です。同じデバイスとアクセスポイントを使う場合は、以後起動するだけで接続されるようになります！&lt;/p&gt;

&lt;h3 id=&#34;wio-nodeにモジュールを接続する&#34;&gt;Wio Nodeにモジュールを接続する&lt;/h3&gt;

&lt;p&gt;アプリから、接続するモジュールを登録します。
&lt;img src=&#34;https://dotstud.io/img/blog/095/10_display_connect.png&#34; alt=&#34;&#34; /&gt;
「PORT0」（左側）をタップして、下の「OUTPUT」から「4-Digit Display」を選択しましょう。&lt;strong&gt;似たようなモジュールがたくさんありますので、よく確認してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/11_temperature_connect.png&#34; alt=&#34;&#34; /&gt;
続いて温度センサを登録します。「PORT1」（右側）をタップして、「INPUT」から「Temperature Sensor」を選択します。&lt;/p&gt;

&lt;p&gt;アプリ画面を参考に、Wio Nodeにモジュールを接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/095/12_module_connect.png&#34; alt=&#34;&#34; /&gt;
「PORT0」に7セグメントディスプレイ、「PORT1」に温度センサを接続しましょう。&lt;/p&gt;

&lt;p&gt;接続できたら、アプリ画面下部の「Update Firmware」をタップしましょう。読み込みのあと、「View API」というAPIサンプルページが表示されるようになります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updateが失敗する場合はモジュールの接続が左右間違っていないか今一度確認してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;アプリからapiを試す&#34;&gt;アプリからAPIを試す&lt;/h3&gt;

&lt;p&gt;「View API」のページでは、手軽にモジュールを操作するAPIを試すことができます。正しく接続できているか、試してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/095/13_display_api.png&#34; alt=&#34;&#34; /&gt;
まずは7セグメントディスプレイの「display_point」というAPIを試してみます。説明部分には、「&lt;strong&gt;POSTメソッドで1を送ると&amp;rdquo;:&amp;ldquo;が表示される&lt;/strong&gt;」とありますね。「Test Request」から1を送ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/14_display_demo.png&#34; alt=&#34;&#34; /&gt;
7セグメントディスプレイに&amp;rdquo;:&amp;ldquo;が表示されました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/15_temp_api.png&#34; alt=&#34;&#34; /&gt;
続いて温度センサのAPIを試します。温度の取得には値は必要ないので、そのままGETメソッドでRequestします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/16_temp_demo.png&#34; alt=&#34;&#34; /&gt;
現在の温度が返ってきました。（かなり暑いですね（笑））&lt;/p&gt;

&lt;p&gt;挙動が確認できたら、2つのモジュールを連携させるプログラムを書いていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-getメソッドとpostメソッド&#34;&gt;memo: GETメソッドとPOSTメソッド&lt;/h4&gt;

&lt;p&gt;HTTPリクエストにはいくつかのメソッド（送信方法）があります。GET、POSTの他にもPUTメソッド、DELETEメソッドなどがあり、最近主流の「RESTful API」という考え方では&lt;strong&gt;操作する内容によってメソッドを使い分ける&lt;/strong&gt;ことになっています。&lt;/p&gt;

&lt;p&gt;今回はメソッド名だけわかればプログラミング可能ですが、詳しく知りたい方は調べてみてください！&lt;/p&gt;

&lt;h3 id=&#34;node-jsでプログラムを書く&#34;&gt;Node.jsでプログラムを書く&lt;/h3&gt;

&lt;p&gt;センサの値を取得して、室温をディスプレイに表示するプログラムを書いていきましょう。プログラムはAPIを叩ければよいので、今回は&lt;strong&gt;Node.js&lt;/strong&gt;で作成します。&lt;/p&gt;

&lt;p&gt;プログラムの仕組みを理解するために、以下の手順で説明します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node.jsのインストール&lt;/li&gt;
&lt;li&gt;プロジェクトの作成&lt;/li&gt;
&lt;li&gt;温度情報を取得する&lt;/li&gt;
&lt;li&gt;温度情報を表示したい文字列に変換する&lt;/li&gt;
&lt;li&gt;ディスプレイに温度を表示する&lt;/li&gt;
&lt;li&gt;3秒ごとに更新する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-コマンドラインの使い方&#34;&gt;memo: コマンドラインの使い方&lt;/h4&gt;

&lt;p&gt;Node.jsの実行やファイル操作はコマンドラインで行います。Macには「ターミナル」、Windowsには「コマンドプロンプト」というアプリケーションが最初から入っているので、立ち上げて使いましょう。&lt;/p&gt;

&lt;p&gt;初めてコマンドを使う方は、「ターミナル コマンド」などで検索すると基本的な使い方がわかりますよ！&lt;/p&gt;

&lt;p&gt;筆者はiTerm2というクライアントアプリにzshというシェルを入れています。（画面がちょっと違うくらいだと思ってください。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-node-jsのインストール&#34;&gt;1. Node.jsのインストール&lt;/h4&gt;

&lt;p&gt;まずはNode.jsのインストールから始めます。また&lt;code&gt;async/await&lt;/code&gt;という機能を使っているので、&lt;strong&gt;v7.6.0以上が必要&lt;/strong&gt;です。最新版をインストール済みの方は次項の「プロジェクトの作成」から始めてください。&lt;/p&gt;

&lt;p&gt;Node.jsのインストールには、簡単にバージョン管理ができる「&lt;strong&gt;nvm&lt;/strong&gt;」や「&lt;strong&gt;nodebrew&lt;/strong&gt;」を使うのが便利です。nodebrewを使ったインストール方法は下記を参照してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#node-js%E7%92%B0%E5%A2%83%E6%95%B4%E5%82%99&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;インストールが完了したら、Node.jsが正しく動くか確認してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/095/17_node_v.png&#34; alt=&#34;&#34; /&gt;
コマンドラインで&lt;code&gt;node -v&lt;/code&gt;を叩くとバージョンが出るようになったでしょうか？（v7.6.0以上ですよ！）&lt;/p&gt;

&lt;p&gt;Node.jsの環境構築はとても簡単なので、ウェブ開発が初めての方にもオススメです！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-コーディング無しで動かしてみる&#34;&gt;memo: コーディング無しで動かしてみる&lt;/h4&gt;

&lt;p&gt;サクッと試したい方は、githubの&lt;a href=&#34;https://github.com/dotstudio/wionode_handson&#34;&gt;完成プログラム&lt;/a&gt;をご覧ください。READMEの手順を進めるとコーディングなしで動かせます。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-プロジェクトの作成&#34;&gt;2. プロジェクトの作成&lt;/h4&gt;

&lt;p&gt;今回のWio Nodeのプログラムを置くプロジェクトを作成しましょう。&lt;/p&gt;

&lt;p&gt;適当なディレクトリに移動します。（私は&lt;code&gt;/Users/ユーザ名/workspace&lt;/code&gt;という作業ディレクトリを用意しています。参考まで。）
&lt;img src=&#34;https://dotstud.io/img/blog/095/18_mkdir.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;mkdir ディレクトリ名&lt;/code&gt;で新しいディレクトリを作成できます。&lt;code&gt;wio_temperature&lt;/code&gt;というディレクトリを作ってみました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/19_cd.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;cd ディレクトリ名&lt;/code&gt;で作成したディレクトリの下に移動します。&lt;/p&gt;

&lt;p&gt;Node.jsでは「npm」でモジュールを管理できます。&lt;code&gt;npm init -y&lt;/code&gt;を実行しましょう。&lt;code&gt;-y&lt;/code&gt;オプションで名前等をデフォルト値で作成してくれます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/20_npm_init.png&#34; alt=&#34;&#34; /&gt;
プロジェクト名やライブラリなどを管理する「&lt;strong&gt;package.json&lt;/strong&gt;」が作成されました。&lt;/p&gt;

&lt;p&gt;今回使用する「&lt;strong&gt;axios&lt;/strong&gt;」ライブラリをインストールします。&lt;code&gt;npm install axios --save&lt;/code&gt;を実行しましょう。&lt;code&gt;--save&lt;/code&gt;オプションをつけることでpackage.jsonに記載されます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/21_npm_install.png&#34; alt=&#34;&#34; /&gt;
axiosがインストールされ、package.jsonに追加されました。&lt;/p&gt;

&lt;p&gt;続いてプログラムを記述するファイルを作成します。&lt;code&gt;touch ファイル名&lt;/code&gt;でファイルが作成されます。（Windowsの場合はコマンドがないのでフォルダから作成してください。）
&lt;img src=&#34;https://dotstud.io/img/blog/095/22_touch.png&#34; alt=&#34;&#34; /&gt;
app.jsというファイルを作成しました。（&lt;code&gt;ls&lt;/code&gt;コマンドでカレントディレクトリのファイルが見れます。Windowsは&lt;code&gt;dir&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;以上でプロジェクトの作成は完了です。ファイルにプログラムを書いていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-ファイルの編集とエディタについて&#34;&gt;memo: ファイルの編集とエディタについて&lt;/h4&gt;

&lt;p&gt;コマンドラインからでもファイルの編集はできますが、&lt;strong&gt;インデントやコードの補完が効かず作業しづらい&lt;/strong&gt;ので、テキストエディタを使うのがオススメです。&lt;/p&gt;

&lt;p&gt;下記記事ではVisual Studio Codeのインストール方法を紹介しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#visual-studio-code&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-温度情報を取得する&#34;&gt;3. 温度情報を取得する&lt;/h4&gt;

&lt;p&gt;まずは温度を取得するプログラムを書いていきます。&lt;code&gt;BASE_URL&lt;/code&gt;はドメインが違う場合があるので、アプリから確認して自身のものに置き換えてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const TOKEN = process.argv[2] || &#39;&#39;;
const BASE_PATH = `https://us.wio.seeed.io/v1/node`; // 自身のものをアプリで確認

/**
 * 温度取得
 */
 const getTemp = () =&amp;gt; {
     const ENDPOINT = `/GroveTempA0/temp`;
     const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${TOKEN}`;
     axios.request({method: &#39;get&#39;, baseURL: BASE_URL})
     .then((resp) =&amp;gt; console.log(resp));
 }

getTemp();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;axiosに温度取得APIのURLとオプションを渡し、返ってきた値を出力しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;&lt;/code&gt;の部分は、コマンドライン引数（実行時に渡す値）を取得しています。tokenなどの人に知られたくない値は、ファイルに直接書かないのがベターです。&lt;/p&gt;

&lt;p&gt;それでは正しく動くか試してみましょう。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;というコマンドで実行します。&lt;/p&gt;

&lt;p&gt;ご自身のtokenは&lt;strong&gt;アプリのView API画面から確認してください&lt;/strong&gt;。&lt;code&gt;?access_token=&lt;/code&gt;の後の文字列がtokenです。
&lt;img src=&#34;https://dotstud.io/img/blog/095/23_temp_test.png&#34; alt=&#34;&#34; /&gt;
温度センサの情報が返ってきたでしょうか？&lt;/p&gt;

&lt;p&gt;1番下に温度情報がありますね。この情報を使ってディスプレイに表示する文字列を作っていきます。&lt;/p&gt;

&lt;p&gt;エラーが出てしまった人は、「Node.js &amp;lt;エラーメッセージ&amp;gt;」で検索すると答えが見つかりやすいです。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-温度情報を表示したい文字列に変換する&#34;&gt;4. 温度情報を表示したい文字列に変換する&lt;/h4&gt;

&lt;p&gt;取得した温度情報を、ディスプレイに表示する文字列に作り変えるfunctionを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, tempstr.length-1);
  }
  return `${temp_str}C`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;temp2digit()の引数には、先ほど受け取った情報の温度部分だけを渡します。&lt;/p&gt;

&lt;p&gt;数値を文字列に変換し、不要な&amp;rsquo;.&amp;lsquo;を取り除き、3桁にして、温度計らしく&amp;rsquo;C&amp;rsquo;を付けて返します。&lt;/p&gt;

&lt;p&gt;これを先ほど作ったgetTemp()と一緒に実行するようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const TOKEN = process.argv[2] || &#39;&#39;;
const BASE_PATH = `https://us.wio.seeed.io/v1/node`; // 自身のものをアプリで確認

/**
 * 温度取得
 */
 const getTemp = () =&amp;gt; {
     const ENDPOINT = `/GroveTempA0/temp`;
     const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${TOKEN}`;
     return axios.request({method: &#39;get&#39;, baseURL: BASE_URL}); // ここでは実行しない
 }

/**
 * 温度情報を文字列変換+Cを追加
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt;{
    let temp_str = `${temp}`;
    temp_str = temp_str.replace(&#39;.&#39;,&#39;&#39;);
    if(temp_str.length &amp;gt;= 4){
        temp_str = temp_str.substr(0,temp_str.length-1);
    }
    return `${temp_str}C`;
}

async function main(){ // async/awaitを使う
   const res = await getTemp();
   const temp = res.data.temperature;
   const text = temp2digit(temp);
   console.log(text);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではasync/awaitを使っています。awaitで指定したタスクの実行を待ってレスポンスを受け取り、asyncを付けたメソッドを一つのタスクとして処理するような機能です。Node.jsではv7.6.0から導入されました。&lt;/p&gt;

&lt;p&gt;実行を待たせるため、getTemp()では、APIの結果ではなくメソッドを返すだけに変更します。&lt;/p&gt;

&lt;p&gt;getTemp()で受け取ったobjectの子要素には&lt;code&gt;.&lt;/code&gt;でアクセスします。先ほどのレスポンスのdataの中のtemperatureが欲しいので&lt;code&gt;res.data.temperature&lt;/code&gt;となります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/24_temp2digit.png&#34; alt=&#34;&#34; /&gt;
温度計の文字列ができました！&lt;/p&gt;

&lt;p&gt;次はいよいよこの文字列をディスプレイに表示させます。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-ディスプレイに温度を表示する&#34;&gt;5. ディスプレイに温度を表示する&lt;/h4&gt;

&lt;p&gt;取得した温度の値を使って、ディスプレイに表示するAPIを叩きます。温度の区切りを表すため、最初に試した&amp;rsquo;:&amp;lsquo;を表示するAPIも使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL})
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fourDigit()のstart_posにはディスプレイ表示の開始位置、charsには表示する文字を渡します。（詳しくはAPIの説明を読んでみてください）&lt;/p&gt;

&lt;p&gt;fourDigitPoint()には表示するかどうかの0/1を渡すようになっています。&lt;/p&gt;

&lt;p&gt;これまで作ったfunctionと繋げてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const BASE_PATH = &#39;https://us.wio.seeed.io/v1/node&#39;; // 自身のものをアプリで確認
const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;

/**
 * 温度を取得
 */
const getTemp = () =&amp;gt; {
  const ENDPOINT = `/GroveTempA0/temp`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;GET&#39;, baseURL: BASE_URL});
}

/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, tempstr.length-1);
  }
  return `${temp_str}C`;
}

/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

async function main() =&amp;gt; {
  let res = getTemp();
  const temp = res.data.temperature;
  const text = temp2digit(temp);
  console.log(text);
  res = await fourDigit(0, text);
  res = await fourDigitPoint(1);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらも試してみましょう。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行です。
&lt;img src=&#34;https://dotstud.io/img/blog/095/25_comp_demo.png&#34; alt=&#34;&#34; /&gt;
温度がディスプレイに表示されました！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-3秒ごとに更新する&#34;&gt;6. 3秒ごとに更新する&lt;/h4&gt;

&lt;p&gt;今のままではコマンドを実行した時しか処理が走りません。3秒ごとに実行するようプログラムを変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const INTERVAL = 3000;

/**
 * 繰り返し実行する
 */
setInterval(() =&amp;gt; {
  main()
  .catch((e) =&amp;gt; {
    if (e.response) console.log(e.response);
  })
}, INTERVAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;update()の実行部分をsetInterval()関数で繰り返すようにします。setInterval()の第二引数にミリ秒で数値を渡すと、その間隔ごとに実行されます。あとから変更しやすいよう、定数で宣言しておきましょう。&lt;/p&gt;

&lt;p&gt;catch()はエラーが発生するとエラーレスポンスを受け取ります。&lt;/p&gt;

&lt;p&gt;完成させたコードはこちら。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const BASE_PATH = &#39;https://us.wio.seeed.io/v1/node&#39;; // 自身のものをアプリで確認
const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;
const INTERVAL = 3000;

/**
 * 温度を取得
 *
 * @return {object}
 */
const getTemp = () =&amp;gt; {
  const ENDPOINT = `/GroveTempA0/temp`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;GET&#39;, baseURL: BASE_URL});
}

/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const tempToDigit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, temp_str.length-1);
  }
  return `${temp_str}C`;
}

/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 * @return {object}
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL})
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 * @return {object}
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

/**
 * メインの処理（同期）
 */
async function main() {
  let res = await getTemp();
  const temp = res.data.temperature;
  const text = tempToDigit(temp);
  console.log(text);
  res = await fourDigit(0, text);
  res = await fourDigitPoint(1);
}

/**
 * 繰り返し実行する
 */
setInterval(() =&amp;gt; {
  main()
  .catch((e) =&amp;gt; {
    if (e.response) console.log(e.response);
  })
}, INTERVAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;試してみる&#34;&gt;試してみる&lt;/h3&gt;

&lt;p&gt;完成コードを試してみます。ドキドキ。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行です。
&lt;img src=&#34;https://dotstud.io/img/blog/095/25_comp_demo.png&#34; alt=&#34;&#34; /&gt;
現在の室温が表示されます。&lt;/p&gt;

&lt;p&gt;3秒ごとに更新されるので、変化を試すため温度センサを手で温めてみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/26_warmer.png&#34; alt=&#34;&#34; /&gt;
少し温度が上がりました。処理を止めたい場合は&lt;code&gt;controll+c&lt;/code&gt;で終了します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これでプログラムは完成です！やったー！！&lt;/strong&gt; お疲れ様でした！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;補足-完成の一歩先へ&#34;&gt;補足: 完成の一歩先へ！&lt;/h4&gt;

&lt;p&gt;「簡単であっという間だった」というあなた！&lt;strong&gt;このガジェットを使ってできることはまだまだあります！&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;例1: Azure Web AppsなどのPaaSを使って常時稼働できるようにする&lt;/li&gt;
&lt;li&gt;例2: 温度情報をAmbientなどのウェブサービスを使ってグラフ化してみる&lt;/li&gt;
&lt;li&gt;例3: 一定の温度をトリガーにTwitterやSlackへ通知を送ってみる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記はほんの一例です。Wio Node対応モジュールもたくさんありますので、ここまでの知見を使って試してみましょう！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いかがだったでしょうか？簡単と言いつつ、コマンドでの作業やウェブ開発の経験がない人には詰まる部分が多かったかもしれません。でも、これで&lt;strong&gt;InternetとThingsの連携ができるようになりました！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IoTの世界には、まだまだたくさんの楽しいデバイスやアイディアが待っています。&lt;strong&gt;作っても使っても楽しい電子工作をやっていきましょう！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最後まで読んでくださりありがとうございました！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefryで取得したセンサーデータをAmbientで簡単にグラフ化しよう！</title>
      <link>https://dotstud.io/blog/nefry-data-show-graphically/</link>
      <pubDate>Tue, 21 Mar 2017 13:48:05 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-data-show-graphically/</guid>
      
      <description>

&lt;p&gt;こんにちは、外部ライターのわみ（&lt;a href=&#34;http://twitter.com/wamisnet&#34;&gt;@wamisnet&lt;/a&gt;）です。愛知県でネットワークの勉強をしている学生です。2014年ごろから電子工作を始め、今回紹介するFRISKサイズのIoT向けデバイス「Nefry（ねふりー）」を自作しました。&lt;/p&gt;

&lt;p&gt;IoTといえば、データを取ることはもちろんですが、データの蓄積や分析が大切です。&lt;/p&gt;

&lt;p&gt;今回は、&lt;strong&gt;簡単にデータを蓄積・グラフ化してくれる「Ambient」&lt;/strong&gt; というサービスを使って、Nefryで取得したセンサーのデータをグラフ化する方法を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;nefryとは&#34;&gt;Nefryとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/059/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「Nefry（ねふりー）」は手軽にIoTに挑戦できるFRISKサイズのデバイスです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nefry.studio/&#34;&gt;公式サイト&lt;/a&gt;から、詳細なドキュメントや制作例を確認できます。&lt;/p&gt;

&lt;h3 id=&#34;wi-fiを初期搭載&#34;&gt;Wi-Fiを初期搭載&lt;/h3&gt;

&lt;p&gt;Nefryは、Wi-Fiモジュールの &lt;strong&gt;ESP-WROOM-02を初期搭載&lt;/strong&gt; しています。簡単にインターネットに接続できるので、接続に時間をとられることなくあなたのアイデア実現に集中できます。&lt;/p&gt;

&lt;h3 id=&#34;スタンドアロンで動かせる&#34;&gt;スタンドアロンで動かせる&lt;/h3&gt;

&lt;p&gt;スマートフォンで使うようなモバイルバッテリー（5V）から給電できます。&lt;strong&gt;モバイルバッテリー＋Nefryの2つで動作する&lt;/strong&gt; ので、場所を選ばずに使うことができる優れものです！&lt;/p&gt;

&lt;h3 id=&#34;外部サービス連携が簡単&#34;&gt;外部サービス連携が簡単&lt;/h3&gt;

&lt;p&gt;NefryはGroveセンサの規格に対応しています。専用のソケットを使い、はんだづけ不要で楽しめます。また、リアルタイム通信を簡単に実現できる「Milkcocoa」や、様々なWebサービス同士を連携できる「IFTTT」などとも組み合わせることもできます。&lt;/p&gt;

&lt;p&gt;実際に使ってみた例は以下をご覧ください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liginc.co.jp/263899&#34;&gt;Webサービス同士を連携できる「IFTTT」と自作IoTデバイスを繋いで生活を便利にしてみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/iotlt-vol24-chantoku-report/&#34;&gt;【大島薫×IoT】浮気男に社会的制裁を加えるマシーンを作ってみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://dotstud.io/projects/nefry-connect-internet/&#34;&gt;Nefryの購入はこちら！&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;ambientとは&#34;&gt;Ambientとは&lt;/h2&gt;

&lt;p&gt;Ambient（アンビエント）は、&lt;strong&gt;センサーデータを蓄積・グラフ化してくれるIoTに特化したクラウドサービス&lt;/strong&gt; です。&lt;/p&gt;

&lt;p&gt;Ambientから発行される「チャネルID」「ライトキー」の &lt;strong&gt;たった2つの情報をプログラムに書き込むだけ&lt;/strong&gt; で、いとも簡単にセンサーデータをグラフ化することができます！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/01_ambient.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このようなグラフを公開したり、簡単にカスタマイズしたりすることができるので、オススメのサービスです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient公式サイト&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;つくってみよう&#34;&gt;つくってみよう！&lt;/h2&gt;

&lt;p&gt;Nefryで取得したデータをグラフ化するために、今回は以下の4ステップを試します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事前準備&lt;/li&gt;
&lt;li&gt;Ambientにチャネルを作成&lt;/li&gt;
&lt;li&gt;プログラムの書き込み&lt;/li&gt;
&lt;li&gt;NefryとAmbientの連携&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;筆者の開発環境は以下です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;windows 10&lt;/li&gt;
&lt;li&gt;Nefry version 2.3.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;開発を始める前に、NefryとAmbientのセットアップをします。&lt;/p&gt;

&lt;p&gt;NefryのWi-Fi接続とAmbientのユーザ登録が完了している方は、&lt;a href=&#34;https://dotstud.io/blog/nefry-data-show-graphically/#ambientにチャネルを作成&#34;&gt;Ambientにチャネルを作成&lt;/a&gt;から開始してください。&lt;/p&gt;

&lt;h3 id=&#34;nefryのセットアップ&#34;&gt;Nefryのセットアップ&lt;/h3&gt;

&lt;p&gt;PCやスマートフォンから、Wi-FiのSSIDが &lt;strong&gt;Nefry-XXXX&lt;/strong&gt;（変更した場合はその名前）になっているものを探し、接続します。&lt;/p&gt;

&lt;p&gt;接続できるとこのようなページが表示されます。表示されない場合は &lt;a href=&#34;http://192.168.4.1&#34;&gt;http://192.168.4.1&lt;/a&gt; に接続してみてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/02_nefry_menu.png&#34; alt=&#34;&#34; /&gt;
このトップページでNefryに関するいろいろな設定ができます。まずは「Setup WiFi」をクリックして、Wi-Fiの設定をします。&lt;/p&gt;

&lt;p&gt;Setup WiFiのページはこのようになっています。
&lt;img src=&#34;https://dotstud.io/img/blog/092/03_nefry_wifi.png&#34; alt=&#34;&#34; /&gt;
接続したいWi-Fiを選び、パスワードがある場合は入力をします。入力が完了したら「Save」をクリックしてください。設定が保存され、Nefryが再起動します。&lt;/p&gt;

&lt;p&gt;おまけですが、&lt;strong&gt;Nefry library 2.3.0&lt;/strong&gt; 以降であると5つまでのWi-Fiを記憶することができ、自動的に最も強いWi-Fiに自動接続する機能を搭載しています。Nefryを持っていて &lt;strong&gt;ライブラリが古い場合は、更新することをオススメします&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;その他のセットアップや使い方の詳細は以下の記事をご覧ください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liginc.co.jp/236620&#34;&gt;自作したオリジナルIoTデバイス「Nefry」とインターネットを繋いでみた&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ambientの登録&#34;&gt;Ambientの登録&lt;/h3&gt;

&lt;p&gt;グラフ化に必要な情報を取得するために、まずAmbientに登録します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient公式サイト&lt;/a&gt;&lt;/strong&gt; の「ユーザー登録」から登録を進めます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/04_ambient_acount.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;メールアドレス認証が必要なので、各自アカウントを用意してください。&lt;/p&gt;

&lt;h2 id=&#34;ambientにチャネルを作成&#34;&gt;Ambientにチャネルを作成&lt;/h2&gt;

&lt;p&gt;Ambientでは &lt;strong&gt;チャネルという単位で送信するデーターを管理・グラフ化する&lt;/strong&gt; ため、まずはチャネルを作成します。「チャネルを作る」ボタンから作成します。
&lt;img src=&#34;https://dotstud.io/img/blog/092/05_ambient_channel.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;チャネルが無事に作成されると、先ほどのページに情報が追加されています。「チャネルID」と「ライトキー」をあとで使うので控えておきましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/092/06_ambient_list.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;プログラムの書き込み&#34;&gt;プログラムの書き込み&lt;/h2&gt;

&lt;p&gt;今回はNefryについている &lt;strong&gt;アナログ入力&lt;/strong&gt; を使ってみます。アナログ入力を扱えるセンサであればどのようなセンサでも大丈夫ですが、この記事ではGroveの明るさセンサを扱います。&lt;/p&gt;

&lt;p&gt;全体のプログラムはこちら。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://gist-it.appspot.com/github/Nefry-Community/ProgramMaster/blob/gh-pages/Nefry/Ambient/Analog/Analog.ino&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nefryにプログラムを書き込む方法は２つあります。&lt;/p&gt;

&lt;h3 id=&#34;arduino-ideを使う&#34;&gt;Arduino IDEを使う&lt;/h3&gt;

&lt;p&gt;プログラムを編集したい場合などは、Arduino IDEに上のプログラムを貼り、編集します。&lt;/p&gt;

&lt;p&gt;Arduino IDEでコンパイルしたプログラムはNefryトップページの「Upload　Sketch」からアップロードすることができます。&lt;/p&gt;

&lt;p&gt;Arduino IDEにNefryの設定を追加する方法は、以下の記事を確認してください。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.liginc.co.jp/wp-content/uploads/2016/07/20160728-nefry.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://liginc.co.jp/298161&#34;&gt;&lt;strong&gt;さくっと生活を便利にする！FRISKサイズのIoT向けデバイス「Nefry」を使ってみよう【環境構築編】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;プログラムをダウンロードして使う&#34;&gt;プログラムをダウンロードして使う&lt;/h3&gt;

&lt;p&gt;もっと簡単に試したい場合、トップページから「Web Sketch Download」のページに移動し以下を入力してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ドメイン :  program.nefry.studio&lt;/li&gt;
&lt;li&gt;URL :  /Nefry/Ambient/Analog&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/092/07_nefry_websketch.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://program.nefry.studio/&#34;&gt;Nefry Platform&lt;/a&gt;というサイトでは他にも様々なプログラムを公開していますので、ぜひご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;nefryとambientの連携&#34;&gt;NefryとAmbientの連携&lt;/h2&gt;

&lt;p&gt;プログラムが書き込めたら、Ambientの情報をNefryに登録します。&lt;/p&gt;

&lt;p&gt;トップページから「Setup Module」をクリックしページを移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/092/08_nefry_module.png&#34; alt=&#34;&#34; /&gt;
設定項目の中から「WriteKey」と「ChannelID」となっている欄を見つけ、そこにAmbientで取得したライトキーとチャネルIDをそれぞれ入力します。&lt;/p&gt;

&lt;p&gt;Saveをクリックすると、Nefryが再起動してAmbientにデータを送るようになります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これで準備は完了です！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;ambientでグラフを見てみよう&#34;&gt;Ambientでグラフを見てみよう&lt;/h2&gt;

&lt;p&gt;Nefryに接続した明るさセンサーの値のグラフです！
&lt;img src=&#34;https://dotstud.io/img/blog/092/09_product.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;右側がAmbientのグラフ、左側がNefryの取得したアナログ値をWebConsoleで表示しています。
&lt;img src=&#34;http://program.nefry.studio/Nefry/Ambient/pic/ambientnefry.gif&#34; alt=&#34;Ambient×Nefry.git&#34; /&gt;
Nefryにライトを当てたり遠ざけたりすると、わりと &lt;strong&gt;リアルタイムにどんどんグラフが生成されていく&lt;/strong&gt; のが分かります。&lt;a href=&#34;https://ambidata.io/ch/channel.html?id=785&#34;&gt;こちらのページ&lt;/a&gt;でで今回撮影したグラフをみることができます。&lt;/p&gt;

&lt;p&gt;Ambientでは &lt;strong&gt;グラフの自動スケールやグラフの公開機能、画像の添付&lt;/strong&gt; など、今回紹介しきれないほど様々な機能が作成されています。&lt;/p&gt;

&lt;p&gt;詳しくはAmbientの公式サイトやドキュメントを確認してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient公式サイト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ambidata.io/docs/&#34;&gt;ドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は、なんとハードウエアもWeb側も &lt;strong&gt;コードを一切書かずにグラフ化する&lt;/strong&gt; ことができました。&lt;/p&gt;

&lt;p&gt;紹介したのは折れ線グラフですが、&lt;strong&gt;棒グラフや散布図などもお手軽にグラフを作れるAmbient&lt;/strong&gt; と &lt;strong&gt;Webへの接続が簡単なNefry&lt;/strong&gt; でぜひぜひ遊んでみてください。&lt;/p&gt;

&lt;p&gt;Ambientを運営されている下島さん、記事にさせていただく許可を頂きありがとうございました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>話題のWebBluetoothでGenuino101をブラウザからリモートコントロールしてみよう</title>
      <link>https://dotstud.io/blog/web-bluetooth-remote-blink/</link>
      <pubDate>Thu, 09 Mar 2017 18:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/web-bluetooth-remote-blink/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioの&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;のびすけ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;最近WebBluetoothがChromeでデフォルトで利用できるようになったと知って、今回試してみたのでまとめてみました。&lt;/p&gt;

&lt;h2 id=&#34;webbluetoothとは&#34;&gt;WebBluetoothとは&lt;/h2&gt;

&lt;p&gt;WebブラウザのAPIでBluetoothが使えるようになるAPIです。正確にはBLE（Bluetooth Low Energy）というBluetooth4.0の機能を使えます。&lt;/p&gt;

&lt;p&gt;通常、BLEはデバイス間を接続して通信させる規格ですが、その性質上、サーバーサイドかつ低レイヤーなプログラミング言語や周辺知識を持っていないと取り扱うことが難しかったです。&lt;/p&gt;

&lt;p&gt;これまでにもNode.jsでは、&lt;a href=&#34;https://github.com/sandeepmistry/noble&#34;&gt;noble&lt;/a&gt;というBLEを扱えるモジュールや類似モジュールが存在しましたが、Node.jsはサーバーサイド言語なためホストマシンが必要でした。&lt;/p&gt;

&lt;p&gt;WebBluetoothはブラウザのJavaScriptからBLEを扱うことができるブラウザAPIです。&lt;/p&gt;

&lt;h3 id=&#34;何が嬉しいの&#34;&gt;何が嬉しいの？&lt;/h3&gt;

&lt;p&gt;WebBluetoothを使えることは、何が利点になるのでしょうか。&lt;/p&gt;

&lt;p&gt;大枠で捉えると、Webとデバイスの連携がしやすくなったことが挙げられます。&lt;/p&gt;

&lt;p&gt;Webブラウザ上のJavaScriptで開発が出来るため、 &lt;strong&gt;通常のWebサイトの機能にデバイスとの連携する機能を追加することができる&lt;/strong&gt;ようになります。&lt;/p&gt;

&lt;p&gt;現行のIoTデバイスはデータを取得するために付属の専用スマホアプリなどをインストールしてBLE通信をする必要があります。これは（スマートフォンの場合）スマホアプリの開発言語のJavaやSwiftからのみBLEを扱うことが出来たからです。&lt;/p&gt;

&lt;p&gt;WebBluetoothが広まれば、デバイスと連携するスマートフォンアプリケーション（以下、スマホアプリ）を開発しなくてもいい時代が来るかもしれません。Webとデバイスの連携が格段にしやすくなるので、Webの表現は圧倒的に広がるなと感じています。&lt;/p&gt;

&lt;p&gt;僕自身は2015年の終わりにWebBluetoothを知り、当時アツくなって発表などをしていました。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;0e2b2871b9d04aab980c1274a383f1cd&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;WebBluetoothの詳細については&lt;a href=&#34;https://www.w3.org/community/web-bluetooth/&#34;&gt;W3Cのページ&lt;/a&gt;などをご確認ください。&lt;/p&gt;

&lt;h2 id=&#34;webbluetoothとgenuino101でリモートlチカをしてみよう&#34;&gt;WebBluetoothとGenuino101でリモートLチカをしてみよう&lt;/h2&gt;

&lt;p&gt;それでは実際にWebBluetoothを使ってみまししょう。&lt;/p&gt;

&lt;p&gt;今回はGenuino101というBluetooth搭載のArduino互換ボードを利用してみます。&lt;/p&gt;

&lt;h3 id=&#34;作るもの&#34;&gt;作るもの&lt;/h3&gt;

&lt;p&gt;Androidのブラウザ（Google Chrome）からGenuino101に繋げたLEDをリモートで制御してみます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-captioned data-instgrm-version=&#34;7&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:28.194444444444443% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt; &lt;p style=&#34; margin:8px 0 0 0; padding:0 4px;&#34;&gt; &lt;a href=&#34;https://www.instagram.com/p/BRMD2E3AxN_/&#34; style=&#34; color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;&#34; target=&#34;_blank&#34;&gt;WebBluetoothがAndroid通常版Chromeでも使えるようになったのでリモートLチカ。 ブラウザでBluetooth使える感動噛みしめてる&lt;/a&gt;&lt;/p&gt; &lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;n0bisukeさん(@n0bisuke)がシェアした投稿 - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2017-03-03T19:54:26+00:00&#34;&gt;2017  3月 3 11:54午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;ul id=&#34;env&#34;&gt;
    &lt;li&gt;Macbook Pro Early 2016&lt;/li&gt;
    &lt;li&gt;macOS Sierra v10.12.2&lt;/li&gt;
    &lt;li&gt;Arduino IDE v1.8.1&lt;/li&gt;
    &lt;li&gt;Android 6.0.1&lt;/li&gt;
    &lt;li&gt;Chrome 56&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;genuino101側&#34;&gt;Genuino101側&lt;/h3&gt;

&lt;p&gt;Genuino101側のソースコードはサンプルにあるものをそのまま使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Copyright (c) 2016 Intel Corporation.  All rights reserved.
 * See the bottom of this file for the license terms.
 */

#include &amp;lt;CurieBLE.h&amp;gt;

BLEPeripheral blePeripheral;  // BLE Peripheral Device (the board you&#39;re programming)
BLEService ledService(&amp;quot;19B10000-E8F2-537E-4F6C-D104768A1214&amp;quot;); // BLE LED Service

// BLE LED Switch Characteristic - custom 128-bit UUID, read and writable by central
BLEUnsignedCharCharacteristic switchCharacteristic(&amp;quot;19B10001-E8F2-537E-4F6C-D104768A1214&amp;quot;, BLERead | BLEWrite);

const int ledPin = 13; // pin to use for the LED

void setup() {
  Serial.begin(9600);

  // set LED pin to output mode
  pinMode(ledPin, OUTPUT);

  // set advertised local name and service UUID:
  blePeripheral.setLocalName(&amp;quot;LED&amp;quot;);
  blePeripheral.setAdvertisedServiceUuid(ledService.uuid());

  // add service and characteristic:
  blePeripheral.addAttribute(ledService);
  blePeripheral.addAttribute(switchCharacteristic);

  // set the initial value for the characeristic:
  switchCharacteristic.setValue(0);

  // begin advertising BLE service:
  blePeripheral.begin();

  Serial.println(&amp;quot;BLE LED Peripheral&amp;quot;);
}

void loop() {
  // listen for BLE peripherals to connect:
  BLECentral central = blePeripheral.central();

  // if a central is connected to peripheral:
  if (central) {
    Serial.print(&amp;quot;Connected to central: &amp;quot;);
    // print the central&#39;s MAC address:
    Serial.println(central.address());

    // while the central is still connected to peripheral:
    while (central.connected()) {
      // if the remote device wrote to the characteristic,
      // use the value to control the LED:
      if (switchCharacteristic.written()) {
        if (switchCharacteristic.value()) {   // any value other than 0
          Serial.println(&amp;quot;LED on&amp;quot;);
          digitalWrite(ledPin, HIGH);         // will turn the LED on
        } else {                              // a 0 value
          Serial.println(F(&amp;quot;LED off&amp;quot;));
          digitalWrite(ledPin, LOW);          // will turn the LED off
        }
      }
    }

    // when the central disconnects, print it out:
    Serial.print(F(&amp;quot;Disconnected from central: &amp;quot;));
    Serial.println(central.address());
  }
}

/*
   Copyright (c) 2016 Intel Corporation.  All rights reserved.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードをArduino IDEでGenuino101に書き込めばBLEのペリフェラル（デバイス側）として起動してくれます。&lt;/p&gt;

&lt;p&gt;ソースコードの22行目の&lt;code&gt;blePeripheral.setLocalName(&amp;quot;LED&amp;quot;);&lt;/code&gt;でLEDと指定していますが、この文字列がBLEデバイスの表示名となります。&lt;/p&gt;

&lt;p&gt;Macからは&lt;a href=&#34;https://itunes.apple.com/jp/app/lightblue/id639944780?mt=12&#34;&gt;LightBlue&lt;/a&gt;などのアプリで確認することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/afc225feba5b36b39547e701171b8070.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ブラウザ側&#34;&gt;ブラウザ側&lt;/h3&gt;

&lt;p&gt;ソースコードは&lt;a href=&#34;https://github.com/n0bisuke/webbluetooth_sample/tree/gh-pages/remote_blink&#34;&gt;こちら&lt;/a&gt;にあげています。&lt;/p&gt;

&lt;p&gt;BLEはペリフェラル（デバイス）のUUID → ServiceのUUID → CharacteristicのUUIDという感じで接続していきます。&lt;/p&gt;

&lt;p&gt;Characteristicがデバイスの個別の機能だとしたら、Serviceは機能群というイメージで捉えると分かりやすいかもしれません。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://codezine.jp/article/detail/9287&#34;&gt;CodeZineさんの記事など&lt;/a&gt;をご参照ください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const UUID = &#39;19b10000-e8f2-537e-4f6c-d104768a1214&#39;;
const SERVICE_UUID = &#39;19b10001-e8f2-537e-4f6c-d104768a1214&#39;;
let g_characteristic = {};
const $light = document.querySelector(&#39;#light&#39;);
const $bulb = document.querySelector(&#39;.bulb&#39;);

//接続後にon/off切り替え
const ledToggel = () =&amp;gt; {
  g_characteristic.readValue()
  .then((val) =&amp;gt; {
    let led_state = val.getUint8(0); //値読み取り
    led_state = led_state ? 0 : 1;
    g_characteristic.writeValue(new Uint8Array([led_state]));
    toggelClass(led_state);
  })
}

const main = () =&amp;gt; {
  return navigator.bluetooth.requestDevice({acceptAllDevices:true, optionalServices:[UUID]})
  .then(device =&amp;gt; {
    console.log(device);
    console.log(&#39;&amp;gt; Name:             &#39; + device.name);
    console.log(&#39;&amp;gt; Id:               &#39; + device.id);
    console.log(&#39;&amp;gt; Connected:        &#39; + device.gatt.connected);
    console.log(&#39;--デバイスに接続中です...--&#39;);
    return device.gatt.connect();
  })
  .then(server =&amp;gt; {
      console.log(&#39;Getting ___ Service...&#39;);
      return server.getPrimaryService(UUID);
  })
  .then(service =&amp;gt; {
      console.log(&#39;Getting ____ Characteristic...&#39;);
      return service.getCharacteristic(SERVICE_UUID);
    })
  .then(characteristic =&amp;gt; {
      g_characteristic = characteristic;
      $light.removeEventListener(&#39;click&#39;,main);
      $light.addEventListener(&#39;click&#39;,ledToggel);
      return characteristic;
    })
  .catch(error =&amp;gt; {
    console.log(&#39;Argh! &#39; + error);
  });
}

/**
 * domのclass付け替え(表示切り替え)
 */
function toggelClass(led_state){
  if(led_state){
    addClass(&#39;#ff0000&#39;);
  }else{
    removeClass();
  }
}

function removeClass(){
    $bulb.style.background = &#39;#bbb&#39;;
    $bulb.style.boxShadow = &#39;&#39;;
    $bulb.classList.remove(&amp;quot;light_up&amp;quot;);
}

function addClass(color){
    $bulb.style.background = color;
    $bulb.style.boxShadow = `0 -10px 100px ${color}`;
    $bulb.classList.add(&amp;quot;light_up&amp;quot;);
}

$light.addEventListener(&#39;click&#39;, main);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21行目の&lt;code&gt;navigator.bluetooth.requestDevice()&lt;/code&gt;で周辺のデバイスを検索し、28行目の&lt;code&gt;device.gatt.connect()&lt;/code&gt;でデバイスに接続します。&lt;/p&gt;

&lt;p&gt;32行目の&lt;code&gt;server.getPrimaryService()&lt;/code&gt;でServiceに接続し、36行目の&lt;code&gt;service.getCharacteristic()&lt;/code&gt;でCharacteristic（機能）にアクセスできます。&lt;/p&gt;

&lt;p&gt;そこで接続が確立するとボタンを押すたびに10行目の&lt;code&gt;ledToggel()&lt;/code&gt;が呼ばれ、&lt;code&gt;.readValue()&lt;/code&gt;で値読みとり、&lt;code&gt;.writeValue()&lt;/code&gt;で値の書き込みができるようになります。&lt;/p&gt;

&lt;p&gt;これらのコードは&lt;a href=&#34;https://n0bisuke.github.io/webbluetooth_sample/remote_blink/index.html&#34;&gt;GitHub Pagesで動作するようにホスティングしてある&lt;/a&gt;ので実際の動作確認もできます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いかがでしたか。&lt;/p&gt;

&lt;p&gt;WebBluetoothを使うことで&lt;strong&gt;ブラウザからBluetoothを使ってデバイスを制御する&lt;/strong&gt;ことができました。&lt;/p&gt;

&lt;p&gt;今後、この技術が普及することでWebブラウザとデバイスの距離がさらになくなっていくかもしれません。&lt;/p&gt;

&lt;p&gt;是非みなさんも試してみて、この可能性を実感してみて下さい。&lt;/p&gt;

&lt;p&gt;それでは。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ハードウェア知識ゼロでも大丈夫。「Gravity」で始める電子工作入門</title>
      <link>https://dotstud.io/blog/dfrobot-gravity-hands-on/</link>
      <pubDate>Tue, 21 Feb 2017 10:00:50 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/dfrobot-gravity-hands-on/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃちゃまるです。&lt;/p&gt;

&lt;p&gt;先日CodeZineさんで紹介した &lt;a href=&#34;http://codezine.jp/article/detail/9982&#34;&gt;ハードウェアの知識ゼロでもボードにセンサーをつなげられる「Gravity」シリーズ&lt;/a&gt; について、さらに詳しく使い方を説明していきたいと思います！&lt;/p&gt;

&lt;p&gt;※この記事は主に初心者の方・他のマイコンボードを使ってはみたが挫折してしまった方向けです。&lt;/p&gt;

&lt;h2 id=&#34;gravity-のおさらい&#34;&gt;「Gravity」のおさらい&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;Gravity&lt;/strong&gt;」とは中国・上海のハードウェア系企業であるDFRobotが作ったコネクタの規格、またそのコネクタを搭載したセンサー等を指します。&lt;/p&gt;

&lt;p&gt;簡単に言うと、開発ボードとコントローラー（ボタンなど）やセンサー（音センサーなど）を統一された規格でつなぐことができるシリーズです。つなぐ部分やコネクタ自体が色分けされているので、&lt;strong&gt;直感的に配線ができ、簡単に自分の思う通りのものができます&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本記事では&lt;a href=&#34;https://www.dfrobot.com/product-1454.html&#34;&gt;Gravity: Stater Kit for Arduino&lt;/a&gt;を題材にしています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/photo.png&#34; alt=&#34;Gravityシリーズ&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;開発環境を整える&#34;&gt;開発環境を整える&lt;/h2&gt;

&lt;p&gt;Gravityのコントローラーやセンサーを使うには、PCにIDE（書き込み用アプリケーション）を用意し、PCとマイコンボードをつなげる必要があります。まずは開発環境から整えていきましょう！&lt;/p&gt;

&lt;ul id=&#34;env&#34;&gt;
    &lt;li&gt;Macbook Air Early 2014&lt;/li&gt;
    &lt;li&gt;OS X El Capitan v10.11.6&lt;/li&gt;
    &lt;li&gt;Arduino IDE v1.6.12&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;arduino-ideをインストール&#34;&gt;Arduino IDEをインストール&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;Arduino - Software&lt;/a&gt;から「Arduino IDE」をダウンロードしてインストールします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/01.png&#34; alt=&#34;Download the Arduino IDE&#34; /&gt;
「Download the Arduino IDE」からお使いのOSを選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/02.png&#34; alt=&#34;JUST DOWNLOAD&#34; /&gt;
Arduino IDEはドネーションウェア（ユーザーが任意の利用料を開発者に寄付するライセンス形態のソフトウェア）なので、寄付金額を選択する画面に移動します。今回はグレーで書かれている「JUST DOWNLOAD」をクリックしてダウンロードを開始します。&lt;/p&gt;

&lt;h3 id=&#34;arduino-ideを起動&#34;&gt;Arduino IDEを起動&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/03.png&#34; alt=&#34;IDE初回起動画面&#34; /&gt;
Arduino IDEをダウンロード後初回起動すると、上のような画面がでてきます。このテキストエリアにコードを書いていきます。&lt;/p&gt;

&lt;p&gt;OSの言語を日本語以外に設定している場合、メニューバーの「Arduino」内の「Preferences」からArduino IDEの言語設定を変更できます。反映するにはOKを押した後アプリの再起動が必要です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/04.png&#34; alt=&#34;IDE画面説明&#34; /&gt;
基本的なArduino IDEの流れとしては、まずエディア部分にコードを書き、検証ボタンでコードを検証、その後「マイコンボードに書き込む」ボタンでマイコンにプログラムを送ります。エラーやメッセージなどはコンパイラ画面に出力されます。&lt;/p&gt;

&lt;h3 id=&#34;pcとマイコンボードをつなげる&#34;&gt;PCとマイコンボードをつなげる&lt;/h3&gt;

&lt;p&gt;PCとマイコンボードをつないで、PCからArduino IDE経由でプログラムを書き込めるようにします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/05.png&#34; alt=&#34;ボードを選択&#34; /&gt;
USBでDFRduinoとPCをつないだら、「ツール」から「Arduino/Genuino UNO」を選択するだけです。DFRduinoはArduinoと全く同じ（下で詳しく解説します）なので、これでボードと接続できました。&lt;/p&gt;

&lt;h2 id=&#34;マイコンボードにプログラムを書き込む&#34;&gt;マイコンボードにプログラムを書き込む&lt;/h2&gt;

&lt;p&gt;Arduino IDEではプログラムを書いたファイルのことを「スケッチ」と呼ぶのですが、実はアプリにいくつものスケッチサンプルが内蔵されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/06.png&#34; alt=&#34;&#34; /&gt;
上の「スケッチ例」を見るとかなりの量があります。今回は「01.Basics」内の「Blink」というスケッチを呼び出してみましょう。「Blink」をクリックすると自動的にプログラムが書かれたウィンドウが出てきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/07.png&#34; alt=&#34;Blinkサンプル&#34; /&gt;
たくさんの文字が書かれていますが、実際のプログラムは色がついている部分です（&lt;code&gt;/* */&lt;/code&gt; で囲まれている部分や&lt;code&gt;//&lt;/code&gt;と行の先頭にあるのはコメントなので、実際の挙動には関係しません）。ここに書く言語はC言語ベースの&lt;strong&gt;Arduino言語&lt;/strong&gt;です。C言語自体の記述方法（&lt;code&gt;if&lt;/code&gt;文や&lt;code&gt;for&lt;/code&gt;文など）はここでは解説しませんので、他のサイトを参考にしてください。&lt;/p&gt;

&lt;p&gt;さて、ここで本来なら「検証」ボタンを使ってプログラムに間違いがないかチェックするのですが、今回はサンプルスケッチを使っているのでエラーは出ません。一応画面左上の「検証」（チェックマークのボタン）を押してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/08.png&#34; alt=&#34;コンパイル完了&#34; /&gt;
「コンパイルが完了しました。」と同時に色々出てきました。このような画面が出たらとりあえず「プログラムの検証は成功した」と認識していれば大丈夫です。ちなみに「コンパイル」とは、人間が理解できるプログラミング言語からコンピュータが理解できる機械語へとプログラムを変換することを指します。&lt;/p&gt;

&lt;p&gt;コンパイルが完了したので、いよいよマイコンボードに書き込みましょう。「検証」の隣にある「マイコンボードに書き込む」（矢印マークのボタン）をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/09.png&#34; alt=&#34;ボード上のLED&#34; /&gt;
DFRduino UNOは上の赤で囲った部分がLEDとなっていて、さきほどのスケッチを書き込むとここが周期的に光ったり消えたりします。&lt;/p&gt;

&lt;p&gt;マイコンボードに書き込んだプログラムは、Arduino IDEで新しいスケッチを書き込まない限り動き続けます。LEDのチカチカを止めたいときは「ファイル」から「新規ファイル」を開いて、空のスケッチを書き込みます。&lt;/p&gt;

&lt;h3 id=&#34;シールドを取り付ける&#34;&gt;シールドを取り付ける&lt;/h3&gt;

&lt;p&gt;「シールド」とは、マイコンボードの機能を拡張させるアドオンボードのことを指します。今回使うマイコンボードの「DFRduino UNO R3」はArduino互換（Arduinoと全く同じ動きをするもので、作っている会社・団体が違うだけ）なので、まだこのままではGravityシリーズのセンサーやコントローラーを使うことはできません。そこで、このボードに重ねる形でGravity用シールド「I/O Sensor Expansion Shield v7.1」を乗せます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/10.png&#34; alt=&#34;シールドを重ねた写真&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このI/O Sensor Expansion Shield v7.1を詳しく見てみると、ピン（金属の出っ張っている部分）が「黒・赤・緑」や「黒・赤・青」に色分けされています。&lt;strong&gt;これがまさに、知識ゼロでもGravityで遊ぶことができる理由&lt;/strong&gt;です（後ほど配線をする際にこの色分けの恩恵を受けます）。この後のチュートリアルでは常にシールドをマイコンボードに乗せた状態で使います。&lt;/p&gt;

&lt;h2 id=&#34;プログラムの実行&#34;&gt;プログラムの実行&lt;/h2&gt;

&lt;p&gt;いよいよプログラムを実際に書いて実行していきましょう！&lt;/p&gt;

&lt;h3 id=&#34;デジタル信号を取得する&#34;&gt;デジタル信号を取得する&lt;/h3&gt;

&lt;p&gt;何かのデータを取得する際、センサーから送られてくる信号には「デジタル」と「アナログ」の二種類があります。デジタル信号は値が「0」もしくは「1」で、アナログ信号の場合は値が「0」から「1023」の1024段階で、センサーから送られています。信号を取得するモジュールのことを&lt;strong&gt;インプットデバイス&lt;/strong&gt;と呼びます。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Digital Push Button Module（以下ボタン）&lt;/p&gt;

&lt;h4 id=&#34;実行編&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;では手始めに、&lt;strong&gt;ボタンが押されているかどうかを確認する&lt;/strong&gt;プログラムを動かしてみましょう！&lt;/p&gt;

&lt;p&gt;まずは配線をします。ボタンに付属のコネクタを指し、もう片方をシールドのD側2番ピン（以下図参照）に、コネクタとピンの色が合うように挿してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/11.png&#34; alt=&#34;回路図-ボタン&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ボタンに付属している「黒・赤・緑」のコネクタは、デジタル信号を送るときに使います。今回はボタンが押されているか押されていないか、の2パターンの値が送られてきます。センサーやコントローラーの基盤の上に「D」や「A」と書かれていますが、これらもそれぞれデジタルかアナログかを示しています。&lt;/p&gt;

&lt;p&gt;次に、D側2番ピンにつながっているボタンが押されているかどうかを検知するプログラムをArduino IDEのエディタ部分に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
	Serial.begin(9600);
	pinMode(2, INPUT);
}

void loop() {
	int buttonState = digitalRead(2);
	Serial.println(buttonState);
	delay(1);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「検証」と「ボードに書き込み」ボタンの列の右端の「シリアルモニタ」ボタン（虫眼鏡のアイコン）をクリックします。ここに&lt;code&gt;Serial.println()&lt;/code&gt;の括弧内の値が表示されるようになります。&lt;/p&gt;

&lt;!--![シリアルモニタスクショ](/img/blog/087/12.png)--&gt;

&lt;h4 id=&#34;プログラム解説編&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;Arduino IDEで作成するプログラムは大きく&lt;code&gt;void setup()&lt;/code&gt;と&lt;code&gt;void loop()&lt;/code&gt;の2つに分けることができます。&lt;code&gt;setup()&lt;/code&gt;に続く中括弧（&lt;code&gt;{}&lt;/code&gt;）の中は一度だけ実行され、&lt;code&gt;loop()&lt;/code&gt;内のコードは繰り返し実行されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Serial.begin(9600);&lt;/code&gt;はシリアル通信の際データの転送速度を9600で指定しています。これはシリアルモニタを使用するのに必要です。おまじない的なものと解釈してもらって大丈夫です（笑）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pinMode()&lt;/code&gt;はどのピンを使ってどのようにデータを使うかを示しています。括弧内の一つ目にはピン番号を、二つ目には&lt;code&gt;INPUT&lt;/code&gt;（データを取得する）もしくは&lt;code&gt;OUTPUT&lt;/code&gt;（データを送信する）を指定します。今回の場合、&lt;strong&gt;D側2番ピン&lt;/strong&gt;からデータ（ボタンが押されたかどうか）を&lt;strong&gt;取得&lt;/strong&gt;したいので、&lt;code&gt;pinMode(2, INPUT);&lt;/code&gt;となります。ちなみにD側2番ピンの場合&lt;code&gt;2&lt;/code&gt;、A側2番ピンの場合&lt;code&gt;A2&lt;/code&gt;と書きます。&lt;/p&gt;

&lt;p&gt;以上が&lt;code&gt;setup()&lt;/code&gt;になります。次は&lt;code&gt;loop()&lt;/code&gt;内を見ていきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;digitalRead()&lt;/code&gt;を使うと、括弧内で指定したピンの値を読み取ることができます。今回は2番ピンを読み取りたいので&lt;code&gt;digitalRead(2)&lt;/code&gt;ですね。この値を&lt;code&gt;buttonState&lt;/code&gt;に入れておきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Serial.println()&lt;/code&gt;は括弧内の値をシリアルモニタに映します。&lt;code&gt;Serial.println(buttonState);&lt;/code&gt;の場合、&lt;code&gt;buttonState&lt;/code&gt;、つまりボタンが押されているかどうかを&lt;code&gt;0&lt;/code&gt;または&lt;code&gt;1&lt;/code&gt;でシリアルモニタに表示します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;delay()&lt;/code&gt;は括弧内の時間実行を遅らせます。時間の単位はミリ秒（1000分の1秒）です。&lt;code&gt;delay(1);&lt;/code&gt;を&lt;code&gt;loop()&lt;/code&gt;の最後に書くことによって、このプログラムを1ミリ秒ごとに実行するよう指定できます。&lt;/p&gt;

&lt;h3 id=&#34;アナログ信号を取得する&#34;&gt;アナログ信号を取得する&lt;/h3&gt;

&lt;p&gt;次はアナログ信号（0から1023までの値）を取得して、シリアルモニタで表示させてみましょう！こちらも先程と同様、センサーをインプットデバイスとして使います。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Analog Rotation Sensor（以下回転センサー）&lt;/p&gt;

&lt;h4 id=&#34;実行編-1&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;付属しているアナログ用（黒・赤・青）のコネクタで回転センサーとシールドのA側0番ピンをつなげます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/13.png&#34; alt=&#34;回路図-回転&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に以下のプログラムをエディタにコピーします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(9600);
}
void loop() {
  int sensorValue = analogRead(A0);
  Serial.println(sensorValue);
  delay(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成したスケッチを検証後ボードに送信します。シリアルモニタを開いて回転センサーのツマミを回すと、0から1023の値が回転角度に合わせて表示されると思います。&lt;/p&gt;

&lt;!--![シリアルモニタスクショ](/img/blog/087/14.png)--&gt;

&lt;h4 id=&#34;プログラム解説編-1&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;前回は&lt;code&gt;digitalRead()&lt;/code&gt;を使いましたが、今回はアナログの値を取得したいので&lt;code&gt;analogRead()&lt;/code&gt;を使います。括弧内にはピン番号を入れます。&lt;/p&gt;

&lt;p&gt;記事がとんでもなく長くなってしまうので、既出のコードは解説しません。分からない方はお手数ですが上に戻って確認してください m(._.)m&lt;/p&gt;

&lt;h3 id=&#34;ledをチカチカさせる&#34;&gt;LEDをチカチカさせる&lt;/h3&gt;

&lt;p&gt;LEDを周期的にチカチカ光らせてみます。今回はピンにつないだものから値を取得するのではなく、値をピンにつないだものに送信します。このようなモジュールを&lt;strong&gt;アウトプットデバイス&lt;/strong&gt;と呼びます。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）&lt;/p&gt;

&lt;h4 id=&#34;実行編-2&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;赤LEDをシールドのD側13番につなげてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/15.png&#34; alt=&#34;回路図-LED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ledPin = 13;
void setup() {
  pinMode(ledPin, OUTPUT);
}
void loop() {
  digitalWrite(ledPin, HIGH);
  delay(1000);
  digitalWrite(ledPin, LOW);
  delay(1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検証→ボードに書き込みで、LEDが1秒周期でチカチカし始めます。&lt;/p&gt;

&lt;h4 id=&#34;プログラム解説編-2&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;digitalWrite()&lt;/code&gt;は、括弧内の一つ目に指定したピンに&lt;code&gt;HIGH&lt;/code&gt;もしくは&lt;code&gt;LOW&lt;/code&gt;の値を送ることができます。&lt;code&gt;HIGH&lt;/code&gt;は「1」、&lt;code&gt;LOW&lt;/code&gt;は「0」となります。&lt;/p&gt;

&lt;p&gt;また、プログラム内で13番ピンの情報を何回か使うので、最初に&lt;code&gt;int ledPin = 13;&lt;/code&gt;と変数に入れておいてあげると、後々ピンの番号を変更したいときに便利です。&lt;/p&gt;

&lt;h3 id=&#34;人感ライトを作る&#34;&gt;人感ライトを作る&lt;/h3&gt;

&lt;p&gt;ここの辺りから電子工作っぽい感じになりますよ！次はインプットデバイスとアウトプットデバイスを同時に使い、&lt;strong&gt;一つのモジュールから値を取得して、その値を別のモジュールに送る&lt;/strong&gt;ような仕組みを作ってみます！&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- PIR Sensor（以下人感センサー）→インプットデバイス&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）→アウトプットデバイス&lt;/p&gt;

&lt;h4 id=&#34;実行編-3&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;人感センサーで動きを確認したら、赤LEDを点灯します。どちらもデジタルで良さそう（動いている・動いていない、点灯している・点灯していない、のそれぞれ2つの状態しかない）なので、人感センサーをD側2番ピンに、赤LEDをD側13番ピンにつなげます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/16.png&#34; alt=&#34;回路図-人感LED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int sensorPin = 2;
int ledPin =  13;
int sensorState = 0;
void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(sensorPin, INPUT);
}

void loop() {
  sensorState = digitalRead(sensorPin);
  if (sensorState == HIGH) {
    digitalWrite(ledPin, HIGH);
} else {
    digitalWrite(ledPin, LOW);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検証→ボードに書き込んでみましょう。人感センサーに向かって動いたり手を振ったりするとLEDが付くはずです。&lt;/p&gt;

&lt;h4 id=&#34;プログラム解説編-3&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;今回は変数を3つ作りました。ピン番号などは変数で管理すると、可読性も上がりピンの変更などもしやすいのでオススメです。最後に宣言した&lt;code&gt;sensorState&lt;/code&gt;は、人感センサーで読み取った値が入ります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;digitalRead()&lt;/code&gt;で読み取った値は&lt;code&gt;HIGH&lt;/code&gt;または&lt;code&gt;LOW&lt;/code&gt;でかえってきます。なので&lt;code&gt;sensorState == HIGH&lt;/code&gt;や&lt;code&gt;sensorState == LOW&lt;/code&gt;としてあげると、&lt;code&gt;HIGH&lt;/code&gt;のとき、&lt;code&gt;LOW&lt;/code&gt;のとき、と条件によって別々の挙動を指定することができます。&lt;/p&gt;

&lt;p&gt;まとめると、&lt;code&gt;digitalRead()&lt;/code&gt;で人感センサーからの値によって、赤LEDに&lt;code&gt;digitalWrite()&lt;/code&gt;でオンオフを指定しています。&lt;/p&gt;

&lt;h3 id=&#34;音でledをつける&#34;&gt;音でLEDをつける&lt;/h3&gt;

&lt;p&gt;だんだん慣れてきましたか？今度は音センサーを使って、一定の音量を超えたらLEDが光る仕組みを作りましょう！&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Analog Sound Sensor（以下音センサー）→インプットデバイス&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）→アウトプットデバイス&lt;/p&gt;

&lt;h4 id=&#34;実行編-4&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;音センサーの基盤上に「A」と書かれているので、シールドのA側0番ピンに指します。赤LEDはいままで通りD側なので、D側13番に指します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/17.png&#34; alt=&#34;回路図-音LED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;いままではD側何番、A側何番、と指定してきましたが、実はD側・A側さえ合っていれば基本何番でも大丈夫です。いくつものモジュールを近いピン番号にくっつけすぎるとごちゃごちゃするので、適当に間隔を空けて配線すると楽ですよ。&lt;/p&gt;

&lt;p&gt;まずは以下のコードをエディタに入力してみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int soundPin = A0;
int ledPin = 13;

void setup() {
	pinMode(ledPin, OUTPUT);
	Serial.begin(9600);
}
void loop(){
	int soundState = analogRead(soundPin);
	Serial.println(soundState);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムを検証して実行すると、音センサーが返したアナログの値がシリアルモニタに出てきます。今回は音が「ある一定以上の音量になった場合」LEDを光らせたいので、その「ある一定」を見つける必要があります。周りの環境によって返ってくる音量の値が変わるので、自分がこれ以上音が鳴ったら光らせたい！という値を見つけてください。&lt;/p&gt;

&lt;p&gt;「ある一定」の数値が決まったらそれを反映させつつ以下のプログラムにします。先程まで使っていたコードは先頭に&lt;code&gt;//&lt;/code&gt;をつけることで無視することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int soundPin = A0;
int ledPin = 13;

void setup() {
	pinMode(ledPin, OUTPUT);
	// Serial.begin(9600);
}
void loop(){
	int soundState = analogRead(soundPin);
	// Serial.println(soundState);
	if (soundState &amp;gt; 「ある一定」の数値) {
		digitalWrite(ledPin, HIGH);
		delay(10000);
	} else {
		digitalWrite(ledPin, LOW);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度検証→ボードに書き込むと、周りの音が一定ラインを超えるとLEDが光るようになります！&lt;/p&gt;

&lt;h3 id=&#34;ledをゆっくりと点灯させる&#34;&gt;LEDをゆっくりと点灯させる&lt;/h3&gt;

&lt;p&gt;序盤にLEDを点灯させるのをすでにやりましたが、今度は&lt;strong&gt;ゆっくりと&lt;/strong&gt;点灯させます。勘の良い方は「LEDにアナログの値を書き込めないのではないか」と気づくと思います。ゆっくり点灯ということはおそらく&lt;code&gt;analogWrite()&lt;/code&gt;を使うことは予想できますが、LEDはいままで&lt;code&gt;digitalWrite();&lt;/code&gt;で値を送っていたのでできないのではないか、と。&lt;/p&gt;

&lt;p&gt;そこで&lt;strong&gt;PWN&lt;/strong&gt;（Pulse Width Modulation・パルス幅変調）を使います。ググってみると何やら難しい話が出てきますが、簡単に言うと&lt;strong&gt;デジタル信号で擬似的にアナログデータを送る&lt;/strong&gt;ことができます。&lt;/p&gt;

&lt;p&gt;PWMに対応しているピンは、今回のシールド上ではD側のアスタリスク（&lt;code&gt;*&lt;/code&gt;）が付いている3番、5番、6番、9番、10番、11番です。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）→アウトプットデバイス&lt;/p&gt;

&lt;h4 id=&#34;実行編-5&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;赤LEDをシールドのD側10番につなげます。PWM対応なのを確認してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/18.png&#34; alt=&#34;回路図-LEDPWM&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ledPin = 10;

void setup() {
	pinMode(ledPin,OUTPUT);
}
void loop(){
	for (int value = 0 ; value &amp;lt; 255; value++) {
		analogWrite(ledPin, value);
		delay(5); }
  for (int value = 255; value &amp;gt;0; value--){
 		analogWrite(ledPin, value);
	delay(5); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検証→ボードに書き込みで、ゆっくりLEDがついて、ゆっくりLEDが消えるようになります。プログラム自体はシンプルなので、解説は割愛します。&lt;/p&gt;

&lt;h2 id=&#34;お疲れ様でした&#34;&gt;お疲れ様でした！&lt;/h2&gt;

&lt;p&gt;ここまでかなり長い道のりでしたね！この記事を書くのにも結構時間かかりました（笑）&lt;/p&gt;

&lt;p&gt;この記事を通して、インプットデバイスから値を取得して、アウトプットデバイスに値を渡す、という処理をできるようになりました。これさえできるようになれば、後は好きなモジュールを使って作りたいものを作るだけです！&lt;/p&gt;

&lt;p&gt;この記事で学んだことだけでできるプロジェクトの一例として、&lt;strong&gt;流れている音楽の大きさを赤・青・緑のLEDで表す&lt;/strong&gt;なんてのはどうでしょうか。音センサーから値を取ってきて、いくつ以上の値で緑LEDを光らせて、いくつ以上で青を、いくつ以上で赤を…… と指定すればできそうですね！PWMを使うことで、さらに細かく音の大きさが表わせそうです。&lt;/p&gt;

&lt;p&gt;2017年2月23日開催の &lt;a href=&#34;https://dotstudio.connpass.com/event/49147/&#34;&gt;今度こそ挫折しない！知識ゼロからの電子工作ハンズオン&lt;/a&gt;イベントに来てくださっている方で、チュートリアルを早く終わってしまった方もぜひやってみてください！&lt;/p&gt;

&lt;p&gt;それではまた！お疲れ様でした！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>littleBits Arduinoモジュールでより細かく値を入出力して状況を伝えよう</title>
      <link>https://dotstud.io/blog/littlebits-arduino-analog-number/</link>
      <pubDate>Thu, 15 Dec 2016 10:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/littlebits-arduino-analog-number/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioライターの田中正吾です。電子回路のパーツを磁石でパチパチとつなげるだけで電子工作ができる「littleBits」の連載をLIGブログでおこなっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/235644&#34;&gt;littleBitsのArduinoモジュールで簡単にプログラミングをはじめてみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/259378&#34;&gt;ArduinoモジュールでLチカしてみた（Windows・Mac）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/268909&#34;&gt;ArduinoモジュールでON・OFFの入力値を取得してみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/280761&#34;&gt;Arduinoモジュールで入出力の連携をしてみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/295334&#34;&gt;シリアルモニタとNode.jsでlittleBits Arduinoモジュールを動かしてみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/315934&#34;&gt;littleBitsのボタンを押すとIFTTT経由でLINEにメッセージが飛ぶ仕組みを作ってみよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本記事では、これでの連載とは少し視点を変えて、 &lt;strong&gt;littleBits Arduinoモジュールでより細かく値を入出力するアナログ入出力&lt;/strong&gt; をご紹介します。では、さっそく始めていきましょう！&lt;/p&gt;

&lt;h2 id=&#34;より細かく状況を伝えるアナログ値&#34;&gt;より細かく状況を伝えるアナログ値&lt;/h2&gt;

&lt;p&gt;いままで、ボタンを押すと何かが起こるON/OFFの反応で説明していましたが、実は&lt;a href=&#34;http://jp.littlebits.com/kits/arduino-coding-kit/&#34;&gt;ARDUINO CODING KIT&lt;/a&gt;には、より細かく状況を伝えるアナログ値を扱う入出力モジュールがあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;たとえば、DIMMERモジュール（真ん中にあるダイヤル状のツマミのモジュール）は、ツマミを回すことで電気の流れが0～100%と変わります。またBAR GRAPHモジュール（右）は流れる電気によって光るLEDの数が変わります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;つまみを回しきったとき。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;半分ぐらいまでひねったとき。電流50%のときですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ON/OFFではセンサーが「反応した」「反応していない」という2つの情報しか伝えられませんでした。しかし、このように電流の量によって度合いを伝えることができると、たとえば光センサーモジュールを使ったときに明るさを「暗い」「やや暗い」「やや明るい」「とても明るい」といったように、より細かく伝えることができます。&lt;/p&gt;

&lt;h2 id=&#34;アナログ値をarduinoモジュールで計測してみる&#34;&gt;アナログ値をArduinoモジュールで計測してみる&lt;/h2&gt;

&lt;p&gt;それでは早速アナログ値をArduinoモジュールで計測してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/05.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DIMMERモジュールをArduinoモジュールの入力2番目のA0に取り付けます。&lt;/p&gt;

&lt;p&gt;Arduinoモジュールでアナログ値を計測するには &lt;code&gt;analogRead&lt;/code&gt; 関数を使います。Arduinoモジュールで計測できるアナログ値は0%は0として、100%は1023として計測できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(9600);
}

void loop() {
  int sensorValue = analogRead(A0);
  if(sensorValue&amp;gt;0){
    Serial.println(sensorValue);
  }
  delay(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを書き込んで、シリアルモニタで数値を見てみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DIMMERをひねると値が変わります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/07.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;シリアルプロッタのほうがよりわかりやすいですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/08.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/09.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dimmerモジュールのツマミにあわせて点滅を変えてみる&#34;&gt;DIMMERモジュールのツマミにあわせて点滅を変えてみる&lt;/h2&gt;

&lt;p&gt;DIMMERモジュールのツマミの度合いが取れるようになったので、ツマミに合わせてBARGRAPHモジュールの点滅の仕方を変えてみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このように、さきほどのDIMMERモジュールとArduinoモジュールをつないだものに、BAR GRAPHモジュールも加えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(9600);
  pinMode(5,OUTPUT);
}

void loop() {
  int sensorValue = analogRead(A0);
  if(sensorValue&amp;gt;0){
    Serial.println(sensorValue);
    digitalWrite(5,HIGH);
    delay(sensorValue);
    digitalWrite(5,LOW);
  }
  delay(sensorValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書いたコードをArduinoモジュールに書き込みます。&lt;/p&gt;

&lt;iframe width=&#34;715&#34; height=&#34;402&#34; src=&#34;https://www.youtube.com/embed/PircFP-OsQY&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;DIMMERモジュールのつまみに対応して、点滅の仕方が変わるようになりました。&lt;/p&gt;

&lt;h2 id=&#34;さらにサーボに変えてみる&#34;&gt;さらにサーボに変えてみる&lt;/h2&gt;

&lt;iframe width=&#34;715&#34; height=&#34;402&#34; src=&#34;https://www.youtube.com/embed/FVonwS3pb-E&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;http://jp.littlebits.com/kits/arduino-coding-kit/&#34;&gt;ARDUINO CODING KIT&lt;/a&gt;のサーボに変えてみました。LEDよりもわかりやすくなりますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サーボに顔をつけてみます。&lt;/p&gt;

&lt;iframe width=&#34;715&#34; height=&#34;402&#34; src=&#34;https://www.youtube.com/embed/coAm51UmCo0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;ツマミに合わせて顔がビクビクするものに早変わりします！　&lt;a href=&#34;https://liginc.co.jp/280761&#34;&gt;磁石で電子工作できる「littleBits」のArduinoモジュールで、入出力の連携をしてみよう&lt;/a&gt;で試した「三三七拍子するパンダ」はまだ動物らしい動きに見えましたが、この顔ネタはなかなかに気持ち悪いです。夢に出そう。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;今回はlittleBits Arduinoモジュールで &lt;strong&gt;より細かく値を入出力するアナログ入出力&lt;/strong&gt; をお伝えしました。ネタはひとつなのに、モジュールを付け替えるだけで光から動力へと変化します。工作物によって伝わる印象も変わるのがlittleBitsの面白いところです。&lt;/p&gt;

&lt;p&gt;そして、アナログ値を扱うとON/OFFよりも細かく状況を伝えることができたり、動きにもアクセントを持たせるたりすることができます。&lt;/p&gt;

&lt;p&gt;みなさんも、ぜひいろいろなことを試してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;littleBitsのハックには、LIGブログの&lt;a href=&#34;https://liginc.co.jp/series/littlebits&#34;&gt;littleBitsではじめるArduino&lt;/a&gt;連載、ならびに拙著『&lt;a href=&#34;http://www.1ft-seabass.jp/memo/2016/10/11/littlebits-book-release/?utm_content=bufferec8bb&amp;amp;utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=buffer&#34;&gt;「littleBits」ではじめる電子工作&lt;/a&gt;』もぜひご参照ください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>URLを入れるだけ！REST APIでNefryを簡単に制御してみよう！</title>
      <link>https://dotstud.io/blog/nefry-rest-api-tutorial/</link>
      <pubDate>Mon, 21 Nov 2016 08:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-rest-api-tutorial/</guid>
      
      <description>

&lt;p&gt;こんにちは、外部ライターのわみ（&lt;a href=&#34;http://twitter.com/wamisnet&#34;&gt;@wamisnet&lt;/a&gt;）と申します。愛知県でネットワークの勉強をしている学生です。2014年ごろから電子工作を始め、FRISKサイズのIoT向けデバイス「Nefry（ねふりー）」を自作しました。&lt;/p&gt;

&lt;p&gt;そんな「Nefry」をWeb系のエンジニアでも触れられるように、REST APIでハードウエアをいじれるようにしてみました。C言語を使わずに、JavaScriptやC#から簡単に試せるのでぜひ遊んでみてください。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※Nefry library version 2.2.2以上の場合使用できます。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;nefryとは&#34;&gt;Nefryとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/059/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「Nefry（ねふりー）」は手軽にIoTに挑戦できるFRISKサイズのデバイスです。Wi-Fiを搭載しておりインターネットに接続しやすいため、接続に時間をとられることなくあなたのアイデア実現に集中できます。&lt;em&gt;日本の技適に通ったESP-WROOM-02を使っています。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;また、スマートフォンで使うようなモバイルバッテリーで動作するので、場所を選ばずに使えるという優れものです！　Groveセンサー対応しており、はんだ付け不要で楽しめます。（&lt;strong&gt;&lt;a href=&#34;https://dotstud.io/projects/nefry-connect-internet/&#34;&gt;dotstudioのECサイト&lt;/a&gt;にて販売中です！！&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;LIGブログにいくつか記事を載せていますのでご覧ください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://liginc.co.jp/236620&#34;&gt;自作したオリジナルIoTデバイス「Nefry」とインターネットを繋いでみた&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://liginc.co.jp/263899&#34;&gt;Webサービス同士を連携できる「IFTTT」と自作IoTデバイスを繋いで生活を便利にしてみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;rest-apiとは&#34;&gt;REST APIとは&lt;/h2&gt;

&lt;p&gt;REST APIとは、簡単なURLを叩くだけでそこにある情報や資源にアクセスできる仕組みのことです。TwitterのREST APIで例えてみましょう！&lt;/p&gt;

&lt;p&gt;Twitterでフォロワーの一覧を取得したい場合はこちらのREST API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;api.twitter.com/1.1/&lt;strong&gt;followers/list&lt;/strong&gt;.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ツイートを検索したい場合はこちらのREST API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;api.twitter.com/1.1/&lt;strong&gt;search/tweets&lt;/strong&gt;.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;認証情報など必要な引数を渡せばTwitterにアクセスできるのです。URLを見るだけで、何ができるかがわかるのがREST APIのよさの一つだと思います。&lt;/p&gt;

&lt;p&gt;そんなREST APIにNefryも対応し、より簡単にいろんなことを試せるようにしてみました。以下で、どんなことができるのかを簡単に紹介します。&lt;/p&gt;

&lt;h2 id=&#34;nefryのおすすめrest-api&#34;&gt;NefryのおすすめREST API&lt;/h2&gt;

&lt;p&gt;今回紹介するのは、今実装されている機能の一部のみです。実装されているすべての機能は&lt;a href=&#34;http://qiita.com/wamisnet/private/5483d14bf21cd3193ae0&#34;&gt;こちらのQiitaの記事&lt;/a&gt;にまとめていますので興味があればご覧ください。&lt;/p&gt;

&lt;p&gt;デフォルトのままのREST APIであると、URLさえわかれば別の人も簡単に制御できてしまうので、基本的にはPasswordをかけて使用してください。（かけ方は後ほど紹介します）&lt;/p&gt;

&lt;h3 id=&#34;gpio-入出力ピン&#34;&gt;GPIO（入出力ピン）&lt;/h3&gt;

&lt;p&gt;Nefryについている入出力ピンを制御することができるAPIのまとめです。&lt;/p&gt;

&lt;h3 id=&#34;入力&#34;&gt;入力&lt;/h3&gt;

&lt;p&gt;Nefryの入力ピンがどうなっているかを取得できます。スイッチや明るさセンサーのような簡単なセンサーを手軽に試すことができます。&lt;/p&gt;

&lt;h4 id=&#34;デジタル&#34;&gt;デジタル&lt;/h4&gt;

&lt;p&gt;NefryのD0-D5の入力を取得できます。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;項目&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;URL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/digitalRead&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;引数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pin(範囲：D0-D5)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;具体例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/digitalRead?pin=D1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;返り値&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{&amp;ldquo;mode&amp;rdquo;:&amp;ldquo;digitalRead&amp;rdquo;,&amp;ldquo;pin&amp;rdquo;:&amp;ldquo;D1&amp;rdquo;,&amp;ldquo;value&amp;rdquo;:0}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;pin名と状態がvalueに含まれて返答されます。valueの範囲は0(low)-1(high)となります。 &lt;strong&gt;スイッチの状態を取得するのに向いています。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;アナログ&#34;&gt;アナログ&lt;/h4&gt;

&lt;p&gt;NefryのA0の入力を取得できます。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;項目&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;URL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/analogRead&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;引数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;なし&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;具体例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/analogRead&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;返り値&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{&amp;ldquo;mode&amp;rdquo;:&amp;ldquo;analogRead&amp;rdquo;,&amp;ldquo;&amp;ldquo;value&amp;rdquo;:0}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;状態がvalueに含まれて返答されます。valueの範囲は0-255となります。&lt;strong&gt;明るさセンサーを取得するのに向いています。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;出力&#34;&gt;出力&lt;/h3&gt;

&lt;h4 id=&#34;デジタル-1&#34;&gt;デジタル&lt;/h4&gt;

&lt;p&gt;NefryのD0-D5ピンの出力を制御できます。HIGH(3.3v)かLOW(0v)のどちらかを出力します。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;項目&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;URL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/digitalWrite&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;引数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pin(範囲：D0-D5)　state(範囲：HIGH(1)-LOW(0))&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;具体例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/digitalWrite?pin=D1&amp;amp;state=HIGH&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;返り値&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{&amp;ldquo;mode&amp;rdquo;:&amp;ldquo;digitalWrite&amp;rdquo;,&amp;ldquo;pin&amp;rdquo;:&amp;ldquo;D1&amp;rdquo;,&amp;ldquo;value&amp;rdquo;:1}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;pin名と状態がvalueに含まれて返答されます。&lt;strong&gt;LEDを点滅させることができます。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;アナログ-pwm&#34;&gt;アナログ(PWM)&lt;/h4&gt;

&lt;p&gt;NefryのD0-D5ピンの出力を制御できます。1023(3.3v)から0(0v)の指定された出力します。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;項目&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;URL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/analogWrite&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;引数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;pin(範囲：D0-D5)　state(範囲：0-1023)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;具体例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/analogWrite?pin=D1&amp;amp;state=500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;返り値&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{&amp;ldquo;mode&amp;rdquo;:&amp;ldquo;analogWrite&amp;rdquo;,&amp;ldquo;pin&amp;rdquo;:&amp;ldquo;D1&amp;rdquo;,&amp;ldquo;value&amp;rdquo;:500}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;pin名と状態がvalueに含まれて返答されます。&lt;strong&gt;LEDを徐々に明るくしたり、暗くしたりできます。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;nefry関数&#34;&gt;Nefry関数&lt;/h2&gt;

&lt;h3 id=&#34;nefry-led&#34;&gt;Nefry LED&lt;/h3&gt;

&lt;p&gt;NefryについているLEDの色を変更することができます。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;項目&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;URL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/NefrysetLed&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;引数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;r (範囲：0-255) g (範囲：0-255) b (範囲：0-255)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;具体例&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/api/1.0/NefrysetLed?r=255&amp;amp;g=0&amp;amp;b=0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;返り値&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;{&amp;ldquo;mode&amp;rdquo;:&amp;ldquo;NefrysetLed&amp;rdquo;,&amp;ldquo;r&amp;rdquo;:255,&amp;ldquo;g&amp;rdquo;:0,&amp;ldquo;b&amp;rdquo;:0}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;設定した値が返答されます。&lt;strong&gt;NefryについているLEDを制御することができます。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;NefryでREST APIを使う際には、前もってプログラムを書き込んでおく必要があります。
Nefryにプログラムを書き込む際に必要な環境については、下の記事をご覧ください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/298161&#34;&gt;さくっと生活を便利にする！FRISKサイズのIoT向けデバイス「Nefry」を使ってみよう【環境構築編】&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;環境ができたところで、Nefryのプログラムを紹介していきます。まずはシンプルなパスワード &lt;strong&gt;なし&lt;/strong&gt; から。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;NefryRESTAPI.h&amp;gt;
void setup() {
  NefryRESTAPI.begin();//RES TAPIを使うのに必要な初期化をおこないます。
}

void loop() {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ものすごくシンプルですね、&lt;code&gt;#include&amp;lt;NefryRESTAPI.h&amp;gt;&lt;/code&gt;こちらでライブラリーを読み込み、&lt;code&gt;NefryRESTAPI.begin();&lt;/code&gt;にてライブラリーを使うのに必要な処理をするための関数を呼び出すだけでREST APIを使用できるようになります。&lt;/p&gt;

&lt;h3 id=&#34;パスワードをつけてみる&#34;&gt;パスワードをつけてみる&lt;/h3&gt;

&lt;p&gt;次にパスワード &lt;strong&gt;あり&lt;/strong&gt; のプログラムを紹介します。&lt;/p&gt;

&lt;p&gt;※ 現状http通信での通信であるため、セキュリティ的には大変弱いです。あくまでパスワードは誰もが簡単にアクセスできないようにするためのものです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;NefryRESTAPI.h&amp;gt;
void setup() {
  NefryRESTAPI.begin();//REST APIを使うのに必要な初期化をおこないます。
  NefryRESTAPI.setPassword(&amp;quot;Nefry&amp;quot;);//接続時にパスワードが必要になります。
}

void loop() {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほどのプログラムに&lt;code&gt;NefryRESTAPI.setPassword(&amp;quot;Nefry&amp;quot;);&lt;/code&gt;この一行をプラスするだけです。この場合のパスワードは、&lt;strong&gt;Nefry&lt;/strong&gt; となります。&lt;/p&gt;

&lt;p&gt;ダブルクォーテーションの間にパスワードを入力して、Nefryに書き込めば準備完了です！　パスワードありはAPIを使用する際にURLにpass=(プログラム内のパスワード)を追記してください。&lt;/p&gt;

&lt;p&gt;具体例1：　/api/1.0/NefrysetLed?r=255&amp;amp;g=0&amp;amp;b=255&amp;amp;pass=Nefry&lt;br /&gt;
具体例2：　/api/1.0/analogRead?pass=Nefry&lt;/p&gt;

&lt;h3 id=&#34;実際に動かしてみる&#34;&gt;実際に動かしてみる&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-video&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;NefryにRESTAPIぽいものを実装してみた！&lt;br&gt;&lt;br&gt;APIを叩くとNefryにもともとついているledが青から緑に変化して、そのあとD5ピンに繋がってる赤色のledが点灯します &lt;a href=&#34;https://t.co/2Pe4yWuF1I&#34;&gt;pic.twitter.com/2Pe4yWuF1I&lt;/a&gt;&lt;/p&gt; わみ (@wamisnet) &lt;a href=&#34;https://twitter.com/wamisnet/status/796955915966525441&#34;&gt;2016年11月11日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;AndroidのchromeでNefryのREST APIを叩いてみました。初めにNefryついているLEDが青から緑になり、次のAPIの指示でD5ピンに接続されているLEDが点灯する流れを撮影しました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/059/03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;私の環境では、はじめに&lt;strong&gt;&lt;a href=&#34;http://192.168.4.1/api/1.0/NefrysetLed?g=255&#34;&gt;http://192.168.4.1/api/1.0/NefrysetLed?g=255&lt;/a&gt;&lt;/strong&gt;でNefryのLEDの色を変更して、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/059/04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;つぎに&lt;strong&gt;&lt;a href=&#34;http://192.168.4.1/api/1.0/digitalWrite?pin=d5&amp;amp;state=high&#34;&gt;http://192.168.4.1/api/1.0/digitalWrite?pin=d5&amp;amp;state=high&lt;/a&gt;&lt;/strong&gt;で赤色のLEDを光らせています。URLを送信すると驚くくらい即反応します。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ブラウザさえあれば、REST APIで明るさセンサーの値が取れたり、NefryのLEDをいじったりとハードウエアを簡単にいじることができます。また、ArduinoIDEでプログラムが書けなくても手軽に触れるのでちょっと試したいことがあるときなんかにもいいです。&lt;/p&gt;

&lt;p&gt;REST APIはJavaScriptやC#から制御できます。既存のものにハードウエアを制御させることもできるのでぜひ遊んでみてください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to set up your Nefry for the first time</title>
      <link>https://dotstud.io/blog/nefry-enenglish-how-to/</link>
      <pubDate>Fri, 04 Nov 2016 10:00:03 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-enenglish-how-to/</guid>
      
      <description>

&lt;p&gt;Hi I’m Wami. I’m a university student who is learning networking in Japan. I’m into electronics since 2014, and I’ve made an IoT device named “Nefry” which is as small as FRISK.&lt;/p&gt;

&lt;p&gt;This is a very easy and short tutorial on how to set up the development environment on your Nefry and get started programming immediately. Arduino Software (IDE) needed.&lt;/p&gt;

&lt;h2 id=&#34;what-is-nefry&#34;&gt;What is Nefry?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry is an IoT Device which allows you to connect internet very easily. You also can  attach GROVE sensors to it. Nefry does not need complicated setting thus you can spend more time with making your ideas true.&lt;/p&gt;

&lt;p&gt;Nefry also can be connected with useful web services such as &lt;a href=&#34;https://mlkcca.com/&#34;&gt;milkcocoa&lt;/a&gt; (real-time operating system) or &lt;a href=&#34;https://ifttt.com/&#34;&gt;IFTTT&lt;/a&gt;. Since Nefry works with mobile battery, you can put Nefry anywhere you want.&lt;/p&gt;

&lt;h2 id=&#34;let-s-get-started&#34;&gt;Let&amp;rsquo;s get started&lt;/h2&gt;

&lt;p&gt;You can make a program for Nefry on Arduino Software (IDE). Arduino is an open-source electronics platform which provides “Arduino language” to develop hardwares easier.&lt;/p&gt;

&lt;p&gt;Arduino Software (IDE) is a software for writing Arduino language.&lt;/p&gt;

&lt;h3 id=&#34;downloading-arduino-software-ide&#34;&gt;Downloading Arduino Software (IDE)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can get the latest version of Arduino Software (IDE) from the &lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;download page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you are using Windows, choose &amp;ldquo;Windows Installer”. If you are using Mac, click &amp;ldquo;Mac OS X” to install.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After choosing the software, the page above will come up. If you want to donate and donate, choose &amp;ldquo;CONTRIBUTE &amp;amp; DOWNLOAD”. Otherwise click &amp;ldquo;JUST DOWNLOAD” to start downloading.&lt;/p&gt;

&lt;h4 id=&#34;when-a-popup-like-this-comes-up-needed-uninstalling&#34;&gt;When a popup like this comes up (Needed uninstalling)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/05.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If a popup like this comes up, that means you have already installed old version of Arduino Software (IDE). Click “OK” to uninstall the old one.&lt;/p&gt;

&lt;p&gt;If not, please skip until next headline.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/07.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/08.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;installing-arduino-software-ide&#34;&gt;Installing Arduino Software (IDE)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/09.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you do not have any problems with Licence Agreement, click on the “I Agree” button to the next step.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can select options (There is no problem with all checked though). Click “Next” to following step.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can browse the installation location.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Please wait for a while until install finishes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the installation finishes, you will see COMPLETED on the desplay.&lt;/p&gt;

&lt;h3 id=&#34;activating-arduino-software-ide&#34;&gt;Activating Arduino Software (IDE)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After you have installed the Arduino Software (IDE), there will be an icon like this on you desktop. Double click to run Arduino Software (IDE).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Arduino Software (IDE) will automatically start-up.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can now start programming. Well done!&lt;/p&gt;

&lt;h2 id=&#34;installing-the-nefry-board&#34;&gt;Installing the Nefry board&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Arduino Software (IDE) does not support Nefry. To activate Nefry, you need to install the “board”. Open “Preferences”, and type the URL below to the new Additional Boards Manager URLs option.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wamisnet.github.io/package_nefry_index.json&#34;&gt;http://wamisnet.github.io/package_nefry_index.json&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click &amp;ldquo;OK&amp;rdquo; to save the new preference settings.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Open the Boards Manager by navigating to the Tools &amp;gt; Board menu.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You will then be able to select Nefry and install the board. If you can’t find Nefry, please reconfirm you have typed the correct URL at Additional Boards Manager URLs option.&lt;/p&gt;

&lt;h4 id=&#34;making-install-clean&#34;&gt;Making install clean&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click on &amp;ldquo;Install&amp;rdquo; button to install the latest version (v1.6.12 2016/11/01). Download will begin in a moment.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;“INSTALLED” comes up when the installation is completed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can now choose Nefry V2 on the category drop down menu (Tools &amp;gt; Board “Nefry” &amp;gt; Nefry V2). These settings are needed at the first time.&lt;/p&gt;

&lt;p&gt;Once you have done the primary settings, you can start from writing codes.&lt;/p&gt;

&lt;h4 id=&#34;update-to-the-latest-version&#34;&gt;Update to the latest version&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Some troubles may cause if the old version of the board remains in your computer. You need to uninstall it by “Delete” button. Please wait for a while until uninstall is completed.&lt;/p&gt;

&lt;p&gt;After uninstalling, you can now install the newest version of Arduino Software (IDE). Please refer the headline “Making install clean” above.&lt;/p&gt;

&lt;h2 id=&#34;writing-the-code&#34;&gt;Writing the code&lt;/h2&gt;

&lt;p&gt;So now let’s write the program for Nefry. Nefry runs with the same codes with Arduino. When you run Arduino Software (IDE), following program should be written from the beginning.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup(){

}

void loop(){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let me briefly explain about these codes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this part, you write processes to be carried out only once at start-up. For example, settings for input and output pin, or initial setting for sensors.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void loop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this part, you write processes to be repeatedly carried out during the boot. For example, LED blinking or sensor data acquisition.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To wrap up, it is like this.&lt;/p&gt;

&lt;h3 id=&#34;using-led&#34;&gt;Using LED&lt;/h3&gt;

&lt;p&gt;This time, we will blink full-color LED randomly. Please delete all statements written on Arduino Software (IDE), and paste the program below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
//full-color LED, the color changes randomly
void setup() {
  Nefry.println(&amp;quot;fullColorLED!&amp;quot;);
  randomSeed(analogRead(A0));
}
int red,green,blue;
void loop() {
  red=random(255);//random function reply numbers from 0 to 255 randomly
  green=random(255);
  blue=random(255);
  Nefry.setLed(red,green,blue);//LED blinks randomly
  String color=&amp;quot;Red:&amp;quot;;color+=red;
  color+=&amp;quot; Green:&amp;quot;;color+=green;
  color+=&amp;quot; Blue:&amp;quot;;color+=blue;
  Nefry.println(color);//Nefry console shows the color
  Nefry.ndelay(1000);//wait a second
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry functions are used in some places. I summarized these on &lt;a href=&#34;http://qiita.com/wamisnet/items/e44812eb6d6fded7af26&#34;&gt;Qiita&lt;/a&gt;. Please have a look if you are interested.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/28.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You need to save the program after writing the code. The program will be saved in the location where you chose (Don&amp;rsquo;t forget the place!).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/29.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click on &amp;ldquo;Export compiled Binary” to convert the file for Nefry. It takes a little time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/30.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It will display &amp;ldquo;Done compiling” if there is no problem with the program. If there is, Arduino Software (IDE) shows you where you have to fix (such as &amp;ldquo;no semicolons&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;In the following part, we will write a program to Nefry.&lt;/p&gt;

&lt;h3 id=&#34;writing-program-on-nefry&#34;&gt;Writing program on Nefry&lt;/h3&gt;

&lt;p&gt;Finally let’s write the program on Nefry. Please connect Nefry to the USB port of mobile battery or PC.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/31.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After a while, there will be &amp;ldquo;Nefry-○○○○” on your Wi-Fi. Please connect to it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/32.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When you have done connecting, main page of Nefry automatically opens. If not, please enter the URL below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://192.168.4.1&#34;&gt;http://192.168.4.1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can do various settings on this page.&lt;/p&gt;

&lt;p&gt;To write program on Nefry, you need to change Nefry to writing mode. To change to writing mode, click on &amp;ldquo;setup Module”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/33.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry will automatically restart itself.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/34.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I might as well tell you what happens when you click on &amp;ldquo;Next page” at setup Module. At there, you can check networking information such as Mac address and IP address.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/35.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So let’s write the program on Nefry. Click on &amp;ldquo;Upload Sketch” to open the page. There will be “参照” button where you can choose your file. (You may be displayed different design than this due to your browser.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/36.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Open “arduino.bin”. (Please make sure you have selected the correct file.
(If wrong, Nefry will stop starting up at the worst time so please be aware)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/37.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click on “Upload”. When uploading is completed, Nefry automatically restarts to update the program.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/38.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, LED shoule be blinking like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/39.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Besides, there is also a page called &amp;ldquo;Nefry Console” where you can check the status of Nefry.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/40.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Also, at “Web Sketch Download”, you can download program to update your Nefry.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/047/41.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At &amp;ldquo;Setup WiFi”, you can connect Nefry to your own Wi-Fi.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;s all for setting up you Nefry. I know it wouold be hard to make developing environment for the first time, but once you have created, that’s all.&lt;/p&gt;

&lt;p&gt;Thanks for reading and hope Nefry helps you to try IoT easier.&lt;/p&gt;

&lt;p&gt;Original Article (Japanese) : &lt;a href=&#34;https://liginc.co.jp/298161&#34;&gt;https://liginc.co.jp/298161&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GR-COTTONで見た目も可愛く電子工作！部屋の温度をブラウザからチェックしてみよう</title>
      <link>https://dotstud.io/blog/milkcocoa-grcotton-realtime-temperature/</link>
      <pubDate>Thu, 03 Nov 2016 10:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/milkcocoa-grcotton-realtime-temperature/</guid>
      
      <description>

&lt;p&gt;こんにちは！　dotstudioのエディターのうららです。先日、バックエンドサービス「Milkcocoa」を題材にしたLT大会「 &lt;strong&gt;&lt;a href=&#34;http://mlkcca.connpass.com/event/34936/&#34;&gt;紅白Milkcocoa合戦&lt;/a&gt;&lt;/strong&gt; 」に参加してきました。&lt;/p&gt;

&lt;p&gt;そこで発表した &lt;strong&gt;Webサイト上から部屋の温度がわかる&lt;/strong&gt; という仕組みが何かしらに役に立つ気がするので本記事にまとめておこうと思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;こんな人におすすめ&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部屋の気温をブラウザ上からチェックできるようにしたり、データとして貯めたい人（ペットを飼ってる人や観葉植物を育てている人におすすめ）&lt;/li&gt;
&lt;li&gt;電子工作には興味があるけれど、せっかくなら見た目が可愛いアイテムで挑戦したい人&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;全体の構成&#34;&gt;全体の構成&lt;/h2&gt;

&lt;p&gt;マイコンボード「GR-COTTON」でセンサーの値を取得し、バックエンドサービス「Milkcocoa」を使いブラウザ側にデータを送ります。&lt;/p&gt;

&lt;p&gt;MacとGR-COTTONをUSB接続し、Node.jsを経由してMilkcocoaにデータを送ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;milkcocoa&#34;&gt;Milkcocoa&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/01_milkcocoa.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://mlkcca.com&#34;&gt;milkcocoa&lt;/a&gt;とは、&lt;strong&gt;JavaScriptのソースコードを1行挿入するだけで、リアルタイム通信ができるようになる&lt;/strong&gt; サービスです。リアルタイム通信にはバックエンドの構築が必要ですが、そこの手間が省けます。&lt;/p&gt;

&lt;h3 id=&#34;gr-cotton&#34;&gt;GR-COTTON&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/02_cotton.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こちらが今回使うマイコンボード「&lt;a href=&#34;http://gadget.renesas.com/ja/product/cotton.html&#34;&gt;GR-COTTON&lt;/a&gt;」です。ルネサスエレクトロニクスが企画する「&lt;a href=&#34;http://gadget.renesas.com/ja/&#34;&gt;がじぇっとるねさす&lt;/a&gt;（通称がじぇるね）」が作っています。&lt;/p&gt;

&lt;p&gt;最初からタッチセンサーや気温センサー、フルカラーLEDを搭載しています。しかもその &lt;strong&gt;タッチセンサーが星型&lt;/strong&gt; で、基盤も白をベースにしているので、見た目がものすごく可愛いんです！　&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;p&gt;では早速作ってみましょう！　大きく分けると次の4つの作業をします。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Milkcocoaの登録をする&lt;/li&gt;
&lt;li&gt;GR-COTTONのチュートリアル1〜10をおこなう&lt;/li&gt;
&lt;li&gt;app.jsをビルドする&lt;/li&gt;
&lt;li&gt;Webサイトを作る（HTMLのみでOK）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-milkcocoaの登録をする&#34;&gt;1. Milkcocoaの登録をする&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/04_milkcocoa.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://mlkcca.com/&#34;&gt;トップページ&lt;/a&gt;からログインして、「新しいアプリを作る」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/05_milkcocoa.png&#34; alt=&#34;&#34; /&gt;
アプリ名は自分で好きなものを登録します。ここでは「GR-COTTON」にしました。&lt;/p&gt;

&lt;p&gt;これだけでMilkcocoa側の準備はOKです。&lt;/p&gt;

&lt;h3 id=&#34;2-gr-cottonのチュートリアル1-10をおこなう&#34;&gt;2. GR-COTTONのチュートリアル1〜10をおこなう&lt;/h3&gt;

&lt;p&gt;がじぇっとるねさすが提供している、こちらの&lt;a href=&#34;http://gadget.renesas.com/ja/product/cotton_sp1.html&#34;&gt;チュートリアル&lt;/a&gt;を参考に、1〜10まで進めてください。&lt;/p&gt;

&lt;h3 id=&#34;3-node-jsのプログラムを用意する&#34;&gt;3. Node.jsのプログラムを用意する&lt;/h3&gt;

&lt;p&gt;シリアル通信でCOTTONとMilkcocoaの橋渡しをするプログラムを用意します。以下のapp.jsをプログラムに記入して実行してみてください。Node.jsで作成しています。&lt;/p&gt;

&lt;h4 id=&#34;app-js&#34;&gt;app.js&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Milkcocoaの設定
const MilkCocoa = require(&#39;milkcocoa&#39;);
const milkcocoa = new MilkCocoa(&#39;your api key&#39;);
const ds = milkcocoa.dataStore(&#39;status&#39;);

// シリアル通信の設定
const SerialPort = require(&#39;serialport&#39;);
const portName = &#39;COM6&#39;; // IDE for GRとかで調べる
const serial = new SerialPort(portName, {
  baudrate: 9600,
  flowcontrol: false,
  parser: SerialPort.parsers.readline(&amp;quot;\n&amp;quot;)
});

serial.on(&#39;open&#39;, () =&amp;gt; {
  console.log(&#39;open&#39;);
});

// シリアル通信でデータを受信したに呼び出される関数を定義
serial.on(&#39;data&#39;, (input) =&amp;gt; {
  console.log(input);
  ds.send({message: input});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ターミナルを開いて、以下のコマンドでインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm init
npm i serialport milkcocoa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;app.jsを動かしたいときは、以下のコマンドを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-webサイトを作る-htmlのみでok&#34;&gt;4. Webサイトを作る（HTMLのみでOK）&lt;/h3&gt;

&lt;p&gt;最後はフロント側を作ります！&lt;/p&gt;

&lt;h4 id=&#34;index-html&#34;&gt;index.html&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;フロント&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;log&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;https://code.jquery.com/jquery-2.2.4.min.js&amp;quot;   integrity=&amp;quot;sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=&amp;quot;   crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&#39;https://cdn.mlkcca.com/v2.0.0/milkcocoa.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
    window.onload = () =&amp;gt; {
      // Milkcocoa
      const milkcocoa = new MilkCocoa(&#39;your api key&#39;);
      const ds = milkcocoa.dataStore(&#39;status&#39;);

      // Milkcocoaからデータが送られてきた時のコールバック
      ds.on(&#39;send&#39;, (data) =&amp;gt; {
        console.log(data.value);
        // ここでhtmlのDOMを操作する

     })
    }
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/07_milkcocoa.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;14行目の&lt;code&gt;your api key&lt;/code&gt;には、先ほど登録したMilkcocoaのこの箇所の文字列を入れます。&lt;/p&gt;

&lt;p&gt;これで、&lt;code&gt;node app.js&lt;/code&gt;を打つと、コンソールに気温がリアルタイムで表示されるようになります！  ちなみに、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;うららフロント&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;


  &amp;lt;body&amp;gt;
	// ここに書き込める
    &amp;lt;div id=&amp;quot;log&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;https://code.jquery.com/jquery-2.2.4.min.js&amp;quot;   integrity=&amp;quot;sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=&amp;quot;   crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&#39;https://cdn.mlkcca.com/v2.0.0/milkcocoa.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
    window.onload = () =&amp;gt; {
      const milkcocoa = new MilkCocoa(&#39;your api key&#39;);
      const ds = milkcocoa.dataStore(&#39;status&#39;);

      ds.on(&#39;send&#39;, (data) =&amp;gt; {
        console.log(data.value);
     })
    }
    &amp;lt;/script&amp;gt;
	// ここに書き込める
  &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;// ここに書き込める&lt;/code&gt; にHTMLなどを書くと、フロント側をいじることができます。&lt;/p&gt;

&lt;h4 id=&#34;わたしが作ったフロント側のソースコード-cotton-html&#34;&gt;わたしが作ったフロント側のソースコード cotton.html&lt;/h4&gt;

&lt;p&gt;完全に余談ですが、私が作ったフロント側のソースコードも載せておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;部屋の温度なう&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;http://fonts.googleapis.com/earlyaccess/notosansjp.css&amp;quot;&amp;gt; // googleフォントを入れてみた
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;cotton.css&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;welcome&amp;quot;&amp;gt;Temperature Now&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;log&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;marquee&amp;gt;あなたは10573人目の訪問者です！&amp;lt;/marquee&amp;gt; // 文字が流れます
    &amp;lt;div id=&amp;quot;you&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;center&amp;gt;&amp;lt;table border=&amp;quot;0&amp;quot; cellspacing=&amp;quot;0&amp;quot; cellpadding=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;http://www.rays-counter.com/&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.rays-counter.com/d350_f6_022/578cc94f09357/&amp;quot; alt=&amp;quot;アクセスカウンター&amp;quot; border=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot; style=&amp;quot;font-size:xx-small&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.rays-counter.com/images/counter_01.gif&amp;quot; border=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.rays-counter.com/images/counter_02.gif&amp;quot; border=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.rays-counter.com/images/counter_03.gif&amp;quot; border=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.rays-counter.com/images/counter_04.gif&amp;quot; border=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.rays-counter.com/images/counter_05.gif&amp;quot; border=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/center&amp;gt; // アクセスカウンターです、フリーのを使いました
    &amp;lt;script src=&amp;quot;https://code.jquery.com/jquery-2.2.4.min.js&amp;quot;   integrity=&amp;quot;sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=&amp;quot;   crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&#39;https://cdn.mlkcca.com/v2.0.0/milkcocoa.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
    $(document).ready(function(){
      // Milkcocoa
      const milkcocoa = new MilkCocoa(&#39;yieldiq29oxas.mlkcca.com&#39;);
      const ds = milkcocoa.dataStore(&#39;status&#39;);

      // Milkcocoaからデータが送られてきた時のコールバック
      ds.on(&#39;send&#39;, (data) =&amp;gt; {
        console.log(data.value);
        const temp=data.value.message;
        if (temp&amp;gt;29){
          $(&#39;#log&#39;).css(&#39;color&#39;, &#39;red&#39;);
          $(&#39;#you&#39;).text(&#39;あついね！&#39;) // 29度以上になると「あついね！」というコメントが表示されます
        }
        else if (temp&amp;lt;27){
          $(&#39;#log&#39;).css(&#39;color&#39;, &#39;blue&#39;);
          $(&#39;#you&#39;).text(&#39;さむいね！&#39;)　// 27度以下になると「さむいね！」というコメントが表示されます
        }
        else {
          $(&#39;#log&#39;).css(&#39;color&#39;, &#39;#eebbcb&#39;);
          $(&#39;#you&#39;).text(&#39;ちょうどいいね！&#39;) // 27&amp;amp;28度になると「ちょうどいいね！」というコメントが表示されます
        }
        $(&#39;#log&#39;).text(&#39;今の温度は&#39;+data.value.message+&#39;度☆&#39;); // 今の温度が表示されます
        // ここでhtmlのDOMを操作する
        // milkcocoa と push でカウンター（javascript）

     })
   　});
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;style-css&#34;&gt;style.css&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;body {
  font-family: &#39;Noto Sans Japanese&#39;, sans-serif;
}

#log {
  font-size: 30px;
  text-align: center;
}

#welcome {
  font-size: 50px;
  text-align: center;
  color: darkblue
}

#you {
    text-align: center;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;見た目&#34;&gt;見た目&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/08_website.png&#34; alt=&#34;&#34; /&gt;
このような感じの見た目になります。1990年代のサイトを目指しました。全然可愛くないですね。アクセスカウンタは無料で配布されていた「&lt;a href=&#34;http://www.rays-counter.com/&#34;&gt;無料アクセスカウンター&lt;/a&gt;」を使っています。&lt;/p&gt;

&lt;p&gt;ということで、Webサイトの見た目はこのように自分でアレンジできます。HTMLの技術が少し必要になりますが、自由にいじって自分好みのサイトにしてみてください。（CSSもあればなおよしですね）&lt;/p&gt;

&lt;p&gt;この状態ではサーバーにアップされていないのでローカル環境でないとサイトを見られませんが、これをアップすれば家の外からでもスマホやPCなどで室温を確認することができます。&lt;/p&gt;

&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;

&lt;p&gt;ここからは私が詰んだ箇所を紹介します。全部で3つあります。&lt;/p&gt;

&lt;h3 id=&#34;gr-cottonのジャンパを配線する&#34;&gt;GR-COTTONのジャンパを配線する&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/09_jumper.png&#34; alt=&#34;&#34; /&gt;
通常はこのパーツを反対側に刺さないといけないです。チュートリアルにも載っていますが見落とすと操作できなくなります。&lt;/p&gt;

&lt;h3 id=&#34;ケーブルは純正のものを使う&#34;&gt;ケーブルは純正のものを使う&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/10_cable.png&#34; alt=&#34;&#34; /&gt;
コンビニで売っているモバイルバッテリーに付属しているようなケーブルだと、認識されないのです……。&lt;/p&gt;

&lt;p&gt;データ通信が可能なタイプを用意しましょう。（GR-COTTONには純正のケーブルが付属していません）&lt;/p&gt;

&lt;h3 id=&#34;kurumiwriterにチェックを入れる&#34;&gt;KurumiWriterにチェックを入れる&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/11_notfound.png&#34; alt=&#34;&#34; /&gt;
ケーブルを純正にしたのにPCからUSBドライバが表示されない、ということがありました。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;FTDIの仕様上USBポートが開いた/閉じたときでDTR(COTTONのリセット)がハイ/ロウが排他的になります。KurumiWriterでその設定ができますがデフォルト(チェックなし)ではポートが開いたときDTRがロウになります。 &lt;a href=&#34;https://t.co/aWANpSdJka&#34;&gt;https://t.co/aWANpSdJka&lt;/a&gt;&lt;/p&gt; Renesas_FUN (@Renesas_FUN) &lt;a href=&#34;https://twitter.com/Renesas_FUN/status/750323606601609216&#34;&gt;2016年7月5日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;これをTwitterでつぶやいたところ、がじぇっとるねさすさんの公式アカウントからご回答いただきました。KurumiWriterのチェックボックスにチェックをいれていなかったことが原因でした……。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;自分が詰んだところの余談が長くなってしまったのですが、部屋の温度をGR-COTTONで取得してブラウザに表示する方法を紹介しました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/010/06_code.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;余談ですが、今回使った app.jsとhtmlは、知り合いの元組み込みエンジニアいわたんさん（&lt;a href=&#34;twitter.com/iwata_n&#34;&gt;@iwata_n&lt;/a&gt;）にお願いして作ってもらいました。いわたんさんありがとうございます！&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;aa68f3d1934d480f9a3a26a6062ffa9b&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;また、当日発表したプレゼン資料はこちらから見られます。&lt;/p&gt;

&lt;p&gt;みなさんぜひ試してみてください！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>地味に便利！Raspberry Piが起動したらIPアドレスを通知するチャットボットを作る</title>
      <link>https://dotstud.io/blog/raspberry-pi-ip-notification/</link>
      <pubDate>Tue, 11 Oct 2016 10:00:49 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/raspberry-pi-ip-notification/</guid>
      
      <description>

&lt;p&gt;こんにちは、代表の&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;のびすけ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;Raspberry Piは起動するたびにIPアドレスが変わってしまうことがありますよね。
だいたいの人はSSH接続していると思うのでIPアドレスが変わると再確認をしないといけませんが、 &lt;strong&gt;RaspberryPiは基本的にディスプレイとキーボードを接続しないとIPアドレスの確認できないのがめんどくさいですね&lt;/strong&gt;。 （FTDIとかはありますがこれも手間はあります。）&lt;/p&gt;

&lt;p&gt;そこで今回は、&lt;strong&gt;Raspberry Piの起動時に自身のIPアドレスをHipChatに通知する仕組みを作ります。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ちなみに、ここでいうチャットボットは「会話をする」というより「チャットに通知するプログラム」っていう意味合いです。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 2 ModelB&lt;/li&gt;
&lt;li&gt;Raspbian 8.0 Jessie&lt;/li&gt;
&lt;li&gt;Node.js 4.4.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;node-jsでipアドレスを知る&#34;&gt;Node.jsでIPアドレスを知る&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;os.networkInterfaces()&lt;/code&gt;でネットワーク情報を取得し、&lt;code&gt;os.hostname()&lt;/code&gt;でマシン名を取得できます。
「&lt;a href=&#34;http://qiita.com/_shimizu/items/b38d1459abf8436f7f1f&#34;&gt;node.jsでローカルIPアドレスの取得&lt;/a&gt;」を参考にさせて頂きました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js
&#39;use strict&#39;

const os = require(&#39;os&#39;);
let interfaces = os.networkInterfaces();
let mes = &#39;&#39;;

for (let dev in interfaces) {
    interfaces[dev].forEach((details) =&amp;gt; {
        if (details.internal || details.family !== &#39;IPv4&#39;) return;

        mes = `${os.hostname()}:${details.address} (standup)`;
        console.log(mes);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node app.js

raspberrypi:192.168.43.70 (standup)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでホスト名とIPアドレスを取得することができました。&lt;/p&gt;

&lt;h2 id=&#34;hipchatにポストする&#34;&gt;HipChatにポストする&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/hipchat-bot-by-nodejs/&#34;&gt;話題のチャットボット開発。Node.jsでHipChatに投稿してみよう。&lt;/a&gt;の記事でHipChatに投稿している部分を外部モジュール化しておきます。
&lt;code&gt;libs/hcPost.js&lt;/code&gt;としました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.js
&#39;use strict&#39;

const os = require(&#39;os&#39;);
const hcPost = require(&#39;./libs/hcPost&#39;);
let interfaces = os.networkInterfaces();
let mes = &#39;&#39;;

for (let dev in interfaces) {
    interfaces[dev].forEach((details) =&amp;gt; {
        if (details.internal || details.family !== &#39;IPv4&#39;) return;

        mes = `${os.hostname()}:${details.address} (standup)`;
        let postData = {
            &amp;quot;color&amp;quot;: &amp;quot;yellow&amp;quot;,
            &amp;quot;message&amp;quot;: mes,
            &amp;quot;notify&amp;quot;: false,
            &amp;quot;message_format&amp;quot;:&amp;quot;text&amp;quot;
        };
        hcPost(postData);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行するとホスト名とIPアドレスがHipChatに投稿されます。&lt;/p&gt;

&lt;p&gt;ソースコードは&lt;a href=&#34;https://github.com/n0bisuke/raspi-j5-hue/blob/master/ip.js&#34;&gt;GitHub&lt;/a&gt;にも載せてあります。&lt;/p&gt;

&lt;h2 id=&#34;raspberry-piの起動時にnode-jsアプリケーションの起動を設定する&#34;&gt;Raspberry Piの起動時にNode.jsアプリケーションの起動を設定する&lt;/h2&gt;

&lt;p&gt;Node.jsのアプリケーションはRaspberry Piを再起動させたタイミングで完全にプロセスが落ちてしまうので、起動時に実行されるように設定します。
「&lt;a href=&#34;http://qiita.com/n0bisuke/items/781eac201a907a524f8e&#34;&gt;RaspberryPiの起動時にNode.jsを実行&amp;amp;PM2で永続化するメモ&lt;/a&gt;」にもあるように、&lt;code&gt;/etc/rc.local&lt;/code&gt;に処理を書き込むことで起動時に処理をしてくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vim /etc/rc.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などでファイルを開くと、デフォルトで以下の内容が記載されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Print the IP address
_IP=$(hostname -I) || true
if [ &amp;quot;$_IP&amp;quot; ]; then
  printf &amp;quot;My IP address is %s\n&amp;quot; &amp;quot;$_IP&amp;quot;
fi

exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここにNode.jsアプリケーションの実行処理を記述しましょう。&lt;code&gt;/etc/rc.local&lt;/code&gt;に以下を書き込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -u pi /home/pi/.nvm/versions/node/v4.4.2/bin/node /home/pi/app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみにこの&lt;code&gt;sudo -u pi &amp;lt;nodeコマンドの絶対パス&amp;gt; &amp;lt;起動するスクリプトの絶対パス&amp;gt;&lt;/code&gt;となります。
パスが分からない人は、whichコマンドでパスを見つけましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which node

/home/pi/.nvm/versions/node/v4.4.2/bin/node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的にこうなりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Print the IP address
_IP=$(hostname -I) || true
if [ &amp;quot;$_IP&amp;quot; ]; then
  printf &amp;quot;My IP address is %s\n&amp;quot; &amp;quot;$_IP&amp;quot;
fi

sudo -u pi /home/pi/.nvm/versions/node/v4.4.2/bin/node /home/pi/app.js

exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この状態で上手く動作するか確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /etc/rc.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでエラーが出る場合はパスの指定などが間違ってる可能性が高いです。&lt;/p&gt;

&lt;p&gt;こんな感じの表示がHipChat側にされたら成功です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/033/01.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ちなみに&lt;a href=&#34;http://japan.blogs.atlassian.com/2014/12/goodnews-new-and-improved-emoticons/&#34;&gt;HipChatの絵文字&lt;/a&gt;は種類が豊富で&lt;code&gt;(standup)&lt;/code&gt;を指定すると画像のように人が立ち上がる絵文字になります。&lt;/p&gt;

&lt;p&gt;最後に設定が出来たらRaspberry Piの電源を再起動してみましょう。
起動直後にHipChatにRaspberry PiのIPアドレスが通知されたら、起動設定が成功している証拠です。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;これで「Raspberry PiのIPが変わってしまいSSHログインがしにくい問題」が解決しそうです。
起動した際に通知が来るので通常起動してるかどうかの監視にも使えそうです。&lt;/p&gt;

&lt;p&gt;Raspberry Piからチャットへの一方通行な通信なので、Raspberry Piが何らかの原因で動作していない場合はMilkcocoaなどで双方向の通信を入れれば死活監視もできそうですね。&lt;/p&gt;

&lt;p&gt;皆さんも是非活用してみて下さい。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>