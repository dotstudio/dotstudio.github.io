<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Try on dotstudio（ドットスタジオ）</title>
    <link>https://dotstud.io/categories/try/</link>
    <description>Recent content in Try on dotstudio（ドットスタジオ）</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© 2016 dotstudio inc.</copyright>
    <lastBuildDate>Mon, 19 Mar 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/try/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Nefry BTで簡単IoT！★IoTバイブステンアゲポロシャツ★ 後編</title>
      <link>https://dotstud.io/blog/gyaruden-mao-vibes-polo2/</link>
      <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-mao-vibes-polo2/</guid>
      
      <description>

&lt;p&gt;こんにちは！ギャル電のまおです❤︎&lt;/p&gt;

&lt;p&gt;今回は「★IoTバイブステンアゲポロシャツ★」の作り方後編です。前回の記事はこちら↓
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-mao-vibes-polo/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;作り方の流れ&#34;&gt;作り方の流れ☆&lt;/h2&gt;

&lt;p&gt;作り方の流れはざっとこんな感じです。今回はArduino IDEでプログラムを書き込むところから始めていきたいと思います。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;IFTTTでレシピを作成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Arduino IDEでプログラムを書き込む&lt;/strong&gt; &lt;strong&gt;←今回はここから❤︎&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Nefry BTのWi-Fi設定とIFTTTの連携&lt;/li&gt;
&lt;li&gt;センサーとLEDをNefry BTに配線&lt;/li&gt;
&lt;li&gt;ボロシャツに取り付け&lt;/li&gt;
&lt;li&gt;☆テスト☆&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;arduino-ideでプログラムを書き込む&#34;&gt;Arduino IDEでプログラムを書き込む&lt;/h2&gt;

&lt;h3 id=&#34;arduino-ideをインストール&#34;&gt;Arduino IDEをインストール&lt;/h3&gt;

&lt;p&gt;Nefry BTはArduino IDEという無料ソフトウェアで書き込めるボードです。まだパソコンにインストールされてない方は、&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;でダウンロードしてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;Arduino IDEをPCにインストール&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;nefry-btライブラリの追加&#34;&gt;Nefry BTライブラリの追加&lt;/h3&gt;

&lt;p&gt;Arduino IDEを立ち上げてまだすぐプログラミングはできません。 まず、&lt;u&gt;Aduino IDEにNefry BTというマイコンボードを知ってもらうためにボードのインストール&lt;/u&gt;をします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/1.png&#34; alt=&#34;&#34; /&gt;
Arduino &amp;gt; Preferences をクリックしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/2.png&#34; alt=&#34;&#34; /&gt;
下記のURLを「追加のボードマネージャのURL」という欄に追加してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nefry.studio/package_nefrybt_index.json&#34;&gt;http://nefry.studio/package_nefrybt_index.json&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;追加できたら「OK」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/3.png&#34; alt=&#34;&#34; /&gt;
次にツール＞ボード＞ボードマネージャをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/4.png&#34; alt=&#34;&#34; /&gt;
ボードマネージャというウィンドウが出てくるので上にある検索欄で”Nefry”と検索すると、Nefryのライブラリが出てくるので「インストール」をクリックします。&lt;/p&gt;

&lt;p&gt;インストールが完了したらプログラムを書き込む準備は終わりです。&lt;/p&gt;

&lt;h3 id=&#34;プログラムを書き込む&#34;&gt;プログラムを書き込む&lt;/h3&gt;

&lt;p&gt;まずNefry BTをパソコンのUSBポートに差し込みましょう。&lt;/p&gt;

&lt;p&gt;下記のプログラムは&lt;u&gt;デジタルチルトセンサーが傾きを検出した時に画像がツイートされる&lt;/u&gt;というプログラムです。Nefry BTのスケッチ例の「NefryIFTTT」というプログラムを少し変えたものです。&lt;/p&gt;

&lt;p&gt;以下をArduino IDEにコピペしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;NefryIFTTT.h&amp;gt;
String Event, SecretKey;
int counter =0;                       //送信データのカウンタ
int ledPin = 1;                // Connect LED to pin A1
int switcher = 0;                 // Connect Tilt sensor to D0


void setup() {
  Nefry.setStoreTitle(&amp;quot;SecretKey&amp;quot;,0); //Nefry DataStoreのタイトルを指定
  Nefry.setStoreTitle(&amp;quot;Event&amp;quot;,1);     //Nefry DataStoreのタイトルを指定
  SecretKey = Nefry.getStoreStr(0);   //Nefry DataStoreからデータを取得
  Event = Nefry.getStoreStr(1);       //Nefry DataStoreからデータを取得
  pinMode(ledPin, OUTPUT);      // Set digital pin A1 to output mode
  pinMode(switcher, INPUT);       // Set digital pin D0 to input mode

}

void loop() {
  if (digitalRead(switcher)==HIGH) {               
    digitalWrite(ledPin, HIGH);   // Turn on LED when the sensor is tilted
    counter++;                        //送信回数加算
    bool sendData = IFTTT.send(Event, SecretKey,&amp;quot;Nefry&amp;quot;,(String)(micros()/1000000)+&amp;quot;秒&amp;quot;,(String)counter);//IFTTTにデータを送信
                                      //Value1:Nefry,Value2:Nefryが起動してからの秒数,Value3:送信カウンタ
    if (!sendData) {//IFTTTにデータを送信が成功したか失敗したかの判定
      Nefry.setLed(255, 0, 0);        //Errの時、赤色点灯
    }

    Nefry.ndelay(1000);               //送信後1秒間待つ
  }
else
     {
        digitalWrite(ledPin, LOW);    // Turn off LED when the sensor is not triggered
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/5.png&#34; alt=&#34;&#34; /&gt;
ツールをクリックして、ボード・UploadSpeed・シリアルポートを以下のように設定しましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ボード：Nefry BT&lt;/li&gt;
&lt;li&gt;UploadSpeed:115200&lt;/li&gt;
&lt;li&gt;シリアルポート:/dev/cu.usbserial-XXXXX（MacOSの場合）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/6.png&#34; alt=&#34;&#34; /&gt;
設定が完了したら左上にある「➡︎」ボタンをクリックしてボードに書き込みます。&lt;/p&gt;

&lt;h2 id=&#34;nefry-btのwi-fi設定とiftttの連携&#34;&gt;Nefry BTのWi-Fi設定とIFTTTの連携&lt;/h2&gt;

&lt;p&gt;次にNefry BTのWi-Fi設定とIFTTTの連携をします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/7.png&#34; alt=&#34;&#34; /&gt;
Nefry BTをパソコンのUSBポートなど電源が取れる状態にしてから、パソコンのWi-Fi設定のところをクリックすると、&amp;rdquo;NefryBT-xxx&amp;rdquo;のような表示があります。それをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/8.png&#34; alt=&#34;&#34; /&gt;
すると、上のようなコンソール画面が出てきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/9.png&#34; alt=&#34;&#34; /&gt;
Setup WiFiをクリックして、Nefry BTが使うWi-Fi（2.4GHz帯）を設定します。使いたいWi-FiのSSIDとパスワードを入力して「Save」します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/10.png&#34; alt=&#34;&#34; /&gt;
次に、前の画面に戻ってData Storeをクリックします。上のような画面が出てくるので、ここではIFTTTのwebhookの設定で取得した「SecretKey」とレシピを作成した時に設定した「イベント名」を記入して「Save」すれば設定完了です。&lt;/p&gt;

&lt;h2 id=&#34;センサーとledをnefry-btに配線&#34;&gt;センサーとLEDをNefry BTに配線&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/11.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;こんな感じで配線しました〜！&lt;/strong&gt;（※Nefry BT（無印）での配線です。Nefry BT R2の場合は配線表を参考に配線してください。）&lt;/p&gt;

&lt;p&gt;デジタルチルトセンサーのピン配置は以下になります。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/153/12.png&#34; alt=&#34;&#34; /&gt;
1: Input / 2: Power / 3: GND
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Nefry BT、LEDとデジタルチルトセンサーの配線表は以下になります。
&lt;img src=&#34;https://dotstud.io/img/blog/153/13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ポロシャツに取り付け&#34;&gt;ポロシャツに取り付け&lt;/h2&gt;

&lt;p&gt;ポロシャツの襟の裏側にチルトセンサーを取り付けます。
&lt;img src=&#34;https://dotstud.io/img/blog/153/14.png&#34; alt=&#34;&#34; /&gt;
配線がポロシャツの中に隠れるように、ポロシャツに穴を開けて配線を通します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/15.png&#34; alt=&#34;&#34; /&gt;
モバイルバッテリーにネフリーを接続して、巾着袋に入れます。&lt;/p&gt;

&lt;p&gt;最後に首から背中に巾着袋をかけて、チルトセンサーのピンをNefry BTに接続したら出来上がり❤︎&lt;/p&gt;

&lt;h2 id=&#34;テスト&#34;&gt;☆テスト☆&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;襟を立てると、ツイートされる！😆&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/demo.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;みんなも襟立てをインターネット化して、パリピになろうね卍&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;シャンパンは死にます✨ &lt;a href=&#34;https://t.co/2AbCV5ffOq&#34;&gt;pic.twitter.com/2AbCV5ffOq&lt;/a&gt;&lt;/p&gt; mao (@galmao777) &lt;a href=&#34;https://twitter.com/galmao777/status/964164179643912192?ref_src=twsrc%5Etfw&#34;&gt;2018年2月15日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BTで簡単IoT！★IoTバイブステンアゲポロシャツ★ 前編</title>
      <link>https://dotstud.io/blog/gyaruden-mao-vibes-polo/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-mao-vibes-polo/</guid>
      
      <description>

&lt;p&gt;こんにちは！ギャル電のまおです★
&lt;img src=&#34;https://dotstud.io/img/blog/152/1.png&#34; alt=&#34;&#34; /&gt;
今回は去年のIoTLT第30回目にてプレゼンした&lt;u&gt;インターネット経由できるバイブスアゲ↑アゲ↑なポロシャツの作り方&lt;/u&gt;について、紹介していきたいと思います！&lt;/p&gt;

&lt;h2 id=&#34;iotバイブステンアゲポロシャツ&#34;&gt;IoTバイブステンアゲポロシャツ&lt;/h2&gt;

&lt;p&gt;うちみたいな大学生ギャルがたまに六本木のクラブにいくと世代間のギャップで疑問に思うことがよくある。&lt;/p&gt;

&lt;p&gt;毎回最もモヤモヤすることは、お兄さん達のファッション。みんなも何回かは見たことあるであろう、あのちょっと色黒のがたい良さげなお兄さん達がよく着ている&amp;hellip;&amp;hellip;&lt;strong&gt;最高に襟が立ったピッチピチなポロシャツ。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;うちみたいなヤンギャル（若いギャル）は、あの最高に襟が立ったポロシャツのよさみがわからない。&lt;/p&gt;

&lt;p&gt;よってうちらギャル電、&lt;u&gt;テクノロジーを使って襟が立ったポロシャツにナウみを足してかっこよさを引き立てられるスタイル&lt;/u&gt;を提案した。&lt;/p&gt;

&lt;p&gt;それが「 &lt;strong&gt;襟立てポロシャツのインターネット化&lt;/strong&gt;」、俺が最もイケてる瞬間をインターネットで全世界にお知らせ😄&lt;/p&gt;

&lt;p&gt;しくみは、ポロシャツの襟を立てた瞬間ツイッターに通知される感じ。これならヤンギャルでも、&lt;strong&gt;バイブステンアゲピーナッツすぎてまじやばたん&lt;/strong&gt;ってなる。&lt;/p&gt;

&lt;p&gt;IoTバイブステンアゲポロシャツについてプレゼンした資料はこちら↓&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;23b7788d53344c4ab9e6d7c5415a7802&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;さっそく作っていく&#34;&gt;さっそく作っていく！&lt;/h2&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの♡&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/docs/nefrybt&#34;&gt;Nefry BT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;デジタルチルトセンサー（例: &lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-07036/&#34;&gt;DFR0028（秋月電子）&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;LED  1個&lt;/li&gt;
&lt;li&gt;モバイルバッテリー&lt;/li&gt;
&lt;li&gt;襟がめっちゃ立っているボロシャツ&lt;/li&gt;
&lt;li&gt;紐長めの巾着袋&lt;/li&gt;
&lt;li&gt;両面テープ、穴あけ道具&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;作り方の流れ&#34;&gt;作り方の流れ☆&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;IFTTTでレシピを作成&lt;/strong&gt; ←今回はここまで❤︎&lt;/li&gt;
&lt;li&gt;Arduino IDEでプログラムを書き込む&lt;/li&gt;
&lt;li&gt;Nefry BTとIFTTTの連携とwifi設定&lt;/li&gt;
&lt;li&gt;センサーとLEDをNefry BTに配線&lt;/li&gt;
&lt;li&gt;ボロシャツに取り付け&lt;/li&gt;
&lt;li&gt;☆テスト☆&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今回IoTバイブステンアゲポロシャツを作成するのにあたり、Nefry BT開発者わみさんの「&lt;a href=&#34;https://dotstud.io/blog/nefry-ifttt-push-line/&#34;&gt;&lt;strong&gt;Nefry BTとIFTTTでスイッチを押したらLINEを送る仕組みを作ってみよう&lt;/strong&gt;&lt;/a&gt;」の記事を元に作りました。こちらを参考にしながら作成するのもいいと思います！&lt;/p&gt;

&lt;h2 id=&#34;iftttでレシピを作成&#34;&gt;IFTTTでレシピを作成&lt;/h2&gt;

&lt;p&gt;IFFT（いふと）とは&lt;u&gt;いろんなWebサービス同士を簡単に連携できるサービス&lt;/u&gt;です。&lt;/p&gt;

&lt;p&gt;IFTTTは、「&lt;strong&gt;If This Then That&lt;/strong&gt;」の略で「&lt;strong&gt;もし☆☆したら♡♡をする&lt;/strong&gt;」ことを&lt;strong&gt;レシピ&lt;/strong&gt;と呼びます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/2.png&#34; alt=&#34;&#34; /&gt;
まず、&lt;a href=&#34;https://ifttt.com/&#34;&gt;IFTTTの公式サイト&lt;/a&gt;でアカウントを作ってください。&lt;/p&gt;

&lt;p&gt;次に、さっそくレシピを作成していきます。&lt;/p&gt;

&lt;h3 id=&#34;secret-keyの取得&#34;&gt;Secret Keyの取得&lt;/h3&gt;

&lt;p&gt;まずはNefry BTとIFTTTの連携に必要な「Secret Key」を取得します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/3.png&#34; alt=&#34;&#34; /&gt;
メニューバーの「Search」を選択して検索欄で”Webhook”と記入すると、Webhookアプリが出てくるのでそれをクリックしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/4.png&#34; alt=&#34;&#34; /&gt;
右上にある「Settings」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/5.png&#34; alt=&#34;&#34; /&gt;
そうすると、Account Infoが出てきます。こちらに表示されている&lt;strong&gt;URLの最後の部分がSecret Key&lt;/strong&gt;となるのでこちらを各自ゲトりましょう。（画像の中に表示されているSecret Keyは無効なので各自取得してください。）&lt;/p&gt;

&lt;h3 id=&#34;トリガーの作成&#34;&gt;トリガーの作成&lt;/h3&gt;

&lt;p&gt;次に、「もし☆☆したら」の部分（トリガー）を作成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/6.png&#34; alt=&#34;&#34; /&gt;
メニューバーの「My Applets」をクリックして「New Applet」をクリックしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/7.png&#34; alt=&#34;&#34; /&gt;
このような画面が出てきたら、「this」のとこをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/8.png&#34; alt=&#34;&#34; /&gt;
検索欄で再び&amp;rdquo;Webhook&amp;rdquo;を検索します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/9.png&#34; alt=&#34;&#34; /&gt;
「Receive a web request」をクリック！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/10.png&#34; alt=&#34;&#34; /&gt;
続いて、イベント名を記入します（Nefry　BTにプログラムを書き込む際使用する）。&lt;/p&gt;

&lt;p&gt;記入したら「Create trigger」をクリックしてトリガーの作成が完了です。&lt;/p&gt;

&lt;h3 id=&#34;アクションの作成&#34;&gt;アクションの作成&lt;/h3&gt;

&lt;p&gt;最後に「♡♡をする」の部分（アクション）を設定します！
&lt;img src=&#34;https://dotstud.io/img/blog/152/11.png&#34; alt=&#34;&#34; /&gt;
画面の「that」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/12.png&#34; alt=&#34;&#34; /&gt;
次に、使うサービスを検索欄で検索します。今回はツイッターにツイートさせたいので”twitter”と検索します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/13.png&#34; alt=&#34;&#34; /&gt;
そして、今回は画像をツイートさせたいので「Post a tweet with image」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/14.png&#34; alt=&#34;&#34; /&gt;
この画面ではツイートさせたい文章と画像のURLを記入して、「Create action」をクリックします。&lt;/p&gt;

&lt;p&gt;すると、最後の画面に移るので「Finish」をクリックしてレシピ作成終了です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;こんな感じで今回はここまで！次回後半はで残りのステップを紹介します★ では！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;デコトラサンバイザーを更にアプリで盛る🤙✨💓 &lt;a href=&#34;https://t.co/G01xOz2L3k&#34;&gt;pic.twitter.com/G01xOz2L3k&lt;/a&gt;&lt;/p&gt; ギャル電 (@GALDEN999) &lt;a href=&#34;https://twitter.com/GALDEN999/status/956156306007601152?ref_src=twsrc%5Etfw&#34;&gt;2018年1月24日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;後編の記事はこちら↓
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-mao-vibes-polo2/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon Echoを使いこなそう！Node.jsでAlexaスキル開発 - スマートスピーカーの基本とスキル開発入門</title>
      <link>https://dotstud.io/blog/nodejs-amazon-alexa-skill/</link>
      <pubDate>Tue, 06 Mar 2018 01:00:43 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nodejs-amazon-alexa-skill/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃんとくです。突然ですが、「&lt;strong&gt;スマートスピーカー&lt;/strong&gt;」流行っていますね！&lt;/p&gt;

&lt;p&gt;dotstudioでも「LINE Wave」「Google Home mini」「Amazon Echo Dot」と取り揃えております。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;が。&lt;strong&gt;ぶっちゃけ「音楽かけて」しか活用できてない……。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで、スマートスピーカーのスキルを開発し、&lt;u&gt;活用できるよう自分向けにカスタマイズ&lt;/u&gt;してみましょう！今回は&lt;strong&gt;Amazon EchoのAlexaスキルをNode.jsで開発&lt;/strong&gt;してみます！&lt;/p&gt;

&lt;p&gt;※記事は長いですが、開発は簡単なのでぜひチャレンジしてみてください！&lt;/p&gt;

&lt;h2 id=&#34;開発を始める前に&#34;&gt;開発を始める前に&lt;/h2&gt;

&lt;h3 id=&#34;alexaって何-amazon-echoじゃないの&#34;&gt;Alexaって何？Amazon Echoじゃないの？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/device.png&#34; alt=&#34;&#34; /&gt;
Amazonのスマートスピーカーは「Echo」という&lt;strong&gt;スピーカーのシリーズ&lt;/strong&gt;に、「Alexa」という&lt;strong&gt;音声AI&lt;/strong&gt;が搭載されたものです。Alexaは音声AIの名前なので、Alexa搭載のPCやクルマもありますよね。&lt;/p&gt;

&lt;p&gt;各スピーカの違いは音質だったり、スマートホームハブ内臓だったりと色々あるので、調べてみてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1711/08/news107.html&#34;&gt;日本上陸「Amazon Echo」3機種の違いは？　他社とどう差別化する？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ちなみに「LINE WAVE」の音声AIは「Clova」、「Google Home」の音声AIは「Googleアシスタント」と言います。&lt;/p&gt;

&lt;h3 id=&#34;alexaのスキルってなに&#34;&gt;Alexaのスキルってなに？&lt;/h3&gt;

&lt;p&gt;「スキル」とは、&lt;u&gt;開発者によって追加された拡張機能&lt;/u&gt;を指します。スマートフォンでいうアプリのようなものですね。&lt;/p&gt;

&lt;p&gt;スキルにも「カスタムスキル（汎用）」「スマートホームスキル（家電制御など）」「フラッシュブリーフィングスキル（読み上げ）」などの種類があります。&lt;/p&gt;

&lt;p&gt;開発したカスタムスキルは&lt;strong&gt;自分のデバイスですぐに利用&lt;/strong&gt;できますが、&lt;strong&gt;Alexaスキルストアで公開して頒布する&lt;/strong&gt;こともできます！今回は自分のデバイスで利用できるところまでやってみますよ〜！&lt;/p&gt;

&lt;h3 id=&#34;スキルを開発する方法&#34;&gt;スキルを開発する方法&lt;/h3&gt;

&lt;p&gt;まずはスキルの全体の処理の流れを見てみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/144/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Echoデバイスは受け取った音声をAlexaサービスに渡します。&lt;/li&gt;
&lt;li&gt;Alexaサービスは音声を解析してテキストに変換し、処理ロジックに渡します。&lt;/li&gt;
&lt;li&gt;処理ロジックの結果がAlexaに渡され、音声データを生成してデバイスに渡します。&lt;/li&gt;
&lt;li&gt;Echoデバイスが音声を発します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スキルを開発するときに必要なのは、上の図で「&lt;strong&gt;音声インタフェース&lt;/strong&gt;」と「&lt;strong&gt;処理ロジック&lt;/strong&gt;」の部分です。&lt;/p&gt;

&lt;p&gt;音声インタフェースは&lt;u&gt;どんな言葉を受け取るか、どう理解するか&lt;/u&gt;などです。この部分は&lt;strong&gt;Amazon Developer上で設計&lt;/strong&gt;することができます。&lt;/p&gt;

&lt;p&gt;処理ロジックは&lt;u&gt;返答をする部分&lt;/u&gt;です。自前でエンドポイントを作成することもできますが、&lt;strong&gt;AWS Lambdaで作成すると簡単に紐付けることができます&lt;/strong&gt;。今回はAWS Lambdaを使ってみます。&lt;/p&gt;

&lt;h3 id=&#34;開発手順の整理&#34;&gt;開発手順の整理&lt;/h3&gt;

&lt;p&gt;今回は下記の手順で開発していきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Amazon Developer上で音声インタフェースを設計&lt;/li&gt;
&lt;li&gt;AWS Lambdaで処理ロジックを開発&lt;/li&gt;
&lt;li&gt;音声インタフェースと処理ロジックの紐付け&lt;/li&gt;
&lt;li&gt;デバイスでスキルを有効にする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一つ一つの手順は難しくないので、しっかり理解しておきましょう！&lt;/p&gt;

&lt;h2 id=&#34;開発の事前準備&#34;&gt;開発の事前準備&lt;/h2&gt;

&lt;p&gt;各種アカウントやセットアップは開発の前にあらかじめ用意しておくとスムーズです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Amazon Developerアカウント&lt;/li&gt;
&lt;li&gt;Echoデバイスのセットアップ&lt;/li&gt;
&lt;li&gt;AWSアカウント&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下記でそれぞれの手順を紹介します。&lt;/p&gt;

&lt;h3 id=&#34;amazon-developerアカウントの作成&#34;&gt;Amazon Developerアカウントの作成&lt;/h3&gt;

&lt;p&gt;Alexaスキルの登録や音声インタフェースの設計に必要です。Amazon.co.jpのお買い物アカウントをそのまま紐付けることができます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※Amazon.com（米国）アカウントを紐付けると最後のデバイスとスキルの紐付けでうまくいかない場合があります。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://developer.amazon.com/ja/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_console.png&#34; alt=&#34;&#34; /&gt;
Amazon Developer（日本語版）&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;右上のDeveloper Consoleから登録します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_monetize.png&#34; alt=&#34;&#34; /&gt;
収益化の項目はひとまず「いいえ」にしておきます（後から変更できます）。&lt;/p&gt;

&lt;h3 id=&#34;echoデバイスのセットアップ&#34;&gt;Echoデバイスのセットアップ&lt;/h3&gt;

&lt;p&gt;スマートフォンアプリで、Amazon Developerアカウントの紐づけとWi-Fi設定を行います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_login.png&#34; alt=&#34;&#34; /&gt;
お手持ちのiPhone、Android端末にAlexaアプリをインストールしましょう（以下iPhoneでの説明です）。Amazon Developerアカウントでログインします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_setup.png&#34; alt=&#34;&#34; /&gt;
「設定」から「新しいデバイスをセットアップ」を選びます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_wifi.png&#34; alt=&#34;&#34; /&gt;
言語を選択し、スマートフォンを利用するWi-Fiに接続します。&lt;strong&gt;Wi-Fiは2.4GHz帯でないと利用できない&lt;/strong&gt;ので注意しましょう（最近だと5GHz帯も多いので確認してください）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_action.png&#34; alt=&#34;&#34; /&gt;
Echoデバイスと接続します。デバイスがオレンジになっていない場合はアクションボタンを長押しします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_mode.png&#34; alt=&#34;&#34; /&gt;
「・」のボタンがアクションボタンです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_device.png&#34; alt=&#34;&#34; /&gt;
「Amazon-XXXX」に接続します（複数のデバイスがセットアップモードになっている場合、混同しないよう注意してください）。&lt;/p&gt;

&lt;p&gt;以上でセットアップ完了です！&lt;/p&gt;

&lt;h3 id=&#34;awsアカウントの作成&#34;&gt;AWSアカウントの作成&lt;/h3&gt;

&lt;p&gt;AWSアカウントは下記の公式サイトを参考に進めてみてください（以前に登録済みだったので画面キャプチャが用意できませんでした……）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/register-flow/&#34;&gt;https://aws.amazon.com/jp/register-flow/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;アカウント登録の際には&lt;strong&gt;クレジットカードの登録&lt;/strong&gt;、&lt;strong&gt;電話確認&lt;/strong&gt;（自動応答）が必要です。&lt;/p&gt;

&lt;p&gt;AWSアカウントには2018年3月現在では1年間の無料枠がついてきますが、&lt;u&gt;ご自身のアカウントの管理には注意してください。&lt;/u&gt;&lt;/p&gt;

&lt;h2 id=&#34;音声インタフェースの設計&#34;&gt;音声インタフェースの設計&lt;/h2&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://developer.amazon.com/ja/&#34;&gt;Amazon Developer&lt;/a&gt;上で音声インタフェースを作成していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/144/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;alexaスキルを新規登録&#34;&gt;Alexaスキルを新規登録&lt;/h3&gt;

&lt;p&gt;Amazon Developerにログインして&lt;a href=&#34;https://developer.amazon.com/home.html&#34;&gt;Developer Console&lt;/a&gt;を開きます。
&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_alexa.png&#34; alt=&#34;&#34; /&gt;
Alexaのページへ移動します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_start.png&#34; alt=&#34;&#34; /&gt;
「Alexa Skills Kit」を始めます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/create1.png&#34; alt=&#34;&#34; /&gt;
「新しいスキルを追加」します（新メニューのβ版が出てますが、まだ日本語対応していないようです）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/create2.png&#34; alt=&#34;&#34; /&gt;
作成するスキルの情報を入力します。今回は下記のようにしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;スキルの種類 ⇒ 「カスタム対話モデル」&lt;/li&gt;
&lt;li&gt;言語 ⇒ 日本語&lt;/li&gt;
&lt;li&gt;スキル名 ⇒ ちゃんとくカフェ&lt;/li&gt;
&lt;li&gt;呼び出し名 ⇒ ちゃんとくカフェ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「保存」して「次へ」で作成します。&lt;/p&gt;

&lt;h3 id=&#34;対話モデルを作成&#34;&gt;対話モデルを作成&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/create3.png&#34; alt=&#34;&#34; /&gt;
作成したら、&lt;strong&gt;対話モデル&lt;/strong&gt;を作っていきます。「スキルビルダーを起動する」を選択します。&lt;/p&gt;

&lt;p&gt;対話モデルとは、&lt;u&gt;ユーザがどのように発話するか、どのように解釈して処理ロジックに伝えるか&lt;/u&gt;の部分です。用語がいくつか出てくるので、下の図を見てみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/144/model1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;スキル名を&lt;strong&gt;Invocation name&lt;/strong&gt;と言い、「&lt;strong&gt;Alexa、{Invocation name}を開いて&lt;/strong&gt;」と呼びかけます。&lt;/li&gt;
&lt;li&gt;起動後に返すAlexaの言葉を&lt;strong&gt;LaunchRequest&lt;/strong&gt;と言います。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;Alexaが受け付けるアクションの呼びかけ&lt;/u&gt;を、&lt;strong&gt;Intent&lt;/strong&gt;と言います。&lt;/li&gt;
&lt;li&gt;Intentに対するAlexaの返答を&lt;strong&gt;IntentRequest&lt;/strong&gt;と言います。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これが基本的なユーザとAlexaのやりとりの構図です。対話モデルでは&lt;strong&gt;Intent&lt;/strong&gt;を設定して、Alexaに受け付けてもらえるようにしていきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/model2.png&#34; alt=&#34;&#34; /&gt;
ちなみに「スキルを開く〜アクション」までは一文での呼びかけでもできます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder1.png&#34; alt=&#34;&#34; /&gt;
スキルビルダーの画面が開いたら、左のIntentsから「ADD」を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder2.png&#34; alt=&#34;&#34; /&gt;
設定するIntentの名前を付けます。今回はオススメを教えてもらうアクションを作成したいので「RecomendIntent」にしてみました。&lt;u&gt;アクションに沿った名前をつけておく&lt;/u&gt;とIntentが増えてもわかりやすいと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder3.png&#34; alt=&#34;&#34; /&gt;
アクションを呼ぶときの「呼びかけ」のサンプル発話を登録していきます。公式によると、パターン数は1つのIntentに対し、&lt;u&gt;最低6つ、理想は30&lt;/u&gt;だそうです。サンプル発話が多いほど認識精度が向上します。&lt;/p&gt;

&lt;p&gt;登録したら「&lt;strong&gt;Save Model&lt;/strong&gt;」、「&lt;strong&gt;Build Model&lt;/strong&gt;」を順に選択します。（Buildには少し時間がかかります。ここで機械学習がされているそうです。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder4.png&#34; alt=&#34;&#34; /&gt;
ビルドが完了したら「Configuration」を選択し、設定画面に戻ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder5.png&#34; alt=&#34;&#34; /&gt;
スキルの「ID」をコピーして、Amazon Developerは一旦置いておきます（まだ設定があるので開いたまま）。&lt;/p&gt;

&lt;h2 id=&#34;処理ロジックの開発&#34;&gt;処理ロジックの開発&lt;/h2&gt;

&lt;p&gt;続いて、&lt;a href=&#34;https://aws.amazon.com/jp/&#34;&gt;AWS&lt;/a&gt;のLambda上で処理ロジックを作っていきます。
&lt;img src=&#34;https://dotstud.io/img/blog/144/4.png&#34; alt=&#34;&#34; /&gt;
AWS Lambdaは、&lt;u&gt;AWSに関するイベントにをトリガーにする処理を作成できる実行環境&lt;/u&gt;です。&lt;/p&gt;

&lt;p&gt;自分自身でエンドポイントを立てることもできますが、AWS Lambdaを使うとロジック自体の開発や他のAWSサービスとの連携も簡単です。&lt;/p&gt;

&lt;h3 id=&#34;aws-lambda関数を作成&#34;&gt;AWS Lambda関数を作成&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func1.png&#34; alt=&#34;&#34; /&gt;
AWSコンソールを開いたら、「lambda」を検索して開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func2.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;リージョンが「東京」になっていることを確認&lt;/strong&gt;し、「関数を作成」します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func3.png&#34; alt=&#34;&#34; /&gt;
「設計図」から作成し、「alexa-skill-sdk-factskill」を検索して選びます。この設計図を利用すると、&lt;strong&gt;Alexa Skills Kit for Node.jsというNode.jsのSDK&lt;/strong&gt;がデフォルトで入ってきます。&lt;u&gt;現在のところ公式に開発されているSDKはNode.jsだけ&lt;/u&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func4.png&#34; alt=&#34;&#34; /&gt;
上記のように関数の情報を設定します。&lt;/p&gt;

&lt;p&gt;「ロール」は関数のアクセス権限です。今回は「シンプルなマイクロハーネスのアクセス権限」を選択しましたが、S3など他のサービスに繋ぎたい場合は別途選択が必要です。AWSの&lt;a href=&#34;https://developer.amazon.com/ja/docs/custom-skills/host-a-custom-skill-as-an-aws-lambda-function.html&#34;&gt;ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func5.png&#34; alt=&#34;&#34; /&gt;
下にスクロールして保存します。&lt;/p&gt;

&lt;h3 id=&#34;トリガーをセット&#34;&gt;トリガーをセット&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func6.png&#34; alt=&#34;&#34; /&gt;
関数が作成できたら、トリガー部分に「Alexa Skills Kit」をドラッグ＆ドロップで設定します。&lt;/p&gt;

&lt;p&gt;ここで「Alexa Skills Kitがない！」という人は、&lt;strong&gt;リージョンが東京になっているか&lt;/strong&gt;をもう一度確認してください。（東京じゃない場合は、リージョンを選び直して関数を再度作成ですよ！）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func8.png&#34; alt=&#34;&#34; /&gt;
下にスクロールして「トリガーの設定」に、Amazon Developerで取得した「スキルのID」を貼り付けます。&lt;/p&gt;

&lt;h3 id=&#34;処理ロジックを編集&#34;&gt;処理ロジックを編集&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func9.png&#34; alt=&#34;&#34; /&gt;
関数がデフォルトの設計図のままなので編集します。上記の部分を選択すると下にエディタが開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func11.png&#34; alt=&#34;&#34; /&gt;
コードのエントリタイプ（エディタを使う・アップロードするなど）や、ランタイムを選択できます。Node.jsは6.10までの対応になっています。もう少しバージョンが上がってほしいですね……！&lt;/p&gt;

&lt;p&gt;エディタには、デフォルトのコードを参考に下記のようなコードを貼り付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const Alexa = require(&#39;alexa-sdk&#39;);

const handlers = {
    // アプリ起動時の返答
    &#39;LaunchRequest&#39;: function () {
        const speechOutput = &#39;こんにちは。オススメをお知らせします。&#39;
        const reprompt = &#39;オススメをお知らせします。&#39;
        this.emit(&#39;:ask&#39;, speechOutput, reprompt);
    },
    // RecomendIntentへの返答
    &#39;RecomendIntent&#39;: function () {
        const intent = this.event.request.intent;
        const speechOutput = &#39;オススメはハンバーグ定食です。&#39;
        this.emit(&#39;:tell&#39;, speechOutput);
    },
    // ヘルプ（デフォルト）への返答
    &#39;AMAZON.HelpIntent&#39;: function () {
        const speechOutput = &#39;ちゃんとくカフェのオススメメニューをお知らせします。&#39;;
        const reprompt = &#39;オススメを聞いてみてください。&#39;
        this.emit(&#39;:ask&#39;, speechOutput, reprompt);
    },
    // キャンセル（デフォルト）への返答
    &#39;AMAZON.CancelIntent&#39;: function () {
        this.emit(&#39;:tell&#39;, this.t(&#39;STOP_MESSAGE&#39;));
    },
    // 対応できないアクションへの返答
    &#39;AMAZON.StopIntent&#39;: function () {
        const speechOutput = &#39;すみません。わかりません。&#39;;
        const reprompt = &#39;もう一度お願いします。&#39;
        this.emit(&#39;:tell&#39;, this.t(&#39;STOP_MESSAGE&#39;));
    },
};

// 下記のように修正
exports.handler = function(event, context, callback) {
    const alexa = Alexa.handler(event, context, callback);
    alexa.registerHandlers(handlers);
    alexa.execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほど設定した「RecomendIntent」（ご自身が設定したIntent名。小文字大文字など注意！）に対する返答や、その他の返答を作成しました。RaunchRequest、HelpIntentなど、&lt;strong&gt;スキル開発で推奨されている設定があるので記述する&lt;/strong&gt;ようにします。&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;strong&gt;この辺がきちんと設定されていないとAlexaスキルストアでは公開できない&lt;/strong&gt;みたいです。&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func7.png&#34; alt=&#34;&#34; /&gt;
コードが編集できたら右上で保存し、ARNをコピーして、AWSの設定は完了です。&lt;/p&gt;

&lt;h2 id=&#34;音声インターフェースと処理ロジックの紐付け&#34;&gt;音声インターフェースと処理ロジックの紐付け&lt;/h2&gt;

&lt;p&gt;作成したAWS Lambda関数とAmazon Developer上のスキルを紐づけます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_func.png&#34; alt=&#34;&#34; /&gt;
Amazon Developer側の設定ページで、「エンドポイント」に「AWS LambdaのARN」を選択し、「デフォルト」に先ほどのARNを貼り付けます。&lt;/p&gt;

&lt;p&gt;保存して紐づけは完了です！&lt;strong&gt;これでスキルの作成が一通り完了しました！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;試してみよう&#34;&gt;試してみよう！&lt;/h2&gt;

&lt;h3 id=&#34;シミュレータでテスト&#34;&gt;シミュレータでテスト&lt;/h3&gt;

&lt;p&gt;まずはAmazon Developer上に用意されているシミュレータでテストしてみます（実はスキル開発だけならEchoデバイスが無くてもできるんですね）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/simu1.png&#34; alt=&#34;&#34; /&gt;
「テスト」のサービスシミュレータに登録したサンプル発話を入力し、スキルを呼び出します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/simu2.png&#34; alt=&#34;&#34; /&gt;
レスポンスが返ってきました！処理ロジックを作ったらここでデバッグをしていくのが良さそうです。&lt;/p&gt;

&lt;h3 id=&#34;echoデバイスでスキルを有効にする&#34;&gt;Echoデバイスでスキルを有効にする&lt;/h3&gt;

&lt;p&gt;開発したスキルは、自分のAmazon Developerアカウントに紐付いているデバイスで検証することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo1.png&#34; alt=&#34;&#34; /&gt;
スマートフォンアプリから「スキル」を選びます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo2.png&#34; alt=&#34;&#34; /&gt;
「有効なスキル」を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo3.png&#34; alt=&#34;&#34; /&gt;
「DEVスキル」の項目から、作成したスキルを選択します。&lt;/p&gt;

&lt;p&gt;ここで作ったスキルが表示されていない場合は、Amazon Developerアカウントが&lt;strong&gt;Amazon.comアカウント（米国）に紐付いてないか確認&lt;/strong&gt;してください。Amazon.co.jpアカウントに紐づけないとダメみたい……（現象が起こせなくて解決策がイマイチわかっていません、すみません）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo4.png&#34; alt=&#34;&#34; /&gt;
選択すると連携しているEchoデバイスでスキルが使えるようになります（無効にすると使えなくなります）。&lt;/p&gt;

&lt;h3 id=&#34;いざ-スキルを呼び出し&#34;&gt;いざ、スキルを呼び出し！&lt;/h3&gt;

&lt;p&gt;デバイスで作成したスキルを試してみましょう！&lt;/p&gt;

&lt;p&gt;基本のやりとりから……
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/RyHESCiE03s&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;
バッチリです！&lt;/p&gt;

&lt;p&gt;「ヘルプ」「ストップ」などの呼びかけは、Intentを登録しなくてもデフォルトで設定されています。
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/dr-akz9qTDk&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;手順の紹介は長くなってしまいましたが、あまり引っかかるところなくスキルの開発ができたと思います。&lt;/p&gt;

&lt;p&gt;今回の基本のスキルに加えて、&lt;u&gt;デフォルトのIntentの拡張や、任意の数字や都市を受け取ることができる「Slot」の追加&lt;/u&gt;などまだまだカスタマイズができます。&lt;/p&gt;

&lt;p&gt;次回はカスタマイズを加えたスキルを開発し、公開するところまでやってみたいと思います。それではまた！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラブでモテる！つまみ付きユニコーンポーチ　後編</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/</link>
      <pubDate>Wed, 28 Feb 2018 10:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/</guid>
      
      <description>

&lt;p&gt;みなさん、ちょりおつ！ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案するユニット、ギャル電で活動しています。今回は&lt;strong&gt;クラブ行くときにぎゃんかわに盛れる光るポーチ&lt;/strong&gt;の作り方後編でっす！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 前編をチェック！
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;arduino-nano互換機の導入方法&#34;&gt;Arduino Nano互換機の導入方法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回使用したボードはArduino Nano互換機。AmazonやAliExpressとかで一枚300円くらいから買える感じの小さいボードっす。&lt;strong&gt;いいところは、安くて小さいところ&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;導入にクセがあるのと、ケーブルがUSB MiniBタイプなところがちょっとめんどいけど、Digisparkだとちょっと容量足りなくてプログラムが書き込めないときとかにこのボードよく使ってます。&lt;/p&gt;

&lt;h2 id=&#34;ドライバのインストール&#34;&gt;ドライバのインストール&lt;/h2&gt;

&lt;p&gt;Arduino Nano互換機を使用するためには、&lt;strong&gt;ドライバのインストールが必要&lt;/strong&gt;っす。「Arduino Nano 互換 OSの名前 ドライバ」、または「CH340 ドライバ OSの名前」とかで検索すると親切なインターネット上の先輩方の情報がみつかるとおもいまっす！&lt;/p&gt;

&lt;p&gt;Macの新しめの機種使っててうまく認識しない場合には、接続するUSBの口を変えてみるか、USB2.0対応のUSBハブを接続してハブにつなげると認識しやすくなるかも。&lt;/p&gt;

&lt;p&gt;あとどうにも認識しないときは、&lt;strong&gt;一回忘れて寝る。そんで再トライ。うちらはだいたいコレでいつも乗りきってる&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ボードのセッティング&#34;&gt;ボードのセッティング&lt;/h2&gt;

&lt;p&gt;ドライバのインストールが完了して、デバイスを認識するようになったら、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「Arduino IDE」→「ツール」→「ボード」→「Arduino Nano」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;をえらんで書き込み準備オッケー。Aruduino IDEの設定等はインターネットで調べるか、&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;ドキュメント&lt;/a&gt;や&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-led-cassette/#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E6%BA%96%E5%82%99&#34;&gt;過去記事&lt;/a&gt;等も参考にしてね☆&lt;/p&gt;

&lt;h2 id=&#34;fastledライブラリの導入方法&#34;&gt;FASTLEDライブラリの導入方法&lt;/h2&gt;

&lt;p&gt;今回はいつも超お世話になっているNeoPixcelライブラリではなくて、&lt;strong&gt;FastLEDライブラリ&lt;/strong&gt;を使用してLEDを光らせたいと思いまっす。&lt;/p&gt;

&lt;p&gt;まずは、ここからライブラリファイル(SourceCode.zip)をダウンロードします。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://github.com/FastLED/FastLED/releases&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/link2.png&#34; alt=&#34;&#34; /&gt;
https://github.com/FastLED/FastLED/releases&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ダウンロードしたファイルを、Arduino IDEを起動して&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「スケッチ」→「ライブラリのインクルード」→「.Zip形式のライブラリをインストール」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;で指定してインストールします。&lt;/p&gt;

&lt;h2 id=&#34;プログラム&#34;&gt;プログラム&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/hsiboy/11545fd0241ab60b567d&#34;&gt;こちら&lt;/a&gt;のページのプログラムを参考にしました。というかLEDの数とLEDのPIN、可変抵抗のPINを書き換えただけでコピペさせていただきました。&lt;/p&gt;

&lt;p&gt;「led potentiometer」でググるといい感じの参考作例やプログラムがいっぱいみつかるよ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//FastLED_AnalogueInput.ino

/*
   Using a potentiometer to control colour, brightness and speed.
 Wire up as per http://arduino.cc/en/Tutorial/AnalogInput
 You can connect the wiper, to any analogue input pin, and
 adjust the settings below.
 You will need three 10k potentiometers.
 */

#include &amp;lt;FastLED.h&amp;gt;

#define LED_PIN 6              // which pin are LEDS connected to?
#define NUM_LEDS 24
#define COLOR_ORDER RGB
#define LED_TYPE WS2811        // i&#39;m using WS2811s, FastLED supports lots of different types.

/*
 set your desired minimum and maxium brigtness settings here.
 Valid values are 0 - 255
 With 0 being fully dim, or not lit, and 255 being fully on.
 Therefore half power, or 50%, would be 128
 */

#define MAX_BRIGHTNESS 164      // Thats full on, watch the power!
#define MIN_BRIGHTNESS 32       // set to a minimum of 25%

const int brightnessInPin = A0;  // The Analog input pin that the brightness control potentiometer is attached to.
const int speedInPin = A1;       // Analog input pin that the speed control potentiometer is attached to.
const int colourInPin = A2;      // The Analog input pin that the colour control potentiometer is attached to.

struct CRGB leds[NUM_LEDS];

void setup() {
  delay(3000); // in case we do something stupid. We dont want to get locked out.

  LEDS.addLeds&amp;lt;LED_TYPE, LED_PIN, COLOR_ORDER&amp;gt;(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
  FastLED.setBrightness(MAX_BRIGHTNESS);
}

void loop() {
  // read the analog brightness value:
  //int brightValue = analogRead(brightnessInPin);            
  // map it to the range of the FastLED brightness:
  int mappedValue = map(analogRead(brightnessInPin), 0, 1023, 0, 255);

  /*
   At this point, brightness could be full off (mappedValue == 0)
   or it could be fully on (mappedValue == 255).
   if you are ruuning from a battery pack, or in a dark room, you
   may not want full brightness.
   Or if you are in daylight, you may not want the pixels to go out.
   the following code, checks if mappedValue is above or below our defined
   brightness settings above.
   It works like this.

   we get mappedValue: if mappedValue is between MIN_BRIGHTNESS and MAX_BRIGHTNESS.
   we get MIN_BRIGHTNESS: if mappedValue is less than our defined MIN_BRIGHTNESS.
   we get MAX_BRIGHTNESS: if mappedValue is greater than our defined MAX_BRIGHTNESS

   so, it limits range of brightness values.

   */

  //int outputValue = constrain(mappedValue, MIN_BRIGHTNESS, MAX_BRIGHTNESS);

  // now we set the brightness of the strip
  FastLED.setBrightness(constrain(mappedValue, MIN_BRIGHTNESS, MAX_BRIGHTNESS));

  // read the analog speed value:          
  // map it to a value used in delay();
  int delayValue = map(analogRead(speedInPin), 0, 1023, 0, 50);  

  int mappedHue;
  // read the analog brightness value:
  //int hueValue = analogRead(colourInPin);            
  // map it to the range of the FastLED brightness:

  // First slide the led in one direction
  for(int i = 0; i &amp;lt; NUM_LEDS; i++) {
    mappedHue = map(analogRead(colourInPin), 0, 1023, 0, 255);
    // Set the i&#39;th led to the chosen colour
    leds[i] = CHSV(mappedHue, 255, 255);
    // Show the leds
    FastLED.show();
    // now that we&#39;ve shown the leds, reset the i&#39;th led to black
    leds[i] = CRGB::Black;
    // Wait a little bit before we loop around and do it again
    delay(delayValue);  
  }

  // Now go in the other direction.  
  for(int i = NUM_LEDS-1; i &amp;gt;= 0; i--) {
    mappedHue = map(analogRead(colourInPin), 0, 1023, 0, 255);
    // Set the i&#39;th led to the chosen colour
    leds[i] = CHSV(mappedHue, 255, 255);
    // Show the leds
    FastLED.show();
    // now that we&#39;ve shown the leds, reset the i&#39;th led to black
    leds[i] = CRGB::Black;
    // Wait a little bit before we loop around and do it again
    delay(delayValue);  
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;プログラムを書き込んでテストしてみよう&#34;&gt;プログラムを書き込んでテストしてみよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/2.png&#34; alt=&#34;&#34; /&gt;
プログラムが書き込めたら、ちゃんと可変抵抗器で光り方が変わるかを確認します。&lt;/p&gt;

&lt;p&gt;このプログラムでは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A0に接続したつまみが、明るさ&lt;/li&gt;
&lt;li&gt;A1に接続したつまみが、点滅速度&lt;/li&gt;
&lt;li&gt;A2に接続したつまみが、色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を調整できるようになっています。&lt;/p&gt;

&lt;h2 id=&#34;いい感じにポーチと部品を合体しよう&#34;&gt;いい感じにポーチと部品を合体しよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;光る部分が完成したので、ユニコーンファーポーチと合体します。&lt;/p&gt;

&lt;p&gt;ファーの表面に可変抵抗器用の小さな穴をあけます。可変抵抗器をポーチの表面に出し、キャップをかぶせます。この時、ファーの毛を巻き込んで動きにくい場合は毛を少し刈ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/4.png&#34; alt=&#34;&#34; /&gt;
ポーチの裏側にLEDを貼ったプラ板を固定し、配線をいい感じに収納します。今回はポーチに裏布がついていたので、上部を切り開いてポケット状にして超いい感じに格納したっす。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/5.png&#34; alt=&#34;&#34; /&gt;
とりあえず、ポーチにLEDとボードとモバイルバッテリーがおさまれば完成でっす！&lt;/p&gt;

&lt;h2 id=&#34;光らすと超ユニコーン&#34;&gt;光らすと超ユニコーン！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/6.png&#34; alt=&#34;&#34; /&gt;
うひょー！超かわいくない？！シーンに合わせてかわいめからハードめまで光りかたが調整できちゃうから、現場（クラブ）でモテる未来しか見えない！！！！&lt;/p&gt;

&lt;p&gt;みんなも作ってひからせてみよ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>パソコンやモバイルバッテリーに繋いで動かせるデバイスを作ろう！USB電子工作のすすめ#1 - 基礎知識編</title>
      <link>https://dotstud.io/blog/usb-power-supply-making/</link>
      <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/usb-power-supply-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、ものづくり担当のうこ(&lt;a href=&#34;https://twitter.com/harmoniko&#34;&gt;@harmoniko&lt;/a&gt;)です。&lt;/p&gt;

&lt;p&gt;みなさんは、&lt;strong&gt;電子工作をするときの電源はどこから取っていますか？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Arduinoをよく使われる方だと5V端子や3.3V端子から取っている場合が非常に多いですが、ではArduinoを使わない、ピュアな電子工作の場合だとどうしたらいいでしょうか？&lt;/p&gt;

&lt;p&gt;今回は、電子工作用電源としても非常に有用な&lt;strong&gt;USBの基本と扱い方&lt;/strong&gt;についてお伝えします。&lt;/p&gt;

&lt;h2 id=&#34;usbのしくみ&#34;&gt;USBのしくみ&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;USB&lt;/strong&gt;」は「&lt;strong&gt;Universal Serial Bus&lt;/strong&gt;」の略で、PCとその周辺機器の間の汎用的な通信規格として1996年に登場しました。USBは1対2本の信号線（※）で順番にデータを送る「&lt;strong&gt;シリアル接続&lt;/strong&gt;」という方式で、複数のデバイスを吊り下げられる「&lt;strong&gt;バス規格&lt;/strong&gt;」の1つです。&lt;/p&gt;

&lt;p&gt;※…USB 2.0まで&lt;/p&gt;

&lt;p&gt;端子は従来のものと比べてシンプルになり、ホストとデバイスをすぐに区別できるようなものになりました。&lt;/p&gt;

&lt;p&gt;USBを使って通信をするには、USBを制御する専用のコントローラハードウェアが必要となるため、電子工作では少し難易度があがります。ただし、&lt;strong&gt;電源を使うだけならケーブルを切って電源のVcc線（+）とGnd線（-）を引き出すだけでよい&lt;/strong&gt;ので、スマホが普及しはじめるよりも早くから電源用ケーブルとしても使われるようになりました。&lt;/p&gt;

&lt;p&gt;USBの簡単な特徴をまとめると、以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通信は、 1つの「ホスト」（PC側）と1〜複数の「デバイス」（周辺機器側）との間で行われる。&lt;/li&gt;
&lt;li&gt;ホスト側とデバイス側で端子形状が区別されている（タイプC端子を除く）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;電源供給用のケーブルおよび端子として使うなら扱いは簡単！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ここ数年普及してきている「USB PD」は、大電力の供給が可能でMacBookの給電などにも利用されている。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて当記事は、 &lt;strong&gt;「電子工作において電源として気軽に使えるUSB」&lt;/strong&gt; を知っていただくためのものですので、扱いの簡単な「USB2.0規格（タイプC端子を除く）」までを使う前提の説明にとどめます。&lt;/p&gt;

&lt;p&gt;USB3.0規格以降は端子が増えたり電源規格が多様になったりしているため、電子工作での利用であれば、USB2.0規格までの理解で問題ありません。&lt;/p&gt;

&lt;p&gt;さらに詳しくUSBについて知りたい方は、以下のリンクを参考にしてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://thinkit.co.jp/article/11142&#34;&gt;現代PCの基礎知識(7):仕様書を紐解くとわかる―本当はややこしいUSB（Think IT）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;電源に使うことのメリット&#34;&gt;電源に使うことのメリット&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モバイルバッテリー、PC、コンセントアダプタなど、多彩なソースが選べる。&lt;/li&gt;
&lt;li&gt;給電方法に汎用性があるため、必要なパーツが安くて手に入りやすい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;電源に使うことのデメリット&#34;&gt;電源に使うことのデメリット&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;「外部電源」となるため、電池として本体に含めることができない。&lt;/li&gt;
&lt;li&gt;規格上、5V電圧以外を扱うときや大電流が必要なものには適さない（USB PDを除く）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;仕様の一覧&#34;&gt;仕様の一覧&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 1.0&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 1.1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 2.0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端子タイプ（ホスト側）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A, タイプC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端子タイプ（デバイス側）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ミニA, マイクロA, ミニB, マイクロB, タイプC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;通信速度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12Mビット/秒&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12Mビット/秒&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;480Mビット/秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;定格電圧&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;同右&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;同右&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;約5V（ホスト側4.4~5.25V）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;最大電流&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA（USB BC拡張:1.5A）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上は通信に関する基本的なバージョン仕様ですが、さらにUSB2.0を拡張したUSB電源専用規格である「USB BC（Battery Charging）」というものがあり、1.5Aまでの電流を流すことが可能となっています。&lt;/p&gt;

&lt;p&gt;また、電子工作で利用するためのUSBパーツは100円ショップなどで購入できます。&lt;strong&gt;100円ショップなどで安価に入手可能なUSBパーツはほぼ100%がUSB2.0規格またはUSB BC規格のもの&lt;/strong&gt;となります。&lt;/p&gt;

&lt;p&gt;よって、電子工作の&lt;strong&gt;電源として&lt;/strong&gt;USBを使ってみたいときは&lt;strong&gt;USB2.0規格またはUSB BC規格&lt;/strong&gt;に準じたUSB部品の仕様を知っておけばOKです。&lt;/p&gt;

&lt;h2 id=&#34;usbケーブルの配線図&#34;&gt;USBケーブルの配線図&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;USB2.0には、電源線の5V（VccやVBUSとも）とGND、信号線のD-とD+の合計4種類の線があります。ケーブルのほとんどは2層構造になっていて、内側に収められている4本の線の色分けも上図のように決まっています。&lt;/p&gt;

&lt;p&gt;電子工作でUSBを使うときは、「標準Aメス端子を基板に実装する」か、上図のような「標準Aオス端子がついたケーブルの電源線を接続する」ことになるので、端子の順番や色分けは覚えておくと楽です。&lt;/p&gt;

&lt;h2 id=&#34;電圧と電流&#34;&gt;電圧と電流&lt;/h2&gt;

&lt;p&gt;USB電源の基本は「&lt;strong&gt;電圧5V/電流500mAまで&lt;/strong&gt;」です。&lt;/p&gt;

&lt;p&gt;といっても、これはパソコンのような「電源供給」を主目的としないホストから給電する場合の「USB2.0規格」による制限値です。&lt;/p&gt;

&lt;p&gt;電子工作でUSB電源を扱う場合は、モバイルバッテリーやUSBコンセントなどからの給電がほとんどになると思われます。その場合は、USB BC規格の上限値である1.5Aとなりますが、普通はバッテリーやコンセントに最大出力が書いてあります（例：5V/800mA）ので、電流値の最大はそれに従いましょう。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;usbケーブルの注意点&#34;&gt;USBケーブルの注意点&lt;/h4&gt;

&lt;p style=&#34;font-size: 80%&#34;&gt;細かい話をすると、市場で出回る多くの充電器は「最大2.4A出力」などを謳っていて、この場合だとUSB BC規格にもあてはまりません。このような製品は、USBを通信を行わない完全な電源ケーブルとみなし、独自の規格を採用している場合が多いです。よって、電子工作でUSB電源を使うときは、「USB2.0規格の配線」と「使いたい電源供給源（バッテリーやコンセント等）の出力電流」を考慮して回路設計をするのがベストだといえます。難しく考えたくない人は、 **とにかく省エネになるように意識して作る**ようにするのがよいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 80%&#34;&gt;⇒ 参考: &lt;a href=&#34;https://hanpenblog.com/1472/&#34;&gt;乱立するスマホ向け急速充電の規格について調べた（HANPEN-BLOG）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;電子工作での利用を考えると電流消費を見ることが大事で、個人で製作する小規模な回路であればほとんどが500mA以内に収まることが多いです。&lt;/p&gt;

&lt;p&gt;ヒーターやモーターを使った回路は例外的で、接続された個数や負荷で変動しますが、最大電流が容易に1Aを超えてしまうことがあります。しかし、どのような場合であっても、個人製作された電子回路は漏電流やショートへの配慮、適切な電流制限などが行われていないことが大半です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本的には、USB電源を利用する自作の電子回路は、安全上の理由からパソコンに接続して給電してはいけません。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⇒ 参考：&lt;a href=&#34;http://www.wheel.gr.jp/~dai/hardware/usb-port.html&#34;&gt;USBポートは電源ではありません&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現実には今のパソコンは全て保護回路が入っているため、ブレッドボードを繋げたArduinoにパソコンから給電するといったようなことを行なっていてもまず問題はありません。しかし&lt;strong&gt;危険性は少なからずあるもの&lt;/strong&gt;だとして意識してもらえれば幸いです。&lt;/p&gt;

&lt;p&gt;（15年ほど前のパソコンでは、USB端子に500mA以上の過電流を流すといきなりパソコンの電源ごと落ちるものもありました。）&lt;/p&gt;

&lt;h2 id=&#34;入手方法&#34;&gt;入手方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;おすすめは100円ショップ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;100円ショップの電気系コーナーに行くと、どこに行っても大抵はUSBケーブルが置いてあります。USBケーブルの中でも取り扱いが多いのは、おそらく次の3つでしょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Aオス端子-microBオス端子（スマホ充電用）&lt;/li&gt;
&lt;li&gt;Aオス端子-Bオス端子（プリンタなどの接続用）&lt;/li&gt;
&lt;li&gt;Aオス端子-Aメス端子（ケーブル延長用）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このうち、最後の &lt;strong&gt;Aオス端子-Aメス端子（ケーブル延長用）&lt;/strong&gt; は、置いていない店舗もありますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ケーブル部分が比較的長い。&lt;/li&gt;
&lt;li&gt;基本的にはAオス端子側を使うが、工作の内容によってはAメス端子があると便利なことがある。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった点から、電子工作で利用するには最もおすすめなケーブルとなっています。売られているのを発見したら、ぜひ買っておきましょう。&lt;/p&gt;

&lt;h2 id=&#34;実際に電子工作で使うには&#34;&gt;実際に電子工作で使うには&lt;/h2&gt;

&lt;p&gt;USBについて、どんなものなのかなんとなくおわかりいただけましたでしょうか？&lt;/p&gt;

&lt;p&gt;とりあえず要約すると、 &lt;strong&gt;「100円で手に入って電子工作で簡単に利用できる汎用電源インターフェース」&lt;/strong&gt; といったところでしょうか。では、実際に使うにはどうすればいいかを見ていきましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;USBケーブルを電源として利用する上で最も重要なパーツが「Aオス端子」部分となります。&lt;/p&gt;

&lt;p&gt;100円ショップで購入できるUSBケーブルは少なくとも一方がこの端子ですので、この端子から伸びるケーブルを十分長く残したうえでニッパで切断します。長さは、製作するモノによって適切に決めてください。あとから調整できるという意味では長めに切り取るのがよいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/5.png&#34; alt=&#34;&#34; /&gt;
切り取った部分の一番外側の皮膜をニッパまたは皮膜剥き用のニッパで1cm程度除去します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/6.png&#34; alt=&#34;&#34; /&gt;
すると細い4本のケーブルが中から出てきますが、このうち赤色と黒色がそれぞれ電源となります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/7.png&#34; alt=&#34;&#34; /&gt;
残りの2本は信号線で、&lt;del&gt;USB BC規格として大きめの電流を流したい場合は、この信号線を200Ωの抵抗でショートします。が、実際には何もしなくても給電はなされます。&lt;/del&gt;ここでは簡単にするため切り落としました。&lt;/p&gt;

&lt;p style=&#34;font-size: 80%; color: red;&#34;&gt;
（3/4 修正）200Ωの抵抗を接続するのは充電器側であるとのご指摘をいただき、上記訂正します。
&lt;/p&gt;
&lt;p style=&#34;font-size: 80%;&#34;&gt;
⇒ 出展: USB.orgの&lt;a href =&#34;http://www.usb.org/developers/docs/devclass_docs/&#34;&gt;開発者向けドキュメント&lt;/a&gt;にある「Battery Charging v1.2 Spec and Adopters Agreement.zip」内のBC1.2_FINAL.pdf「Battery Charging Specification, Revision 1.2」3.2.4項「Primary Detection」のFigure 3-6 など）
&lt;/p&gt;

&lt;p&gt;これで、Aオス端子が電源側、切断したほうが電子回路側となります。&lt;/p&gt;

&lt;p&gt;さて、次回はこの1対の電源線を使って、電池で動作するおもちゃをUSB電源駆動に改造してみます。&lt;/p&gt;

&lt;p&gt;お楽しみに。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>放置されていた3Dプリンタ「Trinus」で初めての3Dプリントに挑戦</title>
      <link>https://dotstud.io/blog/3d-printer-trinus-usage/</link>
      <pubDate>Thu, 22 Feb 2018 03:00:43 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/3d-printer-trinus-usage/</guid>
      
      <description>

&lt;p&gt;こんにちは、たくろーどんです。大学で&lt;a href=&#34;https://dotstud.io/docs/nefrybt&#34;&gt;NefryBT&lt;/a&gt;を使った工作をしていたら、いつのまにかdotstudioでアルバイトすることになっていました。宇宙工学を勉強しています。以後よろしくお願いします。&lt;/p&gt;

&lt;p&gt;=&amp;gt; 参考: &lt;a href=&#34;https://qiita.com/minwinmin/items/d1f296b8a9cd1a2c22f6&#34;&gt;研究室のみんなとNefry BTを使ってはじめてIoTデバイスをつくってみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今回は、dotstudioに放置されていた3Dプリンタ「Trinus（トライナス）」を使って初めての3Dプリントに挑戦してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/149/lead.png&#34; alt=&#34;&#34; /&gt;
これで哲学的なものを錬成していきましょう。&lt;/p&gt;

&lt;h2 id=&#34;3dプリントを始める前に&#34;&gt;3Dプリントを始める前に&lt;/h2&gt;

&lt;h3 id=&#34;3dプリンタとは&#34;&gt;3Dプリンタとは？&lt;/h3&gt;

&lt;p&gt;3Dプリンタとは、その名の通り&lt;strong&gt;3Dのデータを出力できる&lt;/strong&gt;プリンタです。
&lt;img src=&#34;https://dotstud.io/img/blog/149/3dprint.png&#34; alt=&#34;&#34; /&gt;
プリンタによりますが、金属、アルミ、ゴムなどさまざまな素材で出力できるため広い分野で活躍しています。&lt;/p&gt;

&lt;p&gt;現在は業務用から一般向けまでさまざまな種類の3Dプリンタが販売されていますが、今回はdotstudioに放置されていた「Trinus（トライナス）」を使ってみます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://www.trinus3d.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/trinus.png&#34; alt=&#34;&#34; /&gt;
Trinus - Kodama, Inc.&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;3万円代とお手頃価格で、樹脂に加えて木材やアルミも利用でき、別売りのヘッドをつけることでレーザ彫刻機にもなる優れものです。&lt;/p&gt;

&lt;h3 id=&#34;3dプリントには3dデータが必要&#34;&gt;3Dプリントには3Dデータが必要&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;3Dプリントをするためには3Dデータが必要です&lt;/strong&gt;。3Dデータをモデリング（作成すること）方法はいくつかありますが、今回は3D CADソフトを使っています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/inventor.png&#34; alt=&#34;&#34; /&gt;
僕はAutodeskの「&lt;a href=&#34;https://www.autodesk.co.jp/products/inventor/overview&#34;&gt;&lt;strong&gt;Inventor&lt;/strong&gt;&lt;/a&gt;」を使ってデータを作成しました。有料ソフトですが、なんと&lt;strong&gt;学生だと3年間無料で&lt;/strong&gt;つかえます！&lt;/p&gt;

&lt;p&gt;Inventorは本格的な機械設計向きなので、簡単に試したい人は同じくAutodeskの「&lt;a href=&#34;https://www.autodesk.co.jp/products/fusion-360/overview&#34;&gt;&lt;strong&gt;fusion360&lt;/strong&gt;&lt;/a&gt;」の方がとっつきやすいかと思います。こちらも個人利用の場合は無料です。&lt;/p&gt;

&lt;p&gt;3D CADソフトは他にも&lt;a href=&#34;https://www.rs-online.com/designspark/mechanical-software-jp&#34;&gt;DesignSpark Mechanical&lt;/a&gt;や&lt;a href=&#34;https://www.freecadweb.org/?lang=ja&#34;&gt;FreeCAD&lt;/a&gt;などいくつかあるので、自分が使いやすいと思ったものを使うと良いでしょう。&lt;/p&gt;

&lt;p&gt;さらにもう一つ。
プログラマーのためにGithubがあるなら、&lt;strong&gt;メカ系エンジニアのために&lt;a href=&#34;https://grabcad.com/&#34;&gt;GrabcCAD&lt;/a&gt;というものがあります&lt;/strong&gt;。
&lt;img src=&#34;https://dotstud.io/img/blog/149/grabccad.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで、世界中のエンジニアが製作した様々なモデリングを閲覧したり使用したりできます。もし複雑なパーツをモデリングすることが難しければ、GrabCADを参考にしてみるのも手だと思います。&lt;/p&gt;

&lt;h3 id=&#34;trinusの組み立て&#34;&gt;Trinusの組み立て&lt;/h3&gt;

&lt;p&gt;Trinusの組み立てに関しては説明書をご覧ください。
また、日本語の公式サイトもあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://www.trinusjapan.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/community.png&#34; alt=&#34;&#34; /&gt;
http://trinusjapan.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;trinus用ソフト-pango-をインストール&#34;&gt;Trinus用ソフト「Pango」をインストール&lt;/h3&gt;

&lt;p&gt;Trinusで3Dプリントするには、モデリングしたものを扱う専用ソフト「Pango」が必要です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://trinusjapan.com/softwaredownload/&#34;&gt;こちらのリンク&lt;/a&gt;からインストールしてください。&lt;/p&gt;

&lt;h2 id=&#34;3dプリントに挑戦&#34;&gt;3Dプリントに挑戦！&lt;/h2&gt;

&lt;h3 id=&#34;プリンタ側の準備&#34;&gt;プリンタ側の準備&lt;/h3&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://trinusjapan.com/firstprint/&#34;&gt;公式サイト&lt;/a&gt;にのっているので、要点だけ説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/printer.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まず、Trinusの電源をいれるため、コンセントにつなげましょう。電源がつくと「ビッ」という音がします。&lt;/p&gt;

&lt;h3 id=&#34;pangoにデータを取り込む&#34;&gt;Pangoにデータを取り込む&lt;/h3&gt;

&lt;p&gt;パソコンからデータ（stlファイル）をPangoで開きましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/1.png&#34; alt=&#34;&#34; /&gt;
①のように「書き出し」から「CAD形式」を選択し、stl形式で保存します。&lt;strong&gt;サイズがモデリングと一致&lt;/strong&gt;しているかしっかりと確認してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/2.png&#34; alt=&#34;&#34; /&gt;
Pangoでstlファイルを開くと&lt;strong&gt;何故かサイズが10分の1&lt;/strong&gt;になってしまうので（dotstudioだけで起こる現象なのか不明）、元のサイズに戻します。③と④のように比率（Ratio）を10に変えます。Amountは寸法を意味していて、単位はmmです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/3.png&#34; alt=&#34;&#34; /&gt;
必要があれば3Dプリントしやすいようにモデルの向きを変えましょう。&lt;strong&gt;どのような向きで出力するか&lt;/strong&gt;、これがとても大事です！印刷中に思いがけない失敗を引き起こすことになります。&lt;/p&gt;

&lt;p&gt;⑤のように赤丸部をクリックすると回転軸の表示が出ます。そして、回転したい軸にマウスポインタを持っていきます。⑥のように回転する軸が強調されます。マウスで操作する場合はホイールを動かすことで回転させることができます。パソコンにあるタッチパッドの場合は2本の指で、上下になぞるように動かすと回転します（Windowsの場合）。&lt;/p&gt;

&lt;h3 id=&#34;印刷のシミュレーション&#34;&gt;印刷のシミュレーション&lt;/h3&gt;

&lt;p&gt;実際にどのように印刷が進められるかPango上で確認することもできます。Pangoの上部にある「View」から「Layer」をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/149/4.png&#34; alt=&#34;&#34; /&gt;
すると自分がモデリングしたもの以外に格子状のモデリング（濃いピンクの部分）が追加されています。これは「&lt;strong&gt;ラフト&lt;/strong&gt;」と呼ばれ、3Dプリンタの印刷面と出力するものの間に積層される荒い土台のことです。&lt;/p&gt;

&lt;p&gt;これがあると出力した後に製作物を外しやすく、最終的には除去してゴミとして捨てることができます。&lt;/p&gt;

&lt;h3 id=&#34;データをtrinusに移す&#34;&gt;データをTrinusに移す&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/5.png&#34; alt=&#34;&#34; /&gt;
データをSDカードに「pcode」形式で保存します。図の赤丸部をクリックし、SDカードにデータをpcode形式で保存します。この形式は、Torinusで出力するために必要な形式です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/6.png&#34; alt=&#34;&#34; /&gt;
SDカードをTorinusに接続し、TorinusとパソコンをUSB接続します。&lt;/p&gt;

&lt;h3 id=&#34;出力設定を調整&#34;&gt;出力設定を調整&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/7.png&#34; alt=&#34;&#34; /&gt;
Pango上部の「Preference」から「Setting」を選択します。ここでは、出力するスピードや厚みなどを設定することができます。&lt;strong&gt;設定はあまりいじる必要はない&lt;/strong&gt;ので、眺めおきましょう！（ただし今回は試行錯誤の結果、Thickness: 0.2mm、Print Speed: 40mm/sとしています）&lt;/p&gt;

&lt;h3 id=&#34;重要-出力位置の初期位置を調整&#34;&gt;【重要】出力位置の初期位置を調整&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/8.png&#34; alt=&#34;&#34; /&gt;
TorinusとパソコンをUSB接続した状態でPango上部の「View」から「Console」をクリックします。上のような画像が出たら、さらに「Console」をクリックします。　&lt;/p&gt;

&lt;p&gt;そうすると下記のような設定画面があらわれます。&lt;strong&gt;この画面で行う設定が非常に重要です&lt;/strong&gt;。
&lt;img src=&#34;https://dotstud.io/img/blog/149/9.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;まず「Home」をクリック&lt;/strong&gt;します。これで、3Dプリンタのノズル（フィラメントが出る部分）が初期位置に戻ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/10.png&#34; alt=&#34;&#34; /&gt;
ここで&lt;strong&gt;z軸の距離（ノズルから出力される面の高さ、画像でいう赤い矢印部分）を確認&lt;/strong&gt;してください。その距離が初期位置で広すぎると上手く出力されません。なので、目視でその距離を縮めましょう。「Offset」をクリックすると&lt;strong&gt;z軸方向の距離を上下&lt;/strong&gt;することができます。&lt;/p&gt;

&lt;h3 id=&#34;出力を開始&#34;&gt;出力を開始！&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/9.png&#34; alt=&#34;&#34; /&gt;
位置設定が終わったら、「&lt;strong&gt;Heat E」をクリック&lt;/strong&gt;し3Dプリンタのノズルを温めます。どれくらい温まっているかは、Console画面の左下に示す数字（分数部分）で表されます。最後に右のSDカードのイラスト部分をクリックし、保存したpcodeファイルを指定します。3Dプリンタのノズルが十分に温まれば自動で出力が始まります！&lt;/p&gt;

&lt;h3 id=&#34;出力直後にやるべきこと&#34;&gt;出力直後にやるべきこと&lt;/h3&gt;

&lt;p&gt;出力が始まるとその直後に、&lt;strong&gt;ノズルから溶け出たフィラメント&lt;/strong&gt;が垂れてきます。&lt;strong&gt;垂れて固まったフィラメントは出力の邪魔になることもあるので、ピンセットで取り除きましょう&lt;/strong&gt;。下記の図の赤丸で囲った部分がその例です。
&lt;img src=&#34;https://dotstud.io/img/blog/149/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;あとは見守りながら完成するまで放置しましょう。&lt;/p&gt;

&lt;h2 id=&#34;はじめての出力&#34;&gt;はじめての出力&lt;/h2&gt;

&lt;p&gt;プリンタとデータをセットして出力されるのを待ちます……。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/c7659ea8-e54a-f50a-400a-183218006215.gif&#34; alt=&#34;出力.gif&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成しました。
&lt;img src=&#34;https://dotstud.io/img/blog/149/完成1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;哲学的なゴミです。特に用途はありません。
&lt;img src=&#34;https://dotstud.io/img/blog/149/完成2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3dプリンタを使うときに注意すること&#34;&gt;3Dプリンタを使うときに注意すること&lt;/h2&gt;

&lt;p&gt;セットアップの説明でも述べましたが、3Dプリンターを使ってみて注意した方が良い点をもう一度まとめます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pango上でモデリングのサイズを要チェック&lt;/li&gt;
&lt;li&gt;モデリングしたものをどの向きで出力するか&lt;/li&gt;
&lt;li&gt;初期位置の設定を正確に！（特にz軸方向）&lt;/li&gt;
&lt;li&gt;出力直後に溶け出したフィラメントを必ず除去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3Dプリンタは複雑なものを簡単に出力できるイメージですが、実際に使ってみると経験やコツがいります。やはり、どんな道具も使いこなせるようになるには時間が必要なようです。&lt;/p&gt;

&lt;p&gt;まだまだ3Dプリンターを使う上で学ぶことが多いと感じたので、継続して使っていきたいと思います。&lt;/p&gt;

&lt;p&gt;それではまた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラブでモテる！つまみ付きユニコーンポーチ　前編</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette/</guid>
      
      <description>

&lt;p&gt;みなさん、ちょりおつ！ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案するユニット、ギャル電で活動しています。今回は、&lt;strong&gt;クラブ行くときにぎゃんかわに盛れる光るポーチの作り方&lt;/strong&gt;を2回にわけて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;ユニコーンきゃわたん&#34;&gt;ユニコーンきゃわたん&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ちょっと前から、イケてるヤングの間ではユニコーンがはやってるっぽい。角生えてる馬、かっこいいしかわいいからはやるのも超わかりみある。&lt;/p&gt;

&lt;p&gt;つーことで、イケてるユニコーンっぽいバッグが街には今いっぱい売ってる。今回は、&lt;strong&gt;WEGOで500円のサイズ感もぴったりな超イケてるポーチ&lt;/strong&gt;をゲット。めっちゃリーズナブル！！！！&lt;/p&gt;

&lt;p&gt;コレ光らせたらやばくねってことで、さっそく作ってこう。&lt;/p&gt;

&lt;h2 id=&#34;材料&#34;&gt;材料&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;①Arduino Nano 互換機&lt;/li&gt;
&lt;li&gt;②可変抵抗 10KΩ 3個&lt;/li&gt;
&lt;li&gt;③つまみのキャップ&lt;/li&gt;
&lt;li&gt;④LEDテープ（WS2812B 60LED/M）LED24個分&lt;/li&gt;
&lt;li&gt;線材（コネクタは気分で）&lt;/li&gt;
&lt;li&gt;USB miniB ケーブル&lt;/li&gt;
&lt;li&gt;プラ板&lt;/li&gt;
&lt;li&gt;ユニコーンぽいファーのいい感じのポーチ（白系）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;材料はこんな感じ。つまみのキャップはギター用のカッコいいやつを使ったよ。ポーチはだいたいモバイルバッテリーと小銭と携帯が入るくらいのサイズ感のものがおすすめっす。&lt;/p&gt;

&lt;h2 id=&#34;可変抵抗器をアクセントにしてみよう&#34;&gt;可変抵抗器をアクセントにしてみよう&lt;/h2&gt;

&lt;p&gt;可変抵抗器はイケてるキャップをつけるとめっちゃかわいい！&lt;/p&gt;

&lt;p&gt;今回は三つの可変抵抗器の値を変更することで、LEDの&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;明るさ&lt;/li&gt;
&lt;li&gt;色&lt;/li&gt;
&lt;li&gt;点灯速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を変更できる仕組みをつくります。&lt;/p&gt;

&lt;h2 id=&#34;配線をはんだ付けしよう&#34;&gt;配線をはんだ付けしよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずは写真と図のように三つの可変抵抗器のプラスとプラス、マイナスとマイナスを配線でつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/5.png&#34; alt=&#34;&#34; /&gt;
三つのうちの可変抵抗器の一つに、プラスとマイナスの配線をさらに1セット追加してArduino Nanoの5VとGNDにつなぎます。可変抵抗器の真ん中の線とAruduino NanoのA0〜A1ポートを配線でそれぞれつなぎます。&lt;/p&gt;

&lt;p&gt;LEDテープはDINとD6、5V、GNDをそれぞれAruduino Nanoと配線でつなぎます。
&lt;img src=&#34;https://dotstud.io/img/blog/146/6.png&#34; alt=&#34;&#34; /&gt;
Aruduino Nanoの5VとGNDのところは、可変抵抗器とLEDテープからそれぞれ配線がつながります。一つのPINにはんだ付けが難しい場合は、ボードの裏と表にそれぞれ1本ずつ配線をつなげるとはんだ付けがやりやすいです。&lt;/p&gt;

&lt;h2 id=&#34;前編はここまで&#34;&gt;前編はここまで&lt;/h2&gt;

&lt;p&gt;今回は可変抵抗器を三つつなげたので、ちょっと配線とはんだ付けが複雑で疲れちゃったのでここまで！&lt;/p&gt;

&lt;p&gt;後編はArduino Nanoへのプログラム書き込みと、ポーチとLEDを組み立てまっす！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 後編をチェック！
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScriptで開発できる！Mongoose OSでNefry BTをLチカしよう</title>
      <link>https://dotstud.io/blog/mongoose-os-nefry-blink/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/mongoose-os-nefry-blink/</guid>
      
      <description>

&lt;p&gt;唐突ですが、森田(&lt;a href=&#34;https://twitter.com/morita_pac&#34;&gt;@morita_pac&lt;/a&gt;)と申します。&lt;/p&gt;

&lt;p&gt;ヘビーNefryBTユーザです。持ち歩いていろんな場所でNefry BTを利用したり、ケースを作ったりもしています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常Nefry BTはArduino言語でプログラムするのですが、今回はJavaScriptで書き込めるようにしたいと思います。&lt;/p&gt;

&lt;p&gt;※この記事内のプログラムはNefy BT（無印）向けです。Nefry BT R2向けのプログラムは別途準備中です。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで開発できるmongoose-osとは&#34;&gt;JavaScriptで開発できるMongoose OSとは&lt;/h2&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://mongoose-os.com/&#34;&gt;Mongoose OS&lt;/a&gt;というIoTのプロト開発を簡単にできるサービスを利用します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://mongoose-os.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/2.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ Mongoose OS公式サイト
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Mongoose OSでは、ESP32やESP8266へJavaScript（&lt;a href=&#34;https://github.com/cesanta/mjs&#34;&gt;mJS&lt;/a&gt;）でコードを書き込めます。
さらには、セキュアで、AWS IoTやGoogleのCloud IoT Coreなどとも連携設定がシンプルにできます。&lt;/p&gt;

&lt;p&gt;Mongoose OSをインストールしている間は元のNefry BTのプログラムは利用できなくなります。（Arduino IDEで書き込むことですぐに戻せます。）&lt;/p&gt;

&lt;h2 id=&#34;mongoose-osの開発環境をセットアップ&#34;&gt;Mongoose OSの開発環境をセットアップ&lt;/h2&gt;

&lt;h3 id=&#34;windowsの場合&#34;&gt;Windowsの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://mongoose-os.com/software.html&#34;&gt;Download Page&lt;/a&gt;から、exeをダウンロードするだけで使えます。（アンチウイルス系のソフトが反応するかもしれません。）なお、以降MacOSでの説明になります。
&lt;img src=&#34;https://dotstud.io/img/blog/145/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mac-osの場合&#34;&gt;Mac OSの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://mongoose-os.com/software.html&#34;&gt;Download Page&lt;/a&gt;の、MacOS/Linuxのcurlコマンドをターミナルで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://mongoose-os.com/downloads/mos/install.sh | /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ターミナルで以下のようになれば無事完了です。開く場合は、Runの&lt;code&gt;/xxx/.mos/bin/mos&lt;/code&gt;を実行するとWeb UIが開きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://mongoose-os.com/downloads/mos/install.sh | /bin/bash
Downloading https://mongoose-os.com/downloads/mos-release/mac/mos ...
########################################################################
 100.0%
Installing into /xxx/.mos/bin/mos ...
Adding /xxx/.mos/bin to your PATH in /xxx/.profile
SUCCESS: /xxx/.mos/bin/mos is installed.
Run &#39;/xxx/.mos/bin/mos --help&#39; to see all available commands.
Run &#39;/xxx/.mos/bin/mos&#39; without arguments to start a simplified Web UI installer.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;いざ-mongoose-osをnefry-btに入れてみよう&#34;&gt;いざ、Mongoose  OSをNefry BTに入れてみよう&lt;/h2&gt;

&lt;p&gt;Nefry BTをUSBポートに差し込み、Mongose OSとサンプルコードをFlashします。（次回起動時は、ポート選択のみで利用可能です。）&lt;/p&gt;

&lt;p&gt;Mongoose OSのWeb UIは、ブラウザで開きます。①②③の設定が完了すれば無事、JavaScriptで書き込む準備完了です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;①は、Nefry BTのポートを選択します。ポートが見つからない場合はUSBを認識させるための&lt;a href=&#34;https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers&#34;&gt;ドライバ&lt;/a&gt;をインストールする必要があります。
②では、Platformで「esp32」とapp「demo-js」を選択し「Flash」ボタンをクリックし、処理が終わるまで待ちます。
③では、Wi-fi設定を行います。（今回は必須ではないです。）
全ての設定が完了したら、「Done」ボタンをおしてdevice setupを閉じます。&lt;/p&gt;

&lt;h1 id=&#34;4-基本的なweb-uiとサンプルプログラム&#34;&gt;4. 基本的なWeb UIとサンプルプログラム&lt;/h1&gt;

&lt;h3 id=&#34;web-uiについて&#34;&gt;Web UIについて&lt;/h3&gt;

&lt;p&gt;まず、画面左側Device Filesを選択します。すると、init.jsが選択され、メインプログラムが表示されます。init.jsファイルをメインで編集します。&lt;/p&gt;

&lt;p&gt;編集後、書き込みたい場合は、Save + Rebootボタンで行えます。このコードやファイルの情報は、端末から読んでいますので、コードを書き換えたら、書き込む前にバックアップを取っておくことをお勧めします。
&lt;img src=&#34;https://dotstud.io/img/blog/145/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;サンプルプログラムについて&#34;&gt;サンプルプログラムについて&lt;/h3&gt;

&lt;p&gt;デフォルトプログラムを僕の感性でコメントしましたので、ご確認ください。なお、色々と制限付きのJSなので、仕様は&lt;a href=&#34;https://github.com/cesanta/mjs&#34;&gt;こちら&lt;/a&gt;で確認ください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;// 利用するAPIを読み出します。Flashした時点のサンプルAPIが呼ばれています。
// 各APIの仕様やサンプルは画面左のファイル一覧で参照可能です。
load(&#39;api_config.js&#39;);
load(&#39;api_events.js&#39;);
load(&#39;api_gpio.js&#39;);
load(&#39;api_mqtt.js&#39;);
load(&#39;api_net.js&#39;);
load(&#39;api_sys.js&#39;);
load(&#39;api_timer.js&#39;);

// 変数宣言はletのみです。const, varは使えません。
let led = Cfg.get(&#39;pins.led&#39;);
let button = Cfg.get(&#39;pins.button&#39;);
let topic = &#39;/devices/&#39; + Cfg.get(&#39;device.id&#39;) + &#39;/events&#39;;

print(&#39;LED GPIO:&#39;, led, &#39;button GPIO:&#39;, button);

let getInfo = function() {
  return JSON.stringify({
    total_ram: Sys.total_ram(),
    free_ram: Sys.free_ram()
  });
};

// 1秒おきにLEDをチカチカさせてます。ついでにチクタク時を刻んでいます。
GPIO.set_mode(led, GPIO.MODE_OUTPUT);
Timer.set(1000 /* 1 sec */, Timer.REPEAT, function() {
  let value = GPIO.toggle(led);
  print(value ? &#39;Tick&#39; : &#39;Tock&#39;, &#39;uptime:&#39;, Sys.uptime(), getInfo());
}, null);

// リセットボタンではない方のボタンを押すとMQTTでpublishします。
GPIO.set_button_handler(button, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 200, function() {
  let message = getInfo();
  let ok = MQTT.pub(topic, message, 1);
  print(&#39;Published:&#39;, ok, topic, &#39;-&amp;gt;&#39;, message);
}, null);

// ネットワークモニタです。
Event.addGroupHandler(Net.EVENT_GRP, function(ev, evdata, arg) {
  let evs = &#39;???&#39;;
  if (ev === Net.STATUS_DISCONNECTED) {
    evs = &#39;DISCONNECTED&#39;;
  } else if (ev === Net.STATUS_CONNECTING) {
    evs = &#39;CONNECTING&#39;;
  } else if (ev === Net.STATUS_CONNECTED) {
    evs = &#39;CONNECTED&#39;;
  } else if (ev === Net.STATUS_GOT_IP) {
    evs = &#39;GOT_IP&#39;;
  }
  print(&#39;== Net event:&#39;, ev, evs);
}, null);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nefry-btのフルカラーledを点灯しよう&#34;&gt;Nefry BTのフルカラーLEDを点灯しよう&lt;/h2&gt;

&lt;p&gt;やっと本題に入ります。&lt;/p&gt;

&lt;p&gt;Mongoose OSでは、様々なオープンソースコードがあり、それをインポートすることができます。今回は、NefryBTのフルカラーLEDを点灯させるためにNeoPixelのサンプルコードを入手します。&lt;/p&gt;

&lt;p&gt;画面左のProjectsを選択し、Importをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/145/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;App Managerのサーチ部分に「neopixel」と入力し、HARDWAREから「example-neopixel-js」をimportします。完了したらApp Managerの画面を閉じます。
&lt;img src=&#34;https://dotstud.io/img/blog/145/8.png&#34; alt=&#34;&#34; /&gt;
次に、サンプルプログラムをNefryBTに書き込みます。&lt;/p&gt;

&lt;p&gt;今ImportしたAppが選択されていることを確認し、①Rebuildアイコンと②Flashアイコンを処理が完了次第、順番にクリックすることで書き込み完了です。（それぞれ少々時間がかかります。）
&lt;img src=&#34;https://dotstud.io/img/blog/145/9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Device Filesのinit.jsの内容を以下の内容に書き換えます。Nefry BTのボタンを押したらフルカラーLEDが点灯するという内容のプログラムです。&lt;/p&gt;

&lt;p&gt;※なお、R2に関しては動作確認中ですので、確認次第内容を変更いたします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;load(&#39;api_config.js&#39;);
load(&#39;api_events.js&#39;);
load(&#39;api_gpio.js&#39;);
load(&#39;api_sys.js&#39;);
load(&#39;api_timer.js&#39;);
load(&#39;api_neopixel.js&#39;);

// 今回は一部しか利用していませんが、NefryのピンNoです。
let pin = {
    &amp;quot;nefrybt&amp;quot;:{
      &amp;quot;sw&amp;quot;: 4,
      &amp;quot;d0&amp;quot;:22,
      &amp;quot;d1&amp;quot;:21,
      &amp;quot;d2&amp;quot;:23,
      &amp;quot;d3&amp;quot;:19,
      &amp;quot;d4&amp;quot;:18,
      &amp;quot;a0&amp;quot;:25,
      &amp;quot;a1&amp;quot;:26,
      &amp;quot;a2&amp;quot;:32,
      &amp;quot;a3&amp;quot;:33,
      &amp;quot;a4&amp;quot;:27,
      &amp;quot;a5&amp;quot;:14,
      &amp;quot;a6&amp;quot;:13,
      &amp;quot;a7&amp;quot;:35,
      &amp;quot;LED&amp;quot;:16
    },
    &amp;quot;nefrybtR2&amp;quot;:{
      &amp;quot;sw&amp;quot;: 4,
      &amp;quot;d0&amp;quot;:22,
      &amp;quot;d1&amp;quot;:21,
      &amp;quot;d2&amp;quot;:23,
      &amp;quot;d3&amp;quot;:19,
      &amp;quot;d4&amp;quot;:18,
      &amp;quot;d5&amp;quot;:25,
      &amp;quot;d6&amp;quot;:26,
      &amp;quot;d7&amp;quot;:13,
      &amp;quot;d8&amp;quot;:14,
      &amp;quot;a0&amp;quot;:33,
      &amp;quot;a1&amp;quot;:32,
      &amp;quot;a2&amp;quot;:39,
      &amp;quot;a3&amp;quot;:36,
      &amp;quot;LED&amp;quot;:16
    }
  };


// フルカラーLEDのピンと個数、オーダーを指定しています。
let Lpin = pin.nefrybt.LED, numPixels = 1, colorOrder = NeoPixel.GRB;

// api_neopixel.jsに基づき初期化を行います。
let strip = NeoPixel.create(Lpin, numPixels, colorOrder);
strip.clear();
strip.setPixel(0,0,0,0);
strip.show();

// ボタンを押したら赤色をつけます。setpixel(0,0,0,0)は、ピクセルナンバーとRGBになっています。Redの数字は20としていますが、数字をあげるとかなり明るくなります。
// GPIO.set_button_handlerの仕様は、
GPIO.set_button_handler(4, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 200, function() {
    strip.clear();
    strip.setPixel(0,20,0,0);
    strip.show();
}, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;困った時は&#34;&gt;困った時は&lt;/h2&gt;

&lt;p&gt;Q. DeviceLogsにエラーがでている。&lt;/p&gt;

&lt;p&gt;A. Mongoose OS画面右上のdevice setupより、ポートを選択し直してください。それでも治らない場合は、ターミナルにて、&lt;code&gt;control+c&lt;/code&gt;でMongoose OSを一度終わらせて、再起動をしてみてください。&lt;/p&gt;

&lt;p&gt;それでもエラーが発生する場合は、一度Arduino IDEからNefry BTをボードに選択し、何も書いていないコードで書き込み直してください。なお、Nefry BTの状態に戻したい場合もArduino IDEから書き込むことで初期状態にもどせます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTをJavaScriptでプログラムして、LEDを点灯させるところまでできました。&lt;/p&gt;

&lt;p&gt;ディスプレイも表示させることができるので、次回は、Mongoose OSを使ったディスプレイの表示方法をご紹介しようと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）からBLEでNode.jsにデータを送ってみよう</title>
      <link>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</link>
      <pubDate>Fri, 12 Jan 2018 23:58:16 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</guid>
      
      <description>

&lt;p&gt;こんにちは、代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。Nefry BTを使ってBluetooth / BLEを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、検証してませんが他のESP32系のボードでも動作すると思います。&lt;/p&gt;

&lt;h2 id=&#34;bleについて&#34;&gt;BLEについて&lt;/h2&gt;

&lt;p&gt;BLEには大きく分け&lt;strong&gt;Peripheral （ペリフェラル）&lt;/strong&gt;と&lt;strong&gt;Central（セントラル）&lt;/strong&gt;という二つの役割があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Peripheral: 発信側端末、ビーコンやBLEタグなど受信端末に対して情報を送る側&lt;/li&gt;
&lt;li&gt;Central: 受信側端末、iPhoneやMacなどBLEデバイスの情報を探して受け取る側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTは書き込むコードによって、PeripheralにもCentralにもなることができます。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;peripheralの作成&#34;&gt;Peripheralの作成&lt;/h2&gt;

&lt;p&gt;情報発信側のPeripheralをNefry BTで作成します。&lt;/p&gt;

&lt;h3 id=&#34;uuidの作成&#34;&gt;UUIDの作成&lt;/h3&gt;

&lt;p&gt;BLEを利用するためには&lt;strong&gt;SERVICE（サービス）&lt;/strong&gt;と&lt;strong&gt;CHARACTERISTIC（キャラクタリスティック）&lt;/strong&gt;という各機能を司るUUIDを設定する必要があります。プログラミングでいうクラスとメソッドの関係だと思うと良いかもしれません。&lt;/p&gt;

&lt;p&gt;BLEデバイスは部屋の中やカフェ、駅などいたるところに存在するのでそれらのデバイスと自分が所持しているデバイスのIDが競合しないようにユニークな値にする必要があります。そこでUUIDを作成し、設定する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.uuidgenerator.net/&#34;&gt;https://www.uuidgenerator.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このサイトでUUIDが作成出きるので各自作成しましょう。&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;大元のコードはnkolban氏の&lt;a href=&#34;https://github.com/nkolban/ESP32_BLE_Arduino/blob/f8fe9d7cdfb20caa54b70849826d1ac6e375ff78/examples/BLE_notify/BLE_notify.ino&#34;&gt;こちらのコード&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#define SERVICE_UUID&lt;/code&gt;の箇所と&lt;code&gt;#define CHARACTERISTIC_UUID&lt;/code&gt;の箇所に先ほど作成したUUIDを指定します。&lt;/p&gt;

&lt;p&gt;また&lt;code&gt;BLEDevice::init(&amp;quot;&amp;quot;);&lt;/code&gt;の箇所にBLEデバイスの名前を設定できます。
以下のコードではNefryBT-n0bisukeという名前を指定しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;BLEDevice.h&amp;gt;
#include &amp;lt;BLEServer.h&amp;gt;
#include &amp;lt;BLEUtils.h&amp;gt;
#include &amp;lt;BLE2902.h&amp;gt;

BLECharacteristic *pCharacteristic;
bool deviceConnected = false;
uint8_t value = 0;

// See the following for generating UUIDs:
// https://www.uuidgenerator.net/

#define SERVICE_UUID        &amp;quot;D5875408-FA51-4763-A75D-7D33CECEBC31&amp;quot;
#define CHARACTERISTIC_UUID &amp;quot;A4F01D8C-A037-43B6-9050-1876A8C23584&amp;quot;

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
    }
};

void setup() {
  Serial.begin(115200);

  // Create the BLE Device
  BLEDevice::init(&amp;quot;NefryBT-n0bisuke&amp;quot;);

  // Create the BLE Server
  BLEServer *pServer = BLEDevice::createServer();
  pServer-&amp;gt;setCallbacks(new MyServerCallbacks());

  // Create the BLE Service
  BLEService *pService = pServer-&amp;gt;createService(SERVICE_UUID);

  // Create a BLE Characteristic
  pCharacteristic = pService-&amp;gt;createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ   |
                      BLECharacteristic::PROPERTY_WRITE  |
                      BLECharacteristic::PROPERTY_NOTIFY |
                      BLECharacteristic::PROPERTY_INDICATE
                    );

  // https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml
  // Create a BLE Descriptor
  pCharacteristic-&amp;gt;addDescriptor(new BLE2902());

  // Start the service
  pService-&amp;gt;start();

  // Start advertising
  pServer-&amp;gt;getAdvertising()-&amp;gt;start();
  Serial.println(&amp;quot;Waiting a client connection to notify...&amp;quot;);
}

void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイルエラーが出ないで書き込みが出来ればOKです。&lt;/p&gt;

&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;

&lt;p&gt;デバッグには&lt;a href=&#34;https://itunes.apple.com/jp/app/lightblue/id639944780?mt=12&#34;&gt;LightBlue&lt;/a&gt;などのBLEデバッグ用のアプリケーションを利用することをお勧めします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTが起動すると先ほど指定した&lt;strong&gt;NefryBT-n0bisuke&lt;/strong&gt;という名前でBLEデバイスが検出されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SERVICEのUUIDやCHARACTERISTICのUUIDも先ほど指定したものが表示されていると思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これで問題なく、Nefry BTから情報が発信されていることが確認出来ました。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;centralの作成&#34;&gt;Centralの作成&lt;/h2&gt;

&lt;p&gt;次は受信側のCentralを作成していきます。
データの確認だけであれば先ほどのLightBlueなどのアプリで確認でも良いのですが、自分のサービスに組み込む際には何かしらのプログラミング言語でアクセスできた方が都合が良いです。&lt;/p&gt;

&lt;h3 id=&#34;nobleの利用&#34;&gt;nobleの利用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sandeepmistry/noble&#34;&gt;noble&lt;/a&gt;はNode.js向けのBLEライブラリです。MacやWindows、Raspberry PiなどのデバイスをBLEのCentralにすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ble_central
cd ble_central
touch app.js
npm init -y
npm i --save noble
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで準備とnobleのインストールが完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;に以下を記述します。SERVICE_UUIDやCHARACTERISTIC_UUIDは自分で作成したNefry BT側に書き込んだUUIDと同様のものを指定しましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[WIP] Async/Awaitに書き換えたい。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const noble = require(&#39;noble&#39;);
const serviceuuid = `d5875408fa514763a75d7d33cecebc31`;
const charauuid = `a4f01d8ca03743b690501876a8c23584`;

//キャラクタリスティックにアクセスしてデータやりとり
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}


//discovered BLE device
const discovered = (peripheral) =&amp;gt; {
    console.log(`BLE Device Found: ${peripheral.advertisement.localName}(${peripheral.uuid}) RSSI${peripheral.rssi}`);

    if(peripheral.advertisement.localName === &#39;NefryBT-n0bisuke&#39;){
        noble.stopScanning();
        console.log(&#39;device found&#39;);
        console.log(`service discover...`);

        peripheral.connect(error =&amp;gt; {
            if (error) {
                console.log(&amp;quot;connection error:&amp;quot;, error)
            } else {
                console.log(&amp;quot;device connected&amp;quot;);
            }

            peripheral.discoverServices([],(err, services) =&amp;gt; {
                if (error) {
                    console.log(&amp;quot;discover service error&amp;quot;, error)
                }
                console.log(&#39;discover service&#39;);               
                services.forEach(service =&amp;gt; {
                    if(service.uuid === serviceuuid){
                        service.discoverCharacteristics([], (error, charas) =&amp;gt; {
                            console.log(&#39;discover chara&#39;);
                            charas.forEach(chara =&amp;gt; {
                                if(chara.uuid === charauuid){
                                    console.log(&amp;quot;found chara: &amp;quot;, chara.uuid)
                                    accessChara(chara);
                                }
                            });
                        });
                    }
                });
            });
        });
    }
}

//BLE scan start
const scanStart = () =&amp;gt; {
    noble.startScanning();
    noble.on(&#39;discover&#39;, discovered);
}

if(noble.state === &#39;poweredOn&#39;){
    scanStart();
}else{
    noble.on(&#39;stateChange&#39;, scanStart);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実行&#34;&gt;実行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で実行します。この時、先ほどのLightBlueなどのアプリでNefryBTにBLEアクセスしていると上手くいかないのでアプリ側の接続は解除しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/5.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mac側のNode.jsのログはこんな感じで表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BLE Device Found: LED(59aa15c3a3274ed7b11d334b5c0d0900) RSSI-68
BLE Device Found: NefryBT-n0bisuke(d0b77d4611f54380b8b63e6d05765ad6) RSSI-49
device found
service discover...
device connected
discover service
discover chara
found chara:  a4f01d8ca03743b690501876a8c23584
-----Start GATT Access-----
listen notif
{ val: 147 }
{ val: 148 }
・
・
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解説&#34;&gt;解説&lt;/h3&gt;

&lt;p&gt;NefryBT側ではデバイスにアクセスがありCentralとのコネクションが確立すると、&lt;code&gt;変数value&lt;/code&gt;の値をセット(pCharacteristic-&amp;gt;setValue)して送信（pCharacteristic-&amp;gt;notify）し、valueの値をインクリメントします。&lt;/p&gt;

&lt;p&gt;これを2秒ごとに行うので2秒間隔でNefryBTからMacのNode.jsに情報が送信されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
(省略)
・
・
void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js（noble）側では、PERIPHERAL -&amp;gt; SERVICE -&amp;gt; CHARACTERISTICと階層的にアクセスしていき、CHARACTERISTICまでアクセスが出きると、accessChara関数が呼ばれます。&lt;/p&gt;

&lt;p&gt;この中の&lt;code&gt;chara.on(&#39;data&#39;)&lt;/code&gt;の箇所でデータが送られてくるたびにイベントが発火して、データの中身を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
・
(省略)
・
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}
・
・
(省略)
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTでBLEを利用する方法を紹介しました。
Nefry BTでセンサーのデータを取得し、Centralに送信する方法なども応用して作れそうですね。&lt;/p&gt;

&lt;p&gt;これを参考にNefry BTとBLEデバイスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;今回はNefry BTをPeripheralにする実装でしたが、別の機会でCentralにする方法も紹介できればと思っています。&lt;/p&gt;

&lt;p&gt;それでは！&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;今回の実装ですが色々と途中でのハマりが多いかつ、調べてもまだまだESP32のBLE利用をArduinoでやってる事例は少なくけっこう大変でした。この辺の大変だった知見はQiitaなどでまとめらたらと思っています。お疲れ様です笑&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title>
      <link>https://dotstud.io/blog/raspberry-pi-case-making/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong&gt;ラズパイにはまってしまったラズパイ女子です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p&gt;

&lt;p&gt;しかしなかなか可愛いいケースがない……。&lt;strong&gt;ないなら、作ってしまえばいい！！！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p&gt;

&lt;h2 id=&#34;レーザーカッターを使える場所を探そう&#34;&gt;レーザーカッターを使える場所を探そう&lt;/h2&gt;

&lt;p&gt;今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong&gt;工作機械を気軽に利用できるFabスペース&lt;/strong&gt;を利用してみましょう！&lt;/p&gt;

&lt;p&gt;レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p&gt;

&lt;p&gt;何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p&gt;

&lt;h3 id=&#34;レーザーカッターが使える初心者向けオススメfabスペース&#34;&gt;レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3&gt;

&lt;p&gt;初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p&gt;

&lt;h4 id=&#34;fabcafe-https-fabcafe-com-tokyo&#34;&gt;&lt;a href=&#34;https://fabcafe.com/tokyo/&#34;&gt;◆FabCafe&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p&gt;

&lt;h4 id=&#34;iotlab-https-cami-jp-iotlab&#34;&gt;&lt;a href=&#34;https://cami.jp/iotlab/&#34;&gt;◆IoTLab&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p&gt;

&lt;h4 id=&#34;techshop-http-www-techshop-jp&#34;&gt;&lt;a href=&#34;http://www.techshop.jp/&#34;&gt;◆TechShop&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p&gt;

&lt;h2 id=&#34;ケースの形について調べてみよう&#34;&gt;ケースの形について調べてみよう&lt;/h2&gt;

&lt;p&gt;一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/1.png&#34; alt=&#34;&#34; /&gt;
「Raspberry Pi  ケース」を検索
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ケースの形によってはかなり難易度が高そうです……。&lt;/p&gt;

&lt;h3 id=&#34;初心者にも作りやすいケースの形&#34;&gt;初心者にも作りやすいケースの形&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li&gt;
&lt;li&gt;ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/2.png&#34; alt=&#34;&#34; /&gt;
上蓋と下蓋を支柱で支えるタイプのケース　　
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;部材を集めよう&#34;&gt;部材を集めよう&lt;/h2&gt;

&lt;h3 id=&#34;かわいいアクリルで作れば-かわいいケースになる-はず&#34;&gt;かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;かわいいアクリルで作ればかわいいケースになる&lt;/strong&gt;と信じて、素敵なアクリルを用意しましょう。&lt;/p&gt;

&lt;p&gt;アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong&gt;実際に店舗に行ってみるのがオススメ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href=&#34;https://www.miyukiacryl.tokyo/tokyo-acryl&#34;&gt;デザインアクリル専門店 ミユキアクリル&lt;/a&gt;」さんのような&lt;strong&gt;デザインアクリル専門店&lt;/strong&gt;もあるので、興味のある方は覗いてみましょう！&lt;/p&gt;

&lt;p&gt;※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/3.png&#34; alt=&#34;&#34; /&gt;
自分好みのアクリルを選ぼう
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p&gt;

&lt;p&gt;厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p&gt;

&lt;p&gt;好みのアクリルがない場合は、&lt;strong&gt;UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong&gt;という手もあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/4.png&#34; alt=&#34;&#34; /&gt;
UVプリンターでイラストや写真を転写
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p&gt;

&lt;h3 id=&#34;ネジやスペーサーなどのパーツ&#34;&gt;ネジやスペーサーなどのパーツ&lt;/h3&gt;

&lt;p&gt;支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/5.png&#34; alt=&#34;&#34; /&gt;
上：真鍮黒ネジ、シルバーの六角スペーサー の組み合わせ&lt;br /&gt;
下：プラネジ、白のプラスチックのスペーサー&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;必要なパーツ一覧&#34;&gt;必要なパーツ一覧&lt;/h3&gt;

&lt;p&gt;好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li&gt;
&lt;li&gt;ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li&gt;
&lt;li&gt;アクリル板固定・ネジ M3（8mm）8本&lt;/li&gt;
&lt;li&gt;アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li&gt;
&lt;li&gt;アクリル（今回は厚さ3mmのもの）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/parts.png&#34; alt=&#34;&#34; /&gt;
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;h3 id=&#34;step1-型の準備&#34;&gt;step1. 型の準備&lt;/h3&gt;

&lt;p&gt;Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p&gt;

&lt;p&gt;ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href=&#34;https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y&#34;&gt;&lt;strong&gt;こちらのaiデータ&lt;/strong&gt;&lt;/a&gt;をそのまま使うこともできます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/6.png&#34; alt=&#34;&#34; /&gt;
左：下蓋 / 右：上蓋
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラ：幅0.9mm × 高さ28mm&lt;/li&gt;
&lt;li&gt;GPIO：幅55mm × 高さ12mm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/7.png&#34; alt=&#34;&#34; /&gt;
上蓋にカメラとGPIOの部分を追加
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;レーザーカッターには切る順番があり、「&lt;strong&gt;彫刻 → 穴 → 切り落とし&lt;/strong&gt;」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p&gt;

&lt;p&gt;これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p&gt;

&lt;h3 id=&#34;step2-アクリルを裁断&#34;&gt;step2. アクリルを裁断&lt;/h3&gt;

&lt;p&gt;今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step3-組み立てる&#34;&gt;step3. 組み立てる&lt;/h3&gt;

&lt;p&gt;まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/9.png&#34; alt=&#34;&#34; /&gt;
短いスペーサーでラズパイを下蓋に固定
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p&gt;

&lt;h3 id=&#34;完成&#34;&gt;完成&lt;/h3&gt;

&lt;p&gt;自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src=&#34;https://dotstud.io/img/blog/142/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/12.png&#34; alt=&#34;&#34; /&gt;
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p&gt;

&lt;p&gt;日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong&gt;どこに連れて行ってもかわいいと言ってもらえる&lt;/strong&gt;ので作りがいがありました。何より愛着がわきますね〜！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）でMQTTを使ってみよう Subscribe編</title>
      <link>https://dotstud.io/blog/nefry-bt-connect-mqtt/</link>
      <pubDate>Sat, 06 Jan 2018 14:28:04 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-bt-connect-mqtt/</guid>
      
      <description>

&lt;p&gt;あけましておめでとうございます。 代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;Nefry BTを使ってMQTTを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;今回はMQTTでNefry BTに情報を送信してみます。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、ESP32系の他のボードを利用している人の参考にもなると思います。&lt;/p&gt;

&lt;h2 id=&#34;mqttの登場人物&#34;&gt;MQTTの登場人物&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Broker - 通信のサーバー&lt;/li&gt;
&lt;li&gt;Publisher - 情報の送信側&lt;/li&gt;
&lt;li&gt;Subscriber - 情報の受信側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebSocketではサーバーとクライアントだけで双方向通信をしますが、MQTTではサーバーはBrocker、クライアント側が送信者のPublisherと受信者のSubscriberに分かれます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回はNefry BTをSubscriber（受信者）にして、外部からNefry BTに情報を送ってみたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subscriberの作成&#34;&gt;Subscriberの作成&lt;/h2&gt;

&lt;h3 id=&#34;arduino向けのmqttライブラリをインストール&#34;&gt;Arduino向けのMQTTライブラリをインストール&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knolleary/pubsubclient&#34;&gt;knolleary/pubsubclient&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;zipファイルをダウンロードしたら、 &lt;code&gt;スケッチ &amp;gt; ライブラリのインポート &amp;gt; .ZIP形式のライブラリをインストール&lt;/code&gt;からArduino IDEにライブラリをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;ブローカーは&lt;a href=&#34;https://mosquitto.org/&#34;&gt;Mosquitto&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;mosquitto.org&amp;rdquo;の&amp;rdquo;n0bisuke&amp;rdquo;という名前のトピックに情報が送信されたら受信します。&lt;/p&gt;

&lt;p&gt;MQTTはデフォルト1883ポートを利用するので、1883ポートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;

WiFiClient httpsClient;
PubSubClient mqttClient(httpsClient);

#define TOPIC &amp;quot;n0bisuke&amp;quot;
#define QOS 0
#define URL &amp;quot;mosquitto.org&amp;quot;
#define PORT 1883

void setup() {
  mqttClient.setServer(URL, PORT);
  mqttClient.setCallback(callback);
}

void loop() {
  if(!mqttClient.connected()) {
    if (mqttClient.connect(TOPIC)) {
      Serial.println(&amp;quot;Connected.&amp;quot;);    
      mqttClient.subscribe(TOPIC, QOS);
      Serial.println(&amp;quot;Subscribed.&amp;quot;);
    }
    else {
      errorReport();
    }
  }

  mqttClient.loop();
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print(&amp;quot;Message arrived [&amp;quot;);
  Serial.print(topic);
  Serial.print(&amp;quot;] &amp;quot;);
  for (int i = 0; i &amp;lt; length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();
}

void errorReport(){
  Serial.print(&amp;quot;Failed. Error state = &amp;quot;);

  switch (mqttClient.state()) {
    case MQTT_CONNECT_UNAUTHORIZED:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAUTHORIZED&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CREDENTIALS:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CREDENTIALS&amp;quot;);
      break;
    case MQTT_CONNECT_UNAVAILABLE:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAVAILABLE&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CLIENT_ID:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CLIENT_ID&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_PROTOCOL:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_PROTOCOL&amp;quot;);
      break;
    case MQTT_CONNECTED:
      Serial.println(&amp;quot;MQTT_CONNECTED&amp;quot;);
      break;
    case MQTT_DISCONNECTED:
      Serial.println(&amp;quot;MQTT_DISCONNECTED&amp;quot;);
      break;
    case MQTT_CONNECT_FAILED:
      Serial.println(&amp;quot;MQTT_CONNECT_FAILED&amp;quot;);
      break;
    case MQTT_CONNECTION_LOST:
      Serial.println(&amp;quot;MQTT_CONNECTION_LOST&amp;quot;);
      break;
    case MQTT_CONNECTION_TIMEOUT:
      Serial.println(&amp;quot;MQTT_CONNECTION_TIMEOUT&amp;quot;);
      break;
  }

  delay(5000); // Wait 5 seconds before retrying
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publisherの作成&#34;&gt;Publisherの作成&lt;/h2&gt;

&lt;p&gt;情報の送信側であるPublisherは手元のMac Book上のNode.jsで作成しました。&lt;/p&gt;

&lt;p&gt;Node.jsでMQTTを利用する場合は&lt;a href=&#34;https://www.npmjs.com/package/mqtt&#34;&gt;mqtt.js&lt;/a&gt;を利用するのが手頃です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir mqtt-test
cd mqtt-test
npm init -y
npm i --save mqtt
touch publisher.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//publisher.js
&#39;use strict&#39;;

const mqtt = require(&#39;mqtt&#39;);
const client = mqtt.connect(&#39;mqtt://mosquitto.org&#39;);

client.on(&#39;connect&#39;, () =&amp;gt; console.log(&#39;publisher.connected.&#39;));

setInterval(() =&amp;gt; {
    const message = Date.now().toString();
    client.publish(&#39;n0bisuke&#39;, message);
    console.log(&#39;publisher.publish:&#39;, message);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行すると、以下のように時間の情報をパブリッシュ（送信）し始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node publisher.js

publisher.publish: 1515219086876
publisher.publish: 1515219087879
publisher.publish: 1515219088880
publisher.publish: 1515219089882
・
・
・
(省略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;思ってたより簡単に実装出来ました。
これを参考にNefry BTとWebサービスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mosca.io/&#34;&gt;Mosca&lt;/a&gt;などを使うとBrokerも自分で作成することが出来るので試してみると良いかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>オフィス移転したらインターホンがなかったのでRaspbeerry Piでカメラ付きインターホン作ってみた</title>
      <link>https://dotstud.io/blog/office-new-door-notification/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/office-new-door-notification/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioモノづくり担当・うこです。&lt;/p&gt;

&lt;p&gt;dotstudioは&lt;a href=&#34;https://dotstud.io/blog/office-relocation-for-akihabara/&#34;&gt;&lt;strong&gt;めでたく新オフィスに移転したのですが&lt;/strong&gt;&lt;/a&gt;、インターホンがついておらず不便なんですよね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/10.png&#34; alt=&#34;&#34; /&gt;
代表・のびすけ「&lt;strong&gt;うこ先生、これRaspberry Piでインターホン作れない？&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/1.png&#34; alt=&#34;&#34; /&gt;
僕「&lt;strong&gt;秒でいけます&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;ということで作ってみました！&lt;/p&gt;

&lt;h2 id=&#34;全体の構成&#34;&gt;全体の構成&lt;/h2&gt;

&lt;p&gt;今回は&lt;strong&gt;ボタンを押したら室内のスピーカに音がなる機能&lt;/strong&gt;に加えて、&lt;strong&gt;押した人の姿が見えるカメラ機能&lt;/strong&gt;も搭載してみました。&lt;/p&gt;

&lt;p&gt;全体の構成はこんな感じです。
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/116011/a7707b67-176f-8dc6-cf32-8323a56e860c.png&#34; alt=&#34;いんたーほん.png&#34; title=&#34;いんたーほん.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Raspberry Pi 3（以下ラズパイ）をベースにして、Grove接続されたタッチセンサに触れると室内のBluetoothスピーカー（今回はBASE EGG）から音が流れる仕組みを作ります。&lt;/p&gt;

&lt;p&gt;さらに、ラズパイカメラをドアの外に出して、外の様子がオフィス内のモニタから見られるようにします。&lt;/p&gt;

&lt;h3 id=&#34;使ったもの&#34;&gt;使ったもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3&lt;/li&gt;
&lt;li&gt;Raspberry Pi カメラモジュール&lt;/li&gt;
&lt;li&gt;Grove タッチセンサ&lt;/li&gt;
&lt;li&gt;Bluetoothオーディオトランスミッタ&lt;/li&gt;
&lt;li&gt;Bluetoothスピーカー（今回はBASS EGG）&lt;/li&gt;
&lt;li&gt;スピーカー（100円）&lt;/li&gt;
&lt;li&gt;オーディオ分岐プラグ（100円）&lt;/li&gt;
&lt;li&gt;マグネット付きプラスチックケース（100円）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;呼び鈴の製作&#34;&gt;呼び鈴の製作&lt;/h2&gt;

&lt;h3 id=&#34;ハードウェア部分&#34;&gt;ハードウェア部分&lt;/h3&gt;

&lt;p&gt;まずはじめに、&lt;strong&gt;来客者がボタンを押すと室内で音が鳴って訪問を知らせるようにする機能&lt;/strong&gt;を作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/12.png&#34; alt=&#34;&#34; /&gt;
ラズパイはマグネット付きのプラスチックケースに入れて、金属製のドアの内側に貼り付けます。ケースはケーブルが引き出せるように適宜加工します。&lt;/p&gt;

&lt;p&gt;次にGroveタッチセンサですが、そのままだとラズパイに接続できないためジャンパワイヤを3本用意します。接続するピンは以下のとおりです。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;タッチセンサのピン&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ラズパイGPIO&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;VCC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3.3V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;GND&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ground&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;NC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SIG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ラズパイGPIOのピン番号と位置については、以下の公式ページにある2番目の図を参照してください。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.raspberrypi.org/documentation/usage/gpio-plus-and-raspi2/&#34;&gt;GPIO: MODELS A+, B+, RASPBERRY PI 2 B AND RASPBERRY PI 3 B&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;次に、100円程度で売られているオーディオ出力分岐器をラズパイのオーディオ出力に接続し、さらにBluetoothのオーディオトランスミッタと小型のスピーカーに接続します。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/133/11.png&#34; alt=&#34;&#34; /&gt;
実証の結果、「押した人にも音が鳴ったことがわかる」ことが必要とわかった
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;オーディオトランスミッタは室内に来客を知らせるスピーカーを鳴らす用、小型スピーカーはドアの外に出して来客者に「呼び鈴が鳴った」ことを知らせる用です。USB接続のアンプ付きスピーカーなどで大きな音が出せるのならそれで代用することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/5.png&#34; alt=&#34;&#34; /&gt;
最後に電源を近くのコンセントからUSBアダプタ経由で接続してハードウェア部分は完了です！&lt;/p&gt;

&lt;h3 id=&#34;ソフトウェア部分&#34;&gt;ソフトウェア部分&lt;/h3&gt;

&lt;p&gt;まず、適当なインターフォンの音となるmp3を用意しましょう。簡単なピンポン音でも、ネタのような効果音でもいいです。dotstudioでは、「ファミマ入店音」が好評だったため採用しました。&lt;/p&gt;

&lt;p&gt;mp3が用意できたら、&lt;code&gt;/home/pi&lt;/code&gt;などのディレクトリに&lt;code&gt;sounds&lt;/code&gt;というフォルダを作ってその中にmp3を入れましょう。&lt;/p&gt;

&lt;p&gt;次に、&lt;code&gt;sudo apt-get install mpg321&lt;/code&gt;を実行し、サウンド再生用のソフトウェア「mpg321」をインストールします。&lt;code&gt;mpg321 sounds/サウンド.mp3&lt;/code&gt;などと実行して、スピーカーから音が出ていればOKです。もしここで音が小さい場合は、&lt;code&gt;alsamixer&lt;/code&gt;コマンドを実行すると音量調整ができますので、矢印キーで大きくしておきます。&lt;/p&gt;

&lt;p&gt;音の再生が確認できたら、以下のPythonプログラムを&lt;code&gt;sounds&lt;/code&gt;ディレクトリと同じ場所に保存して実行します。タッチセンサを触ると同時に、音が鳴ってターミナル上に&amp;rsquo;Ping-pon!&amp;lsquo;と表示されれば成功です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-/home/pi/interphone.py&#34;&gt;#!/usr/bin/python

import RPi.GPIO as GPIO
import glob
import subprocess
from time import sleep
from random import shuffle

GPIO.setmode(GPIO.BCM)
GPIO.setup(24, GPIO.IN)

# mp3が保存されているディレクトリは適宜変更してください
soundlist = glob.glob(&amp;quot;./sounds/*.mp3&amp;quot;)

while True:
    if GPIO.input(24) == GPIO.HIGH:
        shuffle(soundlist)
        print(&#39;Ping-pon!&#39;)
        subprocess.call(&amp;quot;mpg321 -q &amp;quot;+soundlist[0], shell=True)
    else:
        sleep(0.01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、再起動しても動くように、&lt;code&gt;/etc/rc.local&lt;/code&gt;ファイルの末尾に&lt;code&gt;/usr/bin/python /home/pi/interphone.py &amp;amp;&lt;/code&gt;と追記しておきましょう。
ちなみにですが、上記のコードでは&lt;code&gt;sounds&lt;/code&gt;ディレクトリ内に複数のmp3が入っているとランダムで再生されるような仕組みにしています。&lt;/p&gt;

&lt;h2 id=&#34;監視カメラ部分の製作&#34;&gt;監視カメラ部分の製作&lt;/h2&gt;

&lt;p&gt;監視カメラはラズパイ専用カメラを使用します。接続はとても簡単で、HDMI端子とオーディオ端子の間にある細長い端子にケーブルを差し込むだけです。&lt;code&gt;sudo raspi-config&lt;/code&gt;コマンドで、カメラを使うことができるように設定を変更しておきましょう。&lt;code&gt;raspistill -p&lt;/code&gt;コマンドを実行し、特にエラーが出なければ正常に接続されています。&lt;/p&gt;

&lt;p&gt;今回はカメラと呼び鈴部分は連動させず、カメラは&lt;a href=&#34;https://github.com/ccrisan/motioneye/wiki&#34;&gt;motionEye&lt;/a&gt;というオープンソースウェアを使って単独で動作させます。
motionEyeのインストールは以下を参考にしました。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://qiita.com/mt08/items/96207abfba91954b50d4&#34;&gt;らずぱい motionEye (Web UIベースのカメラサーバ) - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こちらのページにも書かれていますが、ラズパイのカメラモジュールを使用するので、以下のコマンドを実行しておくのを忘れないようにしましょう。
&lt;code&gt;grep bcm2835-v4l2 /etc/modules || echo bcm2835-v4l2 | sudo tee -a /etc/modules&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/4.png&#34; alt=&#34;&#34; /&gt;
インストールが完了して、室内に常設してあるPCのブラウザからアクセスしてみました。
ばっちりドアの外が撮影されていますね！
1秒おきに更新されていますが、python上で動作しているためか、少々重たいようです。&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/7.png&#34; alt=&#34;&#34; /&gt;
インターホンを押すと……&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/4W4pJ0bZVGY&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;入店っぽい音が流れます！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/13.png&#34; alt=&#34;&#34; /&gt;
旧スタイルに比べるとだいぶ未来になりました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は数時間ほどでこのシステムを作ることができました。カメラと呼び鈴が独立してしまっていますが、可能ならば「呼び鈴を押した瞬間の画像を保存してhipchatにアップロード」するような仕組みを作ってみたいです。
&lt;img src=&#34;https://dotstud.io/img/blog/133/3.png&#34; alt=&#34;&#34; /&gt;
次は何をつくってやろうか……。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>フェスでテンあげ☆ 光るカセットテープ</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-led-cassette/</link>
      <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-led-cassette/</guid>
      
      <description>

&lt;p&gt;みなさん、チョリおつ！ギャル電きょうこです。ギャルによるギャルのための電子工作をテクノロジーを提案するユニット、ギャル電で活動しておりまっす。今回は、フェスに相性ピッタリの光りものアクセの作り方を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;何を光らせたらエモいのか-問題&#34;&gt;何を光らせたらエモいのか?!問題&lt;/h2&gt;

&lt;p&gt;光るとモテる！
でも、なんでも光らせただけでかっこよくなるわけではないのです。
ギャル電も&lt;strong&gt;とりあえず光らせてみたけど全然ぐっと来ないものを作ってしまう&lt;/strong&gt;ことがよくあります。
&lt;img src=&#34;https://dotstud.io/img/blog/129/1.png&#34; alt=&#34;&#34; /&gt;
今回は、まずとりあえず首からさげられる形で単純にＬＥＤテープを貼り付けたものをつくってみましたが&lt;strong&gt;ときめきがゼロ！！！！
こんなもの！！！！！&lt;/strong&gt; 泣きながら窓から投げ捨てて、そっとあとで拾いに行きました。&lt;/p&gt;

&lt;p&gt;そのあと、おやつをたべながらテンションを上げるために&lt;strong&gt;スピードコア&lt;/strong&gt;（めっちゃテンポの速いナイスなミュージック）と&lt;strong&gt;バニラのテーマソング&lt;/strong&gt;を交互に聴いていたら&lt;/p&gt;

&lt;p&gt;天啓が下りてきました。&lt;/p&gt;

&lt;p&gt;「&lt;strong&gt;カセットテープなら、首から下げる光もののケースにジャストフィット！！そしてエモい&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;ありがとう、スピードコアの神よ！
みんなもアイデアに詰まったときはスピードコア聴くといいよ。&lt;/p&gt;

&lt;h2 id=&#34;材料を揃えよう&#34;&gt;材料を揃えよう&lt;/h2&gt;

&lt;p&gt;今回の材料は、基板や配線以外はだいたい100均で揃えることができます。&lt;/p&gt;

&lt;p&gt;ボードは超小型ボード&lt;strong&gt;Digispark互換機&lt;/strong&gt;を使用しています。最初のセットアップは少し面倒ですが、安くて小さいので気軽に電子工作を作ることができます。&lt;/p&gt;

&lt;h3 id=&#34;材料&#34;&gt;材料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;カセットテープ（光を通すように透明なものか乳白色で透けるものがおすすめです）&lt;/li&gt;
&lt;li&gt;LEDテープ（1m60個ＬＥＤついてるテープを10LED分）&lt;/li&gt;
&lt;li&gt;ひも（ストラップはお好みで。わたしは柄がかわいい靴ひもを使いました）&lt;/li&gt;
&lt;li&gt;リング（事務用品コーナーに売ってる簡単な鉄の輪っか）&lt;/li&gt;
&lt;li&gt;Digispark互換機（amazonとかでこの名前で検索すると買えます）&lt;/li&gt;
&lt;li&gt;線材（普通の電線でOKですが、コネクタは付いてるとプログラムを入れなおすときとかにちょっと便利です）&lt;/li&gt;
&lt;li&gt;インシロック&lt;/li&gt;
&lt;li&gt;両面テープ（超強力）&lt;/li&gt;
&lt;li&gt;ニッパー&lt;/li&gt;
&lt;li&gt;ワイヤストリッパー&lt;/li&gt;
&lt;li&gt;はんだごて&lt;/li&gt;
&lt;li&gt;はんだ線&lt;/li&gt;
&lt;li&gt;ピンバイスまたはハンドドリル（本体穴あけ用）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ledのケース用にカセットテープを加工する&#34;&gt;LEDのケース用にカセットテープを加工する&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずはカセットテープの四隅のねじを外して分解します。
このとき、&lt;strong&gt;ねじが超小さいのでなくさないようになんか入れ物にいれたりマスキングテープに貼り付けておく&lt;/strong&gt;と便利です。&lt;/p&gt;

&lt;p&gt;また、&lt;strong&gt;分解する前に元の形がわかるように写真を撮っておくとあとですごい役立つのでおすすめ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;磁気テープ部分は今回は使わないので軸からはさみで切り離して外します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/3.png&#34; alt=&#34;&#34; /&gt;
配線を通すため2.5センチくらいカセットテープの上端をカットして穴をあけておきます。
磁気テープ以外は、&lt;strong&gt;ディテールとしてエモいので元の位置に収まるように戻して使用&lt;/strong&gt;します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/4.png&#34; alt=&#34;&#34; /&gt;
リングを通すための穴をカットしたほうとは逆の上端にピンバイスであけておきます。&lt;/p&gt;

&lt;p&gt;以上でカセットテープの加工は完了です。&lt;strong&gt;後でさみしい気持ちになってしまうので、ねじは絶対に無くさないように注意です&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ledと基板のはんだ付け&#34;&gt;LEDと基板のはんだ付け&lt;/h2&gt;

&lt;p&gt;カセットテープにおさまるように、LEDテープを半分（LED5個ずつ）にカットして使用します。
&lt;img src=&#34;https://dotstud.io/img/blog/129/5.png&#34; alt=&#34;&#34; /&gt;
写真の丸がついてるところを何も接続しない状態ではんだづけします。
予備はんだってやつで、やっておくとあとで配線と部品をはんだ付けするのがスムーズになります。&lt;/p&gt;

&lt;p&gt;Digispark基板（おもて）は、5V、GND、P0と書いてある穴の上に予備はんだをします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/6.png&#34; alt=&#34;&#34; /&gt;
Digispark基板の裏と9V電池用のスナップ配線も予備はんだをします。
Digispark基板（うら）は、VIN、GNDを予備はんだします。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※裏側の配線を間違えて5V,GNDで接続すると基板めっちゃ熱くなってなんか焦げたにおいして超ビビるので要注意です。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/7.png&#34; alt=&#34;&#34; /&gt;
予備ハンダ作業が終わったら、まずはDigispark基板の裏側と9V電池用スナップをはんだ付けします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VIN － 赤い配線（電池プラス）&lt;/li&gt;
&lt;li&gt;GND － 黒い配線（電池マイナス）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;をそれぞれ接続します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/8.png&#34; alt=&#34;&#34; /&gt;
次は、LEDに接続するための3本の線をDigispark基板の表側にはんだ付けします。
LEDに接続したときに、以下のように配線がつながるようにします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;5V － （LED側）5V：今回の作例では赤い配線&lt;/li&gt;
&lt;li&gt;GND － （LED側）GND：今回の作例では白い配線&lt;/li&gt;
&lt;li&gt;P0 － （LED側）DIN：今回の作例では緑の配線&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/9.png&#34; alt=&#34;&#34; /&gt;
2本のLEDテープの間もはんだ付けでつなげます。
このとき、LEDテープの進行方向の矢印の向きを間違えないように注意します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/10.png&#34; alt=&#34;&#34; /&gt;
全体図はこんな感じです。
これで、LED配線のはんだ付けは完了でっす。&lt;/p&gt;

&lt;h2 id=&#34;プログラムの書き込み準備&#34;&gt;プログラムの書き込み準備&lt;/h2&gt;

&lt;p&gt;ここからは、初心者にはちょっと気合いのいる作業になります。&lt;/p&gt;

&lt;p&gt;でも、だいたい大丈夫！
わからない単語が出てきたら&lt;strong&gt;速攻ググるとわりとわかるようになります&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;つらくなったときは、光ってモテる近い将来を想像したりスピードコア聴いて気分転換したりご飯食べたり寝たりしてのりこえていきましょう。&lt;/p&gt;

&lt;p&gt;まずは、Digisparkボードにプログラムを書き込むためにArduino IDEというソフトウェアをPCにインストールします。&lt;/p&gt;

&lt;p&gt;下記リンクはMacでの説明なので、Windowsユーザーはダウンロードするファイルを選択するときに、Windowsのリンクを選んでダウンロードしてインストールを行ってください。&lt;/p&gt;

&lt;p&gt;【参考】&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;Arduino IDEをPCにインストール&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;arduinoideでdigisparkのボードを書き込めるように設定する&#34;&gt;ArduinoIDEでDigisparkのボードを書き込めるように設定する&lt;/h3&gt;

&lt;p&gt;英語のページになりますが、以下のページを参考にインストールを行いました。
&lt;a href=&#34;http://digistump.com/wiki/Digispark/tutorials/connecting&#34;&gt;http://digistump.com/wiki/Digispark/tutorials/connecting&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;※環境はWindows10（64bit）、ArduinoIDE 1.8.3にて動作を確認しました。&lt;/p&gt;

&lt;p&gt;大雑把にいうとWindowsの場合には、&lt;/p&gt;

&lt;p&gt;①ドライバをダウンロードしてインストールする
&lt;a href=&#34;https://github.com/digistump/DigistumpArduino/tree/master/tools&#34;&gt;https://github.com/digistump/DigistumpArduino/tree/master/tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;②ArduinoIDEを起動し、ファイル→環境設定→「追加のボードマネージャのURL」に
&lt;code&gt;http://digistump.com/package_digistump_index.json&lt;/code&gt;
をコピペで追加して「OK」ボタンで環境設定を閉じる&lt;/p&gt;

&lt;p&gt;③ツール→ボード→ボードマネージャをクリック&lt;/p&gt;

&lt;p&gt;④検索窓をクリックし、タイプの項目で「提供された」を選択。
「Digistump AVR Boards」を検索し、検索結果をクリックして「インストール」をクリック&lt;/p&gt;

&lt;p&gt;⑤インストール後、ツールから
「ボード：Digispark(Default - 16.5mhz)」
をクリックで選択&lt;/p&gt;

&lt;p&gt;上記手順で書き込み準備は完了です。&lt;/p&gt;

&lt;p&gt;プログラムは、以下のものをコピーしてArduinoIDEにペーストします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#ifdef __AVR__
  #include &amp;lt;avr/power.h&amp;gt;
#endif

//neopixcel用の設定部分

//neopixelを接続するPINを設定
#define PIN_LED 0

//neopixelのLEDの数を設定
#define NUM_LEDS 10

Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN_LED, NEO_GRB + NEO_KHZ800);

bool oldState = HIGH;
int showType = 0;

void showStrip() {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.show();
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   FastLED.show();
 #endif
}

void setPixel(int Pixel, byte red, byte green, byte blue) {
 #ifdef ADAFRUIT_NEOPIXEL_H
   strip.setPixelColor(Pixel, strip.Color(red, green, blue));
 #endif
 #ifndef ADAFRUIT_NEOPIXEL_H
   leds[Pixel].r = red;
   leds[Pixel].g = green;
   leds[Pixel].b = blue;
 #endif
}

void setAll(byte red, byte green, byte blue) {
  for(int i = 0; i &amp;lt; 17; i++ ) {
    setPixel(i, red, green, blue);
  }
  showStrip();
}

// ここからNeoPixelのアニメーション設定


void FadeInOut(byte red, byte green, byte blue){
  float r, g, b;

  for(int k = 0; k &amp;lt; 256; k=k+1) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }

  for(int k = 255; k &amp;gt;= 0; k=k-2) {
    r = (k/256.0)*red;
    g = (k/256.0)*green;
    b = (k/256.0)*blue;
    setAll(r,g,b);
    showStrip();
  }
}

void Strobe(byte red, byte green, byte blue, int StrobeCount, int FlashDelay, int EndPause){
  for(int j = 0; j &amp;lt; StrobeCount; j++) {
    setAll(red,green,blue);
    showStrip();
    delay(FlashDelay);
    setAll(0,0,0);
    showStrip();
    delay(FlashDelay);
  }

 delay(EndPause);
}

void Twinkle(byte red, byte green, byte blue, int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),red,green,blue);
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}
void TwinkleRandom(int Count, int SpeedDelay, boolean OnlyOne) {
  setAll(0,0,0);

  for (int i=0; i&amp;lt;Count; i++) {
     setPixel(random(NUM_LEDS),random(0,255),random(0,255),random(0,255));
     showStrip();
     delay(SpeedDelay);
     if(OnlyOne) {
       setAll(0,0,0);
     }
   }
}

//

void setup()
{
    pinMode(PIN_LED, OUTPUT);
    digitalWrite(PIN_LED, LOW);
   #if defined (__AVR_ATtiny85__)

   if (F_CPU == 16000000) clock_prescale_set(clock_div_1);
  #endif
  strip.begin();
  strip.show();
}

void loop()
{
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x1C, 0xFF, 0xB3);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    FadeInOut(0x36, 0xEB, 0xFF);
    Twinkle(0xff, 40, 99, 10, 50, false);
    Twinkle(0xff, 40, 99, 10, 50, false);
    TwinkleRandom(20, 100, false);
    TwinkleRandom(20, 100, false);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xff, 0xff, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
    Strobe(0xff, 0xAB, 0xf9, 10, 50, 1000);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ソースコードはこの解説を書くのにちょっと疲れちゃったので光る大五郎のコードをセルフコピペしました。同じプログラムで光ります。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;書き込むときの注意ポイント&#34;&gt;書き込むときの注意ポイント&lt;/h4&gt;

&lt;p&gt;PCにDigisparkを差し込まない状態で、ArduinoIDEで「→（マイコンボードに書き込み）」をクリック
以下のメッセージが表示されたらPCにDigisparkを差し込む
&lt;img src=&#34;https://dotstud.io/img/blog/129/ide1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下記のメッセージが表示されたら書き込み完了！
&lt;img src=&#34;https://dotstud.io/img/blog/129/ide2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;※うまく書き込みができないときには、「Digispark 互換 Windows10(またはMacとか自分の使ってるPCのOS)」のワードとかで検索するといいよ&lt;/p&gt;

&lt;h2 id=&#34;カセットテープとled配線を合体して組み立てよう&#34;&gt;カセットテープとLED配線を合体して組み立てよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/11.png&#34; alt=&#34;&#34; /&gt;
写真のように、配線用に穴をあけたほうのカセットテープ部品にLEDテープを貼ります。
カセットテープの元々の部品を組み込んで、ねじを締めてケースを閉じます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/12.png&#34; alt=&#34;&#34; /&gt;
後ろの配線はフィーリングでまとめて、真ん中の穴にインシロックを通して9V電池を固定します。電池の裏側とDigisparkの裏側に両面テープを貼っておくと、&lt;strong&gt;フェスでテンションが上がりすぎて激しく動いても部品が落ちません&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;LEDの電源を入れるときには、9V電池のスナップをつけて消したいときには外します。
つまり、スナップのつけ外し以外に特にスイッチはありません。&lt;/p&gt;

&lt;p&gt;光り方のプログラムによって、電池の消費量は変わります。
今回のプログラムだとだいたい連続使用で３時間程度で電池がなくなる感じです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/13.png&#34; alt=&#34;&#34; /&gt;
ピンバイスで開けた穴に、無理やりリングを通して好きなひもやストラップをつければ完成です！
やったね！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/129/14.png&#34; alt=&#34;&#34; /&gt;
この光るカセットテープ、ギャル電は&lt;strong&gt;無人島フェスやULTRAJAPANで実際に使ってみたけどやっぱめっちゃモテた&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;光るとめっちゃ楽しいから、みんなも作っていろんなところに遊びに行ってみてね☆&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.jsとNefry BTで監視システムを作ろう！ for Pepper #iotlt</title>
      <link>https://dotstud.io/blog/nefrybt-pepper-monitoring-system/</link>
      <pubDate>Thu, 21 Sep 2017 18:40:38 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefrybt-pepper-monitoring-system/</guid>
      
      <description>

&lt;p&gt;こんにちは、のびすけです。&lt;/p&gt;

&lt;p&gt;IoTLT vol31で話をしたNefry BT（ESP32系ボード）を使ってネットワークカメラを作ってみたいと思います。&lt;/p&gt;

&lt;p&gt;発表資料もご参照ください。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;a4d673e00b57428ebe22543efda38f6f&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/n0bisuke/pepperlian-xi-falsejian-shi-sisutemu-number-iotlt&#34;&gt;Pepper連携の監視システム? #iotlt by n0bisuke&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstudio.connpass.com/event/61189/&#34;&gt;Nefry BTのハンズオン&lt;/a&gt;も開催しますので合わせてご覧ください。&lt;/p&gt;

&lt;h2 id=&#34;やりたいこと&#34;&gt;やりたいこと&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Pepperを監視したい。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;謎ですが、Pepperを監視したいです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://iotlt.connpass.com/event/65379/&#34;&gt;IoTLT vol31&lt;/a&gt;で話をした内容ですが、Pepperが動いてくれないので、Pepperがいつ動き出しても大丈夫なように&lt;strong&gt;Pepperを見守り&lt;/strong&gt;します。&lt;/p&gt;

&lt;p&gt;巷では「Pepperが見守り」だったり、「Pepperが防犯」みたいな先進的な取り組みがありますが、僕は&lt;strong&gt;あえてPepperを見守ります。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;完成イメージ&#34;&gt;完成イメージ&lt;/h2&gt;

&lt;p&gt;こんな感じで見守ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/c3fa7c7bb7dbdd5bba505e7a3de3b54b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そして、外からでもブラウザでPepperを見守るストリーミングサービスっぽいものを作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/09e912583e26710a13f0d49f4a866b55.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;使うもの&#34;&gt;使うもの&lt;/h2&gt;

&lt;p&gt;デバイスはNefry BTとGroveカメラの二つです。
（ちょっとジャンパワイヤ使います。）&lt;/p&gt;

&lt;h3 id=&#34;nefry-bt&#34;&gt;Nefry BT&lt;/h3&gt;

&lt;p&gt;ESP32ベースのArduino互換開発ボードです。
&lt;a href=&#34;http://sengoku.co.jp/mod/sgk_cart/detail.php?code=EEHD-55W8&#34;&gt;千石電商さん&lt;/a&gt;でも購入できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/d43d9926b0e5293b1045890bdd7fbc6c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;grove-シリアルカメラキット&#34;&gt;Grove シリアルカメラキット&lt;/h3&gt;

&lt;p&gt;Grove対応のカメラです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/1626/&#34;&gt;スイッチサイエンスさん&lt;/a&gt;などで購入できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/99ad24d2ffcfd62c8407d7db7fb753c5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;構成イメージ&#34;&gt;構成イメージ&lt;/h2&gt;

&lt;p&gt;カメラで撮影した画像をNefry BT経由でサーバーにアップロードします。
アップロードされた画像はNode.jsで立てたサーバーで受け取り、WebSocket(Socket.io)でブラウザに配信します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/bfdd4f3e37898144268c2edd086320dc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;p&gt;3つに分けて紹介します。&lt;/p&gt;

&lt;p&gt;デバイス（Nefry BT）で撮影した画像をサーバーに送りサーバーからブラウザに配信します。&lt;/p&gt;

&lt;p&gt;データの流れ的に&lt;code&gt;デバイス -&amp;gt; サーバー -&amp;gt; ブラウザ&lt;/code&gt;という流れです。&lt;/p&gt;

&lt;p&gt;全体のコードは&lt;a href=&#34;https://github.com/dotstudio/nefrybt_camera_server&#34;&gt;こちらのGitHubリポジトリ&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h3 id=&#34;デバイス側-arduino&#34;&gt;デバイス側 - Arduino&lt;/h3&gt;

&lt;p&gt;デバイス側は&lt;a href=&#34;http://wiki.seeed.cc/Grove-Serial_Camera_Kit/&#34;&gt;Grove - Serial Camera Kitの公式Wiki&lt;/a&gt;にあるサンプルコードをもとに作っています。&lt;/p&gt;

&lt;p&gt;dotstudioの&lt;a href=&#34;https://dotstud.io/members/ukkz/&#34;&gt;ものづくりアーティストうこ&lt;/a&gt;さんがメインで作ってくれました。&lt;/p&gt;

&lt;p&gt;少し長いので&lt;a href=&#34;https://github.com/dotstudio/nefrybt_camera_server/blob/master/nefry/nefrybt_grove_camera/nefrybt_grove_camera.ino&#34;&gt;GitHubのリポジトリ&lt;/a&gt;を参照しましょう。&lt;/p&gt;

&lt;p&gt;このプログラムをNefry BTに書き込みましょう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;host&lt;/code&gt;の箇所に画像アップロード先のサーバーを指定します。&lt;/p&gt;

&lt;h4 id=&#34;配線&#34;&gt;配線&lt;/h4&gt;

&lt;p&gt;配線はD3,D4に繋ぎます。&lt;/p&gt;

&lt;p&gt;プログラム的には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define SEREAL_RX 19 //Nefry BT D3
#define SEREAL_TX 18 //Nefry BT D4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;の部分が該当します。NefryBTの&lt;a href=&#34;https://drive.google.com/file/d/0B_mvDQF8yaQRLVprUHl4WTFLWVE/view&#34;&gt;仕様書&lt;/a&gt;を見ると分かりますが、ESP32のGPIO 19番がNefryBTのD3にあたり、18番がD4になります。&lt;/p&gt;

&lt;h3 id=&#34;サーバー側-node-js&#34;&gt;サーバー側 - Node.js&lt;/h3&gt;

&lt;p&gt;Node.jsで画像を受信するサーバーを作ります。&lt;/p&gt;

&lt;p&gt;無難にSocket.ioとexpressを使います。 Node.jsのバージョンは8.4です。
7系以前だと動かない可能性があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i --save socket.io express
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//server.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const app = require(&#39;express&#39;)();
const http = require(&#39;http&#39;).Server(app);
const io = require(&#39;socket.io&#39;)(http);
const express = require(&#39;express&#39;);
const PORT = process.env.PORT || 3000;
app.use(express.static(__dirname));

const {promisify} = require(&#39;util&#39;);
const writeFileAsync = promisify(fs.writeFile);

io.on(&#39;connection&#39;, (socket) =&amp;gt; console.log(&#39;a user connected&#39;)); //socket.ioのコネクション

app.get(&#39;/&#39;, (req, res) =&amp;gt; res.sendFile(&#39;./index.thml&#39;));
app.post(&#39;/&#39;, (req, res) =&amp;gt; {
    let buffers = [];
    let cur = 0;
    const len = parseInt(req.headers[&#39;content-length&#39;], 10);

    req.on(&#39;data&#39;, (chunk) =&amp;gt; {
        buffers.push(chunk);
        cur += chunk.length;
        console.log(`Downloading...${(100.0 * cur / len).toFixed(2)}%`);
    });

    req.on(&#39;end&#39;, async () =&amp;gt; {
        console.log(`\n[done] Image upload`);
        req.rawBody = Buffer.concat(buffers);
        const base64image = req.rawBody.toString(&#39;base64&#39;); //base64変換
        await writeFileAsync(&#39;./img.jpeg&#39;, req.rawBody, &#39;utf-8&#39;)
        console.log(`[done] Image Save`);
        io.sockets.emit(&#39;new image&#39;,base64image); //画像送信
    });

});

http.listen(PORT, () =&amp;gt; console.log(`listening on *:${PORT}`));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常Expressを使う際に&lt;a href=&#34;https://github.com/expressjs/body-parser&#34;&gt;body-parser&lt;/a&gt;をよく使いますが、今回はあえて使わずに、&lt;code&gt;dataイベント&lt;/code&gt;で&lt;code&gt;chunk&lt;/code&gt;を拾って画像アップロードのプログレス表示を実装しています。&lt;/p&gt;

&lt;p&gt;Nefry BTも含めてこういったマイコンボードはスマートフォンやPCに比べるとCPUパワーが弱いため、画像アップロードに時間がかかることがあります。&lt;/p&gt;

&lt;p&gt;サーバー側でどれくらいのデータ送信が完了しているのかの進捗が分かると安心して開発できます。
画像を受信したら&lt;code&gt;toString(&#39;base64&#39;)&lt;/code&gt;でBase64の文字列に変換をしています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.sockets.emit()&lt;/code&gt;の箇所では変換した文字列をSocket.io経由でブラウザに配信しています。&lt;/p&gt;

&lt;h3 id=&#34;ブラウザ側-javascript&#34;&gt;ブラウザ側 - JavaScript&lt;/h3&gt;

&lt;p&gt;ブラウザ側では、文字列で送られた画像データを受け取り、Canvasに流し込みます。
HTML側では&lt;code&gt;id=&amp;quot;myCanvas&amp;quot;&lt;/code&gt;のcanvasを作り、&lt;code&gt;socket.io&lt;/code&gt;の読み込みと以下で作る&lt;code&gt;app.js&lt;/code&gt;の読み込みをします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Nefry BT Camera&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body style=&amp;quot;background-color:#D0D0D0;&amp;quot;&amp;gt;
    &amp;lt;canvas id=&amp;quot;myCanvas&amp;quot; width=&amp;quot;640&amp;quot; height=&amp;quot;480&amp;quot; style=&amp;quot;background-color:#FFFFFF;&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;script src=&amp;quot;/socket.io/socket.io.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;/public/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;draw()&lt;/code&gt;では、canvasに&lt;code&gt;drawImage()&lt;/code&gt;で画像を描画します。
Base64の場合はsrcが画像パスではなく&lt;code&gt;data:image/jpeg;base64,~~~~~&lt;/code&gt;という指定方法です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /public/app.js
&#39;use strict&#39;;

const socket = io();

const draw = (imageData = &#39;&#39;) =&amp;gt; {
    const canvas = document.getElementById(&#39;myCanvas&#39;);
    const ctx = canvas.getContext(&#39;2d&#39;);
    const img = new Image();
    img.src = `data:image/jpeg;base64,${imageData}`; //基本base64の文字列
    if(imageData === &#39;init&#39;) img.src = `./img.jpeg`; //初期実行時のみサーバーのimg.jpegを取得
    img.onload = () =&amp;gt; {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0, 640, 480);
    }
    console.log(`update ${new Date()}`);
}

socket.on(&#39;new image&#39;, draw); //画像更新時
draw(&#39;init&#39;); //初期実行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;socket.on(&#39;new image&#39;, draw)&lt;/code&gt;でサーバーからデータが送られてくるたびに&lt;code&gt;draw()&lt;/code&gt;を実行します。&lt;/p&gt;

&lt;h2 id=&#34;使ってみた感想&#34;&gt;使ってみた感想&lt;/h2&gt;

&lt;p&gt;1週間ほど動かしていますが、問題なくずっと稼働写真を送り続けてくれるので意外と&lt;strong&gt;ラズパイなどで作るシステムより安定しているかも&lt;/strong&gt;しれません。&lt;/p&gt;

&lt;p&gt;あと、発表のオチだったのですが、Pepperの調子が悪く被写体が動かないので成功してるのか分かりにくいです苦笑&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/b2fb0a60f31c12e61e99b51d442dd563.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTとNode.jsを使ってネットワークカメラを作ることができました。&lt;/p&gt;

&lt;p&gt;GroveのカメラとNefry V2を使って過去に&lt;a href=&#34;https://am-our.com/love/110/13945/&#34;&gt;【大島薫×IoT】浮気男を社会的に制裁するマシーンを作ってみた&lt;/a&gt;こともありましたが、ネットワークカメラを作りたい需要はそこそこあると思うので、その際の参考になれば幸いです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>日本上陸！littleBits cloudBitモジュールでIFTTT連携してみた！</title>
      <link>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</link>
      <pubDate>Tue, 22 Aug 2017 19:43:42 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</guid>
      
      <description>

&lt;p&gt;littleBits cloudBitモジュールの技適が通りまして、ついに日本でも使えることになったということで、早速littleBits cloudBitモジュールを購入してIFTTTと連携してみました。
&lt;img src=&#34;https://dotstud.io/img/blog/119/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;littlebits-cloudbitモジュールとは&#34;&gt;littleBits cloudBitモジュールとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/2.png&#34; alt=&#34;&#34; /&gt;
littleBits cloudBitモジュールは、磁石でつなげて簡単に電子工作ができる知育ブロックlittleBitsのモジュールのひとつ、littleBits Cloudが橋渡しとなってインターネットとやり取りできるモジュールです。&lt;/p&gt;

&lt;p&gt;詳しくはこちら → &lt;a href=&#34;https://littlebits.cc/cloudstart&#34;&gt;Getting Started with your CloudBit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/3.png&#34; alt=&#34;&#34; /&gt;
橋渡しとなるlittleBits Cloudは、スマートフォンやPCからWEBアクセスできる CLOUD CONTROL APP や、LITTLEBITS APIによってREST APIでさらに深いところまで操作できるプログラミングできるLITTLEBITS APIといった入り口があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/4.png&#34; alt=&#34;&#34; /&gt;
今回ご紹介するのは、もうひとつ。ノンプログラミングでインターネットのいろいろなことに接続できる&lt;a href=&#34;https://ifttt.com/login&#34;&gt;IFTTT&lt;/a&gt;とlittleBitsの連携についてお伝えします。&lt;/p&gt;

&lt;p&gt;たとえば、littleBitsモジュールでボタンを押すとメールが送られたり、SNSでいいねが押されるとlittleBitsのLEDが反応するようなIoTの仕組みをさっと作ることができます。&lt;/p&gt;

&lt;h2 id=&#34;今回の仕組み&#34;&gt;今回の仕組み&lt;/h2&gt;

&lt;p&gt;今回の仕組みはGitHubでissueが上がるとBARGRAPH LEDが点灯する仕組みです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/5.png&#34; alt=&#34;&#34; /&gt;
ですが、ただBARGRAPH LEDが光るだけだと見落としてしまうので、100円ショップで買った光で動くソーラーゆらゆら（がいこつ）にLEDを照らして動かしてよりわかりやすくします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/6.png&#34; alt=&#34;&#34; /&gt;
このような仕組みです。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;littlebitsの準備&#34;&gt;littleBitsの準備&lt;/h3&gt;

&lt;p&gt;セットアップについてはすでに行われているものとします。&lt;a href=&#34;http://www.1ft-seabass.jp/memo/2017/08/09/cloudbit-setup-step-memo/&#34;&gt;cloudBitモジュールのセットアップについてのメモ&lt;/a&gt;についてもご参考下さい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/7.png&#34; alt=&#34;&#34; /&gt;
CLOUDBITパッケージに入っているものはcloudBitモジュール関連だけなので、別途写真のようにlittleBitから入力させるボタンモジュールや、出力を反応させるBARGRAPHモジュールは別途揃えておきましょう。また今回はソーラーゆらゆら（がいこつ）へうまくつなげるためにWIREモジュールも用意しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CLOUDBITパッケージにあるもの

&lt;ul&gt;
&lt;li&gt;USB power adapter ケーブル&lt;/li&gt;
&lt;li&gt;USB POWER モジュール&lt;/li&gt;
&lt;li&gt;cloudBitモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;別途必要なもの

&lt;ul&gt;
&lt;li&gt;ボタンモジュール&lt;/li&gt;
&lt;li&gt;BARGRAPHモジュール&lt;/li&gt;
&lt;li&gt;WIREモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/8.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆらを準備します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/9.png&#34; alt=&#34;&#34; /&gt;
コンセントをつないだアダプターからUSBケーブルを差し込みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/10.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュールにUSBケーブルをつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/11.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュール→ボタンモジュール→cloudBitモジュールまでつないで、接続されるまで待ちます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/12.png&#34; alt=&#34;&#34; /&gt;
つづいて、cloudBitモジュールの先にWIREモジュールとBARGRAPH LEDモジュールをつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/13.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆら（がいこつ）のソーラーパネル部分にガッとBARGRAPH LEDモジュールを当てます。マスキングテープで補強します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/14.png&#34; alt=&#34;&#34; /&gt;
これで準備完了です。&lt;/p&gt;

&lt;h3 id=&#34;cloud-control-appの準備&#34;&gt;CLOUD CONTROL APPの準備&lt;/h3&gt;

&lt;p&gt;cloudBitを管理している CLOUD CONTROL APP ページにログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iftttの準備&#34;&gt;IFTTTの準備&lt;/h3&gt;

&lt;p&gt;IFTTTもlittleBitsとの関連付けを行うのでログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こちらで準備完了です。&lt;/p&gt;

&lt;h2 id=&#34;littlebits-cloudbitモジュールとiftttの関連付け&#34;&gt;littleBits CloudBitモジュールとIFTTTの関連付け&lt;/h2&gt;

&lt;p&gt;さきほどログインしたCLOUD CONTROL APP ページでlittleBits CloudBitモジュールとIFTTTの関連付けを行います。
&lt;img src=&#34;https://dotstud.io/img/blog/119/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下部のメニューでAUTOMATEを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AUTOMATEページに遷移するとIFTTTとのアクティベートを促されるので GO TO IFTTT.COM ボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;IFTTTのlittleBitsチャンネルに遷移するので、CONNECTを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;すでにIFTTTとCLOUD CONTROL APPがログインしてあるので、アクティベート確認ページに遷移します。AUTHORIZEボタンを押して認証します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ログインが完了します。これで、IFTTTでlittleBitsと連携することができます。&lt;/p&gt;

&lt;h2 id=&#34;githubサービスのiftttでの認証をする&#34;&gt;GitHubサービスのIFTTTでの認証をする&lt;/h2&gt;

&lt;p&gt;GitHubでもIFTTTで使えるようにしておきましょう。上部のSearchからgithubを検索します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Servicesに出てきたGitHubをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/119/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubのページに移動するのでConnectボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubのAuthrize IFTTTページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Authrize IFTTTCHannelsボタンを押して認証を済ませておきます。&lt;/p&gt;

&lt;h2 id=&#34;littlebitsのifttt連携の設定&#34;&gt;littleBitsのIFTTT連携の設定&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/28.png&#34; alt=&#34;&#34; /&gt;
右上にある自分のプロフィールメニューからNew Appletを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/29.png&#34; alt=&#34;&#34; /&gt;
New Appletをつくる画面に行きます。thisボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/30.png&#34; alt=&#34;&#34; /&gt;
Choose a serviceではgitと検索しGitHubをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/31.png&#34; alt=&#34;&#34; /&gt;
今回は自分にissueが来たときに動作するようにしたいので、Any new issueをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/32.png&#34; alt=&#34;&#34; /&gt;
つづいて動作のきっかけ this が作れたので、なにが起こるかの that を設定するため that ボタンを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/33.png&#34; alt=&#34;&#34; /&gt;
Choose action service画面になるので、littleBitsと検索し、littleBitsアクションをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/34.png&#34; alt=&#34;&#34; /&gt;
Choose action画面になるので、Set Output Levelをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/35.png&#34; alt=&#34;&#34; /&gt;
Complete action fields画面になるので以下のように設定します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Which cloudBit?

&lt;ul&gt;
&lt;li&gt;動かしたいcloudBit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Level

&lt;ul&gt;
&lt;li&gt;100&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Duration

&lt;ul&gt;
&lt;li&gt;20 seconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/36.png&#34; alt=&#34;&#34; /&gt;
設定が終わったら、下の方のCreate Actionボタンを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/37.png&#34; alt=&#34;&#34; /&gt;
Review and finish画面に来るので、設定を確認します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/38.png&#34; alt=&#34;&#34; /&gt;
問題なければ、下の方のFinishボタンを押します。&lt;/p&gt;

&lt;p&gt;これで設定は完了です。&lt;/p&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;早速試しにissueをGitHubで作ってみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/119/39.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回は適当に作ってみます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/40.png&#34; alt=&#34;&#34; /&gt;
issues発行します。&lt;/p&gt;

&lt;p&gt;多少タイムラグがあるので5～10秒ほど待ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/demo.gif&#34; alt=&#34;&#34; /&gt;
無事動きました！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ということで、技適が通り日本上陸となった、littleBits cloudBitモジュールのIFTTT連携をお伝えしました。&lt;/p&gt;

&lt;p&gt;今回はIoTでも実装に手間がかかるインターネット上の反応をlittleBitsに降ろす仕組みを軸にお伝えしましたがIFTTTとlittleBits Cloudの連携は手軽に作れますね。IoTにおけるいろいろな技術要素が裏側でしっかり作られています。&lt;/p&gt;

&lt;p&gt;もちろん、IFTTTと連携するとAmazon Dash Buttonのような、ボタンを押すとツイートがされるようなlittleBitsからインターネットを動かす仕組みについても実現可能です。&lt;/p&gt;

&lt;p&gt;littleBitsの持つブロックを組み合わせて電子工作ができる手軽さに加えて、IFTTTが組み合わさることでインターネットもあたかもブロックのように扱えてるlittleBits cloudBitモジュール、ぜひ試してみてください！&lt;/p&gt;

&lt;p&gt;※今回の図表の一部では&lt;a href=&#34;http://icooon-mono.com/&#34;&gt;アイコン素材ダウンロードサイト「icooon-mono」&lt;/a&gt;さんの画像を利用いたしました。ありがとうございます。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>