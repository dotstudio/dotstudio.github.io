<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Handson on dotstudio（ドットスタジオ）</title><link>https://dotstud.io/series/handson/</link><description>Recent content in Handson on dotstudio（ドットスタジオ）</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>© 2018 dotstudio inc.</copyright><lastBuildDate>Mon, 28 Jan 2019 00:51:35 +0900</lastBuildDate><atom:link href="/series/handson/" rel="self" type="application/rss+xml"/><item><title>ArduinoでTwitter連携！愛しのぬいぐるみトンピーちゃんに命を吹き込んでみた</title><link>https://dotstud.io/blog/arduino-nodejs-twitter-connect/</link><pubDate>Mon, 28 Jan 2019 00:51:35 +0900</pubDate><guid>https://dotstud.io/blog/arduino-nodejs-twitter-connect/</guid><description>
&lt;p&gt;皆さん、大好きなぬいぐるみが動き出したらいいなと思ったこと、ありませんか？&lt;/p&gt;
&lt;p&gt;今回は私の愛すべきお友達「トンピーちゃん」に命を吹き込むべく、プログラミング初心者の私がArduinoとTwitterの連携に挑戦してみました！&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;4&#34;&gt;こちらです！！&lt;/font&gt;
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/721a8190-3ffc-8bca-c4b3-774ee58d45e9.gif&#34; alt=&#34;ezgif.com-video-to-gif.gif&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;今回やること&#34;&gt;今回やること&lt;/h2&gt;
&lt;h3 id=&#34;実装の構成&#34;&gt;実装の構成&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/a75b45dc702b385f5e32fcd3e39c5b64&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/a75b45dc702b385f5e32fcd3e39c5b64.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ざっくりの構成です。Node.jsでTwitterの「#tonpy」というハッシュタグを監視し、「move #tonpy」「stop #tonpy」というツイートがあったらArduinoを経由してトンピーちゃんが動いたり止まったりします。&lt;/p&gt;
&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;
&lt;h4 id=&#34;こぐまのトンピーちゃん&#34;&gt;■こぐまのトンピーちゃん&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/210df088-f5f0-6f8a-e9ee-2a63f06e2364.jpeg&#34; alt=&#34;トンピー.jpg&#34; /&gt;
愛用のトンピーちゃんです。乾電池を入れるとピーヒャラドンドンします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;購入: &lt;a href=&#34;https://www.amazon.co.jp/%E3%82%A4%E3%83%AF%E3%83%A4-%E3%81%93%E3%81%90%E3%81%BE%E3%81%AE%E3%83%88%E3%83%B3%E3%83%94%E3%83%BC/dp/B0002U3OBA&#34;&gt;Amazon.co.jp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arduino-uno&#34;&gt;■Arduino Uno&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/c26d230d-e320-b73d-f15f-32d813e1294f.jpeg&#34; alt=&#34;Arduino Uno.jpg&#34; /&gt;
Arduino Unoは2010年に発売されたArduinoで、&lt;a href=&#34;https://store.arduino.cc/usa/arduino-uno-rev3&#34;&gt;Arduinoの公式サイト&lt;/a&gt;にも「&lt;strong&gt;電子工作初心者に最適&lt;/strong&gt;」と書いてあったのでこちらに決めました。&lt;/p&gt;
&lt;p&gt;購入にあたっては「Arduino 初心者」と調べヒットした「&lt;a href=&#34;https://www.amazon.co.jp/%E3%82%B9%E3%82%A4%E3%83%83%E3%83%81%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9-SSCI-GettingStartedArduinoKit-Arduino%E3%82%92%E3%81%AF%E3%81%98%E3%82%81%E3%82%88%E3%81%86%E3%82%AD%E3%83%83%E3%83%88/dp/B0025Y6C5G/ref=sr_1_fkmr1_2?ie=UTF8&amp;amp;qid=1544321570&amp;amp;sr=8-2-fkmr1&amp;amp;keywords=arduino+%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%82%AD%E3%83%83%E3%83%88&#34;&gt;Arduinoをはじめようキット&lt;/a&gt;」を購入しました。&lt;/p&gt;
&lt;p&gt;&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/d7099cb0-97aa-8ff1-4e3d-b959e8139fb4.jpeg&#34;&gt;
─ Arduinoをはじめようキット
&lt;/center&gt;
Arduino Unoの他にブレッドボードや抵抗など電子工作を始めるにあたり必要なもの一式が揃っているため、すぐに始める事ができます。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;fet-pch-mosfet-2sjs527l-e-60v5a&#34;&gt;■FET（Pch MOSFET 2SJS527L-E 60V5A）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/88510174-eed9-e286-5343-3deeb08a7884.jpeg&#34; alt=&#34;I-08315.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;FETはロードスイッチとも呼ばれ、簡単にいうと外部からの電圧によって電流の流れを制御できるスイッチのようなもののようです。小さな電力で動作させる事ができます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/#回路を作成&#34;&gt;回路を作成&lt;/a&gt;で説明しますが、FETには「Pチャネル」と「Nチャネル」の2種類あります。今回はNチャネルのFETを利用します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;購入: &lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-07145/&#34;&gt;秋月電子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;node-jsをインストールしたpc&#34;&gt;■Node.jsをインストールしたPC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/efcdf34b-504e-cc68-125a-0acadd815510.jpeg&#34; alt=&#34;IMG_9204.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;今回はNode.jsでプログラムを動かします。下記記事を参考にインストールしてみてください！&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;136&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/nodejs-install-use-nodebrew/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/136/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.jsを始めよう！nodebrewを使って5分で環境構築
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-12-15
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
nodebrewを使ったNode.jsのインストール方法をまとめました。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;ul&gt;
&lt;li&gt;筆者PC: mac OS HighSierra バージョン10.13.6&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Node.js: v10.10.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;その他&#34;&gt;■その他&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/eb369434-a5ff-e44a-c7b9-02a065030098.jpeg&#34; alt=&#34;IMG_9206.jpg&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/docs/breadboard/&#34;&gt;ブレッドボード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/docs/jumperwire/#%E3%83%9F%E3%83%8E%E3%83%A0%E3%82%B7%E3%82%AF%E3%83%AA%E3%83%83%E3%83%97-%E3%83%AF%E3%83%8B%E5%8F%A3&#34;&gt;ワニ口クリップ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;抵抗（今回は220Ω）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;トンピーちゃんを解体&#34;&gt;トンピーちゃんを解体&lt;/h2&gt;
&lt;p&gt;まずはトンピーちゃんの導線を確認するため、少し解体します。
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/69ccd688-afb6-0715-124a-44d886fe3178.jpeg&#34; alt=&#34;IMG_6786.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/84c4fcd7-8c65-a0dc-1a84-ee75b5c2ef48.jpeg&#34; alt=&#34;IMG_9205.jpg&#34; /&gt;
電池の部分を取り外してみました。すると、導線は電池部分と本体でパックリ分かれている事が確認できました。今回はその部分にArduino Unoを繋げば回路の開/閉が制御できそうですね。&lt;/p&gt;
&lt;h2 id=&#34;arduino-unoとトンピーちゃんを連携&#34;&gt;Arduino Unoとトンピーちゃんを連携&lt;/h2&gt;
&lt;h3 id=&#34;回路を作成&#34;&gt;回路を作成&lt;/h3&gt;
&lt;p&gt;Arduino Unoから直接ON/OFFを制御しようとすると、電流が少なく回路を開/閉できませんでした。そこでArduino Unoとトンピーちゃんの間に&lt;strong&gt;FETを挿入&lt;/strong&gt;します。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/230/fet.png&#34; alt=&#34;fet&#34;&gt;
&lt;/center&gt;
&lt;p&gt;FETは、電圧の加え方の違いによって「Pチャネル」と「Nチャネル」の2種類に分かれます。今回はNチャネルのFETを利用します。&lt;/p&gt;
&lt;p&gt;また、回路の「+側」にFETを繋ぐことを「ハイサイド（スイッチ）」、-側に繋ぐことを「ローサイド（スイッチ）」と呼称します。今回はNチャネルなので、ローサイドにFETを繋ぎます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/d32c3f6f4b1de908ceced242cc2ba7f4.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最終的に上記のような回路図になりました。&lt;/p&gt;
&lt;h3 id=&#34;arduino-unoにプログラムを書き込む&#34;&gt;Arduino Unoにプログラムを書き込む&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/b544f541-a5ac-ee97-18a3-de3963210c92.png&#34; alt=&#34;スクリーンショット 2018-12-18 12.35.58.png&#34; /&gt;
ArduinoをUSBケーブルでPCに繋ぎ、アプリケーションでArduino IDEを開きます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/da16043a-121e-52e2-e395-3121a8a3e48f.png&#34; alt=&#34;スクリーンショット 2018-12-16 15.10.09.png&#34; /&gt;
ファイル→新規ファイルを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/2a42d894-497d-a0c4-5573-6a4c148fc5fe.png&#34; alt=&#34;スクリーンショット 2018-12-16 15.09.45.png&#34; /&gt;
ツール→ボード→繋いだArduino（今回はArduino Uno）を選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/9f5d63e2-454b-c637-ef5d-07550cccf8d5.png&#34; alt=&#34;スクリーンショット 2018-12-16 15.11.33.png&#34; /&gt;
ツール→シリアルポート→接続したArduinoを選択します。&lt;/p&gt;
&lt;p&gt;下記コードを新規ファイルにコピー&amp;amp;ペーストします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// pins
const int tonpyPin = 2;
void setup() {
// initialize serial:
Serial.begin(9600);
// make the pins outputs:
pinMode(tonpyPin, OUTPUT);
}
void loop() {
// if there&#39;s any serial available, read it:
while (Serial.available() &amp;gt; 0) {
char value = Serial.read();
if (value == &#39;p&#39;) {
digitalWrite(tonpyPin, HIGH);
} else if (value == &#39;q&#39;){
digitalWrite(tonpyPin, LOW);
} else{
digitalWrite(tonpyPin, LOW);
}
Serial.println(value);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/8ec32eee-c610-137c-febd-9408f22db6e1.png&#34; alt=&#34;スクリーンショット 2018-12-10 9.25.26.png&#34; /&gt;
左上にある「→」ボタンを押してマイコンボードに書き込みます。&lt;/p&gt;
&lt;p&gt;これでArduino Unoからの信号（p: スイッチON、q: スイッチOFF）でトンピーちゃんが動く/止まるようになりました。&lt;/p&gt;
&lt;p&gt;これをツイートと連動できれば完成です！&lt;/p&gt;
&lt;h2 id=&#34;node-jsのプログラム&#34;&gt;Node.jsのプログラム&lt;/h2&gt;
&lt;p&gt;ハッシュタグ「#tonpy」を取得し、さらに「move」「stop」のツイートがあったらArduino Unoに送るプログラムを作成します。&lt;/p&gt;
&lt;h3 id=&#34;twitter-apiの準備&#34;&gt;Twitter APIの準備&lt;/h3&gt;
&lt;p&gt;API使用には&lt;a href=&#34;https://developer.twitter.com/&#34;&gt;Twitter Developer&lt;/a&gt;へ登録する必要があります。登録の際、用途など英文で書く部分がありました（筆者はGoogle翻訳を駆使しました）。&lt;/p&gt;
&lt;p&gt;手順については下記の記事に詳しく書かれており、そちらに沿って登録しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/kngsym2018/items/2524d21455aac111cdee&#34;&gt;Twitter API 登録 (アカウント申請方法) から承認されるまでの手順まとめ　※2018年9月時点の情報&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tweetを取得するnode-jsのプログラムを作成&#34;&gt;Tweetを取得するNode.jsのプログラムを作成&lt;/h3&gt;
&lt;h4 id=&#34;ディレクトリを用意&#34;&gt;■ディレクトリを用意&lt;/h4&gt;
&lt;p&gt;任意の保存場所にフォルダを用意します。今回はDesktopにTonpyフォルダを作りました。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;jsファイルを作成&#34;&gt;■JSファイルを作成&lt;/h4&gt;
&lt;p&gt;作成したフォルダに任意の名前のJSファイルを用意します。今回は「app.js」としました。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;twitter-apiを使用するモジュールのインストール&#34;&gt;■Twitter APIを使用するモジュールのインストール&lt;/h4&gt;
&lt;p&gt;Node.jsでTwitter APIが使用できるよう&lt;a href=&#34;https://www.npmjs.com/package/twitter&#34;&gt;Twitterモジュール&lt;/a&gt;をnpmでインストールします。ターミナルで作成したフォルダを開き、下記コマンドを叩きます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install twitter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでNode.jsでTwitter APIが使用できるようになりました。&lt;/p&gt;
&lt;p&gt;実際に使用する際はJSファイル内で最初に下記のように書くとTwitter APIが呼び出されます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Twitter = require(&#39;twitter&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;ツイートを取得するプログラムを作成&#34;&gt;■ツイートを取得するプログラムを作成&lt;/h4&gt;
&lt;p&gt;TwitterAPIには「REST API」と「Streaming API」の2種類があります。&lt;/p&gt;
&lt;p&gt;REST APIはエンドポイントへリクエストして初めて結果が得られるものに対して、Streaming APIはレートのリミットなくツイートを受信し続ける事ができます。&lt;/p&gt;
&lt;p&gt;今回はツイートを常に監視し該当のツイートがあったら結果を取得する、という事がしたいので&lt;strong&gt;Streaming API&lt;/strong&gt;を使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const twitter = require(&amp;quot;twitter&amp;quot;);
const fs = require(&amp;quot;fs&amp;quot;);
const client = new twitter({
consumer_key: &#39;&#39;,//Dev Accountで取得したkeyを書く
consumer_secret: &#39;&#39;,
access_token_key: &#39;&#39;,
access_token_secret: &#39;&#39;,
});
let tweetText =&#39;w&#39;;
client.stream(&#39;statuses/filter&#39;, {track:&amp;quot;#tonpy &amp;quot;}, (stream) =&amp;gt; {//Streaming APIを呼び出す
stream.on(&#39;data&#39;, (tweet) =&amp;gt; {
tweetText = tweet.text;
(~tweetText.indexOf(&#39;move&#39;)) ? (tweetText = &#39;p&#39;) : (~tweetText.indexOf(&#39;stop&#39;)) ? (tweetText = &#39;q&#39;) : (tweetText = &#39;w&#39;);
});
stream.on(&#39;error&#39;, (error) =&amp;gt; {//エラー
console.error(`Error: ${error.message}`);
stream.destroy();
});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ツイートを取得するNode.jsのプログラムが完成しました。&lt;/p&gt;
&lt;h3 id=&#34;arduinoに送るプログラムを作成&#34;&gt;Arduinoに送るプログラムを作成&lt;/h3&gt;
&lt;h4 id=&#34;シリアル通信をするモジュールのインストール&#34;&gt;■シリアル通信をするモジュールのインストール&lt;/h4&gt;
&lt;p&gt;PCとArduino間でシリアル通信をするために、シリアルポートでシリアル通信を行うモジュールもnpmでインストールします。&lt;/p&gt;
&lt;p&gt;シリアルポートとは&lt;strong&gt;シリアル通信を行う時の接続口&lt;/strong&gt;のことで、今回はArduinoと接続したPCのUSBポートにあたります。&lt;/p&gt;
&lt;p&gt;ターミナルで下記コマンドを叩きます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install serialport
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでNode.jsでシリアルポートを制御できるようになりました。&lt;/p&gt;
&lt;p&gt;使用する際はJSファイル内で最初に下記のように呼び出します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Serialport = require(&#39;serialport&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;シリアルポートの名前を調べる&#34;&gt;■シリアルポートの名前を調べる&lt;/h4&gt;
&lt;p&gt;プログラム内では、USBポートに挿しているArduino Uno（ttyデバイス）を指定します。&lt;/p&gt;
&lt;p&gt;ターミナルで下記コマンドを打ち、PCのシリアルポートに接続されている機器を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls -l /dev/tty.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Auduino Unoを挿し、もう一度先ほどのコマンドを打ちます。新しく出てきたttyデバイス名がArduino Unoです。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arduino-unoに送るnode-jsのプログラムを作成&#34;&gt;■ Arduino Unoに送るNode.jsのプログラムを作成&lt;/h4&gt;
&lt;p&gt;下記がシリアル通信するためのコードです。ツイートを取得するためのJSファイルの続きに記述してください。&lt;/p&gt;
&lt;p&gt;1行目の&lt;code&gt;/dev/tty.xxx&lt;/code&gt;には上記のシリアルポート名を記入してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const port = new SerialPort(&#39;/dev/tty.xxx&#39;,{
baudRate: 9600//baudRate:9600は1秒に最大9600ビットを送信するという意味
});
port.write(&#39;main screen turn on&#39;, function(err) {
if (err) {
return console.log(&#39;Error on write: &#39;, err.message);
}
console.log(&#39;message written&#39;);
});
port.on(&#39;open&#39;, () =&amp;gt; {
console.log(&#39;Serial open.&#39;);
setInterval(write, 1000);
});
const write = () =&amp;gt; {
console.log(`Input to Arduino: ${tweetText}`);
port.write(tweetText, (error) =&amp;gt; {
if(error) {
console.error(`Error: ${error.message}`);
}
});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでツイート情報を取得し、Arduinoに信号を送る事ができるようになりました。&lt;/p&gt;
&lt;h3 id=&#34;完成コード&#34;&gt;完成コード&lt;/h3&gt;
&lt;p&gt;ツイートを取得するプログラム、Arduinoを制御するプログラムを合わせた完成コードは下記のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//-----------------------------------------------
// twitterからツイートを取得
//-----------------------------------------------
const twitter = require(&amp;quot;twitter&amp;quot;);
const client = new twitter({
consumer_key: &#39;&#39;,//Dev Accountで取得したkeyを書く
consumer_secret: &#39;&#39;,
access_token_key: &#39;&#39;,
access_token_secret: &#39;&#39;,
});
let tweetText =&#39;w&#39;;
client.stream(&#39;statuses/filter&#39;, {track:&amp;quot;#tonpy &amp;quot;}, (stream) =&amp;gt; {
stream.on(&#39;data&#39;, (tweet) =&amp;gt; {
tweetText = tweet.text;
(~tweetText.indexOf(&#39;move&#39;)) ? (tweetText = &#39;p&#39;) : (~tweetText.indexOf(&#39;stop&#39;)) ? (tweetText = &#39;q&#39;) : (tweetText = &#39;w&#39;);
});
stream.on(&#39;error&#39;, (error) =&amp;gt; {
console.error(`Error: ${error.message}`);
stream.destroy();
});
});
//-----------------------------------------------
// Node.jsからArduinoに送信
//----------------------------------------------
const SerialPort = require(&#39;serialport&#39;);
const port = new SerialPort(&#39;/dev/tty.xxx&#39;,{
baudRate: 9600
});
port.on(&#39;open&#39;, () =&amp;gt; {
console.log(&#39;Serial open.&#39;);
setInterval(write, 1000);
});
port.on(&#39;data&#39;, (data) =&amp;gt; {
console.log(`Data from Arduino: ${data}`);
});
const write = () =&amp;gt; {
console.log(`Input to Arduino: ${tweetText}`);
port.write(tweetText, (error) =&amp;gt; {
if(error) {
console.error(`Error: ${error.message}`);
}
});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;node-jsを実行する&#34;&gt;■Node.jsを実行する&lt;/h4&gt;
&lt;p&gt;Node.jsは、ファイルのある場所で下記コマンドで実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;部分は、ご自身が作成したファイル名に置き換えてください。「Serial open」がターミナル上に表示されたら無事実行されています。&lt;/p&gt;
&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;
&lt;p&gt;Node.jsを起動しながら、ツイートしてみましょう……。「&lt;strong&gt;#tonpy move&lt;/strong&gt;」!!!!!
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/9c8c2611-d9b2-e7dd-3710-8d2011c2b424.gif&#34; alt=&#34;ezgif.com-video-to-gif.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;う、動いたーーーー！！！（少々タイムラグがありますが……。）&lt;/p&gt;
&lt;p&gt;初めてのIoTとっっても楽しかったです！電子工作やNode.jsの勉強にもなり一石二鳥ですね。&lt;/p&gt;
&lt;p&gt;これから色々作っていきたいです！&lt;/p&gt;
&lt;style&gt;
.caution {
border: 1px solid #BFBFBF;
padding: 1em 2em;
margin: 2em 0;
color: #474747;
background: whitesmoke;/*背景色*/
border-left: double 7px #0B0B61;/*左線*/
font-size: 90%;
}
.caution &gt; p {
font-weight: bold;
margin: 0 0 10px 0;
padding: 0;
}
blockquote {
font-size:80%;
}
.accbox {
margin: 2em 0;
padding: 0;
max-width: 710px;
}
.accbox label {
display: block;
margin: 1.5px 0;
padding : 11px 12px;
color :#ffffff;
font-weight: bold;
background :#2f2f2f;
cursor :pointer;
transition: all 0.5s;
}
.accbox label:hover {
background :#A4A4A4;
}
.accbox input {
display: none;
}
.accbox .accshow {
height: 0;
padding: 0;
overflow: hidden;
opacity: 0;
transition: 0.8s;
}
.cssacc:checked + .accshow {
height: auto;
padding: 5px;
background: #eaeaea;
opacity: 1;
}
&lt;/style&gt;</description></item><item><title>【ハンズオン資料】GR-LYCHEEとOpenCVで画像認識やってみよう</title><link>https://dotstud.io/blog/gr-lychee-opencv-handson/</link><pubDate>Thu, 13 Dec 2018 05:17:31 +0900</pubDate><guid>https://dotstud.io/blog/gr-lychee-opencv-handson/</guid><description>
&lt;p&gt;この記事は12/07の&lt;a href=&#34;https://ai-iot-bol-fukui.connpass.com/event/109573/&#34;&gt;AI×IoT ハンズオン with IoTLT&amp;amp;ふくもく会 in 福井&lt;/a&gt;向け資料です。記事を読んで試せる内容になっているので、終了後や参加されていない方もぜひ試してみてください！&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■ハンズオンの進行について&lt;/p&gt;
ハンズオンはこのページに沿って進めます。進められる方は、どんどん進めていきましょう！リンクは別タブや別ウィンドウで開くのがオススメです。
&lt;/section&gt;
&lt;p&gt;この記事はがじぇっとるねさすさんの「&lt;a href=&#34;http://gadget.renesas.com/ja/product/e-ai/mnist_tutorial.html&#34;&gt;e-AIトランスレータ チュートリアル GRボードで実行してみよう！&lt;/a&gt;」を参考に作成しています。&lt;/p&gt;
&lt;h2 id=&#34;今回やってみること&#34;&gt;今回やってみること&lt;/h2&gt;
&lt;p&gt;PythonとTensorflow、数字認識のデータライブラリMNISTを使い、数字認識する学習モデルを作成します。&lt;strong&gt;Pythonなしでもコピペで試せる内容&lt;/strong&gt;になっています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/233/result.gif&#34; alt=&#34;demo&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;
&lt;h4 id=&#34;マイコンボード-gr-lychee&#34;&gt;■マイコンボード「GR-LYCHEE」&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/714caa81da618bf491f460087f27d3cb.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;がじぇっとるねさす（通称がじぇるね）が提供している高性能マイコンボードです。電子工作でよく使われるArduino UNOとピンが互換になっていて、Wi-Fi・BLE通信モジュール「ESP32」を搭載しています。&lt;/p&gt;
&lt;p&gt;わりと手軽にIoTプロトタイピングを試せる高性能マイコンボード、な立ち位置です。（ちゃんとく所感）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;購入: &lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-12850/&#34;&gt;秋月電子&lt;/a&gt;（¥10,580）&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■実行するGRボードについて&lt;/p&gt;
他のGRシリーズのボードでも今回のプログラムを試すことができますが、GR-KURUMI、GR-COTTON、GR-ADZUKIはROM容量不足で実行できないようです。
&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;usbケーブル-microb&#34;&gt;■USBケーブル（microB）&lt;/h4&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/usb.png&#34; alt=&#34;usb&#34;&gt;
&lt;/center&gt;
&lt;p&gt;PCとGR-LYCHEEの通信（プログラムの書き込み、カメラ映像の出力など）には、Android端末などに使われているmicroBタイプのUSBケーブルを使います。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;購入: &lt;a href=&#34;http://akizukidenshi.com/catalog/g/gC-09312/&#34;&gt;秋月電子&lt;/a&gt;（¥100）&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■USBケーブルについて&lt;/p&gt;
ご自身で用意する場合、&lt;b&gt;シリアル通信ができるタイプ&lt;/b&gt;のものか確認してください。安価なものだと一方向の給電専用タイプのものが多いです。
&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&#34;事前準備&#34;&gt;事前準備&lt;/h2&gt;
&lt;h3 id=&#34;displayapp-をインストール&#34;&gt;「DisplayApp」をインストール&lt;/h3&gt;
&lt;p&gt;GR-LYCHEEのカメラで映している映像を確認するために利用します。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gadget.renesas.com/ja/product/lychee.html#displayapp&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/5cf7140ebfb5221592c1ca7f6aa7f839.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;がじぇるね公式ページの&lt;a href=&#34;http://gadget.renesas.com/ja/product/lychee.html#displayapp&#34;&gt;こちら&lt;/a&gt;からご自身のOSに合ったものをダウンロードし、ZIPファイルを展開します。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;macosの方&#34;&gt;■MacOSの方&lt;/h4&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/app.png&#34; alt=&#34;app&#34;&gt;
&lt;/center&gt;
ZIPファイルを展開し、Macの方は「アプリケーション」に移動させます。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;windowsの方&#34;&gt;■Windowsの方&lt;/h4&gt;
&lt;p&gt;展開したファイル内の「〜.exe」をダブルクリックで実行します。インストーラが起動するので、手順通り進めます。&lt;/p&gt;
&lt;h2 id=&#34;はじめてのプログラムを書き込んでみる&#34;&gt;はじめてのプログラムを書き込んでみる&lt;/h2&gt;
&lt;p&gt;最初のプログラムとして、Lチカをやってみます。LEDチカチカの略で、入門向けのプログラムとして汎用的に紹介されています。&lt;/p&gt;
&lt;p&gt;簡単なプログラムを書き込むことで、ボードが正常に動くか試す際に利用することも多いです。WebでいうHello, worldです。&lt;/p&gt;
&lt;h3 id=&#34;webコンパイラの準備&#34;&gt;Webコンパイラの準備&lt;/h3&gt;
&lt;p&gt;GRシリーズでは「Webコンパイラ」という、ブラウザ上で利用できるコンパイラが利用できます。面倒な環境構築が不要なので楽チンですね。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gadget.renesas.com/ja/&#34;&gt;がじぇるねのページ&lt;/a&gt;から、「ログイン」または「ゲストログイン」をクリックし移動します。
&lt;img src=&#34;https://i.gyazo.com/bcf47b506593c244633350381c30422f.png&#34; alt=&#34;compiler&#34; /&gt;&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■ログインボタンが見つからない！という方&lt;/p&gt;
ブラウザを横に広げてみてください。ひょこっとボタンが出てきます。
&lt;/section&gt;
&lt;p&gt;プロジェクト作成画面になるので、「LYCHEE」でフィルターをかけてみます。
&lt;img src=&#34;https://i.gyazo.com/9fbdd84ff53037965a358bc646d3923c.png&#34; alt=&#34;create project&#34; /&gt;
「GR-LYCHEE_mbed…」と「GR-LYCHEE_Sketch…」という2タイプあるので、&lt;strong&gt;Sketchの方を選択&lt;/strong&gt;します（mbed OSのプログラムを利用したいときは前者を選びましょう）。&lt;/p&gt;
&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;メニュー左側の「〜.cpp」という拡張子のファイルがメインのプログラムファイルになります。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/edit_cpp.png&#34; alt=&#34;edit_cpp&#34;&gt;
&lt;/center&gt;
「〜.cpp」をダブルクリックすると、中央に編集画面が表示されます。&lt;/p&gt;
&lt;p&gt;表示されたサンプルコードを&lt;strong&gt;一旦全て消してから&lt;/strong&gt;、下記のプログラムを貼り付けます。&lt;/p&gt;
&lt;div class=&#34;accbox&#34;&gt;
&lt;label for=&#34;label1&#34;&gt;クリックしてコードを表示&lt;/labe&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;label1&#34; class=&#34;cssacc&#34; /&gt;
&lt;div class=&#34;accshow&#34;&gt;
&lt;pre&gt;
&lt;code class=&#34;hljs hljs-cpp&#34;&gt;
/* GR-LYCHEE Sketch Template V1.04 */
#include &amp;lt;Arduino.h&amp;gt;
#define INTERVAL 50
void setup()
{
Serial.begin(9600);
pinMode(LED_RED, OUTPUT);
pinMode(LED_ORANGE, OUTPUT);
pinMode(LED_YELLOW, OUTPUT);
pinMode(LED_GREEN, OUTPUT);
pinMode(USER_BUTTON0, INPUT);
}
void loop()
{
while(digitalRead(USER_BUTTON0) == 0){
digitalWrite(LED_GREEN, 1);
delay(INTERVAL);
digitalWrite(LED_GREEN, 0);
delay(INTERVAL);
Serial.println(&#34;I&#39;m LYCHEE!&#34;);
}
digitalWrite(LED_RED, 1);
delay(INTERVAL);
digitalWrite(LED_RED, 0);
digitalWrite(LED_ORANGE, 1);
delay(INTERVAL);
digitalWrite(LED_ORANGE, 0);
digitalWrite(LED_YELLOW, 1);
delay(INTERVAL);
digitalWrite(LED_YELLOW, 0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/build.png&#34; alt=&#34;build&#34;&gt;
&lt;/center&gt;
貼り付けたら、右側の「ビルド実行」ボタンをクリックし、記述したプログラムをコンパイルします。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/compiled.png&#34; alt=&#34;compiled&#34;&gt;
&lt;/center&gt;
コンパイルが完了すると、「コンパイルが完了しました」というメッセージと実行ログが表示されるので、「&lt;strong&gt;閉じる&lt;/strong&gt;」ボタンで完了します。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/download_bin.png&#34; alt=&#34;download_bin&#34;&gt;
&lt;/center&gt;
「〜.bin」というファイルが作成されているので、右クリックしダウンロードします。&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■コンパイルについて&lt;/p&gt;
プログラムを、&lt;b&gt;機械が実行可能な機械語に変換すること&lt;/b&gt;です。プログラムは人間に理解しやすい形、機械語は機械が理解しやすい形に最適化されています。
&lt;/section&gt;
&lt;h3 id=&#34;pcとgr-lycheeを接続&#34;&gt;PCとGR-LYCHEEを接続&lt;/h3&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/connect.png&#34; alt=&#34;connect&#34;&gt;
&lt;/center&gt;
&lt;p&gt;GR-LYCHEEとPCをUSBケーブルで接続しましょう。GR-LYCHEEのUSBソケットは&lt;strong&gt;真ん中の方&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/recog.png&#34; alt=&#34;recog&#34;&gt;
&lt;/center&gt;
PCに「MBED」という名前で認識されます。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;デバイスが認識されない-windows&#34;&gt;■デバイスが認識されない（Windows）&lt;/h4&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/usb_driver.png&#34; alt=&#34;usb_driver&#34;&gt;
&lt;/center&gt;
&lt;a href=&#34;https://os.mbed.com/docs/latest/tutorials/windows-serial-driver.html&#34;&gt;こちら&lt;/a&gt;のページから「Arm Mbed Windows serial port driver」をクリックし、インストールしてください。&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■USBドライバについて&lt;/p&gt;
PCに、USBで接続した機器を認識・通信させるためのツールです。
&lt;/section&gt;
&lt;h3 id=&#34;プログラムを書き込み&#34;&gt;プログラムを書き込み&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/drop.png&#34; alt=&#34;drop&#34;&gt;
&lt;/center&gt;
ダウンロードした「〜.bin」ファイルを「MBED」にドラッグ＆ドロップでコピーします。コピー後、ファイルはMBEDフォルダ内には表示されません。&lt;/p&gt;
&lt;h3 id=&#34;再起動して実行&#34;&gt;再起動して実行&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/reset.png&#34; alt=&#34;reset&#34;&gt;
&lt;/center&gt;
リセットボタンを押し、GR-LYCHEEを再起動させます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/233/blink.gif&#34; alt=&#34;blink&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Lチカプログラムが実行されました！&lt;/p&gt;
&lt;h2 id=&#34;gr-lycheeカメラの映像をdisplayappに表示&#34;&gt;GR-LYCHEEカメラの映像をdisplayAppに表示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/233/display.gif&#34; alt=&#34;display&#34; /&gt;&lt;/p&gt;
&lt;p&gt;GR-LYCHEEにカメラを取り付けて、PC上で映る映像を確認してみましょう。&lt;/p&gt;
&lt;h3 id=&#34;カメラの取り付け&#34;&gt;カメラの取り付け&lt;/h3&gt;
&lt;h4 id=&#34;カメラ本体&#34;&gt;■カメラ本体&lt;/h4&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/camera.png&#34; alt=&#34;camera&#34;&gt;
&lt;/center&gt;
&lt;ol&gt;
&lt;li&gt;カメラ本体のソケット部を持ち上げます&lt;/li&gt;
&lt;li&gt;フレキシブルケーブルの無地面を上に、ソケットに差し込みます&lt;/li&gt;
&lt;li&gt;ソケット部を元に戻します&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;gr-lychee&#34;&gt;■GR-LYCHEE&lt;/h4&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/camera2.png&#34; alt=&#34;camera2&#34;&gt;
&lt;/center&gt;
&lt;ol&gt;
&lt;li&gt;GR-LYCHEE背面のソケット部を上にずらします&lt;/li&gt;
&lt;li&gt;フレキシブルケーブルの文字面を上に、ソケットに差し込みます&lt;/li&gt;
&lt;li&gt;ソケット部を下に戻します&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;プログラム-1&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;Webコンパイラでプログラムを下記に置き換え、先ほど同様書き込みます。&lt;/p&gt;
&lt;div class=&#34;accbox&#34;&gt;
&lt;label for=&#34;label2&#34;&gt;クリックしてコードを表示&lt;/labe&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;label2&#34; class=&#34;cssacc&#34; /&gt;
&lt;div class=&#34;accshow&#34;&gt;
&lt;pre&gt;
&lt;code class=&#34;hljs hljs-cpp&#34;&gt;
// Sample for GR-PEACH, GR-LYCHEE
// Required hardware: Camera, USB
// Public Domain
#include &amp;lt;Arduino.h&amp;gt;
#include &amp;lt;Camera.h&amp;gt;
#include &#34;DisplayApp.h&#34;
#define LOOP_WAITTIME 17 // 17ms for 60 fps of camera spec.
Camera camera(640, 480);
static DisplayApp display_app;
void setup() {
Serial.begin(9600);
Serial.println(&#34;start&#34;);
camera.begin();
}
void loop() {
static unsigned long last_time = millis();
while ((millis() - last_time) &lt; LOOP_WAITTIME);
last_time = millis();
display_app.SendJpeg(camera.getJpegAdr(), (int)camera.createJpeg());
delay(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;usbを付け替えて実行&#34;&gt;USBを付け替えて実行&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/connect2.png&#34; alt=&#34;connect2&#34;&gt;
&lt;/center&gt;
書き込んだら、GR-LYCHEE側のUSBソケットを外側に付け替えます。（通信用）&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/port.png&#34; alt=&#34;port&#34;&gt;
&lt;/center&gt;
DisplayAppでシリアルポートを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/233/display.gif&#34; alt=&#34;display&#34; /&gt;
カメラの画像がDisplayAppに表示されます。高画質！&lt;/p&gt;
&lt;h2 id=&#34;数字認識の学習モデルを作ろう&#34;&gt;数字認識の学習モデルを作ろう&lt;/h2&gt;
&lt;p&gt;MNISTとTensorflowを使って学習モデルを作り、カメラに映った数字を判定するプログラムを作成してみます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python+Tensorflowをインストールせず試してみたい&lt;/strong&gt;、という方は、「&lt;a href=&#34;#完成コード&#34;&gt;完成コード&lt;/a&gt;」の章から進めてください。&lt;/p&gt;
&lt;h3 id=&#34;作業用ディレクトリを作成&#34;&gt;作業用ディレクトリを作成&lt;/h3&gt;
&lt;p&gt;今回のプログラムを試すディレクトリ（フォルダ）を作ります。&lt;/p&gt;
&lt;p&gt;プログラムを実行する上では&lt;strong&gt;今どこで作業しているか&lt;/strong&gt;というのが重要です。最初のうちはわかりづらいので、意識するようにしましょう。&lt;/p&gt;
&lt;p&gt;コマンドラインに不慣れである方は、下記記事を参照してみてください。&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;158&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/how-to-use-cli/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/158/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
【Mac向け】「黒い画面」の苦手意識を克服しよう！コマンドラインインタフェースの基本操作
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2018-04-09
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Macユーザ向けコマンドラインインタフェースの使い方！実は難しくない「黒い画面」の操作方法を覚えていきましょう。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;windowsの方-1&#34;&gt;■Windowsの方&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;デスクトップで右クリックし、&lt;code&gt;gr-tutorial&lt;/code&gt;というファイルを作成&lt;/li&gt;
&lt;li&gt;Windowsメニューから「コマンドラインプロンプト」を検索し開く（「cmd」で候補にでてきます）&lt;/li&gt;
&lt;li&gt;下記コマンドを1行ずつ実行（&lt;code&gt;$&lt;/code&gt;は不要。コマンドラインであることを表しています）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ cd Desktop
$ cd gr-tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cd&lt;/code&gt;はディレクトリを移動するコマンドです。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;macの方&#34;&gt;■Macの方&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;「ターミナル」を起動（⌘+スペースで「ターミナル」を検索すると便利）&lt;/li&gt;
&lt;li&gt;下記コマンドを1行ずつ順に打ち込む（&lt;code&gt;$&lt;/code&gt;は不要。コマンドラインであることを表しています）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/Desktop
$ mkdir gr-tutorial
$ cd gr-tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;デスクトップに「gr-tutorial」というフォルダができているかと思います（右クリックで作成してもOKです）。&lt;code&gt;cd&lt;/code&gt;コマンドは移動するコマンド、&lt;code&gt;mkdir&lt;/code&gt;コマンドはディレクトリを作成するコマンドです。&lt;/p&gt;
&lt;h3 id=&#34;python-tensorflow環境構築&#34;&gt;Python＆Tensorflow環境構築&lt;/h3&gt;
&lt;p&gt;今回はご自身の環境に、以下の内容を用意し進めます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python実行環境&lt;/li&gt;
&lt;li&gt;Tensorflow&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;環境構築はおそらく&lt;strong&gt;このハンズオンで1番大変なところ&lt;/strong&gt;です。乗り越えたらサクッと試せるようになるので頑張りましょう！&lt;/p&gt;
&lt;p&gt;PCの状態に合わせて場合分けしましたので、ご自身に合う部分を読んでください。&lt;/p&gt;
&lt;h3 id=&#34;まずは現在の環境を確認する&#34;&gt;まずは現在の環境を確認する&lt;/h3&gt;
&lt;p&gt;下記コマンドを試して、PythonとTensorFlowがインストールされているか確認しましょう。コマンドは&lt;code&gt;$&lt;/code&gt;マークの後ろの部分です。（↓の場合は&lt;code&gt;python -V&lt;/code&gt;と打ち込む）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python -V
Python X.X.X
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pythonのバージョンが表示されればOKです。「command not found」や「実行する〜〜が見つかりません」などと表示された方は、インストールされていない（または正しくインストールできていない）のでPythonの環境構築手順を進めます。&lt;/p&gt;
&lt;p&gt;インストールされていなかった方は、「&lt;a href=&#34;#Pythonをインストール&#34;&gt;Pythonをインストール&lt;/a&gt;」へ進んでください。&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■Pythonのバージョンについて&lt;/p&gt;
Pythonのバージョンは2系、3系どちらでも実行可能ですが、Python3.7系ではTensorflowがうまく実行できないようです。
&lt;/section&gt;
&lt;p&gt;続いて、Tensorflowモジュールがインストールされているかの確認です。&lt;code&gt;pip list&lt;/code&gt;と打ち込んでみましょう。（表示されるものは一例）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip list
Package Version
---------------------- ---------
absl-py 0.6.1
bleach 1.5.0
html5lib 0.9999999
Markdown 3.0.1
nose 1.3.7
numpy 1.15.3
pip 18.1
protobuf 3.6.1
setuptools 39.0.1
six 1.11.0
tensorflow 1.5.0
…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一覧に&lt;code&gt;tensorflow&lt;/code&gt;とあればOKです。バージョンが古い場合は、下記コマンドで更新をしておきましょう（最新は1.5系です）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python2系の場合&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ pip install --upgrade tensorflow
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Python3系の場合&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ pip3 install --upgrade tensorflow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PythonがインストールされているがTensorflowはインストールされていない場合は、「&lt;a href=&#34;#tensorflowをインストール&#34;&gt;Tensorflowをインストール&lt;/a&gt;」へ進んでください。&lt;/p&gt;
&lt;p&gt;どちらもインストールされていた場合は、「&lt;a href=&#34;#MNISTで学習モデルを作成&#34;&gt;MNISTで学習モデルを作成&lt;/a&gt;」へ進みます。&lt;/p&gt;
&lt;h3 id=&#34;pythonをインストール&#34;&gt;Pythonをインストール&lt;/h3&gt;
&lt;h4 id=&#34;windowsの方-2&#34;&gt;■Windowsの方&lt;/h4&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/install_python.png&#34; alt=&#34;install_python&#34;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;a href=&#34;https://www.python.org/downloads/windows/&#34;&gt;Pythonの公式ページ&lt;/a&gt;へ移動し、インストールしたいPythonのバージョンをクリックします。（Tensorflowがうまく動かないので&lt;strong&gt;Python3.7系は避けてください&lt;/strong&gt;。3.6.xがオススメです。）&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/233/select_version.png&#34; alt=&#34;select_version&#34;&gt;
&lt;/center&gt;
&lt;p&gt;移動先のページ下部のリストから、「Windows x86-64 web-based installer」をダウンロードします。32bit版の場合は「Windows x86 web-based installer」を選択してください。&lt;/p&gt;
&lt;p&gt;ダウンロードされたパッケージを実行し、「&lt;strong&gt;Add Python xxx to PATH&lt;/strong&gt;」をチェックしてインストールを実行します。&lt;/p&gt;
&lt;p&gt;完了したら、コマンドプロンプトで&lt;code&gt;python -V&lt;/code&gt;を打ち、任意のバージョンが表示されるか確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python -V
Python X.X.X
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示されない方はコマンドプロンプトを再起動して試してみてください。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;macの方-1&#34;&gt;■Macの方&lt;/h4&gt;
&lt;p&gt;デフォルトでPython2系がインストールされているはずですが、何かのタイミングで消してしまった可能性があります。&lt;/p&gt;
&lt;p&gt;ターミナルで下記コマンドを実行し、Homebrewがインストールされているか確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ brew -v
Homebrew x.x.x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールされていない場合は下記コマンドを実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ /usr/bin/ruby -e &amp;quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;続いてHomebrewでpyenvをインストールします。pyenvはPythonのバージョン管理を行うツールです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ brew install pyenv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールされたら下記コマンドで確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pyenv -v
pyenv x.x.x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pyenvでPythonをインストールします。バージョンは任意のものでよいですが、Tensorflowがうまく動かないので&lt;strong&gt;3.7系は避けてください&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pyenv install 3.6.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完了したら、選択したバージョンを設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pyenv global 3.6.7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ターミナルで下記コマンドを実行し、バージョンが表示されるか確認してみてください。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python -V
Python 3.6.7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tensorflowをインストール&#34;&gt;TensorFlowをインストール&lt;/h3&gt;
&lt;p&gt;コマンドラインで下記コマンドを実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install tensorflow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;だらだらと実行文が表示され、最後の行に &lt;code&gt;Successfully installed tensorflow-X.X.X&lt;/code&gt;などと表示されればOKです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip list&lt;/code&gt;というコマンドを打って、インストールされたか確認してみます。（表示されるものは一例）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip list
Package Version
---------------------- ---------
absl-py 0.6.1
bleach 1.5.0
html5lib 0.9999999
Markdown 3.0.1
nose 1.3.7
numpy 1.15.3
pip 18.1
protobuf 3.6.1
setuptools 39.0.1
six 1.11.0
tensorflow 1.5.0
…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一覧に、&lt;code&gt;tensorflow&lt;/code&gt;とあればOKです。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;実行したらエラーが出た&#34;&gt;■実行したらエラーが出た&lt;/h4&gt;
&lt;p&gt;長い実行文が表示されたあと、最後の一行が下記のようなエラー文になることがあります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: &#39;/Library/Python/2.7/site-packages/tensorflow-1.11.0.dist-info&#39; Consider using the --user option or check the permissions.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下記コマンドを再度実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo pip install tensorflow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;パスワードを求められるので、PCのユーザのパスワードを入力します。（入力したパスワードは表示されません）&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;エラーが出てインストールが実行されない①&#34;&gt;■エラーが出てインストールが実行されない①&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;pip install tensorflow&lt;/code&gt;を実行すると、&lt;code&gt;command not found&lt;/code&gt;といったエラーが出る場合があります。以下のコマンドを実行し、pipをインストールします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python -m ensurepip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;エラーが出てインストールが実行されない②&#34;&gt;■エラーが出てインストールが実行されない②&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;pip install tensorflow&lt;/code&gt;を実行すると、下記のようなエラーが出る場合があります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Could not find a version that satisfies the requirement tensorflow (from versions: )
No matching distribution found for tensorflow
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下のコマンドを再度実行しましょう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python2系&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ pip install --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.11.0-py2-none-any.wh
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Python3系&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ python3 -m pip install --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.5.0-py3-none-any.whl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;インストールしたのにlistに表示されない&#34;&gt;■インストールしたのにlistに表示されない&lt;/h4&gt;
&lt;p&gt;主にMacで、Python環境がPC上に複数あり、意図する場所にインストールできていない可能性があります。&lt;/p&gt;
&lt;p&gt;主に下記の記事を参考にしてみてください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/ta_ta_ta_miya/items/e24394c6b0022405a126&#34;&gt;pyenvでPythonがSystemバージョンから切り替わらない時の対処&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/mckyhrs/items/94a2db3506287df0420e&#34;&gt;pythonのバージョンが切り替わらない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mnistで学習モデルを作成&#34;&gt;MNISTで学習モデルを作成&lt;/h3&gt;
&lt;p&gt;画像認識向けに、大量の画像を自分で収集し学習用に加工するのはとても大変です。&lt;/p&gt;
&lt;p&gt;MNIST（Mixed National Institute of Standards and Technology database）は、手書き数字画像60,000枚とテスト画像10,000枚を集めたデータセットです。&lt;/p&gt;
&lt;p&gt;手軽に入手でき簡単に扱えるので、AI入門のサンプルデータとしてオススメです。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;mnist用pythonコードを作成&#34;&gt;■MNIST用Pythonコードを作成&lt;/h4&gt;
&lt;p&gt;作成した作業用ディレクトリに、コマンドか右クリックなどで&lt;code&gt;mnist_softmax_for_e-ai.py&lt;/code&gt;というファイルを作成します。&lt;/p&gt;
&lt;p&gt;プログラム向けのエディタでファイルを開き、下記のプログラムを貼り付けます。&lt;/p&gt;
&lt;div class=&#34;accbox&#34;&gt;
&lt;label for=&#34;label3&#34;&gt;クリックしてコードを表示&lt;/labe&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;label3&#34; class=&#34;cssacc&#34; /&gt;
&lt;div class=&#34;accshow&#34;&gt;
&lt;pre&gt;
&lt;code class=&#34;hljs python&#34;&gt;
# Copyright 2015 The TensorFlow Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
&#34;&#34;&#34;A very simple MNIST classifier.
See extensive documentation at
https://www.tensorflow.org/get_started/mnist/beginners
&#34;&#34;&#34;
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import argparse
import sys
from tensorflow.examples.tutorials.mnist import input_data
import tensorflow as tf
FLAGS = None
def main(_):
# Import data
mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot=True)
# Create the model
x = tf.placeholder(tf.float32, [None, 784])
#Add Renesas 2 --------- ----------
# change
# x_ = tf.placeholder(tf.float32, [None, 784])
# x = tf.reshape(x_, [-1])
# --------- ----------
W = tf.Variable(tf.zeros([784, 10]))
b = tf.Variable(tf.zeros([10]))
y = tf.matmul(x, W) + b
# Define loss and optimizer
y_ = tf.placeholder(tf.float32, [None, 10])
# The raw formulation of cross-entropy,
#
# tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(tf.nn.softmax(y)),
# reduction_indices=[1]))
#
# can be numerically unstable.
#
# So here we use tf.nn.softmax_cross_entropy_with_logits on the raw
# outputs of &#39;y&#39;, and then average across the batch.
cross_entropy = tf.reduce_mean(
tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y))
train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)
sess = tf.InteractiveSession()
tf.global_variables_initializer().run()
# Train
for _ in range(1000):
batch_xs, batch_ys = mnist.train.next_batch(100)
sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})
# Test trained model
correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
print(sess.run(accuracy, feed_dict={x: mnist.test.images,
y_: mnist.test.labels}))
#Add Renesas 1 --------- ----------
import os
#Save Learned AI
out_dir = &#34;./tf_LearnedModel&#34;
if os.path.isdir(out_dir) is False:
os.makedirs(out_dir)
saver = tf.train.Saver()
saver.save(sess, out_dir+&#34;/tf_LearnedModel&#34;)
# --------- ----------
if __name__ == &#39;__main__&#39;:
parser = argparse.ArgumentParser()
parser.add_argument(&#39;--data_dir&#39;, type=str, default=&#39;/tmp/tensorflow/mnist/input_data&#39;,
help=&#39;Directory for storing input data&#39;)
FLAGS, unparsed = parser.parse_known_args()
tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;今回はがじぇるねさんの&lt;a href=&#34;http://gadget.renesas.com/ja/product/e-ai/mnist_tutorial.html#%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92%E3%81%AE%E5%AE%9F%E8%A1%8C&#34;&gt;チュートリアルのサンプルコード&lt;/a&gt;をお借りしました！&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;tensorflowで実行&#34;&gt;■Tensorflowで実行&lt;/h4&gt;
&lt;p&gt;下記コマンドで学習モデルを作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python mnist_softmax_for_e-ai.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pythonコマンドはPythonで書かれたプログラムを実行するコマンドです。ファイルの中のプログラムが実行され、学習モデルが作成されます。&lt;/p&gt;
&lt;p&gt;Windowsの方は&lt;code&gt;dir&lt;/code&gt;、Macの方は&lt;code&gt;ls&lt;/code&gt;というコマンドを実行し、「tf_LearnedModel」というフォルダが作成されたことを確認してください。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls
mnist_softmax_for_e-ai.py
tf_LearnedModel/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windowsは&lt;code&gt;dir tf_LearnedModel&lt;/code&gt;、Macは&lt;code&gt;ls tf_LearnedModel&lt;/code&gt;のコマンドを実行すると、4つのファイルが入っていることがわかります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls tf_LearnedModel
checkpoint
tf_LearnedModel.data-00000-of-00001
tf_LearnedModel.index
tf_LearnedModel.meta
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;学習モデルをgrボードで扱う&#34;&gt;学習モデルをGRボードで扱う&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/045295f6fe6ebda3cbed3d0150650c27.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;
Webコンパイラを開き、右側のリストから「e-AI Translator」をクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/1ae615bd6f71338dab09647185d3bcb5.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;
アップロードボタンを押し、先ほど作成された「tf_LearnedModel」を選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/2d54b87b9a6c9852f31c1afb14132614.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;
その他はデフォルト選択のまま、「トランスレート」をクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/27fe23312950242e2eee4ff2e6e7ee79.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;
表示されたプログラムを全て選択してコピーします。&lt;/p&gt;
&lt;h2 id=&#34;完成コード&#34;&gt;完成コード&lt;/h2&gt;
&lt;p&gt;上記で生成されたプログラムに、displayAppに表示させるためのコードを加えたプログラムです。USBケーブルは真ん中に接続し、GR-LYCHEEに書き込みましょう。&lt;/p&gt;
&lt;div class=&#34;accbox&#34;&gt;
&lt;label for=&#34;label4&#34;&gt;クリックしてコードを表示&lt;/labe&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;label4&#34; class=&#34;cssacc&#34; /&gt;
&lt;div class=&#34;accshow&#34;&gt;
&lt;pre&gt;
&lt;code class=&#34;hljs hljs-cpp&#34;&gt;
#include &amp;lt;Arduino.h&amp;gt;
#include &amp;lt;Camera.h&amp;gt;
#include &amp;lt;opencv.hpp&amp;gt;
#include &amp;lt;DisplayApp.h&amp;gt;
#ifdef __cplusplus
extern &#34;C&#34; {
#endif
#include &#34;eAI_translated/Typedef.h&#34;
#include &#34;eAI_translated/input_image_0.h&#34;
#include &#34;eAI_translated/layer_graph.h&#34;
TPrecision* dnn_compute(TPrecision* input_img);
#ifdef __cplusplus
}
#endif
// To monitor realtime on PC, you need DisplayApp on following site.
// Connect USB0(not for mbed interface) to your PC
// os.mbed.com/.../
using namespace cv;
#define IMAGE_HW 320
#define IMAGE_VW 240
#define INPUT_HEIGHT 28
#define INPUT_WIDTH 28
Camera camera(IMAGE_HW, IMAGE_VW);
DisplayApp display_app;
void paste(cv::Mat dst, cv::Mat src, int x, int y, int width, int height) {
cv::Mat resized_img;
cv::resize(src, resized_img, cv::Size(width, height));
if (x &gt;= dst.cols || y &gt;= dst.rows) return;
int w = (x &gt;= 0) ? std::min(dst.cols - x, resized_img.cols) : std::min(std::max(resized_img.cols + x, 0), dst.cols);
int h = (y &gt;= 0) ? std::min(dst.rows - y, resized_img.rows) : std::min(std::max(resized_img.rows + y, 0), dst.rows);
int u = (x &gt;= 0) ? 0 : std::min(-x, resized_img.cols - 1);
int v = (y &gt;= 0) ? 0 : std::min(-y, resized_img.rows - 1);
int px = std::max(x, 0);
int py = std::max(y, 0);
cv::Mat roi_dst = dst(cv::Rect(px, py, w, h));
cv::Mat roi_resized = resized_img(cv::Rect(u, v, w, h));
roi_resized.copyTo(roi_dst);
}
int max_array(TPrecision* array, int length){
int i;
float max = array[0];
int index = 0;
for(i = 0; i &lt; length; i++){
if(array[i] &gt; max){
max = array[i];
index = i;
}
}
return index;
}
void setup() {
Serial.begin(9600);
camera.begin();
}
void loop() {
Scalar red(0, 0, 255), green(0, 255, 0), blue(255, 0, 0);
Scalar yellow = red + green;
Scalar white = Scalar::all(255);
Scalar black = Scalar::all(0);
Scalar pink = Scalar(154, 51, 255);
Mat img_raw(IMAGE_VW, IMAGE_HW, CV_8UC2, camera.getImageAdr());
Mat pic, gray;
cvtColor(img_raw, pic, COLOR_YUV2BGR_YUYV); //covert YUV to RGB
cvtColor(img_raw, gray, COLOR_YUV2GRAY_YUYV); //covert from YUV to GRAY
Mat roi(gray, Rect(80, 0, 240, 240));
threshold(roi, roi, 90, 255, THRESH_BINARY);
resize(roi, roi, Size(INPUT_WIDTH, INPUT_HEIGHT));
for(int i = 0; i &lt; 784; i++){
data_in[i] = 1 - (float)roi.data[i] / 255;
}
TPrecision *prediction;
TPrecision *input_img;
TsInt i;
input_img = data_in;
prediction = (TPrecision*) (intptr_t) dnn_compute( input_img);
// Drawing
rectangle(pic, Rect(0, 0, 80, 240), white, FILLED);
rectangle(pic, Rect(80, 0, 240, 240), red, 2);
Mat roi2;
cvtColor(roi, roi2, COLOR_GRAY2BGR);
paste(pic, roi2, 5, 5, roi2.rows, roi2.cols);
rectangle(pic, Rect(4, 4, 30, 30), red, 1);
int max_index = max_array(prediction, 10);
for(i = 0;i &lt; 10;i++){
Serial.print(i); Serial.print(&#34;:&#34;);
Serial.println(prediction[i]);
stringstream ss;
ss &lt;&lt; i;
if(max_index == i){
putText(pic, ss.str(), Point(0, 20 * i + 50), FONT_HERSHEY_SCRIPT_SIMPLEX, 0.5, pink, 1);
rectangle(pic, Rect(20, 20 * i + 40, prediction[i] * 80, 10), pink, FILLED);
} else {
putText(pic, ss.str(), Point(0, 20 * i + 50), FONT_HERSHEY_SCRIPT_SIMPLEX, 0.5, black, 1);
rectangle(pic, Rect(20, 20 * i + 40, prediction[i] * 80, 10), blue, FILLED);
}
}
size_t jpegSize = camera.createJpeg(320, 240, pic.data,
Camera::FORMAT_RGB888);
display_app.SendJpeg(camera.getJpegAdr(), jpegSize);
delay(10);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;これまでの手順と同様、書き込んでみましょう。&lt;/p&gt;
&lt;h2 id=&#34;手書き数字の認識を試してみる&#34;&gt;手書き数字の認識を試してみる&lt;/h2&gt;
&lt;p&gt;USBケーブルを外側につけかえ、試してみます。&lt;/p&gt;
&lt;h3 id=&#34;displayappで表示&#34;&gt;displayAppで表示&lt;/h3&gt;
&lt;p&gt;紙に書く文字は、マッキーペンなどで太くハッキリと書いてみてください。&lt;/p&gt;
&lt;p&gt;カメラに数字を映すと……&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/233/result.gif&#34; alt=&#34;demo&#34; /&gt;&lt;/p&gt;
&lt;p&gt;数字を推論してくれます。お疲れ様でした！&lt;/p&gt;
&lt;h3 id=&#34;シリアルモニタで表示&#34;&gt;シリアルモニタで表示&lt;/h3&gt;
&lt;p&gt;GR-LYCHEEで実行されている内容を、シリアル通信を介してPCで確認してみます。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;macの方-2&#34;&gt;■Macの方&lt;/h4&gt;
&lt;p&gt;下記コマンドを実行し、USB接続されている場所を調べます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls /dev/tty.usb*
/dev/tty.usbmodem~~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接続されている場所をコピーし、下記コマンドで接続します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ screen /dev/tty.usbmodem~~~~ 9600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;windowsの方-3&#34;&gt;■Windowsの方&lt;/h4&gt;
&lt;p&gt;「TeraTerm」というシリアル通信対応のソフトをダウンロード＆インストールします。「Arduino IDE」がインストールされている方は、そちらでも確認できます。&lt;/p&gt;
&lt;p&gt;下記リンクを参考に、TeraTermを起動しシリアル接続します。&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://www.j-oosk.com/teraterm/serial/346/&#34;&gt;Tera Termでシリアル接続を行う手順&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考情報&#34;&gt;参考情報&lt;/h2&gt;
&lt;p&gt;がじぇるねさんのページでは、その他のGR-LYCHEEチュートリアルも紹介されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gadget.renesas.com/ja/product/lychee_sp/4.html&#34;&gt;Webカメラにしてみよう!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gadget.renesas.com/ja/product/lychee_sp/5.html&#34;&gt;Bluetoothでスマホとつなげよう!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gadget.renesas.com/ja/product/lychee_sp/8.html&#34;&gt;OpenCTの応用 輪郭検出、HSV色空間&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ぜひ試してみてください！&lt;/p&gt;
&lt;style&gt;
.caution {
border: 1px solid #BFBFBF;
padding: 1em 2em;
margin: 2em 0;
color: #474747;
background: whitesmoke;/*背景色*/
border-left: double 7px #0B0B61;/*左線*/
font-size: 90%;
}
.caution &gt; p {
font-weight: bold;
margin: 0 0 10px 0;
padding: 0;
}
blockquote {
font-size:80%;
}
.accbox {
margin: 2em 0;
padding: 0;
max-width: 710px;
}
.accbox label {
display: block;
margin: 1.5px 0;
padding : 11px 12px;
color :#ffffff;
font-weight: bold;
background :#2f2f2f;
cursor :pointer;
transition: all 0.5s;
}
.accbox label:hover {
background :#A4A4A4;
}
.accbox input {
display: none;
}
.accbox .accshow {
height: 0;
padding: 0;
overflow: hidden;
opacity: 0;
transition: 0.8s;
}
.cssacc:checked + .accshow {
height: auto;
padding: 5px;
background: #eaeaea;
opacity: 1;
}
&lt;/style&gt;</description></item><item><title>加速度センサとマイコン内蔵LEDで魔法の杖を作ってみた！</title><link>https://dotstud.io/blog/halloween-gadget-witch-stick/</link><pubDate>Wed, 31 Oct 2018 10:07:13 +0900</pubDate><guid>https://dotstud.io/blog/halloween-gadget-witch-stick/</guid><description>
&lt;p&gt;みなさんこんにちは。トボリです。&lt;/p&gt;
&lt;p&gt;私は電子工作が大好きで、いろいろいじったり、&lt;a href=&#34;http://toboli.hatenablog.com/&#34;&gt;ブログ&lt;/a&gt;を書いたりして暮らしています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ところで、みなさん魔法は好きですか？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;電子工作と魔法ってかなり相性いいと思うんですよ。勝手に光る、勝手に動く、勝手にしゃべる……とか！&lt;/p&gt;
&lt;p&gt;気づけばもう10月31日。そう、本日はハロウィンです！電子工作を愛し、電子工作に愛された者として、このイベントで魔法っぽいものを作りたい！！&lt;/p&gt;
&lt;p&gt;魔法といえば、そう、杖ですよね！！&lt;/p&gt;
&lt;p&gt;ということで、今回はみんなが一度は憧れたであろう、&lt;strong&gt;『魔法の杖』&lt;/strong&gt; を作ってみました！&lt;/p&gt;
&lt;h2 id=&#34;振ると光る杖-を作ることにした&#34;&gt;「振ると光る杖」を作ることにした&lt;/h2&gt;
&lt;p&gt;『魔法の杖』っていうからには、できるだけかっこいいことがしたい！
トボリも想像力だけは無駄に豊かなので、うきうきいろんな機能をイメージしました。&lt;/p&gt;
&lt;p&gt;家電を操作したり、一振りでカーテン開けられたりできたらいいなあ～！何か浮かせられたらもっとおもしろいかも……。&lt;/p&gt;
&lt;p&gt;しかし。&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;font-size: 200%&#34;&gt;時間と技術力は限られている！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;今のトボリの技術力でハロウィンまでに作れそうなものといえば、「振ると光る」杖です。&lt;/p&gt;
&lt;p&gt;想像よりだいぶスケールが小さくなりましたが、どんなにささやかな物でもまずは作ることが大事！
と自分に言い聞かせ、とにかく作ってみることにしました！&lt;/p&gt;
&lt;h2 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h2&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/parts.png&#34; alt=&#34;parts&#34;&gt;
&lt;/center&gt;
電子工作初心者の味方、Arduinoを使って作ろうと思います！&lt;/p&gt;
&lt;p&gt;また、なぜミニブレッドボードを使用するかというと……これを見てください！
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/breadboard.png&#34; alt=&#34;breadboard&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;たまたま買った電池ボックスとミニブレッドボードのサイズがほぼ同じ！&lt;/p&gt;
&lt;p&gt;これを見た瞬間、絶対に使おう！と固く決意したのです。
（本当はユニバーサル基板に半田付けしてたんですが、完成間近にピンヘッダの取り付けミスが発覚し、安心安全のブレッドボードでやり直したという経緯があります。つらい。）&lt;/p&gt;
&lt;h2 id=&#34;魔法の杖を作る&#34;&gt;魔法の杖を作る&lt;/h2&gt;
&lt;p&gt;魔法の杖は、下記の3ステップで作って行きます！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;プログラムを書く&lt;/li&gt;
&lt;li&gt;ブレッドボードに回路を作る&lt;/li&gt;
&lt;li&gt;見た目をそれっぽく造形する&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;プログラムを書く&#34;&gt;プログラムを書く&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;Arduino IDE&lt;/a&gt;を使ってプログラムを書いていきます。&lt;/p&gt;
&lt;p&gt;加速度センサのサンプルプログラムと、フルカラーLEDのサンプルプログラムをただ合体しただけのお手軽コードです！&lt;/p&gt;
&lt;div class=&#34;accbox&#34;&gt;
&lt;label for=&#34;label1&#34;&gt;クリックしてコードを表示&lt;/labe&gt;
&lt;input type=&#34;checkbox&#34; id=&#34;label1&#34; class=&#34;cssacc&#34; /&gt;
&lt;div class=&#34;accshow&#34;&gt;
&lt;pre&gt;
&lt;code class=&#34;hljs hljs-line-numbers&#34;&gt;
#include &amp;lt;Wire.h&amp;gt;
#include &amp;lt;SparkFun_MMA8452Q.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#define PIN 2
Adafruit_NeoPixel pixels = Adafruit_NeoPixel(1, PIN, NEO_GRB + NEO_KHZ800);
MMA8452Q accel;
void setup() {
Serial.begin(9600);
Serial.println(&#34;MMA8452Q Test Code!&#34;);
pixels.begin();
pixels.show();
accel.init();
}
void loop() {
if(accel.available()) {
accel.read();
printCalculatedAccels();
printOrientation();
Serial.println();
}
}
void printOrientation() {
byte pl = accel.readPL();
switch (pl) {
case PORTRAIT_U:
Serial.print(&#34;Portrait Up&#34;);
break;
case PORTRAIT_D:
Serial.print(&#34;Portrait Down&#34;);
break;
case LANDSCAPE_R:
Serial.print(&#34;Landscape Right&#34;);
rainbow(20);
break;
case LANDSCAPE_L:
Serial.print(&#34;Landscape Left&#34;);
rainbow(20);
break;
case LOCKOUT:
Serial.print(&#34;Flat&#34;);
pixels.show();
break;
}
}
void rainbow(uint8_t wait) {
uint16_t i, j;
for(j=0; j&amp;lt;256; j++) {
for(i=0; i&amp;lt;pixels.numPixels(); i++) {
pixels.setPixelColor(i, Wheel((i+j) &amp; 255));
}
pixels.show();
delay(wait);
}
}
uint32_t Wheel(byte WheelPos) {
WheelPos = 255 - WheelPos;
if(WheelPos &amp;lt; 85) {
return pixels.Color(255 - WheelPos * 3, 0, WheelPos * 3);
}
if(WheelPos &amp;lt; 170) {
WheelPos -= 85;
return pixels.Color(0, WheelPos * 3, 255 - WheelPos * 3);
}
WheelPos -= 170;
return pixels.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;ブレッドボードに回路を作る&#34;&gt;ブレッドボードに回路を作る&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/fritzing.png&#34; alt=&#34;fritzing&#34;&gt;
&lt;/center&gt;
まずはブレッドボードに配線していきます！配線図はこんな感じ。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/circuit.png&#34; alt=&#34;circuit&#34;&gt;
&lt;/center&gt;
実際に配線したものがこちらです！
LEDの部分だけ基板から離れてしまうので、後で半田付けをします。&lt;/p&gt;
&lt;p&gt;みなさん半田付けって好きですか？トボリは電子工作作業の中で半田付けが一番好きです！
半田の香りは下手なアロマより癒される気がします。&lt;/p&gt;
&lt;h3 id=&#34;見た目をそれっぽく造形する&#34;&gt;見た目をそれっぽく造形する&lt;/h3&gt;
&lt;p&gt;杖はそれっぽい形になればなんでもいいので、3Dプリンタを使える方は使ってもいいし、お好きなやり方で大丈夫です！今回は、粘土をこねて作ってみたので、参考までに材料と作り方も載せておきます！&lt;/p&gt;
&lt;h4 id=&#34;用意するもの-1&#34;&gt;■ 用意するもの&lt;/h4&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/stick1.png&#34; alt=&#34;stick1&#34;&gt;
&lt;/center&gt;
石粉粘土・トイレットペーパーの芯・市販のスティックを用意します。これらは全て百均で買うことができました！いい時代ですね！&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/stick2.png&#34; alt=&#34;stick2&#34;&gt;
&lt;/center&gt;
この市販のスティックを分解し、筒状の棒だけ取り出します。&lt;/p&gt;
&lt;h4 id=&#34;杖の形に造形する&#34;&gt;■ 杖の形に造形する&lt;/h4&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/stick3.png&#34; alt=&#34;stick3&#34;&gt;
&lt;/center&gt;
市販の棒とトイレットペーパーの芯をくっつけます。トイレットペーパーの芯の先に切れ込みを入れて、画像のように内側に折り込みます。トイレットペーパーの芯に棒を差し込んで、テープで固定します。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/stick4.png&#34; alt=&#34;stick4&#34;&gt;
&lt;/center&gt;
中に基板を入れ、筒の中にLEDのワイヤーを通してから、LEDを半田付けします。&lt;/p&gt;
&lt;p&gt;動作チェックをして問題なさそうだったら、どんどん土台に石粉粘土を貼り付けていきます！少しずつ貼り付けて、時々手でなでて滑らかにしていきます。&lt;/p&gt;
&lt;p&gt;乾いたら、カッターで傷をつけ、茶色と黒のアクリル絵の具をインスピレーションに従っていい感じに塗ります。&lt;/p&gt;
&lt;h4 id=&#34;完成&#34;&gt;■ 完成！&lt;/h4&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/228/stick5.png&#34; alt=&#34;stick5&#34;&gt;
&lt;/center&gt;
できた～～～！！！
どう見ても、魔法の杖！！少なくとも自分にとっては手塩にかけた最愛の杖！！&lt;/p&gt;
&lt;h2 id=&#34;魔法を発動する&#34;&gt;魔法を発動する&lt;/h2&gt;
&lt;p&gt;さっそく魔法を発動していきましょう！
左右に杖を振ると……虹色の光が出ます！やった～～！魔法っぽい！
&lt;img src=&#34;https://dotstud.io/img/blog/228/demo.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;次こそはもっとうまく作りたい-それが電子工作沼&#34;&gt;次こそはもっとうまく作りたい……それが電子工作沼&lt;/h2&gt;
&lt;p&gt;LEDとセンサーひとつですが、結構楽しいものができました！&lt;/p&gt;
&lt;p&gt;でも、やっぱり本当はこうしたい……もっとかっこいい機能搭載したい……という欲望はとめどなく溢れ、「次こそもっといいものを！」という気持ちになります。&lt;/p&gt;
&lt;p&gt;もうこうなったらズブズブですよね。&lt;b&gt;電子工作沼&lt;/b&gt;に。このハロウィンは今自分が作れる楽しいものを作りまくって、一緒に電子工作沼で溺れましょう！&lt;/p&gt;
&lt;p&gt;ではでは、トボリでした！&lt;/p&gt;
&lt;style&gt;
.accbox {
margin: 2em 0;
padding: 0;
max-width: 710px;
}
.accbox label {
display: block;
margin: 1.5px 0;
padding : 11px 12px;
color :#ffffff;
font-weight: bold;
background :#2f2f2f;
cursor :pointer;
transition: all 0.5s;
}
.accbox label:hover {
background :#A4A4A4;
}
.accbox input {
display: none;
}
.accbox .accshow {
height: 0;
padding: 0;
overflow: hidden;
opacity: 0;
transition: 0.8s;
}
.cssacc:checked + .accshow {
height: auto;
padding: 5px;
background: #eaeaea;
opacity: 1;
}
&lt;/style&gt;</description></item><item><title>【あのバズマイコンを最速？レポート】極小マイコンのトリリオンノード・エンジンを使ってみた！</title><link>https://dotstud.io/blog/trillion-node-engine-sugoi/</link><pubDate>Fri, 05 Oct 2018 02:39:17 +0900</pubDate><guid>https://dotstud.io/blog/trillion-node-engine-sugoi/</guid><description>
&lt;p&gt;こんにちは、宇宙エンジニアのたくろーどんです。&lt;/p&gt;
&lt;p&gt;夏休みなので「何かハッカソンに出てみたい！モノづくりしたい！」と思いつつ、&lt;a href=&#34;http://www.mcpc-jp.org/&#34;&gt;MCPC（モバイルコンピューティング推進コンソーシアム）&lt;/a&gt;が主催する&lt;strong&gt;第1回ナノコン応用ハッカソン&lt;/strong&gt;に参加しました。&lt;/p&gt;
&lt;p&gt;なんとこのハッカソンで&lt;strong&gt;これから流行りそうな凄い開発ボード&lt;/strong&gt;に出会ったので、紹介します。その名も&lt;u&gt;&lt;strong&gt;トリリオンノード・エンジン&lt;/strong&gt;&lt;/u&gt;です。&lt;/p&gt;
&lt;h2 id=&#34;トリリオンノード-エンジン-のここが凄い&#34;&gt;「トリリオンノード・エンジン」のここが凄い！&lt;/h2&gt;
&lt;h3 id=&#34;小さい&#34;&gt;小さい！&lt;/h3&gt;
&lt;p&gt;特筆すべきポイントは、&lt;strong&gt;トリリオンノード・エンジンの小ささ&lt;/strong&gt;でしょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/d8655c77-c996-4684-adb8-61f8799cbce4.jpeg&#34; alt=&#34;P_20180831_162041_vHDR_On.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;そうです、写真でわかるように&lt;strong&gt;本当に小さい&lt;/strong&gt;です。
決して、手が大きいわけではありません。&lt;/p&gt;
&lt;h3 id=&#34;拡張性が高い&#34;&gt;拡張性が高い！&lt;/h3&gt;
&lt;p&gt;ハッカソンの際は、写真のようにキットが渡されました。
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/ab86e180-f0c0-afdd-c320-baa25fa92140.jpeg&#34; alt=&#34;P_20180831_100142_vHDR_On.jpg&#34; /&gt;
トリリオンノード・エンジンは、&lt;strong&gt;リーフ&lt;/strong&gt;というパーツで構成され、そのリーフの1つ1つに&lt;strong&gt;センサモジュールやBLE（Bluetooth）、Wi-Fi&lt;/strong&gt;といった機能を持っています。それを&lt;u&gt;&lt;strong&gt;重ねていくことで簡単に機能を拡張することができる&lt;/strong&gt;&lt;/u&gt;仕組みです。&lt;/p&gt;
&lt;p&gt;プログラムは&lt;strong&gt;Arduino IDE&lt;/strong&gt;で書きます。これは、Arduinoを触ったことがある人にやさしいですね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/0c71d1f5-486a-a6c7-d408-1aafa14afcdf.jpeg&#34; alt=&#34;P_20180831_100406_vHDR_On.jpg&#34; /&gt;
評価用キットなので、すべてのリーフが入っているわけではありません。今後は、もっとリーフが増えるようです。例えば、&lt;strong&gt;Groveセンサ用のリーフ&lt;/strong&gt;も予定されているそうです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/725d14ea-0149-83c4-87bd-cdade631bf64.jpeg&#34; alt=&#34;P_20181001_002408_vHDR_On.jpg&#34; /&gt;
Arduinoシールドのリーフもあります。プロトタイプをつくる際に役立ちますね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/6bd3b78b-ca6c-7bce-83bd-cb8a76319c44.jpeg&#34; alt=&#34;P_20181001_002538_vHDR_On.jpg&#34; /&gt;
「29TH Leaf」というリーフを使えば基板に直接実装できます。これもArduino互換リーフの一つです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/371ec114-1346-7596-1d0e-f2c12fa5d0e1.jpeg&#34; alt=&#34;P_20181001_002505_vHDR_On.jpg&#34; /&gt;
電源はUSB給電だけなく、&lt;strong&gt;専用のリーフで単3電池やボタン電池駆動&lt;/strong&gt;させることができます。実装には一手間かかるので、専用のリーフがあるのはとてもありがたいですね。&lt;/p&gt;
&lt;p&gt;例えば&lt;strong&gt;ウェアラブルなものをつくりたい&lt;/strong&gt;と思ったときに、必要な電圧にもよりますが電源回路を実装する必要がなくなります。&lt;/p&gt;
&lt;p&gt;重ねるだけでなく、横方向につなげるリーフもあります。発想の幅が広がりますね。&lt;/p&gt;
&lt;h2 id=&#34;試してみた&#34;&gt;試してみた&lt;/h2&gt;
&lt;p&gt;加速度センサとLEDテープを組み合わせてLチカさせてみました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/44f0d940-e547-66b5-bc20-020f64550d0d.gif&#34; alt=&#34;84472b66eb294f495cb1060bfda8c512.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ハッカソンでは、犬につけてコミュニケーションを加速させることを目的としたウェアラブルデバイスを考えました（完成には程遠かったですが……）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/973f6f0e-7487-ba0d-2aef-e2f245826ef9.jpeg&#34; alt=&#34;42142867_568541853564424_1201723650328231936_n.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;このサイズだから出来ることを考えてみると、様々なところに応用できそう&lt;/strong&gt;ですね。&lt;/p&gt;
&lt;h2 id=&#34;そして平成最後の夏-twitterでバズった&#34;&gt;そして平成最後の夏、Twitterでバズった&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;「トリリオンノード・エンジンが凄い！」といったことをつぶやいてみたら、バズりました&lt;/strong&gt;。
小型で使いやすそうなマイコンに対する関心の高さがうかがえます。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;今日つかったマイコン、やばやばなほど小さいんだけど、BLEも照度センサ、加速度センサ、温度センサ、スタックしていけばwifiモジュールもつくし、ボタン電池で駆動できて、Arduinoで開発できる。拡張も自由自在。スタックするだけでなく、横につなげてウェアラブルも可能。凄すぎるん😳😳😳 &lt;a href=&#34;https://t.co/DGqssgNkCF&#34;&gt;pic.twitter.com/DGqssgNkCF&lt;/a&gt;&lt;/p&gt; たくろーどん (@takudooon) &lt;a href=&#34;https://twitter.com/takudooon/status/1035474814696222722?ref_src=twsrc%5Etfw&#34;&gt;2018年8月31日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;そしてバズったら&lt;strong&gt;「トリリオンノード・エンジンの普及に貢献した」としてハッカソンで特別賞を貰いました&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/aa12c34d-e3f2-a9df-92b8-f4eccb6befb9.jpeg&#34; alt=&#34;IMG_20181001_011537_066.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;人生、何が起こるかわからないですね。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;まだまだドキュメントの整備や使用例はこれからのようです。
来年から販売予定だそうなので、目が離せませんね！&lt;/p&gt;</description></item><item><title>気分はセレブ！手を叩くとディナーを出してくれるデバイスを作ろう</title><link>https://dotstud.io/blog/device-of-celebrity-dinner/</link><pubDate>Thu, 27 Sep 2018 12:34:10 +0900</pubDate><guid>https://dotstud.io/blog/device-of-celebrity-dinner/</guid><description>
&lt;p&gt;こんにちは、たいしょーです。&lt;/p&gt;
&lt;p&gt;いきなりですが、&lt;u&gt;高級なレストランで指パッチンや手を叩いて合図するとウェイターがディナーを出してくれるシーン&lt;/u&gt;を見たことありませんか？&lt;/p&gt;
&lt;h2 id=&#34;憧れのシーンを実現したい&#34;&gt;憧れのシーンを実現したい&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/a7be6476-4059-9a5e-b3d6-9aeaff37db85.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;
&lt;p&gt;どこで見たかわからないけどなんとなく想像できる人も多いと思います。&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;で、私はそのシーンをめっちゃ再現したいわけです。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;何も言わずとも合図を送るだけで自分の好みを把握したウェイターがスッとディナーを出してくれる&amp;hellip;そんなセレブ気分を味わいたい…………！
しかし、高級レストランに行くお金もなければ、行けたとしても恥ずかしくてそんなことやる勇気も出ないので自宅で再現してみましょう。&lt;/p&gt;
&lt;h2 id=&#34;設計&#34;&gt;設計&lt;/h2&gt;
&lt;p&gt;先ほどのイメージ画像通り「合図するとディナーを出してくれる」のが完成イメージですが、より具体的な実現方法を考えてみます。&lt;/p&gt;
&lt;p&gt;考えた結果、&lt;u&gt;手を叩いたことをセンサーで認識して、「&lt;strong&gt;Amazon Dash Button&lt;/strong&gt;」を押すことでディナーをネット注文することにしました。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/0af2d3f4-e6a0-9053-7048-c3968bef281e.jpeg&#34; alt=&#34;概要図&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;準備するもの&#34;&gt;準備するもの&lt;/h2&gt;
&lt;h3 id=&#34;準備するものリスト&#34;&gt;準備するものリスト&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;名前&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;個数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Amazon Dash Button　&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Arduino Uno&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://www.aitendo.com/product/4070&#34;&gt;拍手制御スイッチ [AKIT-107]&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://www.aitendo.com/product/3277&#34;&gt;トランジスタ（S8050）&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;デジタル・マイクロサーボ SG90&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ジャンパー線（オス）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;最低6本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;太い輪ゴム&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;半田付けセット&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;手を叩くことを認識するセンサー部分は、aitendo様に「&lt;strong&gt;拍手制御スイッチ&lt;/strong&gt;」というまんま目的に合った素敵キットがあったので注文しました。&lt;/p&gt;
&lt;h2 id=&#34;拍手制御スイッチを組み立てる&#34;&gt;拍手制御スイッチを組み立てる&lt;/h2&gt;
&lt;h3 id=&#34;半田付けする&#34;&gt;半田付けする&lt;/h3&gt;
&lt;p&gt;&lt;font color=&#34;Red&#34;, font size=&#34;3&#34;&gt;&lt;strong&gt;はやく半田付けをしたい人も、このセクションの【注意点!!】を読んでから半田付けをはじめてください。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;拍手制御スイッチは自分で部品を半田付けするキットで届くので組み立てていきましょう。&lt;/p&gt;
&lt;p&gt;半田付けの基本については村田製作所様のこちらのページが参考になります。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.murata.com/ja-jp/campaign/ads/japan/elekids/ele/craft/knack/soldering&#34;&gt;電子工作のコツ/はんだ付け | 村田製作所 - Murata&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;さて、今回用意した半田付けセットはこちら。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/8f09c0ef-4ad5-ef26-4aed-b5a74f2b4fd3.jpeg&#34; alt=&#34;はんだセット&#34; /&gt;&lt;/p&gt;
&lt;p&gt;はんだは&lt;strong&gt;線径0.6mm&lt;/strong&gt;のもの、半田ごては温度を&lt;strong&gt;350度&lt;/strong&gt;に設定したものを用意しました。
洗濯バサミみたいな道具はヒートシンクといい、半田ごての熱から熱に弱い部品を守るものですが今回は使いませんでした。&lt;/p&gt;
&lt;p&gt;どの部品を基板のどこにつけるかなのですが、aitendo様のWebページに&lt;a href=&#34;http://www.aitendo.com/product/4070&#34;&gt;部品リストと回路図&lt;/a&gt;が載っているのでこれを見ながら組み立てて行くしかありません……。&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;これが滅茶苦茶大変です。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;オススメのやり方は最初に部品リストの順番通りに部品を並べてから半田付けを始めることです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/7ff3ab54-423f-7402-cad2-c53d798258f9.jpeg&#34; alt=&#34;部品並べ&#34; /&gt;&lt;/p&gt;
&lt;p&gt;抵抗などは下記のページで抵抗値を入力して5本色帯カラーコードに変換しながら照らし合わせると間違いづらいです。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.desmots.net/hitme/audio/iroobi.php&#34;&gt;抵抗 - カラーコード（4本・5本色帯）変換 - 計算ツール&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;font-color-red-注意点-font&#34;&gt;&lt;font color=&#34;red&#34;&gt;注意点!!&lt;/font&gt;&lt;/h3&gt;
&lt;p&gt;さて、いよいよ半田付け・・・&lt;strong&gt;と、ちょっと待ってください!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部品を整理したら&lt;font color=&#34;Red&#34;&gt;&lt;strong&gt;&lt;u&gt;Q4の場所につけるトランジスタ（S9014）をトランジスタ（S8050）に差し替えてください。&lt;/u&gt;&lt;/strong&gt;&lt;/font&gt;
組み立ててから気づいたのですが、ここの部品をすり替えないと組み上がった後正常に動作しません。（予備に2つ基板を買って試しましたがどちらも同じ結果でした）&lt;/p&gt;
&lt;p&gt;部品を差し替えたら今度こそ半田付けをします。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;電解コンデンサ、LED、ダイオード&lt;/strong&gt;は取り付け向きが決まっているので注意しましょう。
電解コンデンサ、LEDは2本ある足の長い方が+側。ダイオードは黒く模様がついている方向を基板の模様と合わせてください。&lt;/p&gt;
&lt;p&gt;無事、組み終わったものがこちらです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/7d0c5023-7edd-ee18-68de-ce8716f791c5.jpeg&#34; alt=&#34;センサ完成&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;試してみる&#34;&gt;試してみる&lt;/h3&gt;
&lt;p&gt;図のような簡単な回路を組んで、ちゃんと動くか試して見ましょう。
拍手スイッチの&lt;strong&gt;Power（入力電圧）は5Vではなく3.3V&lt;/strong&gt;であることに注意してください。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/ff0c1050-c860-4a07-46e8-7ef7e59306d4.png&#34; alt=&#34;AKIT_TEST.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;2&#34;&gt;&lt;u&gt;今回Fritzing用に拍手制御スイッチ（AKIT-107）のカスタムパーツを作りましたので&lt;a href=&#34;https://github.com/TakedaHiromasa/Fritzing/blob/master/aitendo_AKIT-107.fzpz&#34;&gt;こちら&lt;/a&gt;からDLできます。
よかったらどうぞ。&lt;/u&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;回路を組んだらセンサの上で手を叩いて見ます。手を叩くたびにLEDが点灯・消灯すれば成功です！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/50c1369b-9a73-538a-d7da-c8730fc0f0d0.gif&#34; alt=&#34;Claptest.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;（これが楽しくて、30分ぐらいセンサーの上で手を叩いてました。）&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&#34;サーボの原点合わせ&#34;&gt;サーボの原点合わせ&lt;/h2&gt;
&lt;p&gt;今回用意した「デジタル・マイクロサーボ SG90」は「Amazon Dash Button」を押すのに使います。まずはサーボの原点合わせを行いましょう。&lt;/p&gt;
&lt;p&gt;今回使用するSG90は0~180°まで回るのですが、買った初期状態ではどこを向いているのかわからないので原点として初めに&lt;strong&gt;90°&lt;/strong&gt;に位置合わせを行います。&lt;/p&gt;
&lt;p&gt;まず以下のようにサーボとArduinoを繋ぎましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/7de1f622-c738-1667-9575-601c877556e3.png&#34; alt=&#34;sarvo.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;そして以下のプログラムを書き込んで実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;Servo.h&amp;gt;
Servo myservo;
void setup() {
myservo.attach( 10 );
}
void loop() {
myservo.write( 90 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでサーボの原点が決まったので、付属のホーンを以下のように真上を向くようにつけます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/a66bca6c-f673-4f92-adea-23871a836489.jpeg&#34; alt=&#34;DSC_0577.JPG&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;全体の配線&#34;&gt;全体の配線&lt;/h3&gt;
&lt;p&gt;いよいよ全体の配線！
以下のように配線します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/16a09bda-31dc-1e91-ec16-cdaa9535296b.png&#34; alt=&#34;全体&#34; /&gt;&lt;/p&gt;
&lt;p&gt;「サーボ」と「Amazon Dash Button」は輪ゴムで合体させました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/aa85d4a4-ac2d-4800-dcfe-f248b70bbe7c.png&#34; alt=&#34;Screenshot_2018-09-17-00-05-37.png&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;以下のプログラムを書き込みます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;Servo.h&amp;gt;
Servo myservo;
volatile int flag = 0;
void interruptsw()
{
flag = 1;
}
void setup() {
myservo.attach( 10 );
attachInterrupt(0, interruptsw, CHANGE);
}
void loop() {
if(flag == 1){
myservo.write( 45 );
delay(500);
flag = 0;
}else{
myservo.write( 90 );
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今回のプログラムのポイントは&lt;strong&gt;割り込み処理&lt;/strong&gt;と&lt;strong&gt;volatile&lt;/strong&gt;です。&lt;/p&gt;
&lt;h3 id=&#34;割り込み処理&#34;&gt;割り込み処理&lt;/h3&gt;
&lt;p&gt;割り込み処理とは簡単に言えば、&lt;strong&gt;「イベントが起こった時に、コンピュータがどんな処理をしていようと無理やり別の処理を割り込ませる」&lt;/strong&gt;というもの。&lt;/p&gt;
&lt;p&gt;今回のプログラムの場合&lt;strong&gt;attachInterrupt(0, interruptsw, CHANGE);&lt;/strong&gt;で、&lt;strong&gt;どのピンのどんなイベントを監視するか指定&lt;/strong&gt;しています。指定の仕方は、&lt;strong&gt;attachInterrupt([監視するピン], [割り込ませる処理], [反応するイベントの種類]);&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;Arduino Unoでは監視するピンは&lt;strong&gt;0か１&lt;/strong&gt;しか指定できなく、それぞれ&lt;strong&gt;pin2, pin3&lt;/strong&gt;に対応しています。&lt;/p&gt;
&lt;p&gt;今回のプログラムの&lt;strong&gt;attachInterrupt(0, interruptsw, CHANGE);&lt;/strong&gt;とは&lt;strong&gt;「&lt;font color=&#34;Red&#34;&gt;2pin&lt;/font&gt;の信号が&lt;font color=&#34;Red&#34;&gt;CHANGE&lt;/font&gt;（変化するたび）&lt;font color=&#34;Red&#34;&gt;interruptsw&lt;/font&gt;を実行してね」&lt;/strong&gt;という指定をしていることになります。&lt;/p&gt;
&lt;h3 id=&#34;volatile&#34;&gt;volatile&lt;/h3&gt;
&lt;p&gt;volatileとは&lt;strong&gt;「この変数に関係する部分は消さないで！」&lt;/strong&gt;という指定。&lt;/p&gt;
&lt;p&gt;どういうことかというと、プログラムをよく見てもらうと&lt;u&gt;volatileをつけているflagという変数はloop()の中で、何の計算にも使われていません（足すとか引くとか）。&lt;/u&gt;loop()の中では、&lt;strong&gt;if(flag == 1)&lt;/strong&gt;の部分でフラグが１になることを待っていますが、コンピュータはかしこい？ので、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flagはloop()の中で計算に使ってない&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;↓&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;計算に使ってないならflagの値が増えたり減ったりすることは一生ないんじゃね？&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;↓&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;じゃあ「flag == 1」になることはありえんね、無駄なんでif文消しまーす&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;↓&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;俺優秀☆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;という具合に&lt;strong&gt;最悪の場合勝手にif文を消します&lt;/strong&gt;。
私たちからすれば「そこは割り込みが起こった時に1が代入されるんだけど・・・」と思いますがコンピュータは知ったこっちゃありません。ということで、計算には使ってないけど割り込みなどで確実に値が変化する変数については&lt;strong&gt;volatile&lt;/strong&gt;をつけて消されないようにしてあげます。&lt;/p&gt;
&lt;h2 id=&#34;実際に使ってみる&#34;&gt;実際に使ってみる&lt;/h2&gt;
&lt;p&gt;さて、難しい話はこれぐらいにして早速完成したデバイスを使ってみましょう！&lt;/p&gt;
&lt;p&gt;より雰囲気を出すために&lt;u&gt;フリー素材のおじさまウェイターの画像をA3用紙4枚刷りで印刷し、そこにデバイスを貼り付けました。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/259617/f505fed2-0763-3db7-4e7c-6e9df474b17e.jpeg&#34; alt=&#34;DSC_0571.JPG&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size =&#34;4&#34;&gt;いざ起動・・・・！！！&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/XlFNMBB7lt4&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size =&#34;4&#34;&gt;&lt;strong&gt;無事、手を叩いただけでディナーが届きました！！！！！&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;「シーチキン」の「Amazon Dash Button」を使ったのでシーチキンが届きました。今回使った拍手センサは使い方も簡単なので、他にも音で動くデバイスを作ってみると面白いと思います！&lt;/p&gt;
&lt;p&gt;それでは、みなさん良きセレブライフをー！&lt;/p&gt;</description></item><item><title>【ハンズオン資料】Nefry BTと人感センサで防犯LINE BOTを作ってみよう</title><link>https://dotstud.io/blog/nefrybt-handson-pir-linebot/</link><pubDate>Thu, 30 Aug 2018 09:40:24 +0900</pubDate><guid>https://dotstud.io/blog/nefrybt-handson-pir-linebot/</guid><description>
&lt;p&gt;この記事は8/30の&lt;a href=&#34;https://algyan.connpass.com/event/90564/&#34;&gt;IoT超入門！「Nefry BT」無料お試し体験ハンズオン！&lt;/a&gt;向け資料です。&lt;strong&gt;記事を読んで試せる内容&lt;/strong&gt;になっているので、参加されていない方もぜひ試してみてください！&lt;/p&gt;
&lt;p&gt;最終的にはこんなものが出来上がります。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/a2548f0ff2534496f75b85e87b5b629d&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/a2548f0ff2534496f75b85e87b5b629d.gif&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■ハンズオンの進行について&lt;/p&gt;
ハンズオンはこのページに沿って進めます。進められる方は、どんどん進めていきましょう！リンクは別タブや別ウィンドウで開くのがオススメです。
&lt;/section&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■Nefry BTドキュメントについて&lt;/p&gt;
この授業に合わせて諸々リニューアルしたため、WIP状態の部分が多いです。ご了承ください（わかりづらい部分ぜひ教えてください）。近日中にアップデートします。
&lt;/section&gt;
&lt;h2 id=&#34;今回やってみること&#34;&gt;今回やってみること&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;人が近づくと自分のLINEに通知がくる仕組み&lt;/strong&gt;を、Nefry BT、LINE（、Azure）を使って作ってみます。近づくと点灯する玄関の防犯ライトに近いイメージです。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/architecture.png&#34; alt=&#34;architecture&#34;&gt;
&lt;/center&gt;
&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;
&lt;h4 id=&#34;nefry-bt-ディスプレイ&#34;&gt;■Nefry BT＆ディスプレイ&lt;/h4&gt;
&lt;p&gt;Nefry BTは「ESP-WROOM-32」というWi-Fi・BLE通信モジュールを搭載した、Arduinoと同じように開発できるマイコンボードです。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/nefry.png&#34; alt=&#34;nefry&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/docs/grove/&#34;&gt;Grove&lt;/a&gt;という刺すだけで配線できるモジュール対応のコネクタを搭載していて、&lt;strong&gt;ハードウェアをあまり意識せず&lt;/strong&gt;に開発できます。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;grove-pirモーションセンサ&#34;&gt;■Grove PIRモーションセンサ&lt;/h4&gt;
&lt;p&gt;刺すだけで配線できる&lt;a href=&#34;https://dotstud.io/docs/grove/&#34;&gt;Grove&lt;/a&gt;シリーズの、人感センサです。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/motion_sensor.png&#34; alt=&#34;motion_sensor&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arduino-ide&#34;&gt;■Arduino IDE&lt;/h4&gt;
&lt;p&gt;開発（プログラムの書き込み）には&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;Arduino IDE&lt;/a&gt;というフリーソフトウェアを利用します。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;こちら&lt;/a&gt;の手順を見ながらご自身のPCにインストールしてください。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;lineアカウント&#34;&gt;■LINEアカウント&lt;/h4&gt;
&lt;p&gt;今回はLINE通知の機能を作成します。LINEアカウントをご用意ください。&lt;/p&gt;
&lt;p&gt;また、PCから設定する際にメールアドレスでのログインが必要になります。あらかじめスマートフォンアプリでメールアドレスを設定しておいてください。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;azureアカウント&#34;&gt;■Azureアカウント&lt;/h4&gt;
&lt;p&gt;WIP&lt;/p&gt;
&lt;h2 id=&#34;事前準備-セットアップ&#34;&gt;事前準備（セットアップ）&lt;/h2&gt;
&lt;h3 id=&#34;nefry-btのwi-fi設定&#34;&gt;Nefry BTのWi-Fi設定&lt;/h3&gt;
&lt;p&gt;まずはNefry BTがインターネットにつながるよう、会場のWi-Fi情報をNefry BTに教えてあげます。&lt;/p&gt;
&lt;p&gt;Nefry BTとPCを直接通信させ（アドホックモード）、立ち上がるNefryポータル（設定ウィンドウ）からSSIDとパスワードを入力する手順です。&lt;a href=&#34;https://dotstud.io/docs/nefrybt-setup-wifi/&#34;&gt;こちら&lt;/a&gt;の手順を見ながら進めてみてください。&lt;/p&gt;
&lt;p&gt;一度設定したら、同じWi-Fiを使っている間は起動するだけで接続されます。Wi-Fi情報は5つまで保存でき、消去もできます。&lt;/p&gt;
&lt;h3 id=&#34;開発環境-arduino-ide-にボードを追加&#34;&gt;開発環境（Arduino IDE）にボードを追加&lt;/h3&gt;
&lt;p&gt;Nefty BTの開発にはフリーソフトウェアの&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;Arduino IDE&lt;/a&gt;を利用します。インストールがまだの方は「&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;Arduino IDEのインストール&lt;/a&gt;」を見ながら進めてください。&lt;/p&gt;
&lt;p&gt;Arduino IDEには、Nefry BTのボード情報の追加が必要です。「&lt;a href=&#34;https://dotstud.io/docs/nefrybt-setup-arduino-ide/&#34;&gt;環境構築（Arduino IDE）&lt;/a&gt;」を見ながら追加してください。&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■PCにUSB接続できない方&lt;/p&gt;
セキュリティやポートの問題でPCにUSB接続できない方は、&lt;a href=&#34;https://dotstud.io/docs/nefrybt-program-zip/&#34;&gt;Wi-Fi経由でプログラムの書き込み&lt;/a&gt;が可能です。給電はコンセントやモバイルバッテリーから直接行ってください。
&lt;/section&gt;
&lt;h2 id=&#34;はじめてのプログラムを書き込んでみる&#34;&gt;はじめてのプログラムを書き込んでみる&lt;/h2&gt;
&lt;p&gt;まずはNefry BTに簡単なプログラムを書き込んでみましょう。Nefry BTは、最初から下記の機能が搭載されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内蔵フルカラーLED&lt;/li&gt;
&lt;li&gt;スイッチ（SW/RST）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;まずはlチカ&#34;&gt;まずはLチカ&lt;/h3&gt;
&lt;p&gt;最初のプログラムとして、Lチカをやってみます。LEDチカチカの略で、Webでいう”Hello, World!”です。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arduino-ideでプログラムを書く&#34;&gt;■Arduino IDEでプログラムを書く&lt;/h4&gt;
&lt;p&gt;Arduino IDEを立ち上げ、メニューから&lt;strong&gt;&lt;code&gt;ファイル &amp;gt; 新規ファイル&lt;/code&gt;&lt;/strong&gt;を選択します。下記のような画面が開きます。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/ide.png&#34; alt=&#34;ide&#34;&gt;
&lt;/center&gt;
&lt;p&gt;エディタ部分に、下記のプログラムをコピーして貼り付けましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
void setup() {
}
void loop() {
Nefry.setLed(0, 0, 255); //色合いをRGBで指定
Nefry.ndelay(1000); //1秒待つ
Nefry.setLed(0, 0, 0); //LEDをオフにする
Nefry.ndelay(1000); //1秒待つ
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下記でプログラムの内容を解説しています。&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■PCにUSB接続できない方&lt;/p&gt;
セキュリティやポートの問題でPCにUSB接続できない方は、&lt;a href=&#34;&#34;&gt;Wi-Fi経由でプログラムのアップロード&lt;/a&gt;が可能です。その場合、下記の書き込み手順は不要です。給電はコンセントやモバイルバッテリーから直接行ってください。
&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;ボードを選択&#34;&gt;■ボードを選択&lt;/h4&gt;
&lt;p&gt;メニューの&lt;strong&gt;&lt;code&gt;ツール &amp;gt; ボード &amp;gt; Nefry BT R2 / R3&lt;/code&gt;&lt;/strong&gt;を選択します。この際、ボードは使っているリビジョンに合わせて選択してください。（参照：&lt;a href=&#34;https://dotstud.io/docs/nefrybt-setup-revision/&#34;&gt;リビジョンを確認&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;例えば、使っている基板がR3の場合は&lt;strong&gt;&lt;code&gt;ツール &amp;gt; ボード &amp;gt; Nefry BT R2 / R3&lt;/code&gt;&lt;/strong&gt;を選択します。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/select_board.png&#34; alt=&#34;select_board&#34;&gt;
&lt;/center&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/select_board2.png&#34; alt=&#34;select_board2&#34;&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;シリアルポートを選択&#34;&gt;■シリアルポートを選択&lt;/h4&gt;
&lt;p&gt;Nefry BTをPCのUSBポートにさします。プログラムはこのポートを介して、シリアル通信でNefry BTに流し込まれます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/docs/nefrybt/power_supply.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Macの場合は、メニューの&lt;strong&gt;&lt;code&gt;ツール &amp;gt; シリアルポート &amp;gt; /dev/cu.usbserial-xxxxxx&lt;/code&gt;&lt;/strong&gt;を選択します。環境によっては&lt;strong&gt;&lt;code&gt;/dev/tty.usbserial-xxxxxx&lt;/code&gt;&lt;/strong&gt;などの場合もあります。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/select_port.png&#34; alt=&#34;select_port&#34;&gt;
&lt;/center&gt;
&lt;p&gt;Windowsの場合は、&lt;strong&gt;&lt;code&gt;ツール &amp;gt; シリアルポート &amp;gt; /dev/COM-XX&lt;/code&gt;&lt;/strong&gt;を選択します。&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;2&#34;&gt;
※Nefry BTを抜き差しすると、シリアルポートの選択が解除される場合があります。適宜確認しましょう。
&lt;/font&gt;&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■シリアルポートが選択できない方&lt;/p&gt;
USBドライバのインストールが必要な場合があります。&lt;a href=&#34;&#34;&gt;こちら&lt;/a&gt;を参照して、USBを認識させるためのドライバをインストールしてください。また、Arduino IDEの再起動やUSBの抜き差しで認識する場合があります。
&lt;/section&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;名前をつけて保存&#34;&gt;■名前をつけて保存&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ファイル&amp;gt;名前をつけて保存&lt;/code&gt;&lt;/strong&gt;を選択して保存します。「NefryLedBlink」など、後からみてわかりやすい名前がオススメです。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;プログラムを書き込む&#34;&gt;■プログラムを書き込む&lt;/h4&gt;
&lt;p&gt;「✔️」を押してプログラムをコンパイルします。
&lt;img src=&#34;https://dotstud.io/img/docs/nefrybt/compile.png&#34; alt=&#34;&#34; /&gt;
この手順は省略しても大丈夫ですが、シンタックス（文法）チェックをしてくれるので実施するのがオススメです。&lt;/p&gt;
&lt;p&gt;左上の「→」ボタンを押してNefry BTにプログラムを書き込みます。
&lt;img src=&#34;https://dotstud.io/img/docs/nefrybt/write.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ESP32モジュールの特性上、書き込みに1分ほどかかります。エラーが出てしまうときは、「&lt;a href=&#34;https://dotstud.io/docs/nefrybt-error-handling-2/&#34;&gt;コンパイルは成功するのに書き込みが失敗する&lt;/a&gt;」を参照してください。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;動作を確認&#34;&gt;■動作を確認&lt;/h4&gt;
&lt;p&gt;起動したら、「青いLEDが1秒ごとに光る」ことを確認しましょう。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/801e9ff4982f3326e6f1c3a133fd8de3&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/801e9ff4982f3326e6f1c3a133fd8de3.gif&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;プログラムの解説&#34;&gt;■プログラムの解説&lt;/h4&gt;
&lt;p&gt;プログラムの要所を説明していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;冒頭でライブラリを読み込んでいます。Nefry BTのライブラリでできることは「&lt;a href=&#34;https://dotstud.io/docs/nefrybt-liblary/&#34;&gt;Nefryのライブラリ&lt;/a&gt;」を参照してください。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setup() {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;起動時に処理される部分です。今回はなにもしません。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loop() {
Nefry.setLed(0, 0, 255); //色合いをRGBで指定
Nefry.ndelay(1000); //1秒待つ
Nefry.setLed(0, 0, 0); //LEDをオフにする
Nefry.ndelay(1000); //1秒待つ
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;起動時に繰り返し実行する部分です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nefry.setLed()&lt;/code&gt;という関数で、光らせる色合いをRGBの順で指定します。始めにR=0, G=0, B=255を渡しているので、青く光ります。&lt;/p&gt;
&lt;p&gt;続いて&lt;code&gt;Nefry.ndelay()&lt;/code&gt;という関数で次の処理まで指定した時間待ちます。Arduinoでは時間はミリ秒で指定するので、1000は1秒です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nefry.setLed()&lt;/code&gt;に0, 0, 0を渡すことで、LEDはオフになります。オンとオフのあと1秒ずつ待つことで、点滅を表現しています。&lt;/p&gt;
&lt;h3 id=&#34;スイッチを押したらlチカ&#34;&gt;スイッチを押したらLチカ&lt;/h3&gt;
&lt;h4 id=&#34;arduino-ideでプログラムを書く-1&#34;&gt;■Arduino IDEでプログラムを書く&lt;/h4&gt;
&lt;p&gt;同様の手順で新規ファイルを作成し、下記のプログラムをNefry BTに書き込みます。おさらいがてら、やってみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
void setup() {
// スイッチを有効化
Nefry.enableSW();
}
void loop() {
// スイッチが押されたら
if (Nefry.readSW()) {
Nefry.setLed(255, 0, 0);
Nefry.ndelay(1000);
}
// 青色に戻す
Nefry.setLed(0, 0, 255);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下記でプログラムの内容を解説しています。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;動作を確認-1&#34;&gt;■動作を確認&lt;/h4&gt;
&lt;p&gt;スイッチ（RSTではない方）を押したら、LEDが赤く光ることを確認します。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/73185cad56d6374e6ad394eafbfef51d&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/73185cad56d6374e6ad394eafbfef51d.gif&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;プログラムの解説-1&#34;&gt;■プログラムの解説&lt;/h4&gt;
&lt;p&gt;プログラムの要所を説明します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setup() {
// スイッチを有効化
Nefry.enableSW();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;起動時の処理では、&lt;code&gt;Nefry.enableSW()&lt;/code&gt;という関数でスイッチを有効化しています。マイコンボードでは、入力・出力に使うピンなどは&lt;code&gt;setup()&lt;/code&gt;関数内で有効化します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loop() {
// スイッチが押されたら
if (Nefry.readSW()) {
Nefry.setLed(255, 0, 0);
Nefry.ndelay(1000);
}
// 青色に戻す
Nefry.setLed(0, 0, 255);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if(){}&lt;/code&gt;という条件式で、スイッチが押されたことを取得します。スイッチが押されたら1秒間赤いLEDを光らせます。スイッチが押されている以外のときは、青色のLEDを光らせます。&lt;/p&gt;
&lt;h2 id=&#34;オフラインでgroveセンサを試す&#34;&gt;オフラインでGroveセンサを試す&lt;/h2&gt;
&lt;p&gt;次は、配線してセンサのデータを取得してみます。&lt;strong&gt;まずはインターネットに繋がらない電子工作&lt;/strong&gt;、です。&lt;/p&gt;
&lt;p&gt;エラーの切り分け（どこでエラーが起こっているか）を特定するために、自分で開発するときもステップバイステップでできているか確認しつつ進めるのがオススメです。&lt;/p&gt;
&lt;h3 id=&#34;grove-pirモーションセンサを接続&#34;&gt;Grove PIRモーションセンサを接続&lt;/h3&gt;
&lt;p&gt;Groveは刺すだけで配線できるのでGNDや信号線などの確認は必要ありませんが、デジタル・アナログ・I2Cなどの通信方法はGroveモジュールによって違います。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/seeed_wiki.png&#34; alt=&#34;seeed_wiki&#34;&gt;
&lt;/center&gt;
&lt;p&gt;PIRモーションセンサの製造元・SeeedStudioの&lt;a href=&#34;http://wiki.seeedstudio.com/Grove-PIR_Motion_Sensor/&#34;&gt;Wikiページ&lt;/a&gt;を見てみると、デジタルで読みとることがわかります。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/connection.png&#34; alt=&#34;connection&#34;&gt;
&lt;/center&gt;
Nefry BTのデジタル入力に対応する、「D2」というソケットに差し込みます。少し硬いですが、カチッと言うまで押し込めます。&lt;strong&gt;配線作業は常に電源オフの状態&lt;/strong&gt;で行います。&lt;/p&gt;
&lt;section class=&#34;caution&#34;&gt;
&lt;p&gt;■Nefry BT（無印）を使っている方&lt;/p&gt;
Nefry BT（無印）において、D0・D1ピンはディスプレイの制御（I2C通信）に使用されているため、正常に動作しないことがあります（Nefry BT R2以降では修正されています）。リビジョンの調べ方は「&lt;a href=&#34;https://dotstud.io/docs/nefrybt-setup-revision/&#34;&gt;リビジョンの確認&lt;/a&gt;」をご参照ください。
&lt;/section&gt;
&lt;h3 id=&#34;プログラムを書き込む-1&#34;&gt;プログラムを書き込む&lt;/h3&gt;
&lt;h4 id=&#34;プログラム&#34;&gt;■プログラム&lt;/h4&gt;
&lt;p&gt;以下のプログラムをNefry BTに書き込みます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#define PIR_MOTION_SENSOR D2
void setup()
{
pinMode(PIR_MOTION_SENSOR, INPUT);
}
void loop()
{
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;書き込み手順は、上記の「&lt;a href=&#34;#はじめてのプログラムを書き込んでみる&#34;&gt;はじめてのプログラムを書き込んでみる&lt;/a&gt;」を参照してくださいね。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;動作を確認-2&#34;&gt;■動作を確認&lt;/h4&gt;
&lt;p&gt;メニューの&lt;strong&gt;&lt;code&gt;ツール&amp;gt;シリアルモニタ&lt;/code&gt;&lt;/strong&gt;を選択して開きます。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/serial_monitor.png&#34; alt=&#34;serial_monitor&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;右下のbps設定を「115200bps」に変更します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/bps.png&#34; alt=&#34;bps&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;人感センサに手をかざすと、シリアルモニタに「誰かきたよ」というメッセージが流れます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/adaf9534c9e944f3131336058a304671&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/adaf9534c9e944f3131336058a304671.gif&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;プログラムの解説-2&#34;&gt;■プログラムの解説&lt;/h4&gt;
&lt;p&gt;プログラムの要所を解説します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define PIR_MOTION_SENSOR D2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;で、配線したピンの場所を定義しています。「PIR_MOTION_SENSOR」という名前の箱に「D2」という値を入れているイメージです。&lt;/p&gt;
&lt;p&gt;こうしておくことで、あとでピンの場所を変えても、ここの値だけ変更すればOKになります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setup()
{
pinMode(PIR_MOTION_SENSOR, INPUT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setup関数内ではスイッチのとき同様、今回使うピンを有効化しています。&lt;code&gt;pinMode({ピンの場所}, {モード})&lt;/code&gt;で指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loop()
{
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;loop関数では、モーションセンサに入力があったとき/それ以外のときで処理を分けています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;digitalRead({ピン番号})&lt;/code&gt;で指定したピンの信号を読み取っていて、戻り値は「人を検知している = HIGH」「検知していない = LOW」です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if(digitalRead(PIR_MOTION_SENSOR)) {}&lt;/code&gt; の部分は&lt;code&gt;if(digitalRead(PIR_MOTION_SENSOR) == HIGH) {&lt;/code&gt;と同義で、比較演算子を省略するとHIGHのときにに実行されます。&lt;/p&gt;
&lt;p&gt;200ミリ秒待つことで、0.2秒に1回センサの値をチェックするようになっています。&lt;/p&gt;
&lt;h2 id=&#34;lineに通知してみる&#34;&gt;LINEに通知してみる&lt;/h2&gt;
&lt;p&gt;それでは、人感センサが検知したら（= 人が来たら）自分のLINEに通知がくるようにしてみましょう。LINEが提供している、LINE Notifyというサービスを使っていきます。&lt;/p&gt;
&lt;h3 id=&#34;lineの設定&#34;&gt;LINEの設定&lt;/h3&gt;
&lt;h4 id=&#34;line-notifyアカウントと友達になる&#34;&gt;■LINE Notifyアカウントと友達になる&lt;/h4&gt;
&lt;p&gt;LINE Notifyでは、「LINE Notify」というアカウントからメッセージが届きます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/109f4aa667871bcdb82342d6e2ac3233.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;まずはQRコードを読み取り、アカウントと友達になっておきましょう。&lt;/p&gt;
&lt;h4 id=&#34;トークンを作成&#34;&gt;■トークンを作成&lt;/h4&gt;
&lt;p&gt;自分のLINEと紐付けるために、トークン（鍵のようなもの）を発行します。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://notify-bot.line.me/my/&#34;&gt;LINE Notifyの設定ページ&lt;/a&gt;にいき、「トークンを発行する」ボタンを押します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/token_button.png&#34; alt=&#34;token_button&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;下記のようなウィンドウが表示されます。「トークン名」にはLINE Notifyが何のサービスと連携したかわかる名前をつけましょう。通知するルームは、今回は「1:1」を選択します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/token_config.png&#34; alt=&#34;token_config&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;トークンが発行されたら、コピーしてメモしておきます（あとで使います）。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/token_create.png&#34; alt=&#34;token_create&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;h3 id=&#34;プログラムを書き込む-2&#34;&gt;プログラムを書き込む&lt;/h3&gt;
&lt;h4 id=&#34;プログラム-1&#34;&gt;■プログラム&lt;/h4&gt;
&lt;p&gt;以下のプログラムをNefry BTに書き込みます。すごく長いですが、後ほど説明します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;NefryLineNotify.h&amp;gt;
#define PIR_MOTION_SENSOR D2
String auth, message;
void setup() {
pinMode(PIR_MOTION_SENSOR, INPUT);
Nefry.setStoreTitle(&amp;quot;LINE Auth&amp;quot;,0);
Nefry.setStoreTitle(&amp;quot;LINEMessage&amp;quot;,1);
auth = Nefry.getStoreStr(0);
message = Nefry.getStoreStr(1);
Nefry.enableSW();
}
void loop() {
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
if (!LineNotify.send(auth, message)) {
Nefry.setLed(255, 0, 0);
}
Nefry.ndelay(1000*30);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;書き込み手順は、上記の「&lt;a href=&#34;#はじめてのプログラムを書き込んでみる&#34;&gt;はじめてのプログラムを書き込んでみる&lt;/a&gt;」を参照してくださいね。&lt;/p&gt;
&lt;h3 id=&#34;nefry-btにトークン情報を設定&#34;&gt;Nefry BTにトークン情報を設定&lt;/h3&gt;
&lt;p&gt;ディスプレイに表示されているIPアドレスに接続し、&lt;a href=&#34;https://dotstud.io/docs/nefrybt-basic-portal/&#34;&gt;Nefryポータル&lt;/a&gt;を開きます。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/nefry_portal.png&#34; alt=&#34;nefry_portal&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;「DataStore」のページに行くと2つのフォームが用意されているので、「LINE Auth」には先ほどコピーしたトークン、「LINEMessage」には送りたいメッセージを入力します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/215/nefry_config.png&#34; alt=&#34;nefry_config&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;動作を確認-3&#34;&gt;■動作を確認&lt;/h4&gt;
&lt;p&gt;さっそく完成したものを動かしてみましょう。&lt;/p&gt;
&lt;p&gt;センサに人が近づくと……&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/a2548f0ff2534496f75b85e87b5b629d&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/a2548f0ff2534496f75b85e87b5b629d.gif&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LINEに通知されました！&lt;/p&gt;
&lt;p&gt;完成できた方、お疲れ様でした〜！&lt;/p&gt;
&lt;h3 id=&#34;プログラムの解説-3&#34;&gt;プログラムの解説&lt;/h3&gt;
&lt;p&gt;例のすごく長いコードについて、要所を説明します。大事なところはちょっとだけです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setup() {
pinMode(PIR_MOTION_SENSOR, INPUT);
Nefry.setStoreTitle(&amp;quot;LINE Auth&amp;quot;,0);
Nefry.setStoreTitle(&amp;quot;LINEMessage&amp;quot;,1);
auth = Nefry.getStoreStr(0);
message = Nefry.getStoreStr(1);
Nefry.enableSW();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Nefry.setStoreTitle({タイトル}, {チャンネル番号})&lt;/code&gt;関数を使い、Nefry BTのDataStore機能に場所を作っています。この値はNefryポータル側から入力でき、変更があってもプログラムを書き換える必要はありません。&lt;/p&gt;
&lt;p&gt;また値を&lt;code&gt;getStoreStr({チャンネル番号})&lt;/code&gt;で、ポータル側で設定した値を受け取っています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loop() {
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
if (!LineNotify.send(auth, message)) {
Nefry.setLed(255, 0, 0);
}
Nefry.ndelay(1000*30);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先ほど同様人感センサが検知したとき、という条件文を作っています。&lt;code&gt;LineNotify.send()&lt;/code&gt;関数を使い、もし送れなかったときは赤いLEDを光らせるという処理をしています（&lt;code&gt;!&lt;/code&gt;は&lt;code&gt;!==&lt;/code&gt;と同義で、&lt;code&gt;FALSE&lt;/code&gt;が返ったときに実行されます）。&lt;/p&gt;
&lt;p&gt;何度も連続してLINEが来るとウザいので、一度送ったあとは30秒待ちます。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;LINE送信を実装している部分です、が、これ以降は&lt;strong&gt;気にしなくていいです&lt;/strong&gt;。この部分は&lt;a href=&#34;https://dotstud.io/docs/nefrybt-default/&#34;&gt;初期プログラム&lt;/a&gt;をコピーして作っています。たぶん近々ライブラリ化されます。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;LINE Notifyがライブラリ化されたので編集しました！&lt;/p&gt;
&lt;h2 id=&#34;応用課題-データをクラウドに送ってみる-ロギング&#34;&gt;応用課題: データをクラウドに送ってみる（ロギング）&lt;/h2&gt;
&lt;p&gt;WIP（追記します）&lt;/p&gt;
&lt;h2 id=&#34;関連情報&#34;&gt;関連情報&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://dotstud.io/shop/nefry-bt-set/&#34;&gt;Nefr BTの購入&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Nefry BTはこちらから購入できます（送料無料）。その他にも千石電商、ツクモ、若松通商、共立電子などの実店舗やECサイトで購入できます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://dotstud.io/docs/nefrybt/&#34;&gt;Nefry BTドキュメント&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Nefry BTでは、IFTTTを使ったWebサービスとの連携や、その他のクラウドサービスとの連携も簡単です。ディスプレイを使ったイラスト描画や、100以上あるGroveモジュールの活用なども、ぜひ試してみてください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://www.facebook.com/groups/nefry&#34;&gt;Nefryユーザーグループ（FB）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Nefryユーザ同士が交流するページです。質問を投稿して解決した事例もたくさんありますので、困った際などはぜひお気軽にご利用ください。開発者もよく登場します。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://nefry.connpass.com/event/97692/&#34;&gt;Nefry User Meetup!&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Nefryユーザによる開催イベントです。ハンズオンやLT会、もくもく会などを実施しています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://dotstudio.connpass.com/&#34;&gt;dotstudioイベント&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;dotstudioによる開催イベントです。Nefry BT以外の題材を扱うことも多いです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;style&gt;
.caution {
border: 1px solid #BFBFBF;
padding: 1em 2em;
margin: 2em 0;
color: #474747;
background: whitesmoke;/*背景色*/
border-left: double 7px #0B0B61;/*左線*/
font-size: 90%;
}
.caution &gt; p {
font-weight: bold;
margin: 0 0 10px 0;
padding: 0;
}
blockquote {
font-size:80%;
}
.accbox {
margin: 2em 0;
padding: 0;
max-width: 710px;
}
.accbox label {
display: block;
margin: 1.5px 0;
padding : 11px 12px;
color :#ffffff;
font-weight: bold;
background :#2f2f2f;
cursor :pointer;
transition: all 0.5s;
}
.accbox label:hover {
background :#A4A4A4;
}
.accbox input {
display: none;
}
.accbox .accshow {
height: 0;
padding: 0;
overflow: hidden;
opacity: 0;
transition: 0.8s;
}
.cssacc:checked + .accshow {
height: auto;
padding: 5px;
background: #eaeaea;
opacity: 1;
}
&lt;/style&gt;</description></item><item><title>PWM制御をマスターしよう！Node-REDでサーボモータを遠隔制御する方法＆初ハンズオンレポート</title><link>https://dotstud.io/blog/nefry-servo-handson-takudooon/</link><pubDate>Thu, 12 Jul 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/nefry-servo-handson-takudooon/</guid><description>
&lt;h2 id=&#34;暑さ本番-いよいよ大好きな生ビールの季節がやってまいりました&#34;&gt;暑さ本番、いよいよ大好きな生ビールの季節がやってまいりました！&lt;/h2&gt;
&lt;p&gt;みなさまいかがお過ごしでしょうか？どうも、宇宙エンジニアの&lt;a href=&#34;https://dotstud.io/members/takudooon&#34;&gt;たくろーどん&lt;/a&gt;です。毎日、暑いですね。&lt;/p&gt;
&lt;p&gt;さて先日、&lt;strong&gt;初めてハンズオンイベント&lt;/strong&gt;を企画・実施してみました！題して、「&lt;a href=&#34;https://dotstudio.connpass.com/event/91695/&#34;&gt;&lt;strong&gt;【IoT】PWM制御をマスター！Nefry BT+Node-REDでサーボモータを遠隔制御&lt;/strong&gt;&lt;/a&gt;」！&lt;/p&gt;
&lt;p&gt;「モノづくりをしたい！」「こんなものをつくりたい！」と思っても「&lt;strong&gt;こういう技術がつかえる&lt;/strong&gt;」ということを知らないと、なかなかモノづくりが進みません。&lt;/p&gt;
&lt;p&gt;なので、動くものを作りたいときに便利な&lt;u&gt;&lt;strong&gt;サーボモータとその制御方法であるPWM制御&lt;/strong&gt;をマスターし、&lt;strong&gt;PCからサーボモータを遠隔制御をしよう&lt;/strong&gt;&lt;/u&gt;というのがハンズオンの目論見です。&lt;/p&gt;
&lt;p&gt;では、ちらっとハンズオンの内容を振り返ってみたいと思います。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/1.png&#34; alt=&#34;1&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;h2 id=&#34;pwm制御を用いたプログラムの書き方&#34;&gt;PWM制御を用いたプログラムの書き方&lt;/h2&gt;
&lt;h3 id=&#34;pwm制御について&#34;&gt;PWM制御について&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/docs/pulse-width-modulation/&#34;&gt;PWM制御の大まかな説明&lt;/a&gt;は以前、ドキュメントに書きました。ようするに、PWM制御は「&lt;strong&gt;パルスのオン・オフ繰り返し切り替えることで出力される電力を制御&lt;/strong&gt;」するという意味です。&lt;/p&gt;
&lt;p&gt;でも結局のところ、「&lt;strong&gt;PWM制御ってどんなイメージやねん！&lt;/strong&gt;」と多くの方が思うでしょう。&lt;/p&gt;
&lt;p&gt;なので、これがわかりやすいのではないかという説明を思いつきました。それが、下記の動画です。
&lt;img src=&#34;https://dotstud.io/img/blog/187/2.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;例えば、自宅から最寄りの駅まで走らなければならない状況を考えます。まるで、小学校の算数にでてくるたかしくんの問題を彷彿させますね。知らんけど。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;100%の力で走れば5分で駅につく ≒ 100%出力されるので、5V出力される&lt;/li&gt;
&lt;li&gt;全力で走って途中で歩くと9分で駅に着く（全体的に80%の力で走る） ≒ 80%出力されるので、4V出力される&lt;/li&gt;
&lt;li&gt;全力で走って途中で歩くと10分で駅に着く（全体的に50%の力で走る） ≒ 50%出力されるので、2.5V出力される&lt;/li&gt;
&lt;li&gt;全力で走って途中で歩くと15分で駅に着く（全体的に10%の力で走る） ≒ 10%出力されるので、0.5V出力される&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というようなイメージです。自宅から駅まで走る場合は走る速さの具合によって、到着時間が伸びます。しかし、電圧の場合は実行電圧（実際に出力される電圧）は下がっていきます。&lt;/p&gt;
&lt;h3 id=&#34;esp32開発ボードでのプログラムについて&#34;&gt;ESP32開発ボードでのプログラムについて&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/docs/nefrybt&#34;&gt;Nefry BT&lt;/a&gt;のようなESP32を搭載しているような開発ボードでPWM制御する場合は、ledc関数を使います。&lt;strong&gt;ESP32ではArduinoでつかうようなanalogWrite関数が実装されていない&lt;/strong&gt;とのことなので注意しましょう（ただし、今後変更される可能性があります）。&lt;/p&gt;
&lt;p&gt;例えば、下記のようなプログラムになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
//基本Iotは2.4GHz帯を使うこと
#include&amp;lt;Nefry.h&amp;gt;
#include&amp;quot;esp32-hal-ledc.h&amp;quot;
//PWM信号の周波数をPWMをつくっているクロック周波数で割ったもの
//ledcSetupでPWMの範囲を8bitに設定したとき、0～255　10bitのときは0～1023となる、2進数の話
#define PWM_BITWIDTH 16
//わかりやすいように角度に変換する関数/////////////////////
int deg2pw(int deg, int bit){
double ms = ((double) deg - 90.0) * 0.95 / 90.0 + 1.45;
return (int) (ms / 20.0 * pow(2, bit));
}
//////////////////////////////////////////////////////////
void setup() {
Serial.begin(115200);
//ledcSetup(チャンネル数(0～),周波数(たとえばPWMサイクル20mHzなら50Hzになるという意味(SG90の場合))、分解能は任意(ただし限度はある))
ledcSetup(0,50,PWM_BITWIDTH);
ledcAttachPin(ピン番号,0);//left_motor
Nefry.enableSW();
}
void loop(){
if((Nefry.readSW())){
ledcWrite(0,deg2pw(90, PWM_BITWIDTH));
delay(800);
ledcWrite(0,deg2pw(0, PWM_BITWIDTH));
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;プログラムの書き方&#34;&gt;プログラムの書き方&lt;/h3&gt;
&lt;p&gt;プログラムを詳しく見てましょう。&lt;/p&gt;
&lt;p&gt;ledc関数を使うため、ライブラリ「esp32-hal-ledc.h」を最初にインクルードします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;quot;esp32-hal-ledc.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ライブラリ「esp32-hal-ledc.h」を使うときの主な関数は以下に示すものです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ledcSetup（チャンネル,周波数,分解能）&lt;/li&gt;
&lt;li&gt;ledcAttachPin（ピン番号,チャンネル）：チャンネルはピン番号の識別番号です&lt;/li&gt;
&lt;li&gt;ledcWrite（チャンネル,パルス幅）：設定した角度になるように与えるべきパルス幅を算出する関数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;実際の記述は以下のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void setup() {
Serial.begin(115200);
ledcSetup(0,50,PWM_BITWIDTH);
ledcAttachPin(A2,0);//left_motor
Nefry.enableSW();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分解能は&lt;strong&gt;どれだけ細かく制御するのか&lt;/strong&gt;を表しているイメージです。これは&lt;strong&gt;ビット数&lt;/strong&gt;で表します。&lt;/p&gt;
&lt;p&gt;例えば、分解能を&lt;strong&gt;8ビットとするれば0〜255バイト&lt;/strong&gt;（2の8乗）、&lt;strong&gt;10ビットなら0〜1023バイト&lt;/strong&gt;（2の10乗）となります。&lt;/p&gt;
&lt;p&gt;これを、どのようにPWM制御に使えるのか説明します。PWM制御とは一定電圧の入力から&lt;strong&gt;パルス列のオンとオフの一定周期を作り、オンの時間幅を変化させる電力制御方式&lt;/strong&gt;のことです。つまり、&lt;strong&gt;実効電圧を変化させる&lt;/strong&gt;ことができます。&lt;/p&gt;
&lt;p&gt;なので、例えば、最大5[V]の出力を考えたとき、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分解能8ビットだと0→0[V]、127→2.5[V]、255→5[V]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分解能10ビットだと0→0[V]、511→2.5[V]、1023→5[V]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と表せます。分解能が大きい方が、細かい制御ができることがわかるかと思います。&lt;/p&gt;
&lt;h2 id=&#34;node-red-mqttでサーボモータを遠隔制御&#34;&gt;Node-RED×MQTTでサーボモータを遠隔制御&lt;/h2&gt;
&lt;h3 id=&#34;node-redとは&#34;&gt;Node-REDとは&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/9.png&#34; alt=&#34;9&#34;&gt;
&lt;/center&gt;
&lt;a href=&#34;https://nodered.jp/&#34;&gt;Node-RED&lt;/a&gt;はハードウェアデバイス/APIおよびオンラインサービスを接続するためのツールです。ウェブ上で、フローチャートのように直感的にプログラムをつくることができます。そして、最終的に自分が欲しい仕組みを作り上げるというものです。&lt;/p&gt;
&lt;p&gt;Node-REDを使うには大まかに2パターンあります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自分のPC上でローカルで動かす（今回はこちらで進めていきます）&lt;/li&gt;
&lt;li&gt;外部のサービスを利用する（IBMクラウドやenebularなど）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;導入方法は、&lt;a href=&#34;https://qiita.com/minwinmin/private/6c13d2c912d0d7e8e197&#34;&gt;こちら&lt;/a&gt;で説明していますので参考にしてください。&lt;/p&gt;
&lt;p&gt;また、後ほどNode-REDにフローのコードを貼り付ける必要があるので簡単に貼り付け方法を説明します。&lt;/p&gt;
&lt;p&gt;まずフローのコードをコピーし、Node-REDを立ち上げたら右上のメニュー（3本線）をクリックします。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/10.png&#34; alt=&#34;10&#34;&gt;
&lt;/center&gt;
すると上記のような画面があらわれます。「読み込み」をクリックして、あらわれた画面にコピーしたコードを貼り付ければ完了です。&lt;/p&gt;
&lt;h3 id=&#34;mqttとは&#34;&gt;MQTTとは&lt;/h3&gt;
&lt;p&gt;MQTTとは、&lt;strong&gt;多数のデバイスの間で短いメッセージを頻繁に送受信する&lt;/strong&gt;ことを想定した通信プロトコルです。つまりインフラのようなもの、もしくはメッセージを送受信するので土管のようなものをイメージすると良いかと思います。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/3.png&#34; alt=&#34;3&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;MQTTは先ほど説明したような仕組みの名前です。なので、実際にメッセージを送受信するためにはMQTTブローカーが必要です。イメージは下記の画像のようになります。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/4.png&#34; alt=&#34;4&#34;&gt;
&lt;/center&gt;
MQTTブローカーを用意するには、いくつか方法があります（&lt;a href=&#34;http://acro-engineer.hatenablog.com/entry/2015/06/19/120000&#34;&gt;こちらのサイト&lt;/a&gt;にまとめられています）。今回、ハンズオンでつかったの以下の2パターンです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ローカルホストでMQTTブローカーをたてる&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mcollina/mosca&#34;&gt;Mosca&lt;/a&gt;を利用する -&amp;gt; MQTT brokerのためのライブラリ（IBMクラウドのような外部サービスでNode-REDを使う場合、うまくいきませんでした）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://test.mosquitto.org/&#34;&gt;mosquitto&lt;/a&gt;のテストサーバーを利用する&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;これから記載するプログラムはこちらを使っています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;node-redのフローのコード&#34;&gt;Node-REDのフローのコード&lt;/h3&gt;
&lt;p&gt;下記のNode-REDのフローのコードを、Node-REDにコピーして使いましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
{
&amp;quot;id&amp;quot;: &amp;quot;7878093f.d68778&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;debug&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;active&amp;quot;: true,
&amp;quot;tosidebar&amp;quot;: true,
&amp;quot;console&amp;quot;: false,
&amp;quot;tostatus&amp;quot;: false,
&amp;quot;complete&amp;quot;: &amp;quot;payload&amp;quot;,
&amp;quot;x&amp;quot;: 522.0130081176758,
&amp;quot;y&amp;quot;: 161.99999809265137,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;22ca4d97.8e3382&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;inject&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;payload&amp;quot;: &amp;quot;{\&amp;quot;motor\&amp;quot;:1}&amp;quot;,
&amp;quot;payloadType&amp;quot;: &amp;quot;json&amp;quot;,
&amp;quot;repeat&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;crontab&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;once&amp;quot;: false,
&amp;quot;onceDelay&amp;quot;: 0.1,
&amp;quot;x&amp;quot;: 220.01303100585938,
&amp;quot;y&amp;quot;: 244.00000190734863,
&amp;quot;wires&amp;quot;: [
[
&amp;quot;6b18ace.785b854&amp;quot;
]
]
},
{
&amp;quot;id&amp;quot;: &amp;quot;6b18ace.785b854&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt out&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;,
&amp;quot;qos&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;retain&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;3890dddf.26f532&amp;quot;,
&amp;quot;x&amp;quot;: 508.0130386352539,
&amp;quot;y&amp;quot;: 293.9999957084656,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;e0581ff4.bce8a&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;inject&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;payload&amp;quot;: &amp;quot;{\&amp;quot;motor\&amp;quot;:0}&amp;quot;,
&amp;quot;payloadType&amp;quot;: &amp;quot;json&amp;quot;,
&amp;quot;repeat&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;crontab&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;once&amp;quot;: false,
&amp;quot;onceDelay&amp;quot;: 0.1,
&amp;quot;x&amp;quot;: 220.01303100585938,
&amp;quot;y&amp;quot;: 344.00000190734863,
&amp;quot;wires&amp;quot;: [
[
&amp;quot;6b18ace.785b854&amp;quot;
]
]
},
{
&amp;quot;id&amp;quot;: &amp;quot;3dccf617.5970da&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt in&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;,
&amp;quot;qos&amp;quot;: &amp;quot;2&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;cd2e6f9.ab8069&amp;quot;,
&amp;quot;x&amp;quot;: 235.09634399414062,
&amp;quot;y&amp;quot;: 159.3697967529297,
&amp;quot;wires&amp;quot;: [
[
&amp;quot;7878093f.d68778&amp;quot;
]
]
},
{
&amp;quot;id&amp;quot;: &amp;quot;f5c8b0fb.93d8&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Node-RED上に文字列表示&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 237.09635162353516,
&amp;quot;y&amp;quot;: 114.08594131469727,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;47872155.bfb16&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;MQTTブローカー側に文字列を送信&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 265.0130310058594,
&amp;quot;y&amp;quot;: 206.0104217529297,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;d5a5e79d.ec27a8&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;MQTTブローカー側に文字列を送信するためのフロー&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 609.0130004882812,
&amp;quot;y&amp;quot;: 257.0104160308838,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;3700aeb9.5a7ec2&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;ｍosquittoのテストサーバーを利用&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 265.0130310058594,
&amp;quot;y&amp;quot;: 52.010416984558105,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;3890dddf.26f532&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt-broker&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;http://test.mosquitto.org/&amp;quot;,
&amp;quot;port&amp;quot;: &amp;quot;1883&amp;quot;,
&amp;quot;clientid&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;usetls&amp;quot;: false,
&amp;quot;compatmode&amp;quot;: true,
&amp;quot;keepalive&amp;quot;: &amp;quot;60&amp;quot;,
&amp;quot;cleansession&amp;quot;: true,
&amp;quot;birthTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;birthQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;birthPayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;closePayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;willPayload&amp;quot;: &amp;quot;&amp;quot;
},
{
&amp;quot;id&amp;quot;: &amp;quot;cd2e6f9.ab8069&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt-broker&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;http://test.mosquitto.org/&amp;quot;,
&amp;quot;port&amp;quot;: &amp;quot;1883&amp;quot;,
&amp;quot;clientid&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;usetls&amp;quot;: false,
&amp;quot;compatmode&amp;quot;: true,
&amp;quot;keepalive&amp;quot;: &amp;quot;60&amp;quot;,
&amp;quot;cleansession&amp;quot;: true,
&amp;quot;birthTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;birthQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;birthPayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;closePayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;willPayload&amp;quot;: &amp;quot;&amp;quot;
}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nefry-btのプログラム&#34;&gt;Nefry BTのプログラム&lt;/h3&gt;
&lt;p&gt;下記がNefry BT側のプログラムになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Nefryがwifiにつながっているか確認、2.4Ghzにつなごう
//できたtest.mosquitto.orgで使える！
#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;WiFiClient.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;
#include &amp;lt;ArduinoJson.h&amp;gt;
#include&amp;quot;esp32-hal-ledc.h&amp;quot;
#define URL &amp;quot;mosquitto.org&amp;quot;
#define PWM_BITWIDTH 16
int deg2pw(int deg, int bit){
double ms = ((double) deg - 90.0) * 0.95 / 90.0 + 1.45;
return (int) (ms / 20.0 * pow(2, bit));
}
IPAddress endpoint;
const int port = 1883;
const char *pubTopic;
const char *subTopic;
const char *deviceName;
const char *mqtt_server = &amp;quot;test.mosquitto.org&amp;quot;;
WiFiClient httpsClient;
PubSubClient mqttClient(httpsClient);
void setup() {
ledcSetup(0,50,PWM_BITWIDTH);
ledcAttachPin(A2,0);
//// NefryBT設定画面まわり ////////////////////////////////////////
// NefryBT
pubTopic = &amp;quot;/pub/NefryBT/SAMPLE&amp;quot;;
subTopic = &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;;
deviceName = &amp;quot;NefryBT_SAMPLE&amp;quot;; // 複数台で利用する場合は必ずかぶらないように変更する
// ローカルホストでMQTTブローカーを立てている場合は、パソコンのIPAddress型に収納。配列っぽく入れる。ここはその都度確認すること
//endpoint指定部
endpoint[0] = 192;
endpoint[1] = 168;
endpoint[2] = 43;
endpoint[3] = 105;
//// 以下通常処理 ////////////////////////////////////////
Serial.begin(115200);
//mqttClient.setServer()関数でMQTTブローカーを指定する
mqttClient.setServer(mqtt_server, port);
mqttClient.setCallback(mqttCallback);
connectMQTT();
}
//MQTTがちゃんと動いているか、つながっているかを判断
void connectMQTT() {
Serial.println(&amp;quot;connectMQTT&amp;quot;);
Serial.println(deviceName);
while (!mqttClient.connected()) {
Serial.print(&amp;quot;.&amp;quot;);
if (mqttClient.connect(deviceName)) {
Serial.println(&amp;quot;Connected.&amp;quot;);
int qos = 0;
mqttClient.subscribe(subTopic, qos);
Serial.println(&amp;quot;Subscribed.&amp;quot;);
} else {
Serial.print(&amp;quot;Failed. Error state=&amp;quot;);
Serial.print(mqttClient.state());
// Wait 5 seconds before retrying
delay(5000);
}
}
}
///////////////////////////////////////////////////////
char pubMessage[128];
void mqttCallback (char* topic, byte* payload, unsigned int length) {
String str = &amp;quot;&amp;quot;;
Serial.print(&amp;quot;Received. topic=&amp;quot;);
Serial.println(topic);
for (int i = 0; i &amp;lt; length; i++) {
Serial.print((char)payload[i]);
str += (char)payload[i];
}
Serial.print(&amp;quot;\n&amp;quot;);
StaticJsonBuffer&amp;lt;200&amp;gt; jsonBuffer;
JsonObject&amp;amp; root = jsonBuffer.parseObject(str);
// 読み取った文字列をパース
if (!root.success()) {
Serial.println(&amp;quot;parseObject() failed&amp;quot;);
return;
}
//Node-REDから文字列を読み取ってくる部分//////
const char* message = root[&amp;quot;message&amp;quot;];
int motor = root[&amp;quot;motor&amp;quot;];
////////////////////////////////////////////
Serial.print(&amp;quot;motor = &amp;quot;);
Serial.println(motor);
///サーボモータを動かす処理//////////////////
if( motor == 1 ){
for(int i=90; i&amp;lt;=115; i++){
ledcWrite(0,deg2pw(i, PWM_BITWIDTH));
}
delay(800);
ledcWrite(0,deg2pw(90, PWM_BITWIDTH));
} else {
for(int i=90; i&amp;gt;=65; --i){//0～180°の位置で考える、90度が基準点としてそこからどう動くかを考える
ledcWrite(0,deg2pw(i, PWM_BITWIDTH));
}
delay(800);
ledcWrite(0,deg2pw(90, PWM_BITWIDTH));
}
Nefry.ndelay(1000);
}
//////////////////////////////////////////////
//mqttを動かしている部分///////////////////////
void mqttLoop() {
if (!mqttClient.connected()) {
connectMQTT();
}
mqttClient.loop();
}
void loop() {
mqttLoop();
}
//////////////////////////////////////////////
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;動作させてみると&#34;&gt;動作させてみると……&lt;/h3&gt;
&lt;p&gt;このように、PC上から遠隔でサーボモータを制御できるようになります。
&lt;img src=&#34;https://dotstud.io/img/blog/187/5.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;node-red-mqttでサーボモータをui-ブラウザ-から制御&#34;&gt;Node-RED×MQTTでサーボモータをUI（ブラウザ）から制御&lt;/h2&gt;
&lt;p&gt;先ほどのプログラムはNode-RED上のボタンを押すとある角度回転するというものでした。次はそれを発展させて、&lt;strong&gt;ブラウザから操作して角度を遠隔で制御&lt;/strong&gt;してみます。&lt;/p&gt;
&lt;p&gt;ハンズオンでは、製作途中にタイムアップしてしまいました。少し難易度高めです。&lt;/p&gt;
&lt;h3 id=&#34;node-redのフローのコード-1&#34;&gt;Node-REDのフローのコード&lt;/h3&gt;
&lt;p&gt;下記のNode-REDのフローのコードをNode-REDにコピーして使いましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
{
&amp;quot;id&amp;quot;: &amp;quot;f2dc1b0b.520f98&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt out&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;fab71764.66ef78&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;servo/pan&amp;quot;,
&amp;quot;qos&amp;quot;: &amp;quot;1&amp;quot;,
&amp;quot;retain&amp;quot;: &amp;quot;false&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;954b988c.ec1e08&amp;quot;,
&amp;quot;x&amp;quot;: 520,
&amp;quot;y&amp;quot;: 400,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;954b988c.ec1e08&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt-broker&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;https://test.mosquitto.org/&amp;quot;,
&amp;quot;port&amp;quot;: &amp;quot;1883&amp;quot;,
&amp;quot;clientid&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;usetls&amp;quot;: false,
&amp;quot;compatmode&amp;quot;: true,
&amp;quot;keepalive&amp;quot;: &amp;quot;60&amp;quot;,
&amp;quot;cleansession&amp;quot;: true,
&amp;quot;birthTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;birthQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;birthPayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closePayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;willPayload&amp;quot;: &amp;quot;&amp;quot;
}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nefry-btのプログラム-1&#34;&gt;Nefry BTのプログラム&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;WiFiClient.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;
#include &amp;lt;ArduinoJson.h&amp;gt;
//esp32でPWMを使えるようにするためのライブラリー//
#include&amp;quot;esp32-hal-ledc.h&amp;quot;
//////////////////////////////////////////////
//分解能//////////////////////////////////////
#define PWM_BITWIDTH 16
//////////////////////////////////////////////
//PWM制御：周波数-&amp;gt;角度に変換(プログラムするときにわかりやすい)//
int deg2pw(int deg, int bit){
double ms = ((double) deg - 90.0) * 0.95 / 90.0 + 1.45;
return (int) (ms / 20.0 * pow(2, bit));
}
////////////////////////////////////////////////////////////
IPAddress endpoint;
const int port = 1883;
const char *pubTopic;
const char *subTopic;
const char *deviceName;
const char *mqtt_server = &amp;quot;test.mosquitto.org&amp;quot;;
WiFiClient httpsClient;
PubSubClient mqttClient(httpsClient);
void setup() {
ledcSetup(0,50,PWM_BITWIDTH);
ledcAttachPin(A1,0);
//// NefryBT設定 ////////////////////////////////////////
// NefryBT
pubTopic = &amp;quot;/pub/NefryBT/SAMPLE&amp;quot;;
subTopic = &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;;
deviceName = &amp;quot;NefryBT_SAMPLE&amp;quot;; // 複数台で利用する場合は必ずかぶらないように変更する
// ローカルホストならパソコンのIPAddress型に収納。配列っぽく入れる。ここはその都度確認すること
//mosquittoのテストサーバーを使うときは下記のednpointは気にしなくて大丈夫です
endpoint[0] = 192;
endpoint[1] = 168;
endpoint[2] = 1;
endpoint[3] = 1;
////////////////////////////////////////////
Serial.begin(115200);
mqttClient.setServer(mqtt_server, port);
mqttClient.setCallback(mqttCallback);
connectMQTT();
}
void connectMQTT() {
Serial.println(&amp;quot;connectMQTT&amp;quot;);
Serial.println(deviceName);
while (!mqttClient.connected()) {
Serial.print(&amp;quot;.&amp;quot;);
if (mqttClient.connect(deviceName)) {
Serial.println(&amp;quot;Connected.&amp;quot;);
int qos = 0;
mqttClient.subscribe(subTopic, qos);
Serial.println(&amp;quot;Subscribed.&amp;quot;);
} else {
Serial.print(&amp;quot;Failed. Error state=&amp;quot;);
Serial.print(mqttClient.state());
// Wait 5 seconds before retrying
delay(5000);
}
}
}
char pubMessage[128];
void mqttCallback (char* topic, byte* payload, unsigned int length) {
String str = &amp;quot;&amp;quot;;
Serial.print(&amp;quot;Received. topic=&amp;quot;);
Serial.println(topic);
for (int i = 0; i &amp;lt; length; i++) {
Serial.print((char)payload[i]);
str += (char)payload[i];
}
Serial.print(&amp;quot;\n&amp;quot;);
StaticJsonBuffer&amp;lt;200&amp;gt; jsonBuffer;
JsonObject&amp;amp; root = jsonBuffer.parseObject(str);
// パースが成功かどうか判断
if (!root.success()) {
Serial.println(&amp;quot;parseObject() failed&amp;quot;);
return;
}
const char* message = root[&amp;quot;message&amp;quot;];
int takudooon = root[&amp;quot;takudooon&amp;quot;];
Serial.print(&amp;quot;takudooon = &amp;quot;);
Serial.println(takudooon);
if( takudooon == 1 ){
for(int i=90; i&amp;lt;=115; i++){
ledcWrite(0,deg2pw(i, PWM_BITWIDTH));
}
delay(800);
ledcWrite(0,deg2pw(90, PWM_BITWIDTH));
} else {
for(int i=90; i&amp;gt;=65; --i){//0～180°の位置で考える、90度が基準点としてそこからどう動くかを考える
ledcWrite(0,deg2pw(i, PWM_BITWIDTH));
}
delay(800);
ledcWrite(0,deg2pw(90, PWM_BITWIDTH));
}
Nefry.ndelay(1000);
}
void mqttLoop() {
if (!mqttClient.connected()) {
connectMQTT();
}
mqttClient.loop();
}
void loop() {
mqttLoop();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;操作画面を用意&#34;&gt;操作画面を用意&lt;/h3&gt;
&lt;p&gt;それぞれのプログラムが準備できたら、Node-REDの画面から、
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/6.png&#34; alt=&#34;6&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;URLの「&lt;code&gt;http://localhost:1880&lt;/code&gt;」を「&lt;code&gt;http://localhost:1880/ui&lt;/code&gt;」と記述すると以下のような操作画面があらわれます。ここから、直感的にサーボモータの角度を遠隔制御できるようになります。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/187/7.png&#34; alt=&#34;7&#34;&gt;
&lt;/center&gt;
&lt;h3 id=&#34;実際に動かすと&#34;&gt;実際に動かすと……&lt;/h3&gt;
&lt;p&gt;このようになります。
&lt;img src=&#34;https://dotstud.io/img/blog/187/8.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;いろいろな技術を知ることでモノづくりの幅が増え、作ってみたいものを自由に作れるようになってもらえればな、と思います。&lt;/p&gt;
&lt;p&gt;では！&lt;/p&gt;</description></item><item><title>M5Stack&#43;GPS&#43;臭気センサをつかってトイレの臭いマップをつくりたい！</title><link>https://dotstud.io/blog/m5stack-toilet-smell-map/</link><pubDate>Thu, 28 Jun 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/m5stack-toilet-smell-map/</guid><description>
&lt;h2 id=&#34;公衆トイレ1級判定士を目指します&#34;&gt;公衆トイレ1級判定士を目指します！&lt;/h2&gt;
&lt;p&gt;ある日の出来事、お出掛け中……&lt;/p&gt;
&lt;div class=&#34;parent&#34;&gt;
&lt;div class=&#34;dialogue&#34;&gt;
&lt;div class=&#34;image&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/takudooon.png&#34; /&gt;
&lt;b&gt;たくろーどん&lt;/b&gt;
&lt;/div&gt;
&lt;div class=&#34;text&#34;&gt;
あー、トイレ、トイレ～！！トイレどこ？どこ？　ﾄﾞｺﾄﾞｺ┗(^o^)┛ﾄﾞｺﾄﾞｺ┏(^o^)┓
&lt;br /&gt;
&lt;br /&gt;
あっ、あの公園に公衆トイレあるやん！！！！
&lt;br /&gt;
&lt;br /&gt;
助かったぁ～～～ L( ＾ω＾ )┘ﾑﾞｫｰﾑﾞｫｰ└( ＾ω＾ )」
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;公衆トイレに急いで駆け込む 三└(┐卍^o^)卍ﾄﾞｩﾙﾙﾙﾙﾙ&lt;/p&gt;
&lt;p&gt;すると……&lt;/p&gt;
&lt;div class=&#34;parent&#34;&gt;
&lt;div class=&#34;dialogue&#34;&gt;
&lt;div class=&#34;image&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/takudooon.png&#34; /&gt;
&lt;b&gt;たくろーどん&lt;/b&gt;
&lt;/div&gt;
&lt;div class=&#34;text&#34;&gt;
臭い、臭い過ぎる！！！！なんやこれは！！！！(`ิิд´ิ)ｷｴｴｴｴｴｰ
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;気分、萎え萎え……。みなさん、こんな経験ありませんか？&lt;/p&gt;
&lt;p&gt;お出掛け中に公衆トイレにお世話になるも、臭いがひどくて気分が下がってしまうなんてことありますよね？&lt;/p&gt;
&lt;p&gt;良い（無臭）公衆トイレと悪い（悪臭）公衆トイレが、どこにあるのか分かったらいいなぁ……。&lt;/p&gt;
&lt;div class=&#34;parent&#34;&gt;
&lt;div class=&#34;dialogue&#34;&gt;
&lt;div class=&#34;image&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/takudooon.png&#34; /&gt;
&lt;b&gt;たくろーどん&lt;/b&gt;
&lt;/div&gt;
&lt;div class=&#34;text bold&#34;&gt;
&lt;b&gt;無ければ自分でつくればええやん！&lt;/b&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ということで、そんな公衆トイレマップが作れるようなデバイスをつくってみたいと思います。
たぶん、僕は先駆者なので&lt;strong&gt;公衆トイレ1級判定士&lt;/strong&gt;と名乗ることにします。&lt;/p&gt;
&lt;h2 id=&#34;とりあえずつくってみる&#34;&gt;とりあえずつくってみる&lt;/h2&gt;
&lt;p&gt;今回はM5Stackというとても便利な開発ボードを使ってデバイスを作成していきます（&lt;a href=&#34;https://codezine.jp/article/detail/10853&#34;&gt;M5Stackが便利な話はこちらの記事が参考になります&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;下記がイメージ図です。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/architecture.png&#34; alt=&#34;architecture&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;M5Stackの拡張ボードのGPSを使って位置情報を取得し、臭気センサ（&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gP-00989/&#34;&gt;TGS2450&lt;/a&gt;）で計測した値と紐づけます。そして、&lt;a href=&#34;https://ambidata.io/&#34;&gt;Ambient&lt;/a&gt;（IoT可視化サービス）を使って地図上にマッピングし、良い（無臭）公衆トイレと悪い（悪臭）公衆トイレを可視化していくといった具合です。&lt;/p&gt;
&lt;h2 id=&#34;今回使用する電子部品たち&#34;&gt;今回使用する電子部品たち&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/3648/&#34;&gt;M5Stack Gray
&lt;/a&gt;（今回はM5Stack BasicでもOK）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.switch-science.com/catalog/3861/&#34;&gt;M5Stack用GPSモジュール&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gP-00989/?customer=z&#34;&gt;TGS2450&lt;/a&gt;（臭気センサ）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-04268/&#34;&gt;2SC1815Y&lt;/a&gt;（トランジスタ、60V150mA）&lt;/li&gt;
&lt;li&gt;抵抗&lt;/li&gt;
&lt;li&gt;ユニバーサル基板&lt;/li&gt;
&lt;li&gt;ジャンパワイヤ&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;
&lt;h3 id=&#34;とりあえずarduinoで臭気センサを動かしてみる&#34;&gt;とりあえずArduinoで臭気センサを動かしてみる&lt;/h3&gt;
&lt;p&gt;まず安定感のあるArduinoで臭気センサが動くをことを確認してみます。&lt;/p&gt;
&lt;p&gt;TGS2450のデータシートにあるサンプル回路を試してみたのですがうまくいきませんでした（要検証）。なので、検索した結果、トランジスタを2つ使用した回路が良く使われているようです。&lt;/p&gt;
&lt;p&gt;回路図は以下の通りです。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/circuit.png&#34; alt=&#34;circuit&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;配線がジャングルになりながらも……
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/circuit2.png&#34; alt=&#34;circuit2&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;下記のプログラムを動かすと……&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;Arduino.h&amp;gt;
int val = 0;
void setup() {
pinMode(3,OUTPUT);
pinMode(4,OUTPUT);
Serial.begin(115200);
}
void loop() {
for (int i = 0; i &amp;lt;= 3; i++){
delay(242);
digitalWrite(4,HIGH);
delay(8);
digitalWrite(4,LOW);
}
delay(237);
digitalWrite(3,HIGH);
delay(3);
val = analogRead(5);
delay(2);
digitalWrite(3,LOW);
digitalWrite(4,HIGH);
delay(8);
digitalWrite(4,LOW);
val = 1023 - val;
val = val * 5;
Serial.println(val);
// 3msec loop
delay(3000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自室ではこのようにデータが取れました。部屋の中では約345、ユニットバスの中では約360です。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/graph.png&#34; alt=&#34;graph&#34;&gt;
&lt;/center&gt;
これをM5Stackに応用していきます。&lt;/p&gt;
&lt;h3 id=&#34;m5stackに実装&#34;&gt;M5Stackに実装&lt;/h3&gt;
&lt;p&gt;M5StackにGPSモジュールをスタックします。そして、先ほどの回路図に従って回路をつくり、ジャンパワイヤを使ってM5Stackとつなげます。&lt;/p&gt;
&lt;p&gt;配線後は以下の様になります。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/circuit3.png&#34; alt=&#34;circuit3&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;h2 id=&#34;プログラム&#34;&gt;プログラム&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;M5Stack.h&amp;gt;
#include &amp;lt;TinyGPS++.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;Ambient.h&amp;gt;
WiFiClient client;
Ambient ambient;
//臭気の強度が代入される変数////////////
int val = 0;
/////////////////////////////////////
//デザリングパスワード/////////////////
//屋外で使用するのでスマートフォンのデザリングを使用します
//これでAmbientにデータを送信できます
//const char* ssid = &amp;quot;yourSSID&amp;quot;;
//const char* password = &amp;quot;yourPW&amp;quot;;
/////////////////////////////////////
//Ambientの設定//////////////////////
unsigned int channelId = yourID; // AmbientのチャネルID
const char* writeKey = &amp;quot;yourWriteKey&amp;quot;; // ライトキー
////////////////////////////////////
//GPSの設定/////////////////////////
HardwareSerial GPS_s(2);
TinyGPSPlus gps;
////////////////////////////////////
void setup(){
//WiFi////////////////////////////////////////////////////////
WiFi.begin(ssid, password); // Wi-Fi APに接続
while (WiFi.status() != WL_CONNECTED) { // Wi-Fi AP接続待ち
delay(100);
}
//////////////////////////////////////////////////////////////
//臭気センサ//////////////////////////////////////////////////
pinMode(21,OUTPUT);
pinMode(22,OUTPUT);
//////////////////////////////////////////////////////////////
Serial.begin(115200);
M5.begin();
GPS_s.begin(9600);
ambient.begin(channelId, writeKey, &amp;amp;client);
}
void loop(){
char buf[16];
M5.Lcd.setCursor(0, 70);
M5.Lcd.setTextColor(WHITE, BLACK);
while(!gps.location.isUpdated()){
while(GPS_s.available()&amp;gt;0){
if(gps.encode(GPS_s.read())){
break;
}
}
}
Serial.printf(&amp;quot;lat: %f, lng: %f\r\n&amp;quot;, gps.location.lat(), gps.location.lng());
M5.Lcd.printf(&amp;quot;lat: %f, lng: %f\r\n&amp;quot;, gps.location.lat(), gps.location.lng());
//GPS測定と臭気の測定&amp;amp;Ambientへ送信////////////////
if(M5.BtnA.wasPressed()){
//臭気をAmbientに送信///////
//計測データの平均値を送信//
for (int i = 0; i &amp;lt;= 3; i++){
delay(242);
digitalWrite(22,HIGH);
delay(8);
digitalWrite(22,LOW);
}
delay(237);
digitalWrite(21,HIGH);
delay(3);
val = analogRead(36);
delay(2);
digitalWrite(21,LOW);
digitalWrite(22,HIGH);
delay(8);
digitalWrite(22,LOW);
val = 1023 - val;
val = val * 5;
Serial.println(val);
// 3msec loop
delay(3000);
ambient.set(1,val);
/////////////////////////////////////////
//経度・緯度をAmbientを送信///////////////
dtostrf(gps.location.lat(),12,8,buf);
ambient.set(9, buf);
dtostrf(gps.location.lng(), 12, 8, buf);
ambient.set(10, buf);
ambient.send();
/////////////////////////////////////////
}
//////////////////////////////////////////////////
m5.update();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;動作確認&#34;&gt;動作確認&lt;/h2&gt;
&lt;p&gt;実際に完成したデバイスを動かしてみます。&lt;/p&gt;
&lt;p&gt;M5Stackのボタンを押すと計測されたデータと位置情報がAmbientに表示されるようになりました。自室で試してみたところ以下の図のようになりました（具体的な地名は隠してあります）。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/map.png&#34; alt=&#34;map&#34;&gt;
&lt;/center&gt;
屋内なのでGPSに誤差があるようですね。ですが、臭気の強さが強いほど赤く、弱いほど青くマッピングされていることがわかります。&lt;/p&gt;
&lt;p&gt;しかし、疑問があります。それは、&lt;strong&gt;「臭気センサの値が高すぎる！」&lt;/strong&gt;ということです。&lt;/p&gt;
&lt;p&gt;Arduinoの値が信頼できそうなので、明らかにM5Stackで検出した値は間違っていると考えられます。回路は変更していないのですが……「なんでだろう？」という感じです……。&lt;/p&gt;
&lt;h2 id=&#34;とりあえずフィールドワーク&#34;&gt;とりあえずフィールドワーク&lt;/h2&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/field.png&#34; alt=&#34;field&#34;&gt;
&lt;/center&gt;
とりあえず、完成した（？）デバイスをもってフィールドワークに出かけてみます。公衆トイレを探しに行きます（在籍している大学で探します）。&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;2&#34;&gt;
※ここで公衆トイレとは、「屋外にあるトイレ」を意味します。
&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;意外と公衆トイレはないものですね……。臭気の数値は正しい値ではないので、この臭気マップは参考になりませんが……
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/177/map2.png&#34; alt=&#34;map2&#34;&gt;
&lt;/center&gt;
このデバイスにはどうやら改良が必要のようです……。&lt;/p&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;M5Stackと拡張モジュールのGPSを使うと簡単に位置情報を取得できることがわかりました。また、Ambientを使えばマッピングも自由自在です。&lt;/p&gt;
&lt;p&gt;さらにセンサを組み合わせて使えば、ロガーのようなものが簡単につくれるでしょう。&lt;/p&gt;
&lt;p&gt;しかし、今回は周期を計測する回路がArduinoでは正常で、M5Stackではうまく計測データがとれないという問題がおこりました。おそらく回路を改良する必要があると思います。&lt;/p&gt;
&lt;p&gt;どうやら、公衆トイレ1級判定士の道のりはまだまだ長いようです……。&lt;/p&gt;
&lt;style&gt;
.parent {
position: relative;
margin: 2em 0;
}
.dialogue {
padding: 40px;
position: relative;
margin: auto;
border: 1px solid #C0C0C0;
width: 600px;
display: table;
box-shadow: 0 3px 4px rgba(0, 0, 0, 0.32);
}
.image {
width: 90px;
height: 90px;
margin-right: 30px;
padding-right: 10px;
display: table-cell;
vertical-align: middle;
}
.image img {
border-radius: 50%;
border: 2px solid pink;
}
.text {
display: table-cell;
padding: 0;
vertical-align: middle;
padding-left: 30px;
}
.bold {
font-size: 120%;
}
&lt;/style&gt;</description></item><item><title>7セグメントディスプレイをArduinoで光らせよう！シフトレジスタでのピンの増やし方</title><link>https://dotstud.io/blog/segment-display-shift-register/</link><pubDate>Mon, 04 Jun 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/segment-display-shift-register/</guid><description>
&lt;p&gt;電子工作が趣味なAndroidエンジニアのとまとと申します。&lt;/p&gt;
&lt;p&gt;Arduinoはなんでもできて便利ですが、制御ピンの数に限りがあります。そのため、ピンをたくさん使いたいときは困ってしまいますよね。&lt;/p&gt;
&lt;p&gt;例えばLEDを100個くらい用意してそれぞれ一つずつパターンを決めて制御したいとき、当然ピンが足りなくなりますよね……。&lt;/p&gt;
&lt;p&gt;そんなときのために&lt;strong&gt;制御ピンを増やすことができる方法&lt;/strong&gt;を今回は紹介します！今回はたくさんのピンの制御が必要な7セグメントLEDディスプレイを少ないピンで光らせて見たいと思います。&lt;/p&gt;
&lt;h2 id=&#34;準備するもの&#34;&gt;準備するもの&lt;/h2&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/image3.png&#34; alt=&#34;image3&#34;&gt;
&lt;/center&gt;
今回はArduino Uno、7セグメントLEDに加えて、出力を増やすことのできるシフトレジスタや、スイッチングをすることのできるトランジスタを使って行きます。&lt;/p&gt;
&lt;h3 id=&#34;小型3桁赤色7セグメントled表示器-7ｍｍ高-2381bs-http-akizukidenshi-com-catalog-g-gi-09084&#34;&gt;小型3桁赤色7セグメントLED表示器 7ｍｍ高（&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-09084/&#34;&gt;2381BS&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/7seg.png&#34; alt=&#34;7seg&#34;&gt;
&lt;/center&gt;
7セグメントLEDは7個のLEDを八の字に組み合わせた電子部品で、それぞれのLEDを独立して制御することにより、数字などを表現することができます。&lt;/p&gt;
&lt;p&gt;今回は2381BSという型番のものを使って行きます！&lt;/p&gt;
&lt;h3 id=&#34;8ビットシフトレジスタ-74hc595-http-akizukidenshi-com-catalog-g-gi-08605&#34;&gt;8ビットシフトレジスタ（&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-08605/&#34;&gt;74HC595&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/shift.png&#34; alt=&#34;shift&#34;&gt;
&lt;/center&gt;
シフトレジスタは、簡単に説明すると&lt;strong&gt;一つの出力を複数に増やすことのできる電子部品&lt;/strong&gt;のことです。&lt;/p&gt;
&lt;p&gt;マイコンボードのピンは個数が限られているので、複数のセンサ等を使いたいときはシフトレジスタを用いることにより、資源を有効に使うことができます。&lt;/p&gt;
&lt;p&gt;また、シフトレジスタは出力を増やす以外にも複数の入力を１つにまとめることもできます。&lt;/p&gt;
&lt;h3 id=&#34;トランジスタ-c1815-http-akizukidenshi-com-catalog-g-gi-04268-8個&#34;&gt;トランジスタ（&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-04268/&#34;&gt;C1815&lt;/a&gt;） 8個&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/image2.png&#34; alt=&#34;image2&#34;&gt;
&lt;/center&gt;
トランジスタには3本の端子があり、それぞれベース、コレクタ、エミッタと呼ばれます。コレクタ、エミッタ間を導通するかを、ベースに流すか流さないかで制御することができます。今回はこれをスイッチとして使います。&lt;/p&gt;
&lt;p&gt;今回使うC1815は平らな面から見て左から順にエミッタ、コレクタ、ベースとなっています。&lt;/p&gt;
&lt;h3 id=&#34;その他&#34;&gt;その他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;カーボン抵抗（&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gR-16151/&#34;&gt;150Ω&lt;/a&gt;） × 8&lt;/li&gt;
&lt;li&gt;カーボン抵抗（&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gR-16273/&#34;&gt;25KΩ&lt;/a&gt;） × 8&lt;/li&gt;
&lt;li&gt;ブレッドボード&lt;/li&gt;
&lt;li&gt;ジャンパ線&lt;/li&gt;
&lt;li&gt;Arduino Unoまたは互換機&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配線してみよう&#34;&gt;配線してみよう&lt;/h2&gt;
&lt;p&gt;今回は初心者の方に取ってはあまり馴染みのないパーツも多いと思うので、それぞれ基本の回路の組み方から見ていきたいと思います。&lt;/p&gt;
&lt;p&gt;とにかく7セグの回路が知りたい！と言う方は「&lt;strong&gt;7セグとトランジスタ、シフトレジスタの配線方法&lt;/strong&gt;」の項目を見てみてください。&lt;/p&gt;
&lt;h3 id=&#34;トランジスタの配線方法&#34;&gt;トランジスタの配線方法&lt;/h3&gt;
&lt;p&gt;まずはトランジスタの使い方から見てみます。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/image1.png&#34; alt=&#34;image1&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;コレクタに制御したいピン（LEDなど）をつなぎ、ベースに制御するピン（Arduinoの13番など）をつなぎます。最後に、エミッタをGNDに繋げば回路の完成です。ベースのオンオフによってLEDをつけたり消したりすることができます。&lt;/p&gt;
&lt;h3 id=&#34;シフトレジスタの配線方法&#34;&gt;シフトレジスタの配線方法&lt;/h3&gt;
&lt;p&gt;シフトレジスタの回路の組み方は次のようになります。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/image5.png&#34; alt=&#34;image5&#34;&gt;
&lt;/center&gt;
シフトレジスタの16番・10番を5Vに、13番・8番をGNDに繋いでいます。14、12、11番はそれぞれ、Arduinoの制御ピン（11、10、9番）に繋いでいます。&lt;/p&gt;
&lt;p&gt;余ってる8つのピンをLEDのアノード（+）に繋ぎ、LEDのカソード（−）を抵抗を経由してGNDに繋げば完成です。&lt;/p&gt;
&lt;h3 id=&#34;7セグとトランジスタ-シフトレジスタの配線方法&#34;&gt;7セグとトランジスタ、シフトレジスタの配線方法&lt;/h3&gt;
&lt;p&gt;さて、いよいよ7セグを光らせてみましょう！回路は以下の図です。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/image4.png&#34; alt=&#34;image4&#34;&gt;
&lt;/center&gt;
配線がかなり多くなるので、&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gP-02315/&#34;&gt;短いジャンパ&lt;/a&gt;を駆使するのがオススメです。&lt;/p&gt;
&lt;p&gt;これで回路は完成です。&lt;/p&gt;
&lt;h2 id=&#34;プログラムを書き込もう&#34;&gt;プログラムを書き込もう&lt;/h2&gt;
&lt;p&gt;では、次のプログラムをコピペしてArduino IDEを使ってボードに書き込みましょう！&lt;code&gt;int num = 7&lt;/code&gt;には光らせたい数字を代入します。&lt;/p&gt;
&lt;p&gt;プログラムの仕様は回路の組み方によって変わるため、今回は同じように組んでください。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define DATA 11
#define LATCH 10
#define CLOCK 9
// 0b10000000 DP
// 0b01000000 D
// 0b00100000 E
// 0b00010000 F
// 0b00001000 A
// 0b00000100 G
// 0b00000010 C
// 0b00000001 B
static const int num[] {
0b01111011, //ZERO
0b00000011, //ONE
0b01101101, //TWO
0b01001111, //THREE
0b00010111, //FOUR
0b01011110, //FIVE
0b01110110, //SIX
0b00001011, //SEVEN
0b01111111, //EIGHT
0b01011111, //NINE
};
int count;
void setup()
{
count = 0;
pinMode(DATA, OUTPUT);
pinMode(LATCH, OUTPUT);
pinMode(CLOCK, OUTPUT);
pinMode(1, OUTPUT);
pinMode(2, OUTPUT);
pinMode(3, OUTPUT);
}
void loop()
{
digitalWrite(1, HIGH);
digitalWrite(2, HIGH);
digitalWrite(3, HIGH);
digitalWrite(LATCH, LOW);
shiftOut(DATA, CLOCK, 8, num[count]);
digitalWrite(LATCH, HIGH);
delay(1000);
if (count == 9)
count = 0;
else
count++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;プログラムの解説&#34;&gt;プログラムの解説&lt;/h3&gt;
&lt;p&gt;プログラムの一部を解説していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define DATA 11
#define LATCH 10
#define CLOCK 9
// 0b10000000 DP
// 0b01000000 D
// 0b00100000 E
// 0b00010000 F
// 0b00001000 A
// 0b00000100 G
// 0b00000010 C
// 0b00000001 B
static const int num[] {
0b01111011, //ZERO
0b00000011, //ONE
0b01101101, //TWO
0b01001111, //THREE
0b00010111, //FOUR
0b01011110, //FIVE
0b01110110, //SIX
0b00001011, //SEVEN
0b01111111, //EIGHT
0b01011111, //NINE
};
int count; // カウンタ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでは使うピンと、7セグを光らせるパターンの定義をしています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void setup()
{
count = 0;
pinMode(DATA, OUTPUT);
pinMode(LATCH, OUTPUT);
pinMode(CLOCK, OUTPUT);
pinMode(1, OUTPUT);
pinMode(2, OUTPUT);
pinMode(3, OUTPUT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでは、Arduinoから出力をするピンを指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loop()
{
digitalWrite(1, HIGH);
digitalWrite(2, HIGH);
digitalWrite(3, HIGH);
digitalWrite(LATCH, LOW);
shiftOut(DATA, CLOCK, 8, num[count]);
digitalWrite(LATCH, HIGH);
delay(1000);
if (count == 9)
count = 0;
else
count++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで、1、2、3番ピンを全てHIGHにしていますが、LOWに切り替えることにより各7セグを制御することができます。&lt;/p&gt;
&lt;p&gt;表示したい数字の配列を読み込み、&lt;code&gt;shiftOut()&lt;/code&gt;で光らせたいLEDのピンを指定します。&lt;/p&gt;
&lt;p&gt;LATCHピンをLOWにすることにより、&lt;code&gt;shiftOut()&lt;/code&gt;でデータを送ることができ、送信後HIGHにすることにより、実際にそれぞれのLEDを光らせることができます。&lt;/p&gt;
&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;
&lt;p&gt;上記のコードで&lt;code&gt;int num = 7&lt;/code&gt;を試してみると、このような感じで光らせることができます！
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/169/image6.png&#34; alt=&#34;image6&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;シフトレジスタを用いた回路は電子工作をやりはじめた人には難しいかもしれませんが、初歩的なものの組み合わせでできているのでこの記事を見て試してみるのも面白いと思います。&lt;/p&gt;
&lt;p&gt;また今回使ったシフトレジスタは一つだけでしたが、複数組み合わせて身近なLCDディスプレイやLEDキューブ、自作のロボットの制御などのようなものを実現することができます。考え方次第でなんでも作ることができると思います！&lt;/p&gt;
&lt;p&gt;ぜひ試してみてください！&lt;/p&gt;</description></item><item><title>Raspberry Piとサーボモータで踊るはにわ制作</title><link>https://dotstud.io/blog/dancing-haniwa-servo-raspi/</link><pubDate>Fri, 01 Jun 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/dancing-haniwa-servo-raspi/</guid><description>
&lt;p&gt;あ、どうもはにわと申します。
港町横浜で専門学生やってるものづくりがそこそこ好きなメガネです。&lt;/p&gt;
&lt;p&gt;今回はですねタイトルと名前にあるように動く&lt;strong&gt;┌|∵|┘&lt;/strong&gt;←を作りたいと思うんですよね。&lt;/p&gt;
&lt;p&gt;なぜ作るか……なんですけども&lt;strong&gt;何か大層なことを考えて趣味でものづくりする人ってそうそういない&lt;/strong&gt;と思うんです（┌|∵|┘が作りたいだけ←）。&lt;/p&gt;
&lt;p&gt;今回はRaspberry Piとサーボモータを使って、&lt;strong&gt;踊る┌|∵|┘&lt;/strong&gt;を作ってみます！&lt;/p&gt;
&lt;h2 id=&#34;raspberry-pi-サーボモータ&#34;&gt;Raspberry Pi？サーボモータ？┌|∵|┘？&lt;/h2&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/1.png&#34; alt=&#34;1&#34;&gt;
&lt;/center&gt;
「&lt;a href=&#34;https://www.raspberrypi.org/&#34;&gt;&lt;strong&gt;Raspberry Pi&lt;/strong&gt;&lt;/a&gt;」は、Arduinoに似た何でもできると噂のつよいボードです。
強さの秘訣は内部でLinux OSが動いたり、直接ディスプレイやキーボード、マウス等を接続できたりすることで、超小型のパソコンと考えてもらって大丈夫です！&lt;/p&gt;
&lt;p&gt;LANケーブルを接続すればネットにも繋がり、中にはWi-Fiモジュールが搭載されていて無線で繋がるものもあります。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/2.png&#34; alt=&#34;2&#34;&gt;
&lt;/center&gt;
「&lt;strong&gt;サーボモータ&lt;/strong&gt;」は、
普通のモータとは違い回転角度・速度を細かく調整することができ、ラジコンの翼の制御やロボットのアームの制御などに使われます。&lt;/p&gt;
&lt;p&gt;PWMという方法で制御するのですが、詳細は、ドキュメントの「&lt;a href=&#34;https://dotstud.io/docs/pulse-width-modulation/&#34;&gt;PWM制御&lt;/a&gt;」を参考にしてください。&lt;/p&gt;
&lt;p&gt;そして&lt;strong&gt;┌|∵|┘&lt;/strong&gt;です！
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/3.png&#34; alt=&#34;3&#34;&gt;
&lt;/center&gt;
みなさん知ってますよね！？可愛いですよねうん。説明不要ですようん。&lt;/p&gt;
&lt;h2 id=&#34;今回使うもの-欲しいもの&#34;&gt;今回使うもの、欲しいもの&lt;/h2&gt;
&lt;h3 id=&#34;raspberry-pi3-http-akizukidenshi-com-catalog-g-gm-10414&#34;&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-10414/&#34;&gt;Raspberry Pi3&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-10414/&#34;&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/4.png&#34; alt=&#34;4&#34;&gt;
&lt;/center&gt;
&lt;/a&gt;
Raspberry Pi、通称ラズパイです。今回はRaspberry Pi3を使いますが、別に2でもzeroでも大丈夫かと思われます。ラズパイ上で動かす言語は、RaspbianというOS標準のPython3系を使います。&lt;/p&gt;
&lt;h3 id=&#34;マイクロサーボ9g-sg-90-http-akizukidenshi-com-catalog-g-gm-08761&#34;&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-08761/&#34;&gt;マイクロサーボ9g SG-90&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-08761/&#34;&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/5.png&#34; alt=&#34;5&#34;&gt;
&lt;/center&gt;
&lt;/a&gt;
安価でお求めやすいサーボモータです。PWMサイクルや制御パルス等色々ありますがそんなことを気にしても物は作れません！とりあえず気にせず行きましょう！&lt;/p&gt;
&lt;h3 id=&#34;ジャンパピン&#34;&gt;ジャンパピン&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/7.png&#34; alt=&#34;7&#34;&gt;
&lt;/center&gt;
各機器をつなぎ合わせるために使用します。うーん説明終わり！&lt;/p&gt;
&lt;p&gt;Amazon等で「&lt;a href=&#34;https://www.amazon.co.jp/s/ref=nb_sb_noss_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;url=search-alias%3Daps&amp;amp;field-keywords=%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%91%E3%83%94%E3%83%B3&amp;amp;rh=i%3Aaps%2Ck%3A%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%91%E3%83%94%E3%83%B3&#34;&gt;&lt;strong&gt;ジャンパピン&lt;/strong&gt;&lt;/a&gt;」などと検索してみると、かなり安価で大量に手に入ることがわかります。こんないらねえよ！と思いますよね？私も思います。&lt;/p&gt;
&lt;h3 id=&#34;ブレッドボード&#34;&gt;ブレッドボード&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/6.png&#34; alt=&#34;6&#34;&gt;
&lt;/center&gt;
「&lt;a href=&#34;https://www.amazon.co.jp/s/ref=nb_sb_noss_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;url=search-alias%3Daps&amp;amp;field-keywords=%E3%83%96%E3%83%AC%E3%83%83%E3%83%89%E3%83%9C%E3%83%BC%E3%83%89&#34;&gt;&lt;strong&gt;ブレッドボード&lt;/strong&gt;&lt;/a&gt;」と検索するとこんな感じの穴あきの板が手に入ります。ここに先ほどのピン等をさしていきます。&lt;/p&gt;
&lt;p&gt;ブレッドボードの使い方がよくわからない、という方は、ドキュメントの「&lt;a href=&#34;https://dotstud.io/docs/breadboard&#34;&gt;&lt;strong&gt;ブレッドボード&lt;/strong&gt;&lt;/a&gt;」を参照してください。&lt;/p&gt;
&lt;h2 id=&#34;実際に動かす&#34;&gt;実際に動かす&lt;/h2&gt;
&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;
&lt;p&gt;こういった感じに配線していきましょう。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/8.png&#34; alt=&#34;8&#34;&gt;
&lt;/center&gt;
モータを動かすにはパワーを使うため通常は別で電源を用意することが多いですが、1個だけでしたらラズパイからの給電で動くので接続していきましょう。&lt;/p&gt;
&lt;p&gt;SG90の黒をラズパイの「&lt;strong&gt;GND&lt;/strong&gt;」へ、SG90の赤はラズパイの「&lt;strong&gt;5V&lt;/strong&gt;」へ、そして黄色をラズパイの任意のピンへ接続します。今回は2番ピンに接続しておきましょう。近いですし。&lt;/p&gt;
&lt;p&gt;慣習的に5Vを赤、GNDを黒、その他はそれぞれ違う色のジャンパで繋ぐと見やすいです。わかりやすさって大事！！&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/pin.png&#34; alt=&#34;pin&#34;&gt;
&lt;/center&gt;
ラズパイのボード上にはピン名称の記載がありませんが、「&lt;a href=&#34;https://www.google.co.jp/search?q=raspberry+pi+%E3%83%94%E3%83%B3%E3%82%A2%E3%82%B5%E3%82%A4%E3%83%B3&amp;amp;safe=off&amp;amp;rlz=1C5CHFA_enJP706JP706&amp;amp;source=lnms&amp;amp;tbm=isch&amp;amp;sa=X&amp;amp;ved=0ahUKEwjRkLTTw6rbAhWIx7wKHYGRAMEQ_AUICigB&amp;amp;biw=1163&amp;amp;bih=895&#34;&gt;Raspberry Pi ピンアサイン&lt;/a&gt;」などと検索すると調べることができます。&lt;/p&gt;
&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;ラズパイの初期設定等はとても詳しく説明してくださってる方がたくさんいるので割愛します！！！Python3とpipがあればOKです。&lt;/p&gt;
&lt;p&gt;SSH接続とかNotepad++とかで遠隔で書き込むのもありですが、それができる人は自分で頑張ってください。今回はラズパイに直接書き込んでいきましょう！&lt;/p&gt;
&lt;p&gt;ラズパイへ電源、HDMI、キーボードを接続しログイン。&lt;/p&gt;
&lt;p&gt;シェルが起動しましたら&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip3 install RPi.GPIO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とPython上でGPIOを操作できるライブラリを落とします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ touch motor_test.py
$ nano motor_test.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でファイルを作成して編集モードにし、以下を記述していきます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import RPi.GPIO as GPIO
import time
GPIO.setmode(GPIO.BCM)
gp_out = 2 // SG90の黄色を刺したピン
GPIO.setup(gp_out, GPIO.OUT)
motor = GPIO.PWM(gp_out, 50)
motor.start(0.0)
bot = 2.5
mid = 7.2
top = 12.0
motor.ChangeDutyCycle(bot)
time.sleep(0.5)
motor.ChangeDutyCycle(top)
time.sleep(0.5)
motor.ChangeDutyCycle(mid)
time.sleep(0.5)
GPIO.cleanup()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ctrl + x で終了し、yキーで保存します。&lt;/p&gt;
&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;
&lt;p&gt;プログラムを書き込めたら、動かしてみましょう。配線を確認し次のコマンドを叩きましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python3 motor_test.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/170/9.gif&#34; alt=&#34;&#34; /&gt;
おお！動いた！という事で&lt;code&gt;ChangeDutyCycle()&lt;/code&gt;の中身を変えることで好きな角度に変えることができます。とりあえずの指標として0、90、180度をtop、mid、botという変数に入れていますが、直接数値を入力してもOKです。&lt;/p&gt;
&lt;h2 id=&#34;モータを増やす&#34;&gt;モータを増やす。&lt;/h2&gt;
&lt;p&gt;一つのサーボモータを動かすことには成功しました。なので次はもっと増やしてみましょう。&lt;/p&gt;
&lt;p&gt;具体的には上のプログラムの使いまわしで大丈夫です。使うモータ毎に名前とどのピンを使うかを記述し、&lt;code&gt;名前.ChangeDutyCycle()&lt;/code&gt;とすると対応するサーボモータが作動するようになります。&lt;/p&gt;
&lt;h3 id=&#34;配線-1&#34;&gt;配線&lt;/h3&gt;
&lt;p&gt;では全部で3台動くように追加していきましょう！ラズパイからの給電ではSG90を3台も動かせないので、単3電池2本を追加して電力を補強しつつこういった感じに配線します。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/circuit.png&#34; alt=&#34;circuit&#34;&gt;
&lt;/center&gt;
&lt;p&gt;電池の赤（+）をブレッドボードの+列へ、黒（-）をｰ列へ刺します。&lt;/p&gt;
&lt;p&gt;各サーボモータの赤をブレッドボードの+列に、サーボモーターの黒をブレッドボードの-列に、ラズパイのGNDをボードの-列へ接続し電源を確保します。&lt;/p&gt;
&lt;p&gt;そしてサーボモータの黄色はGPIO端子の対応するところ（今回は2、3、4番ピン）にぶっ刺します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/10.png&#34; alt=&#34;10&#34;&gt;
&lt;/center&gt;
Oh…ｺﾞﾁｬｺﾞﾁｬ……&lt;/p&gt;
&lt;h3 id=&#34;プログラム-1&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;さっき書いたプログラムのように記述します。さっきのを書き換えてもOKです！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import RPi.GPIO as GPIO
import time
GPIO.setmode(GPIO.BCM)
gp_out = 2
GPIO.setup(gp_out, GPIO.OUT)
right = GPIO.PWM(gp_out, 50)
right.start(0.0)
gp_out = 3
GPIO.setup(gp_out, GPIO.OUT)
left = GPIO.PWM(gp_out, 50)
left.start(0.0)
gp_out = 4
GPIO.setup(gp_out, GPIO.OUT)
chest = GPIO.PWM(gp_out, 50)
chest.start(0.0)
bot = 2.5
mid = 7.2
top = 12.0
right.ChangeDutyCycle(bot)
left.ChangeDutyCycle(bot)
time.sleep(0.5)
chest.ChangeDutyCycle(mid)
time.sleep(0.5)
right.ChangeDutyCycle(top)
chest.ChangeDutyCycle(bot)
time.sleep(0.5)
chest.ChangeDutyCycle(top)
right.ChangeDutyCycle(bot)
left.ChangeDutyCycle(top)
time.sleep(0.5)
chest.ChangeDutyCycle(mid)
right.ChangeDutyCycle(top)
left.ChangeDutyCycle(bot)
time.sleep(0.5)
GPIO.cleanup()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんな感じで！もう好きにやっちゃってくださいな。&lt;/p&gt;
&lt;h2 id=&#34;図工&#34;&gt;図工&lt;/h2&gt;
&lt;p&gt;それでは本題である&lt;strong&gt;┌|∵|┘&lt;/strong&gt;を作ります！皆さん童心に帰って好きな素材で作ってください！&lt;/p&gt;
&lt;p&gt;私は今回牛乳パックで作成していきます。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/11.png&#34; alt=&#34;11&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;( ＾ω＾)&lt;br /&gt;
≡⊃⊂≡&lt;br /&gt;
こうしてこうして
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/12.png&#34; alt=&#34;12&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;( ＾ω＾)&lt;br /&gt;
⊃ .. ⊂&lt;br /&gt;
こうじゃ
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/haniwa.png&#34; alt=&#34;haniwa&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;h2 id=&#34;やったぜ&#34;&gt;やったぜ&lt;/h2&gt;
&lt;p&gt;さあさあここまで来たんです！動かしましょうよ！ね！
&lt;strong&gt;┌|∵|┘起動!!!!!&lt;/strong&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/170/14.gif&#34; alt=&#34;&#34; /&gt;
&lt;center&gt;
&lt;font size=&#34;5&#34;&gt;動いたあああああ！躍ったああああああああ！&lt;/font&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
と、いう事で好きにパーツを作ってもらえればどんなものも躍らせられますね……！！踊り自体もPythonで記述しているので、forやifを駆使すれば複雑な踊りだっていけます。ここから皆さんの創造力が試されますぞ！&lt;/p&gt;
&lt;p&gt;それでは長くなりましたがお疲れ様です！皆もなんか動かしてみようぜ！！&lt;/p&gt;</description></item><item><title>非接触ICタグで遊ぼう！ArduinoでRFIDリーダRC522を使う方法</title><link>https://dotstud.io/blog/arduino-use-rfid-reader/</link><pubDate>Wed, 09 May 2018 08:30:26 +0900</pubDate><guid>https://dotstud.io/blog/arduino-use-rfid-reader/</guid><description>
&lt;p&gt;こんにちは、ちゃんとくです。&lt;/p&gt;
&lt;p&gt;みなさんは「&lt;strong&gt;認証機能&lt;/strong&gt;」というとどんなイメージを持つでしょうか？&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/auth.png&#34; alt=&#34;auth&#34;&gt;
&lt;/center&gt;
&lt;p&gt;Webページを開いて、IDとパスワードを入力して、ログインして……。「&lt;strong&gt;めんどくさい！もっと簡単に認証したい！&lt;/strong&gt;」ということもありますよね。&lt;/p&gt;
&lt;p&gt;そんなときは&lt;strong&gt;非接触ICタグ&lt;/strong&gt;を使って、&lt;strong&gt;ピッとして認証できる装置&lt;/strong&gt;を作ってみましょう！&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/touch.png&#34; alt=&#34;touch&#34;&gt;
&lt;/center&gt;
今回はArduinoとRFIDリーダを使って、非接触ICタグをかざすと登録されたユーザかどうか判定するデバイスを作ってみます！&lt;/p&gt;
&lt;p&gt;※ただし今回の実装は&lt;strong&gt;セキュリティ対策を施していない&lt;/strong&gt;ので、ご家庭内や趣味の範囲でお試しください。&lt;/p&gt;
&lt;h2 id=&#34;rfid-nfc-非接触ic&#34;&gt;RFID？NFC？非接触IC？&lt;/h2&gt;
&lt;p&gt;「&lt;strong&gt;RFID&lt;/strong&gt;」とは、電磁界や電波を用いて情報を埋め込んだRFタグとやりとりする無線通信技術です。「&lt;strong&gt;NFC&lt;/strong&gt;」はRFタグの規格の一つで、正式名称は&lt;strong&gt;Near Field Communication&lt;/strong&gt;（近距離無線通信）と言います。&lt;/p&gt;
&lt;p&gt;非接触ICは、&lt;strong&gt;読み取り端末にかざすことで通信ができる電池レスのIC&lt;/strong&gt;です（電池内臓の場合もあります）。&lt;/p&gt;
&lt;p&gt;世界で利用されているMifare（マイフェア）カードやTaspoでは「ISO/IEC 14443 Type A」というNFCの規格、日本で利用されている交通系ICカードでは「FeliCa」という規格が主に利用されています。&lt;/p&gt;
&lt;p&gt;今回利用するRFIDリーダライタのRFID-RC522では、&lt;strong&gt;FeliCa規格のICは読み取ることができません&lt;/strong&gt;。FeliCaを利用したい場合はSony製の&lt;a href=&#34;https://www.sony.co.jp/Products/felica/consumer/index.html&#34;&gt;PaSoRi&lt;/a&gt;やFeliCaリーダライタ&lt;a href=&#34;https://www.switch-science.com/catalog/353/&#34;&gt;RC-S620S&lt;/a&gt;などを使ってみてください。&lt;/p&gt;
&lt;h2 id=&#34;今回使うもの&#34;&gt;今回使うもの&lt;/h2&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/use.png&#34; alt=&#34;use&#34;&gt;
&lt;/center&gt;
今回はArduinoまたは互換ボード（写真はGenuino 101）、RFIDリーダライタRC522、その他に判定用のLEDやブレッドボード、ジャンパワイヤを利用します。&lt;/p&gt;
&lt;h3 id=&#34;arduino-互換ボード&#34;&gt;Arduino/互換ボード&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/genuino.png&#34; alt=&#34;genuino&#34;&gt;
&lt;/center&gt;
Arduinoや互換ボードを利用すると、RC522ライブラリをそのまま使えて簡単です。写真ではGenuino 101（※）を使っていますが、今回使うピンの配置はArduino Unoと全く同じです。&lt;/p&gt;
&lt;p&gt;Arduino Mega、Nano v3、Microなども利用できますが、ピンの接続箇所が変わるので今回利用する&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;&lt;strong&gt;MFRC522ライブラリ&lt;/strong&gt;&lt;/a&gt;の&lt;a href=&#34;https://github.com/miguelbalboa/rfid#pin-layout&#34;&gt;Pin Layout&lt;/a&gt;を参考に配線してください。&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;2&#34;&gt;※Genuino 101はBluetooth搭載のIntel製ボードで、色が好きなので多用しています。ディスコンになってしまったけど……。&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&#34;rfid-rc522&#34;&gt;RFID-RC522&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/rc522set.png&#34; alt=&#34;rc522set&#34;&gt;
&lt;/center&gt;
安価で入手しやすいRFIDリーダライタです。&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;ライブラリ&lt;/a&gt;側でドキュメントとサンプルコードが用意されていて、Arduinoで扱いやすいです。過出力や電波の不要輻射を防ぐため、3.3Vで利用します。&lt;/p&gt;
&lt;p&gt;※RFID-RC522では、&lt;strong&gt;FeliCa規格のICは読み取ることができません&lt;/strong&gt;。FeliCaを利用したい場合はSony製の&lt;a href=&#34;https://www.sony.co.jp/Products/felica/consumer/index.html&#34;&gt;PaSoRi&lt;/a&gt;やFeliCaリーダライタ&lt;a href=&#34;https://www.switch-science.com/catalog/353/&#34;&gt;RC-S620S&lt;/a&gt;などを使ってみてください。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/rc522.png&#34; alt=&#34;rc522&#34;&gt;
&lt;/center&gt;
例えばAmazonで「&lt;strong&gt;RC522&lt;/strong&gt;」を検索すると、&lt;u&gt;価格帯の違うものがたくさんでてきます&lt;/u&gt;。&lt;strong&gt;お届け時期&lt;/strong&gt;や&lt;strong&gt;発送元&lt;/strong&gt;（Amazon.co.jpからだと安心かも）、&lt;strong&gt;送料&lt;/strong&gt;、&lt;strong&gt;レビュー&lt;/strong&gt; などに注意して購入しましょう！&lt;/p&gt;
&lt;p&gt;ちゃんとくは急いでいたので、Amazon.co.jpが発送する翌日受け取りできるものを購入しました。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/solder.png&#34; alt=&#34;solder&#34;&gt;
&lt;/center&gt;
&lt;p&gt;ピンヘッダは未実装の状態で届くので、好きな角度の方をはんだづけしておきます（かっこいい！と思ってくの字型のピンヘッダを使いましたが、タグによってはジャンパが邪魔してタッチしづらいです……）。&lt;/p&gt;
&lt;h3 id=&#34;rfid-nfcタグ&#34;&gt;RFID/NFCタグ&lt;/h3&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/nfc.png&#34; alt=&#34;nfc&#34;&gt;
&lt;/center&gt;
こちらもAmazonで「&lt;strong&gt;NFCタグ&lt;/strong&gt;」などと検索してみると、かなり安価で手に入ることがわかります。ステッカーを使えば、手持ちのキーホルダーなどを簡単にキーにすることができますね！&lt;/p&gt;
&lt;p&gt;RC522のセットを購入した場合はカードとキーホルダーがついてきますし、「&lt;strong&gt;とりあえず試したいだけ&lt;/strong&gt;」「&lt;strong&gt;認識させたいICタグが既にある&lt;/strong&gt;」という場合は購入しなくて大丈夫です。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/shiokara.png&#34; alt=&#34;shiokara&#34;&gt;
&lt;/center&gt;
ちゃんとくは、&lt;strong&gt;シオカラーズの2人（Splatoon）&lt;/strong&gt;に協力してもらおうと思います！！&lt;/p&gt;
&lt;p&gt;これは任天堂のamiiboというフィギュアなんですが、&lt;strong&gt;ゲーム用のNFCを搭載&lt;/strong&gt;していてRFIDリーダで情報を読み取ることができます。&lt;/p&gt;
&lt;h2 id=&#34;識別子を取得する&#34;&gt;識別子を取得する&lt;/h2&gt;
&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;MFRC522ライブラリ&lt;/a&gt;の&lt;a href=&#34;https://github.com/miguelbalboa/rfid#pin-layout&#34;&gt;&lt;strong&gt;Pin Layout&lt;/strong&gt;&lt;/a&gt;を参考に、ArduinoとRC522を接続していきます。Arduino Mega、Nano v3、Microなども利用できますが、ピンの接続箇所が変わるのでライブラリのREADMEを参照してください。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Signal&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;MFRC522 Reader/PCD Pin&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Arduino Uno Pin&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RST/Reset&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RST&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI SS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SDA(SS)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI MOSI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MOSI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11 / ICSP-4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI MISO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MISO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;12 / ICSP-1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI SCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;13/ICSP-3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上記の表の通り、RC522のSignalの名前の部分を見て、対応するArduino Unoのピンに接続します。&lt;/p&gt;
&lt;p&gt;その他、RC522の「GND」はArduinoの「GND」へ、RC522の「3.3V」はArduinoの「3.3V」へ接続します。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/circuit1.png&#34; alt=&#34;circuit1&#34;&gt;
&lt;/center&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/map.png&#34; alt=&#34;map&#34;&gt;
&lt;/center&gt;
慣習的に3.3Vを赤、GNDを黒、その他はそれぞれ違う色のジャンパで繋ぐと見やすいです。書いてある通りに繋ぐだけなので、落ち着いて接続しましょう！（IRQというピンは今回は使用しません）&lt;/p&gt;
&lt;p&gt;ブレッドボードの使い方がよくわからない、という方は、ドキュメントの「&lt;a href=&#34;https://dotstud.io/docs/breadboard/&#34;&gt;&lt;strong&gt;ブレッドボード&lt;/strong&gt;&lt;/a&gt;」を参照してください。&lt;/p&gt;
&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.arduino.cc/en/main/software&#34;&gt;Arduino IDE&lt;/a&gt;というソフトを使い、Arduinoにプログラムを書き込みます。インストール方法は、ドキュメントの「&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;&lt;strong&gt;Arduino IDEをPCにインストール&lt;/strong&gt;&lt;/a&gt;」を参照してください。&lt;/p&gt;
&lt;p&gt;まずArduino IDEに、今回利用する&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;&lt;strong&gt;MFRC522ライブラリ&lt;/strong&gt;&lt;/a&gt;をインストールします。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step1.png&#34; alt=&#34;step1&#34;&gt;
─ ライブラリマネージャを開く
&lt;/center&gt;
[スケッチ] &amp;gt; [ライブラリをインクルード] &amp;gt; [ライブラリを管理]を選択します。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step2.png&#34; alt=&#34;step2&#34;&gt;
─ MFRC522ライブラリをインストール
&lt;/center&gt;
「MFRC」と検索し、MFRC522ライブラリをインストールします。&lt;/p&gt;
&lt;p&gt;エディタには下記のプログラムを貼り付けます。ライブラリの&lt;a href=&#34;https://github.com/miguelbalboa/rfid/blob/master/examples/DumpInfo/DumpInfo.ino&#34;&gt;DumpInfoのサンプルコード&lt;/a&gt;をそのまま利用しています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;MFRC522.h&amp;gt;
constexpr uint8_t RST_PIN = 9; // Configurable, see typical pin layout above
constexpr uint8_t SS_PIN = 10; // Configurable, see typical pin layout above
MFRC522 mfrc522(SS_PIN, RST_PIN); // Create MFRC522 instance
void setup() {
Serial.begin(9600); // Initialize serial communications with the PC
while (!Serial); // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
SPI.begin(); // Init SPI bus
mfrc522.PCD_Init(); // Init MFRC522
mfrc522.PCD_DumpVersionToSerial(); // Show details of PCD - MFRC522 Card Reader details
Serial.println(F(&amp;quot;Scan PICC to see UID, SAK, type, and data blocks...&amp;quot;));
}
void loop() {
// Look for new cards
if ( ! mfrc522.PICC_IsNewCardPresent()) {
return;
}
// Select one of the cards
if ( ! mfrc522.PICC_ReadCardSerial()) {
return;
}
// Dump debug info about the card; PICC_HaltA() is automatically called
mfrc522.PICC_DumpToSerial(&amp;amp;(mfrc522.uid));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step3.png&#34; alt=&#34;step3&#34;&gt;
&lt;/center&gt;
[ツール] &amp;gt; [ボード]は「&lt;strong&gt;Arduino/Genuino 101&lt;/strong&gt;」、[シリアルポート]は&lt;strong&gt;Arduinoを接続したUSBポート&lt;/strong&gt;を選択します（Windowsの方はCOMポート番号）。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step4.png&#34; alt=&#34;step4&#34;&gt;
&lt;/center&gt;
左上の「➡︎」をクリックしてプログラムを書き込みます。&lt;/p&gt;
&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;
&lt;p&gt;プログラムを書き込めたら、タグの情報を確認します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/monitor.png&#34; alt=&#34;monitor&#34;&gt;
&lt;/center&gt;
[ツール] &amp;gt; [シリアルモニタ]を開きます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step5.png&#34; alt=&#34;step5&#34;&gt;
&lt;/center&gt;
シリアルモニタを開いた状態でRFIDリーダにタグをかざすと、タグの情報が表示されます。&lt;/p&gt;
&lt;p&gt;登録したいタグをかざし、「&lt;strong&gt;Card UID:&lt;/strong&gt;」以降の部分（画像では消してある部分）をコピーしておきましょう。&lt;/p&gt;
&lt;h2 id=&#34;識別子を元に動作を変える&#34;&gt;識別子を元に動作を変える&lt;/h2&gt;
&lt;p&gt;識別子を取得したNFCタグを「&lt;strong&gt;認証するユーザ&lt;/strong&gt;」、それ以外のタグを「&lt;strong&gt;認証しないユーザ&lt;/strong&gt;」として、Arduino側の動作を変えてみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/goal.png&#34; alt=&#34;goal&#34;&gt;
&lt;/center&gt;
認証するユーザの場合はLEDを青に、認証しないユーザの場合はLEDを赤に光らせるプログラムを作ってみます。&lt;/p&gt;
&lt;h3 id=&#34;配線-1&#34;&gt;配線&lt;/h3&gt;
&lt;p&gt;回路に、青と赤のLEDを追加します。配線するときは、一旦Arduinoを電源から外します。
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/circuit2.png&#34; alt=&#34;circuit2&#34;&gt;
&lt;/center&gt;
&lt;/p&gt;
&lt;p&gt;青いLEDのアノード（＋側・脚が長い方）を8番ピンに、赤いLEDのアノードをアナログの3番ピンに繋ぎ、カソード（ー側）をそれぞれGNDに接続します。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/map2.png&#34; alt=&#34;map2&#34;&gt;
─ 配線した状態（上の図とLEDの向きが逆になっています）
&lt;/center&gt;
&lt;h3 id=&#34;プログラム-1&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;先ほど取得した&lt;strong&gt;タグの識別子とマッチしたら青いLED、それ以外は赤いLEDを光らせるプログラム&lt;/strong&gt;を作成します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#defin UID&lt;/code&gt;の部分は、ご自身が取得したタグの識別子に置き換えてください。また、今回赤いLEDはアナログ出力に接続しているので、&lt;code&gt;AnalogWrite()&lt;/code&gt;を利用して光量を0〜255で指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;MFRC522.h&amp;gt;
constexpr uint8_t RST_PIN = 9;
constexpr uint8_t SS_PIN = 10;
#define UID &amp;quot;xx xx xx xx xx xx xx&amp;quot; // 取得した識別子を記述
int led_blue = 8;
int led_red = 3;
MFRC522 mfrc522(SS_PIN, RST_PIN);
MFRC522::MIFARE_Key key;
void setup() {
Serial.begin(9600);
pinMode(led_blue, OUTPUT);
pinMode(led_red, OUTPUT);
while (!Serial);
SPI.begin();
mfrc522.PCD_Init();
mfrc522.PCD_DumpVersionToSerial();
Serial.println(F(&amp;quot;Scan PICC to see UID, SAK, type, and data blocks...&amp;quot;));
dump_byte_array(key.keyByte, MFRC522::MF_KEY_SIZE);
}
void loop() {
if ( ! mfrc522.PICC_IsNewCardPresent()) {
return;
}
if ( ! mfrc522.PICC_ReadCardSerial()) {
return;
}
String strBuf[mfrc522.uid.size];
for (byte i = 0; i &amp;lt; mfrc522.uid.size; i++) {
strBuf[i] = String(mfrc522.uid.uidByte[i], HEX);
if(strBuf[i].length() == 1){
strBuf[i] = &amp;quot;0&amp;quot; + strBuf[i];
}
}
String strUID = strBuf[0] + &amp;quot; &amp;quot; + strBuf[1] + &amp;quot; &amp;quot; + strBuf[2] + &amp;quot; &amp;quot; + strBuf[3] + &amp;quot; &amp;quot; + strBuf[4] + &amp;quot; &amp;quot; + strBuf[5] + &amp;quot; &amp;quot; + strBuf[6];
if ( strUID.equalsIgnoreCase(UID) ){
Serial.println(&amp;quot;chantoku&amp;quot;);
digitalWrite(led_blue, HIGH); // 青いLEDを光らせる
delay(1000); // 1秒待つ
digitalWrite(led_blue, LOW); // 青いLEDを消す
} else {
Serial.println(&amp;quot;error!&amp;quot;);
analogWrite(led_red, 180); // 赤いLEDを光らせる
delay(1000); // 1秒待つ
analogWrite(led_red, 0); // 赤いLEDを消す
}
}
void dump_byte_array(byte *buffer, byte bufferSize) {
for (byte i = 0; i &amp;lt; bufferSize; i++) {
Serial.print(buffer[i] &amp;lt; 0x10 ? &amp;quot; 0&amp;quot; : &amp;quot; &amp;quot;);
Serial.print(buffer[i], HEX);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先ほどと同様の手順でArduinoにプログラムを書き込みます。これで完成です！&lt;/p&gt;
&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;
&lt;p&gt;さっそく登録したタグを識別できるか試してみましょう。&lt;/p&gt;
&lt;p&gt;アオリちゃん（ピンクの子）が登録したタグ、ホタルちゃん（緑の子）は登録していないタグです。
&lt;a href=&#34;https://gyazo.com/2a2e957605e230f3d539f331c718f9b4&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/2a2e957605e230f3d539f331c718f9b4.gif&#34; alt=&#34;https://gyazo.com/2a2e957605e230f3d539f331c718f9b4&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登録したアオリちゃんをタッチした時は青、登録していないホタルちゃんをタッチした時は赤を光らせることができました！&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;非接触通信、無線通信というと難しいイメージがありますが、かなり簡単に実装することができました！この機能を使ってタッチした時間を記録したり、タグの識別を利用して電気をつける場所を変えたりと、いろいろなことに活用できそうです。&lt;/p&gt;
&lt;p&gt;次回は&lt;strong&gt;Wi-Fiに接続してタッチした時間を記録するデバイスの実装方法&lt;/strong&gt;を紹介してみたいと思います。&lt;/p&gt;
&lt;p&gt;それではまた！&lt;/p&gt;</description></item><item><title>くるくる回して値を入力！ロータリエンコーダでインプットの幅を広げよう</title><link>https://dotstud.io/blog/mongoose-os-rotary-encoder/</link><pubDate>Mon, 26 Mar 2018 01:00:43 +0900</pubDate><guid>https://dotstud.io/blog/mongoose-os-rotary-encoder/</guid><description>
&lt;p&gt;どうも。森田(&lt;a href=&#34;https://twitter.com/morita_pac&#34;&gt;@morita_pac&lt;/a&gt;)です。&lt;/p&gt;
&lt;p&gt;ボタンを押してトリガー発動！センサー値をグラフにダイレクトアタック！IoTって最高かよ！&lt;/p&gt;
&lt;p&gt;ってみなさん感じていると思います。&lt;/p&gt;
&lt;p&gt;そこへ、新たなスパイスを投ずるべく、森田は&lt;u&gt;&lt;strong&gt;ロータリエンコーダ&lt;/strong&gt;&lt;/u&gt;をおすすめします。&lt;/p&gt;
&lt;h2 id=&#34;ロータリエンコーダってなにかね&#34;&gt;ロータリエンコーダってなにかね？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;これです。&lt;/strong&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/154/1.png&#34; alt=&#34;&#34; /&gt;
回転の機械的変位量を電気信号に変換してくれます。つまり、&lt;u&gt;くるくるくるくる回してデジタル入力できるアイテム。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;今回は&lt;strong&gt;クリック有り&lt;/strong&gt;（カチカチなってくれる）の&lt;strong&gt;インクリメンタル式&lt;/strong&gt;のロータリエンコーダを使って解説します。&lt;/p&gt;
&lt;p&gt;⇒ 参考: ロータリエンコーダ販売ページ（&lt;a href=&#34;https://jp.rs-online.com/web/c/passive-components/rotary-encoders/&#34;&gt;RSコンポーネンツ&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;さまざまな種類のロータリエンコーダがあるので、上記サイトなどを参照してみてください。今回利用したもの（EC12E2420801）も購入できます。&lt;/p&gt;
&lt;h2 id=&#34;インクリメンタル式って何&#34;&gt;インクリメンタル式って何！？&lt;/h2&gt;
&lt;p&gt;まだ引かないでください。。。&lt;/p&gt;
&lt;p&gt;まず、ロータリエンコーダには信号検出の異なる「インクリメンタル式」と「アブソリュート式」があります。&lt;/p&gt;
&lt;h3 id=&#34;アブソリュート式&#34;&gt;アブソリュート式&lt;/h3&gt;
&lt;p&gt;回転位置が&lt;strong&gt;絶対的な数値として出力される高精度な方式&lt;/strong&gt;で、&lt;u&gt;電源断時でも回転位置を保持しておけることが特徴&lt;/u&gt;です。その分お値段も少々お高めなものが多いです。&lt;/p&gt;
&lt;p&gt;回転方向も、数値の増減から判断できます。
&lt;img src=&#34;https://dotstud.io/img/blog/154/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;インクリメンタル式&#34;&gt;インクリメンタル式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;回転した角度だけパルス（短時間の電流）出力される方式&lt;/strong&gt;で、今回使うロータリエンコーダの場合だと、&lt;u&gt;15度回転させるとカチッとする感触があり、その時1パルスが出力され、24パルス出力で1回転&lt;/u&gt;となります。
&lt;img src=&#34;https://dotstud.io/img/blog/154/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;回転方向を検出するために、位相が異なるA層B層の2つの端子からパルスを出力する構造になっており、
例えば、&lt;u&gt;A→Bの順にパルスの変化があった場合は時計回り、B→Aの順にパルスの変化があった場合は反時計周りのように区別&lt;/u&gt;することができます。
&lt;img src=&#34;https://dotstud.io/img/blog/154/4.png&#34; alt=&#34;&#34; /&gt;
※イメージです。&lt;/p&gt;
&lt;h2 id=&#34;使えるようにしてみよう&#34;&gt;使えるようにしてみよう。&lt;/h2&gt;
&lt;p&gt;それでは、さっそくロータリエンコーダを使ってみるよ！&lt;/p&gt;
&lt;p&gt;今回は、ESP32、ESP8266などのボードにJavaScriptで書き込みができる「&lt;strong&gt;Mongoose OS&lt;/strong&gt;」を利用してみます。&lt;strong&gt;なぜなら僕はMongoose OSが好きだから&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;Arduino言語での開発に慣れていない方にとっては、シンプルでわかりやすく感じると思います。Arduino IDEを使った方法やサンプルコードも、先例がたくさんあるので調べてみてください！&lt;/p&gt;
&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://sakura87.net/archives/2969&#34;&gt;Arduino Unoでロータリーエンコーダを使う│SAKURA87.net&lt;/a&gt;&lt;br /&gt;
⇒ 参考: &lt;a href=&#34;http://nn-hokuson.hatenablog.com/entry/2017/03/26/102145&#34;&gt;【Arduino】マウスホイール（ロータリーエンコーダ）の回転量を取得する│おもちゃラボ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mongoose OSを導入するまでの手順は下記の記事を参照してください。
&lt;section class=&#34;link&#34; id=&#34;145&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/mongoose-os-nefry-blink/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/145/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
JavaScriptで開発できる！Mongoose OSでNefry BTをLチカしよう
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2018-02-08
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
JavaScriptでプログラミングできるMongoose OSを使ってNefry BTのLチカを試してみます！
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用意したもの&#34;&gt;用意したもの&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mongoose OS（導入方法は&lt;a href=&#34;https://dotstud.io/blog/mongoose-os-nefry-blink/&#34;&gt;こちらの記事&lt;/a&gt;を参考）&lt;/li&gt;
&lt;li&gt;ロータリエンコーダ（EC12E2420801）&lt;/li&gt;
&lt;li&gt;ESP32-DevKitC&lt;/li&gt;
&lt;li&gt;いい感じのブレッドボード&lt;/li&gt;
&lt;li&gt;10KΩ抵抗 2本&lt;/li&gt;
&lt;li&gt;ジャンパワイヤ 数本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/154/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;
&lt;p&gt;下記の図を参考に配線してください。
&lt;img src=&#34;https://dotstud.io/img/blog/154/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;正回転（※）でプラス10、逆回転でマイナス10の数値をログに出力するプログラム&lt;/u&gt;です。コピーしてMongoose OSで書き込みます。それぞれのコードの詳細はコメントに記載します。&lt;/p&gt;
&lt;p&gt;※…正回転はエンコーダの位置アドレスが増加する回転方向のことです。今回利用したロータリエンコーダの場合は時計回りが正回転、反時計回りが逆回転です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;//GPIOのAPIを使えるようにします。
load(&#39;api_gpio.js&#39;);
//ロータリエンコーダのA,Bのピンアサイン
let pinA = 19;
let pinB = 18;
//A,Bの状態を読みます。
let stateA = GPIO.read(pinA);
let stateB = GPIO.read(pinB);
let count =50;
let rotate =0;
//おまじない
GPIO.set_mode(pinA,GPIO.MODE_INPUT);
GPIO.set_mode(pinB,GPIO.MODE_INPUT);
//プラス1(正回転)を判断するための関数です。
let getRotationActA = function(){
let Acount = 0;
let AA = GPIO.read(pinA);
let AB = GPIO.read(pinB);
if (AA === 0 &amp;amp;&amp;amp; AB === 1)
{
AA = GPIO.read(pinA);
AB = GPIO.read(pinB);
Acount = 1;
}
return Acount;
};
//マイナス1(逆回転)を判断するための関数です。
let getRotationActB = function(){
let Bcount = 0;
let BA = GPIO.read(pinA);
let BB = GPIO.read(pinB);
if (BA === 1 &amp;amp;&amp;amp; BB === 0)
{
BA = GPIO.read(pinA);
BB = GPIO.read(pinB);
Bcount = -1;
}
return Bcount;
};
//Aにパルスが来た時に動くイベントです。
GPIO.set_button_handler(pinA, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 100, function(x) {
rotate = getRotationActA();
if(rotate === 1){
count = count +rotate*10;
print(count);
}
}, null);
//Bにパルスが来た時に動くイベントです。
GPIO.set_button_handler(pinB, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 100, function(x) {
rotate = getRotationActB();
if(rotate === -1){
count = count +rotate*10;
print(count);
}
}, null);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;試してみよう&#34;&gt;試してみよう。&lt;/h2&gt;
&lt;p&gt;書き込めたら、実際に試してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/154/7.png&#34; alt=&#34;&#34; /&gt;
Mongoose OSのコンソールからロータリエンコーダの値を確認することができます。&lt;/p&gt;
&lt;p&gt;下記はOLEDディスプレイに値を表示するようにしてみました。
&lt;img src=&#34;https://gyazo.com/52dce8bbfa4e37382bc964e1aef3109f.gif&#34; alt=&#34;&#34; /&gt;
正回転で値が増え、逆回転で値が減っていきます！&lt;/p&gt;
&lt;p&gt;Mongoose OSの特徴とチャタリングの関係から、勢いよくロータリエンコーダを回すと正確に信号を捉えられません。解決できる方法があるぜ。という場合はご連絡くださいませ。&lt;/p&gt;
&lt;h2 id=&#34;さいごに&#34;&gt;さいごに&lt;/h2&gt;
&lt;p&gt;いかがでしたでしょうか。これで、&lt;strong&gt;入力に新たな選択肢が加わった&lt;/strong&gt;と思います。&lt;/p&gt;
&lt;p&gt;ロータリエンコーダにはボタン付きのものもあったりしますので、選択してボタンプッシュで送信のような機能が欲しい場合に使えると思います。&lt;/p&gt;
&lt;p&gt;初期搭載のスイッチやセンサからの入力に飽きてしまった方は、ぜひ試してみてください！&lt;/p&gt;</description></item><item><title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title><link>https://dotstud.io/blog/raspberry-pi-case-making/</link><pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate><guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid><description>
&lt;p&gt;こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong&gt;ラズパイにはまってしまったラズパイ女子です&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p&gt;
&lt;p&gt;しかしなかなか可愛いいケースがない……。&lt;strong&gt;ないなら、作ってしまえばいい！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p&gt;
&lt;h2 id=&#34;レーザーカッターを使える場所を探そう&#34;&gt;レーザーカッターを使える場所を探そう&lt;/h2&gt;
&lt;p&gt;今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong&gt;工作機械を気軽に利用できるFabスペース&lt;/strong&gt;を利用してみましょう！&lt;/p&gt;
&lt;p&gt;レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p&gt;
&lt;p&gt;何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p&gt;
&lt;h3 id=&#34;レーザーカッターが使える初心者向けオススメfabスペース&#34;&gt;レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3&gt;
&lt;p&gt;初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p&gt;
&lt;h4 id=&#34;fabcafe-https-fabcafe-com-tokyo&#34;&gt;&lt;a href=&#34;https://fabcafe.com/tokyo/&#34;&gt;◆FabCafe&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p&gt;
&lt;h4 id=&#34;iotlab-https-cami-jp-iotlab&#34;&gt;&lt;a href=&#34;https://cami.jp/iotlab/&#34;&gt;◆IoTLab&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p&gt;
&lt;h4 id=&#34;techshop-http-www-techshop-jp&#34;&gt;&lt;a href=&#34;http://www.techshop.jp/&#34;&gt;◆TechShop&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p&gt;
&lt;h2 id=&#34;ケースの形について調べてみよう&#34;&gt;ケースの形について調べてみよう&lt;/h2&gt;
&lt;p&gt;一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/1.png&#34; alt=&#34;&#34; /&gt;
「Raspberry Pi ケース」を検索
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;ケースの形によってはかなり難易度が高そうです……。&lt;/p&gt;
&lt;h3 id=&#34;初心者にも作りやすいケースの形&#34;&gt;初心者にも作りやすいケースの形&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li&gt;
&lt;li&gt;ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/2.png&#34; alt=&#34;&#34; /&gt;
上蓋と下蓋を支柱で支えるタイプのケース　　
&lt;/center&gt;&lt;/p&gt;
&lt;h2 id=&#34;部材を集めよう&#34;&gt;部材を集めよう&lt;/h2&gt;
&lt;h3 id=&#34;かわいいアクリルで作れば-かわいいケースになる-はず&#34;&gt;かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;かわいいアクリルで作ればかわいいケースになる&lt;/strong&gt;と信じて、素敵なアクリルを用意しましょう。&lt;/p&gt;
&lt;p&gt;アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong&gt;実際に店舗に行ってみるのがオススメ&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href=&#34;https://www.miyukiacryl.tokyo/tokyo-acryl&#34;&gt;デザインアクリル専門店 ミユキアクリル&lt;/a&gt;」さんのような&lt;strong&gt;デザインアクリル専門店&lt;/strong&gt;もあるので、興味のある方は覗いてみましょう！&lt;/p&gt;
&lt;p&gt;※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/3.png&#34; alt=&#34;&#34; /&gt;
自分好みのアクリルを選ぼう
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p&gt;
&lt;p&gt;厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p&gt;
&lt;p&gt;好みのアクリルがない場合は、&lt;strong&gt;UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong&gt;という手もあります。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/4.png&#34; alt=&#34;&#34; /&gt;
UVプリンターでイラストや写真を転写
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p&gt;
&lt;h3 id=&#34;ネジやスペーサーなどのパーツ&#34;&gt;ネジやスペーサーなどのパーツ&lt;/h3&gt;
&lt;p&gt;支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/5.png&#34; alt=&#34;&#34; /&gt;
上：真鍮黒ネジ、シルバーの六角スペーサー の組み合わせ&lt;br /&gt;
下：プラネジ、白のプラスチックのスペーサー&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;h3 id=&#34;必要なパーツ一覧&#34;&gt;必要なパーツ一覧&lt;/h3&gt;
&lt;p&gt;好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li&gt;
&lt;li&gt;ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li&gt;
&lt;li&gt;アクリル板固定・ネジ M3（8mm）8本&lt;/li&gt;
&lt;li&gt;アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li&gt;
&lt;li&gt;アクリル（今回は厚さ3mmのもの）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/parts.png&#34; alt=&#34;&#34; /&gt;
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p&gt;
&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;
&lt;h3 id=&#34;step1-型の準備&#34;&gt;step1. 型の準備&lt;/h3&gt;
&lt;p&gt;Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p&gt;
&lt;p&gt;ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href=&#34;https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y&#34;&gt;&lt;strong&gt;こちらのaiデータ&lt;/strong&gt;&lt;/a&gt;をそのまま使うこともできます。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/6.png&#34; alt=&#34;&#34; /&gt;
左：下蓋 / 右：上蓋
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;カメラ：幅0.9mm × 高さ28mm&lt;/li&gt;
&lt;li&gt;GPIO：幅55mm × 高さ12mm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/7.png&#34; alt=&#34;&#34; /&gt;
上蓋にカメラとGPIOの部分を追加
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;レーザーカッターには切る順番があり、「&lt;strong&gt;彫刻 → 穴 → 切り落とし&lt;/strong&gt;」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p&gt;
&lt;p&gt;これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p&gt;
&lt;h3 id=&#34;step2-アクリルを裁断&#34;&gt;step2. アクリルを裁断&lt;/h3&gt;
&lt;p&gt;今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;step3-組み立てる&#34;&gt;step3. 組み立てる&lt;/h3&gt;
&lt;p&gt;まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/9.png&#34; alt=&#34;&#34; /&gt;
短いスペーサーでラズパイを下蓋に固定
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p&gt;
&lt;h3 id=&#34;完成&#34;&gt;完成&lt;/h3&gt;
&lt;p&gt;自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src=&#34;https://dotstud.io/img/blog/142/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/12.png&#34; alt=&#34;&#34; /&gt;
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p&gt;
&lt;p&gt;日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong&gt;どこに連れて行ってもかわいいと言ってもらえる&lt;/strong&gt;ので作りがいがありました。何より愛着がわきますね〜！&lt;/p&gt;</description></item><item><title>日本上陸！littleBits cloudBitモジュールでIFTTT連携してみた！</title><link>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</link><pubDate>Tue, 22 Aug 2017 19:43:42 +0900</pubDate><guid>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</guid><description>
&lt;p&gt;littleBits cloudBitモジュールの技適が通りまして、ついに日本でも使えることになったということで、早速littleBits cloudBitモジュールを購入してIFTTTと連携してみました。
&lt;img src=&#34;https://dotstud.io/img/blog/119/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;littlebits-cloudbitモジュールとは&#34;&gt;littleBits cloudBitモジュールとは&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/2.png&#34; alt=&#34;&#34; /&gt;
littleBits cloudBitモジュールは、磁石でつなげて簡単に電子工作ができる知育ブロックlittleBitsのモジュールのひとつ、littleBits Cloudが橋渡しとなってインターネットとやり取りできるモジュールです。&lt;/p&gt;
&lt;p&gt;詳しくはこちら → &lt;a href=&#34;https://littlebits.cc/cloudstart&#34;&gt;Getting Started with your CloudBit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/3.png&#34; alt=&#34;&#34; /&gt;
橋渡しとなるlittleBits Cloudは、スマートフォンやPCからWEBアクセスできる CLOUD CONTROL APP や、LITTLEBITS APIによってREST APIでさらに深いところまで操作できるプログラミングできるLITTLEBITS APIといった入り口があります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/4.png&#34; alt=&#34;&#34; /&gt;
今回ご紹介するのは、もうひとつ。ノンプログラミングでインターネットのいろいろなことに接続できる&lt;a href=&#34;https://ifttt.com/login&#34;&gt;IFTTT&lt;/a&gt;とlittleBitsの連携についてお伝えします。&lt;/p&gt;
&lt;p&gt;たとえば、littleBitsモジュールでボタンを押すとメールが送られたり、SNSでいいねが押されるとlittleBitsのLEDが反応するようなIoTの仕組みをさっと作ることができます。&lt;/p&gt;
&lt;h2 id=&#34;今回の仕組み&#34;&gt;今回の仕組み&lt;/h2&gt;
&lt;p&gt;今回の仕組みはGitHubでissueが上がるとBARGRAPH LEDが点灯する仕組みです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/5.png&#34; alt=&#34;&#34; /&gt;
ですが、ただBARGRAPH LEDが光るだけだと見落としてしまうので、100円ショップで買った光で動くソーラーゆらゆら（がいこつ）にLEDを照らして動かしてよりわかりやすくします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/6.png&#34; alt=&#34;&#34; /&gt;
このような仕組みです。&lt;/p&gt;
&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;
&lt;h3 id=&#34;littlebitsの準備&#34;&gt;littleBitsの準備&lt;/h3&gt;
&lt;p&gt;セットアップについてはすでに行われているものとします。&lt;a href=&#34;http://www.1ft-seabass.jp/memo/2017/08/09/cloudbit-setup-step-memo/&#34;&gt;cloudBitモジュールのセットアップについてのメモ&lt;/a&gt;についてもご参考下さい。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/7.png&#34; alt=&#34;&#34; /&gt;
CLOUDBITパッケージに入っているものはcloudBitモジュール関連だけなので、別途写真のようにlittleBitから入力させるボタンモジュールや、出力を反応させるBARGRAPHモジュールは別途揃えておきましょう。また今回はソーラーゆらゆら（がいこつ）へうまくつなげるためにWIREモジュールも用意しておきます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CLOUDBITパッケージにあるもの
&lt;ul&gt;
&lt;li&gt;USB power adapter ケーブル&lt;/li&gt;
&lt;li&gt;USB POWER モジュール&lt;/li&gt;
&lt;li&gt;cloudBitモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;別途必要なもの
&lt;ul&gt;
&lt;li&gt;ボタンモジュール&lt;/li&gt;
&lt;li&gt;BARGRAPHモジュール&lt;/li&gt;
&lt;li&gt;WIREモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/8.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆらを準備します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/9.png&#34; alt=&#34;&#34; /&gt;
コンセントをつないだアダプターからUSBケーブルを差し込みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/10.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュールにUSBケーブルをつなぎます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/11.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュール→ボタンモジュール→cloudBitモジュールまでつないで、接続されるまで待ちます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/12.png&#34; alt=&#34;&#34; /&gt;
つづいて、cloudBitモジュールの先にWIREモジュールとBARGRAPH LEDモジュールをつなぎます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/13.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆら（がいこつ）のソーラーパネル部分にガッとBARGRAPH LEDモジュールを当てます。マスキングテープで補強します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/14.png&#34; alt=&#34;&#34; /&gt;
これで準備完了です。&lt;/p&gt;
&lt;h3 id=&#34;cloud-control-appの準備&#34;&gt;CLOUD CONTROL APPの準備&lt;/h3&gt;
&lt;p&gt;cloudBitを管理している CLOUD CONTROL APP ページにログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;iftttの準備&#34;&gt;IFTTTの準備&lt;/h3&gt;
&lt;p&gt;IFTTTもlittleBitsとの関連付けを行うのでログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;こちらで準備完了です。&lt;/p&gt;
&lt;h2 id=&#34;littlebits-cloudbitモジュールとiftttの関連付け&#34;&gt;littleBits CloudBitモジュールとIFTTTの関連付け&lt;/h2&gt;
&lt;p&gt;さきほどログインしたCLOUD CONTROL APP ページでlittleBits CloudBitモジュールとIFTTTの関連付けを行います。
&lt;img src=&#34;https://dotstud.io/img/blog/119/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;下部のメニューでAUTOMATEを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;AUTOMATEページに遷移するとIFTTTとのアクティベートを促されるので GO TO IFTTT.COM ボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;IFTTTのlittleBitsチャンネルに遷移するので、CONNECTを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;すでにIFTTTとCLOUD CONTROL APPがログインしてあるので、アクティベート確認ページに遷移します。AUTHORIZEボタンを押して認証します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ログインが完了します。これで、IFTTTでlittleBitsと連携することができます。&lt;/p&gt;
&lt;h2 id=&#34;githubサービスのiftttでの認証をする&#34;&gt;GitHubサービスのIFTTTでの認証をする&lt;/h2&gt;
&lt;p&gt;GitHubでもIFTTTで使えるようにしておきましょう。上部のSearchからgithubを検索します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Servicesに出てきたGitHubをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/119/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;GitHubのページに移動するのでConnectボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;GitHubのAuthrize IFTTTページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Authrize IFTTTCHannelsボタンを押して認証を済ませておきます。&lt;/p&gt;
&lt;h2 id=&#34;littlebitsのifttt連携の設定&#34;&gt;littleBitsのIFTTT連携の設定&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/28.png&#34; alt=&#34;&#34; /&gt;
右上にある自分のプロフィールメニューからNew Appletを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/29.png&#34; alt=&#34;&#34; /&gt;
New Appletをつくる画面に行きます。thisボタンをクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/30.png&#34; alt=&#34;&#34; /&gt;
Choose a serviceではgitと検索しGitHubをクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/31.png&#34; alt=&#34;&#34; /&gt;
今回は自分にissueが来たときに動作するようにしたいので、Any new issueをクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/32.png&#34; alt=&#34;&#34; /&gt;
つづいて動作のきっかけ this が作れたので、なにが起こるかの that を設定するため that ボタンを押します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/33.png&#34; alt=&#34;&#34; /&gt;
Choose action service画面になるので、littleBitsと検索し、littleBitsアクションをクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/34.png&#34; alt=&#34;&#34; /&gt;
Choose action画面になるので、Set Output Levelをクリックします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/35.png&#34; alt=&#34;&#34; /&gt;
Complete action fields画面になるので以下のように設定します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Which cloudBit?
&lt;ul&gt;
&lt;li&gt;動かしたいcloudBit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Level
&lt;ul&gt;
&lt;li&gt;100&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Duration
&lt;ul&gt;
&lt;li&gt;20 seconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/36.png&#34; alt=&#34;&#34; /&gt;
設定が終わったら、下の方のCreate Actionボタンを押します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/37.png&#34; alt=&#34;&#34; /&gt;
Review and finish画面に来るので、設定を確認します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/38.png&#34; alt=&#34;&#34; /&gt;
問題なければ、下の方のFinishボタンを押します。&lt;/p&gt;
&lt;p&gt;これで設定は完了です。&lt;/p&gt;
&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;
&lt;p&gt;早速試しにissueをGitHubで作ってみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/119/39.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;今回は適当に作ってみます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/40.png&#34; alt=&#34;&#34; /&gt;
issues発行します。&lt;/p&gt;
&lt;p&gt;多少タイムラグがあるので5～10秒ほど待ってみます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/demo.gif&#34; alt=&#34;&#34; /&gt;
無事動きました！&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;ということで、技適が通り日本上陸となった、littleBits cloudBitモジュールのIFTTT連携をお伝えしました。&lt;/p&gt;
&lt;p&gt;今回はIoTでも実装に手間がかかるインターネット上の反応をlittleBitsに降ろす仕組みを軸にお伝えしましたがIFTTTとlittleBits Cloudの連携は手軽に作れますね。IoTにおけるいろいろな技術要素が裏側でしっかり作られています。&lt;/p&gt;
&lt;p&gt;もちろん、IFTTTと連携するとAmazon Dash Buttonのような、ボタンを押すとツイートがされるようなlittleBitsからインターネットを動かす仕組みについても実現可能です。&lt;/p&gt;
&lt;p&gt;littleBitsの持つブロックを組み合わせて電子工作ができる手軽さに加えて、IFTTTが組み合わさることでインターネットもあたかもブロックのように扱えてるlittleBits cloudBitモジュール、ぜひ試してみてください！&lt;/p&gt;
&lt;p&gt;※今回の図表の一部では&lt;a href=&#34;http://icooon-mono.com/&#34;&gt;アイコン素材ダウンロードサイト「icooon-mono」&lt;/a&gt;さんの画像を利用いたしました。ありがとうございます。&lt;/p&gt;</description></item><item><title>ESP8266を使って京急が遅延すると光るガジェットを作ってみた</title><link>https://dotstud.io/blog/pokio-esp-keikyu-chien/</link><pubDate>Tue, 13 Jun 2017 19:28:32 +0900</pubDate><guid>https://dotstud.io/blog/pokio-esp-keikyu-chien/</guid><description>
&lt;p&gt;こんにちは、京急が大好きなポキオです。&lt;/p&gt;
&lt;p&gt;普段はAndroidエンジニアをやってますが、週末は趣味でArduinoやESP8266を触って心を落ち着かせています。先日、「京急が遅延すると光るガジェット」を作って&lt;a href=&#34;https://iotlt.connpass.com/&#34;&gt;IoTLT&lt;/a&gt;で発表を行ってきました。&lt;/p&gt;
&lt;p&gt;今回は、そこで発表したガジェットの作成段階や、技術的な仕組みを紹介します。（発表後に一部パーツ・コーディングを変更しています）&lt;/p&gt;
&lt;h2 id=&#34;今回作るもの&#34;&gt;今回作るもの&lt;/h2&gt;
&lt;p&gt;ESP8266というWi-Fiモジュールを搭載した開発ボード「ESPr® Developer」を使って京急のホームページから運行情報を取得し、遅延していたらLEDを光らせる仕組みを作ります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/01_map.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MacBook Air（13-inch、Mid 2013）&lt;/li&gt;
&lt;li&gt;OS X Yosemite（v10.10.5）&lt;/li&gt;
&lt;li&gt;Arduino IDE 1.8.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ESPr® DeveloperESP8266&lt;/li&gt;
&lt;li&gt;マイコン内臓RGB LED&lt;/li&gt;
&lt;li&gt;光らせたいガジェット（今回はBトレインショーティ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主なパーツ&#34;&gt;主なパーツ&lt;/h2&gt;
&lt;h3 id=&#34;espr-developer&#34;&gt;ESPr® Developer&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/02_esper.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://www.switch-science.com/catalog/2500/&#34;&gt;スイッチサイエンス&lt;/a&gt;さんで売られている、ESP8266というWi-Fiモジュールを搭載した開発ボードです。素のESP8266を直接触るのはハードルが高いですが、USB-シリアル変換やレギュレータ、リセットスイッチなど実装済みで、Arduino IDEでも開発できるため便利です。&lt;/p&gt;
&lt;p&gt;ただし、筆者の開発環境ではArduino IDEからコードを流し込む際に、一手間必要でした。詳しくはこちら。&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://qiita.com/shanonim/items/68fab6dc28b72b31a258&#34;&gt;ESPr Developer（ESP-WROOM-02開発ボード）で &amp;ldquo;warning: espcomm_sync failed&amp;rdquo; と表示される場合の対処&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;マイコン内蔵rgb-led&#34;&gt;マイコン内蔵RGB LED&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/03_led.png&#34; alt=&#34;画像&#34; /&gt;
秋葉原の&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-08412/&#34;&gt;秋月電子通商&lt;/a&gt;さんで1個40円で売られているものを使用します。通常のLEDは足が2本ですが、こちらは足が4本。これらを制御することで、様々な色でLEDを光らせることができます。ESP8266（Arduino）向けに便利なライブラリが公開されているので、今回はこれを使ってコーディングしていきます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/adafruit/Adafruit_NeoPixel&#34;&gt;Adafruit NeoPixel Library&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;bトレインショーティー&#34;&gt;Bトレインショーティー&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/04_train.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://bandai-hobby.net/train/&#34;&gt;Bトレインショーティー&lt;/a&gt;はバンダイさんから発売されている、自分で組み立てるタイプの鉄道模型です。特徴は、何と言っても可愛さ。実車のディテールを表現しつつ、車両の長さをギュッと縮めてコミカルなルックスになっています。今回は（もちろん京急の）2100形をチョイス。京急の中で好きな車両の一つです。&lt;/p&gt;
&lt;h2 id=&#34;ガジェットを作ってみる&#34;&gt;ガジェットを作ってみる&lt;/h2&gt;
&lt;h3 id=&#34;京急の2100形車両の組み立て&#34;&gt;京急の2100形車両の組み立て&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/05_keikyu1.png&#34; alt=&#34;画像&#34; /&gt;
なにはともあれ、京急の車両を組み立てるところから始めます。Bトレインショーティーの京急2100形は、塗装済みで接着剤不要で組み立てができます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/06_keikyu2.png&#34; alt=&#34;画像&#34; /&gt;
久しぶりのプラモデルにテンションがアガります。&lt;/p&gt;
&lt;h3 id=&#34;マイコン内蔵rgb-ledを埋め込む&#34;&gt;マイコン内蔵RGB LEDを埋め込む&lt;/h3&gt;
&lt;p&gt;出来上がった京急の車両にLEDを埋め込んでいきます。ここで便利なのがサンハヤトさんの&lt;a href=&#34;http://www.sunhayato.co.jp/material2/index.php/item?cell003=%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF%E8%A3%BD%E5%93%81&amp;amp;cell004=%E4%B8%AD%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF&amp;amp;name=%E8%96%84%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF+UB-THN01&amp;amp;id=722&amp;amp;label=1&#34;&gt;ハサミで切れるユニバーサル基板&lt;/a&gt;です。
&lt;img src=&#34;https://dotstud.io/img/blog/099/07_universal1.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;
&lt;p&gt;謳い文句の通り、ハサミで自由にカットができて、今回のような小さい車両にも基板を収めることができます。
&lt;img src=&#34;https://dotstud.io/img/blog/099/08_universal2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;
&lt;p&gt;こんな感じで簡単に、そしてその場で車両ピッタリの基板ができました。
&lt;img src=&#34;https://dotstud.io/img/blog/099/09_rgb_led.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;
&lt;p&gt;マイコン内蔵RGB LEDは先述の通り足が4本あり、電源（VDD）とグラウンド（GND）に加えて、制御信号の入出力（DIN・DO）があります。DIN・DOは図のように数珠つなぎで配線します。
&lt;img src=&#34;https://dotstud.io/img/blog/099/10_rgb_led2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;
&lt;p&gt;電源とグラウンドは共通で、それぞれESPr® DeveloperのVOUTとGNDに接続します。大元のDINはPIN4に接続します。&lt;/p&gt;
&lt;h3 id=&#34;遅延情報の取得ロジック&#34;&gt;遅延情報の取得ロジック&lt;/h3&gt;
&lt;p&gt;WebAPI等は使用せずに、10分に一度、&lt;a href=&#34;http://unkou.keikyu.co.jp/&#34;&gt;京急の運行情報ページ&lt;/a&gt;にアクセスして情報を取得します。&lt;/p&gt;
&lt;p&gt;ESPr® Developerから運行情報の文言をHTTP-GETで取得して、その文言に&lt;strong&gt;特定の文字列&lt;/strong&gt;が含まれるかどうかで運行状態を推測します。具体的には・・・&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「&lt;strong&gt;受託&lt;/strong&gt;」という文字列が含まれていたら、他社線からの振替輸送受託のために遅延していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;見合わせ&lt;/strong&gt;」という文字列が含まれていたら、運転見合わせが発生していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;乱れ&lt;/strong&gt;」という文字列が含まれていたら、ダイヤが大幅に乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;遅れ&lt;/strong&gt;」や「&lt;strong&gt;運休&lt;/strong&gt;」が含まれていたら、ダイヤが少し乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;平常&lt;/strong&gt;」が含まれていたら、平常運転であると判断する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このような感じです。そして、運転見合わせであれば赤い点滅、ダイヤが少し乱れているときは黄色い点滅をさせるといった感じで、運行状態に応じてマイコン内蔵RGB LEDの光り方を変えることで、運行状態をひと目で把握することができます。&lt;/p&gt;
&lt;p&gt;ちなみに、他社線からの振替輸送受託が理由で京急が遅延しているときは、個人的にすこし残念な気持ちになるので、光り方を変えています（笑）&lt;/p&gt;
&lt;h3 id=&#34;espr-developerのコーディング&#34;&gt;ESPr® Developerのコーディング&lt;/h3&gt;
&lt;p&gt;かなり無理矢理ですが、こんな感じでコーディングしました。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;ESP8266WiFi.h&amp;gt;
#include &amp;lt;WiFiClient.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;
#define PIN 4 // DINを接続しているPIN
#define NUMLED 4 // マイコン内蔵RGB LEDの個数
#define SSID &amp;quot;（Wi-FiアクセスポイントのSSID）&amp;quot;
#define PASSWORD &amp;quot;（Wi-Fiアクセスポイントのパスワード）&amp;quot;
#define KEIKYU_PAGE &amp;quot;unkou.keikyu.co.jp&amp;quot; // 運行情報のページ
#define INTERVAL_SEC 10 * 60 // ポーリング間隔
Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMLED, PIN, NEO_RGB + NEO_KHZ800);
void setup() {
// Serialの初期化
Serial.begin(115200);
Serial.println(&amp;quot;&amp;quot;);
// マイコン内蔵RGB LEDの初期化
pixels.begin();
}
void loop() {
// Wi-Fi接続開始
connectWifi();
// 京急の運行ページから運行情報取得
String trainInfo = getTrainInfo();
// Wi-Fi接続終了
disconnectWifi();
// 「受託」という文字が含まれていたら、他社からの振替輸送受託で遅延していると判断
if (trainInfo.indexOf(&amp;quot;受託&amp;quot;) &amp;gt; 0) {
Serial.println(&amp;quot;振替輸送受託！&amp;quot;);
blinkLikePartyPeople(INTERVAL_SEC);
return;
}
// 「見合わせ」という文字が含まれていたら、運転見合わせが発生していると判断
if (trainInfo.indexOf(&amp;quot;見合わせ&amp;quot;) &amp;gt; 0) {
Serial.println(&amp;quot;運転見合わせ！&amp;quot;);
blinkRed(INTERVAL_SEC);
return;
}
// 「乱れ」という文字が含まれていたら、ダイヤが大幅に乱れていると判断
if (trainInfo.indexOf(&amp;quot;乱れ&amp;quot;) &amp;gt; 0) {
Serial.println(&amp;quot;大幅に乱れている！&amp;quot;);
blinkYellowAndRed(INTERVAL_SEC);
return;
}
// 「遅れ」「運休」という文字が含まれていたら、ダイヤが少し乱れていると判断
if (trainInfo.indexOf(&amp;quot;遅れ&amp;quot;) &amp;gt; 0 || trainInfo.indexOf(&amp;quot;運休&amp;quot;) &amp;gt; 0) {
Serial.println(&amp;quot;遅延！&amp;quot;);
blinkYellow(INTERVAL_SEC);
return;
}
// 「平常」という文字が含まれていたら、平常運転をしていると判断
if (trainInfo.indexOf(&amp;quot;平常&amp;quot;) &amp;gt; 0) {
Serial.println(&amp;quot;たぶん平常通り運転！&amp;quot;);
delay(INTERVAL_SEC * 1000);
return;
}
// 運行情報取得エラーかもしれないので、10秒待ってもう一度取得する
blinkWhite(10);
}
// Wi-Fi接続
void connectWifi() {
WiFi.mode(WIFI_STA);
WiFi.begin(SSID, PASSWORD);
while (WiFi.status() != WL_CONNECTED) {
Serial.print(&amp;quot;.&amp;quot;);
blinkWhite(3);
}
Serial.println(&amp;quot;Wi-Fi接続完了&amp;quot;);
}
// Wi-Fi切断
void disconnectWifi() {
WiFi.disconnect();
Serial.println(&amp;quot;Wi-Fi切断完了&amp;quot;);
}
// 運行情報の文字列取得
String getTrainInfo() {
WiFiClient client;
if ( !client.connect(KEIKYU_PAGE, 80) ) {
// 接続エラー
return String(&amp;quot;&amp;quot;);
}
// HTTP-GET
// レスポンスのLengthが長すぎるとエラーになることがあったのでRangeを指定している
client.print(String(&amp;quot;GET &amp;quot;) + &amp;quot;/&amp;quot; + &amp;quot; HTTP/1.1\r\n&amp;quot; +
&amp;quot;Host: &amp;quot; + KEIKYU_PAGE + &amp;quot;\r\n&amp;quot; +
&amp;quot;Range: bytes=8000-9000\r\n&amp;quot; +
&amp;quot;Connection: close\r\n\r\n&amp;quot;);
client.println();
delay(1000);
String body = &amp;quot;&amp;quot;;
String trainInfo = &amp;quot;&amp;lt;!-- ======================== 運行情報 =================================== --&amp;gt;&amp;quot;;
while (client.available()) {
body += client.readStringUntil(&#39;\r&#39;);
}
// レスポンスから運行情報部分だけを切り抜く
body = body.substring(body.indexOf(trainInfo) + trainInfo.length());
body = body.substring(0, body.indexOf(trainInfo));
return body;
}
// 白い点滅
void blinkWhite(int sec) {
int count = 0;
while (count &amp;lt; sec) {
for (int i = 0; i &amp;lt; 256; i += 5) {
setColor( i, i, i);
}
for (int i = 255; i &amp;gt;= 0; i -= 5) {
setColor( i, i, i);
}
count++;
}
}
//　黄色い点滅
void blinkYellow(int sec) {
int count = 0;
while (count &amp;lt; sec) {
for (int i = 0; i &amp;lt; 256; i += 5) {
setColor( i, i, 0);
}
for (int i = 255; i &amp;gt;= 0; i -= 5) {
setColor( i, i, 0);
}
count++;
}
}
// 黄色と赤の点滅
void blinkYellowAndRed(int sec) {
int count = 0;
while (count &amp;lt; sec) {
for (int i = 0; i &amp;lt; 256; i += 5) {
setColor( i, 0, 0);
}
for (int i = 255; i &amp;gt;= 0; i -= 5) {
setColor( i, 0, 0);
}
for (int i = 0; i &amp;lt; 256; i += 5) {
setColor( i, i, 0);
}
for (int i = 255; i &amp;gt;= 0; i -= 5) {
setColor( i, i, 0);
}
count++;
count++;
}
}
// 赤い点滅
void blinkRed(int sec) {
int count = 0;
while (count &amp;lt; sec) {
for (int i = 0; i &amp;lt; 256; i += 5) {
setColor( i, 0, 0);
}
for (int i = 255; i &amp;gt;= 0; i -= 5) {
setColor( i, 0, 0);
}
count++;
}
}
// パリピな輝き
void blinkLikePartyPeople(int sec) {
int count = 0;
while (count &amp;lt; sec) {
for (int i = 0; i &amp;lt; 20; i++) {
setRandomColor();
delay(50);
}
count++;
}
}
// LEDを指定した色で光らせる
void setColor(int r, int g, int b) {
for (int i = 0 ; i &amp;lt; NUMLED; i++) {
pixels.setPixelColor(i, pixels.Color(r, g, b));
pixels.show();
}
delay(10);
}
// LEDをランダムな色で光らせる
void setRandomColor() {
for (int i = 0 ; i &amp;lt; NUMLED; i++) {
pixels.setPixelColor(i, pixels.Color(64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 ));
pixels.show();
}
delay(10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実際に光らせてみたのがこちら。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/11_setting.png&#34; alt=&#34;画像&#34; /&gt;
情報取得中に実行される白い点滅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/12_late.png&#34; alt=&#34;画像&#34; /&gt;
運転見合わせ時に実行される赤い点滅。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/13_transport.png&#34; alt=&#34;画像&#34; /&gt;
最後は他社線からの振替輸送受託時に実行されるパリピ点滅。画像では少しわかりづらいですね……。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回は、京急が遅延していると光るガジェットをESPr® Developerをつかって作成しました。情報の取得方法はかなり力技でしたが、WEB上の情報を簡単に可視化できたことは良かったです。&lt;/p&gt;
&lt;p&gt;実際にこのガジェットは、職場のデスクで稼働していて、いつも京急の運行情報を知らせてくれます。今後は他社線バージョンの作成を検討しています。&lt;/p&gt;</description></item></channel></rss>