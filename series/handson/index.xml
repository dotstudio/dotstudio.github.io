<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Handson on dotstudio（ドットスタジオ）</title>
    <link>https://dotstud.io/series/handson/</link>
    <description>Recent content in Handson on dotstudio（ドットスタジオ）</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© 2018 dotstudio inc.</copyright>
    <lastBuildDate>Wed, 09 May 2018 08:30:26 +0900</lastBuildDate>
    <atom:link href="/series/handson/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>非接触ICタグで遊ぼう！ArduinoでRFIDリーダRC522を使う方法</title>
      <link>https://dotstud.io/blog/arduino-use-rfid-reader/</link>
      <pubDate>Wed, 09 May 2018 08:30:26 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/arduino-use-rfid-reader/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃんとくです。&lt;/p&gt;

&lt;p&gt;みなさんは「&lt;strong&gt;認証機能&lt;/strong&gt;」というとどんなイメージを持つでしょうか？&lt;/p&gt;





&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/auth.png&#34; alt=&#34;auth&#34;&gt;

&lt;/center&gt;


&lt;p&gt;Webページを開いて、IDとパスワードを入力して、ログインして……。「&lt;strong&gt;めんどくさい！もっと簡単に認証したい！&lt;/strong&gt;」ということもありますよね。&lt;/p&gt;

&lt;p&gt;そんなときは&lt;strong&gt;非接触ICタグ&lt;/strong&gt;を使って、&lt;strong&gt;ピッとして認証できる装置&lt;/strong&gt;を作ってみましょう！&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/touch.png&#34; alt=&#34;touch&#34;&gt;

&lt;/center&gt;

今回はArduinoとRFIDリーダを使って、非接触ICタグをかざすと登録されたユーザかどうか判定するデバイスを作ってみます！&lt;/p&gt;

&lt;p&gt;※ただし今回の実装は&lt;strong&gt;セキュリティ対策を施していない&lt;/strong&gt;ので、ご家庭内や趣味の範囲でお試しください。&lt;/p&gt;

&lt;h2 id=&#34;rfid-nfc-非接触ic&#34;&gt;RFID？NFC？非接触IC？&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;RFID&lt;/strong&gt;」とは、電磁界や電波を用いて情報を埋め込んだRFタグとやりとりする無線通信技術です。「&lt;strong&gt;NFC&lt;/strong&gt;」はRFタグの規格の一つで、正式名称は&lt;strong&gt;Near Field Communication&lt;/strong&gt;（近距離無線通信）と言います。&lt;/p&gt;

&lt;p&gt;非接触ICは、&lt;strong&gt;読み取り端末にかざすことで通信ができる電池レスのIC&lt;/strong&gt;です（電池内臓の場合もあります）。&lt;/p&gt;

&lt;p&gt;世界で利用されているMifare（マイフェア）カードやTaspoでは「ISO/IEC 14443 Type A」というNFCの規格、日本で利用されている交通系ICカードでは「FeliCa」という規格が主に利用されています。&lt;/p&gt;

&lt;p&gt;今回利用するRFIDリーダライタのRFID-RC522では、&lt;strong&gt;FeliCa規格のICは読み取ることができません&lt;/strong&gt;。FeliCaを利用したい場合はSony製の&lt;a href=&#34;https://www.sony.co.jp/Products/felica/consumer/index.html&#34;&gt;PaSoRi&lt;/a&gt;やFeliCaリーダライタ&lt;a href=&#34;https://www.switch-science.com/catalog/353/&#34;&gt;RC-S620S&lt;/a&gt;などを使ってみてください。&lt;/p&gt;

&lt;h2 id=&#34;今回使うもの&#34;&gt;今回使うもの&lt;/h2&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/use.png&#34; alt=&#34;use&#34;&gt;

&lt;/center&gt;

今回はArduinoまたは互換ボード（写真はGenuino 101）、RFIDリーダライタRC522、その他に判定用のLEDやブレッドボード、ジャンパワイヤを利用します。&lt;/p&gt;

&lt;h3 id=&#34;arduino-互換ボード&#34;&gt;Arduino/互換ボード&lt;/h3&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/genuino.png&#34; alt=&#34;genuino&#34;&gt;

&lt;/center&gt;

Arduinoや互換ボードを利用すると、RC522ライブラリをそのまま使えて簡単です。写真ではGenuino 101（※）を使っていますが、今回使うピンの配置はArduino Unoと全く同じです。&lt;/p&gt;

&lt;p&gt;Arduino Mega、Nano v3、Microなども利用できますが、ピンの接続箇所が変わるので今回利用する&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;&lt;strong&gt;MFRC522ライブラリ&lt;/strong&gt;&lt;/a&gt;の&lt;a href=&#34;https://github.com/miguelbalboa/rfid#pin-layout&#34;&gt;Pin Layout&lt;/a&gt;を参考に配線してください。&lt;/p&gt;

&lt;p&gt;&lt;font size=&#34;2&#34;&gt;※Genuino 101はBluetooth搭載のIntel製ボードで、色が好きなので多用しています。ディスコンになってしまったけど……。&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;rfid-rc522&#34;&gt;RFID-RC522&lt;/h3&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/rc522set.png&#34; alt=&#34;rc522set&#34;&gt;

&lt;/center&gt;

安価で入手しやすいRFIDリーダライタです。&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;ライブラリ&lt;/a&gt;側でドキュメントとサンプルコードが用意されていて、Arduinoで扱いやすいです。過出力や電波の不要輻射を防ぐため、3.3Vで利用します。&lt;/p&gt;

&lt;p&gt;※RFID-RC522では、&lt;strong&gt;FeliCa規格のICは読み取ることができません&lt;/strong&gt;。FeliCaを利用したい場合はSony製の&lt;a href=&#34;https://www.sony.co.jp/Products/felica/consumer/index.html&#34;&gt;PaSoRi&lt;/a&gt;やFeliCaリーダライタ&lt;a href=&#34;https://www.switch-science.com/catalog/353/&#34;&gt;RC-S620S&lt;/a&gt;などを使ってみてください。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/rc522.png&#34; alt=&#34;rc522&#34;&gt;

&lt;/center&gt;

例えばAmazonで「&lt;strong&gt;RC522&lt;/strong&gt;」を検索すると、&lt;u&gt;価格帯の違うものがたくさんでてきます&lt;/u&gt;。&lt;strong&gt;お届け時期&lt;/strong&gt;や&lt;strong&gt;発送元&lt;/strong&gt;（Amazon.co.jpからだと安心かも）、&lt;strong&gt;送料&lt;/strong&gt;、&lt;strong&gt;レビュー&lt;/strong&gt; などに注意して購入しましょう！&lt;/p&gt;

&lt;p&gt;ちゃんとくは急いでいたので、Amazon.co.jpが発送する翌日受け取りできるものを購入しました。&lt;/p&gt;





&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/solder.png&#34; alt=&#34;solder&#34;&gt;

&lt;/center&gt;


&lt;p&gt;ピンヘッダは未実装の状態で届くので、好きな角度の方をはんだづけしておきます（かっこいい！と思ってくの字型のピンヘッダを使いましたが、タグによってはジャンパが邪魔してタッチしづらいです……）。&lt;/p&gt;

&lt;h3 id=&#34;rfid-nfcタグ&#34;&gt;RFID/NFCタグ&lt;/h3&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/nfc.png&#34; alt=&#34;nfc&#34;&gt;

&lt;/center&gt;

こちらもAmazonで「&lt;strong&gt;NFCタグ&lt;/strong&gt;」などと検索してみると、かなり安価で手に入ることがわかります。ステッカーを使えば、手持ちのキーホルダーなどを簡単にキーにすることができますね！&lt;/p&gt;

&lt;p&gt;RC522のセットを購入した場合はカードとキーホルダーがついてきますし、「&lt;strong&gt;とりあえず試したいだけ&lt;/strong&gt;」「&lt;strong&gt;認識させたいICタグが既にある&lt;/strong&gt;」という場合は購入しなくて大丈夫です。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/shiokara.png&#34; alt=&#34;shiokara&#34;&gt;

&lt;/center&gt;

ちゃんとくは、&lt;strong&gt;シオカラーズの2人（Splatoon）&lt;/strong&gt;に協力してもらおうと思います！！&lt;/p&gt;

&lt;p&gt;これは任天堂のamiiboというフィギュアなんですが、&lt;strong&gt;ゲーム用のNFCを搭載&lt;/strong&gt;していてRFIDリーダで情報を読み取ることができます。&lt;/p&gt;

&lt;h2 id=&#34;識別子を取得する&#34;&gt;識別子を取得する&lt;/h2&gt;

&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;MFRC522ライブラリ&lt;/a&gt;の&lt;a href=&#34;https://github.com/miguelbalboa/rfid#pin-layout&#34;&gt;&lt;strong&gt;Pin Layout&lt;/strong&gt;&lt;/a&gt;を参考に、ArduinoとRC522を接続していきます。Arduino Mega、Nano v3、Microなども利用できますが、ピンの接続箇所が変わるのでライブラリのREADMEを参照してください。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Signal&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;MFRC522 Reader/PCD Pin&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Arduino Uno Pin&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RST/Reset&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RST&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI SS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SDA(SS)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI MOSI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MOSI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;11 / ICSP-4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI MISO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MISO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;12 / ICSP-1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SPI SCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;13/ICSP-3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上記の表の通り、RC522のSignalの名前の部分を見て、対応するArduino Unoのピンに接続します。&lt;/p&gt;

&lt;p&gt;その他、RC522の「GND」はArduinoの「GND」へ、RC522の「3.3V」はArduinoの「3.3V」へ接続します。&lt;/p&gt;





&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/circuit1.png&#34; alt=&#34;circuit1&#34;&gt;

&lt;/center&gt;


&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/map.png&#34; alt=&#34;map&#34;&gt;

&lt;/center&gt;

慣習的に3.3Vを赤、GNDを黒、その他はそれぞれ違う色のジャンパで繋ぐと見やすいです。書いてある通りに繋ぐだけなので、落ち着いて接続しましょう！（IRQというピンは今回は使用しません）&lt;/p&gt;

&lt;p&gt;ブレッドボードの使い方がよくわからない、という方は、ドキュメントの「&lt;a href=&#34;https://dotstud.io/docs/breadboard/&#34;&gt;&lt;strong&gt;ブレッドボード&lt;/strong&gt;&lt;/a&gt;」を参照してください。&lt;/p&gt;

&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.arduino.cc/en/main/software&#34;&gt;Arduino IDE&lt;/a&gt;というソフトを使い、Arduinoにプログラムを書き込みます。インストール方法は、ドキュメントの「&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;&lt;strong&gt;Arduino IDEをPCにインストール&lt;/strong&gt;&lt;/a&gt;」を参照してください。&lt;/p&gt;

&lt;p&gt;まずArduino IDEに、今回利用する&lt;a href=&#34;https://github.com/miguelbalboa/rfid&#34;&gt;&lt;strong&gt;MFRC522ライブラリ&lt;/strong&gt;&lt;/a&gt;をインストールします。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step1.png&#34; alt=&#34;step1&#34;&gt;

  ─ ライブラリマネージャを開く

&lt;/center&gt;

[スケッチ] &amp;gt; [ライブラリをインクルード] &amp;gt; [ライブラリを管理]を選択します。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step2.png&#34; alt=&#34;step2&#34;&gt;

  ─ MFRC522ライブラリをインストール

&lt;/center&gt;

「MFRC」と検索し、MFRC522ライブラリをインストールします。&lt;/p&gt;

&lt;p&gt;エディタには下記のプログラムを貼り付けます。ライブラリの&lt;a href=&#34;https://github.com/miguelbalboa/rfid/blob/master/examples/DumpInfo/DumpInfo.ino&#34;&gt;DumpInfoのサンプルコード&lt;/a&gt;をそのまま利用しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;MFRC522.h&amp;gt;

constexpr uint8_t RST_PIN = 9;          // Configurable, see typical pin layout above
constexpr uint8_t SS_PIN = 10;         // Configurable, see typical pin layout above

MFRC522 mfrc522(SS_PIN, RST_PIN);  // Create MFRC522 instance

void setup() {
		Serial.begin(9600);		// Initialize serial communications with the PC
		while (!Serial);		// Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
		SPI.begin();			// Init SPI bus
		mfrc522.PCD_Init();		// Init MFRC522
		mfrc522.PCD_DumpVersionToSerial();	// Show details of PCD - MFRC522 Card Reader details
		Serial.println(F(&amp;quot;Scan PICC to see UID, SAK, type, and data blocks...&amp;quot;));
}

void loop() {
	// Look for new cards
	if ( ! mfrc522.PICC_IsNewCardPresent()) {
			return;
	}

	// Select one of the cards
	if ( ! mfrc522.PICC_ReadCardSerial()) {
			return;
	}

	// Dump debug info about the card; PICC_HaltA() is automatically called
	mfrc522.PICC_DumpToSerial(&amp;amp;(mfrc522.uid));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step3.png&#34; alt=&#34;step3&#34;&gt;

&lt;/center&gt;

[ツール] &amp;gt; [ボード]は「&lt;strong&gt;Arduino/Genuino 101&lt;/strong&gt;」、[シリアルポート]は&lt;strong&gt;Arduinoを接続したUSBポート&lt;/strong&gt;を選択します（Windowsの方はCOMポート番号）。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step4.png&#34; alt=&#34;step4&#34;&gt;

&lt;/center&gt;

左上の「➡︎」をクリックしてプログラムを書き込みます。&lt;/p&gt;

&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;

&lt;p&gt;プログラムを書き込めたら、タグの情報を確認します。




&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/monitor.png&#34; alt=&#34;monitor&#34;&gt;

&lt;/center&gt;

[ツール] &amp;gt; [シリアルモニタ]を開きます。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/step5.png&#34; alt=&#34;step5&#34;&gt;

&lt;/center&gt;

シリアルモニタを開いた状態でRFIDリーダにタグをかざすと、タグの情報が表示されます。&lt;/p&gt;

&lt;p&gt;登録したいタグをかざし、「&lt;strong&gt;Card UID:&lt;/strong&gt;」以降の部分（画像では消してある部分）をコピーしておきましょう。&lt;/p&gt;

&lt;h2 id=&#34;識別子を元に動作を変える&#34;&gt;識別子を元に動作を変える&lt;/h2&gt;

&lt;p&gt;識別子を取得したNFCタグを「&lt;strong&gt;認証するユーザ&lt;/strong&gt;」、それ以外のタグを「&lt;strong&gt;認証しないユーザ&lt;/strong&gt;」として、Arduino側の動作を変えてみます。&lt;/p&gt;

&lt;p&gt;



&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/goal.png&#34; alt=&#34;goal&#34;&gt;

&lt;/center&gt;

認証するユーザの場合はLEDを青に、認証しないユーザの場合はLEDを赤に光らせるプログラムを作ってみます。&lt;/p&gt;

&lt;h3 id=&#34;配線-1&#34;&gt;配線&lt;/h3&gt;

&lt;p&gt;回路に、青と赤のLEDを追加します。配線するときは、一旦Arduinoを電源から外します。




&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/circuit2.png&#34; alt=&#34;circuit2&#34;&gt;

&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;青いLEDのアノード（＋側・脚が長い方）を8番ピンに、赤いLEDのアノードをアナログの3番ピンに繋ぎ、カソード（ー側）をそれぞれGNDに接続します。&lt;/p&gt;





&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/162/map2.png&#34; alt=&#34;map2&#34;&gt;

  ─ 配線した状態（上の図とLEDの向きが逆になっています）

&lt;/center&gt;


&lt;h3 id=&#34;プログラム-1&#34;&gt;プログラム&lt;/h3&gt;

&lt;p&gt;先ほど取得した&lt;strong&gt;タグの識別子とマッチしたら青いLED、それ以外は赤いLEDを光らせるプログラム&lt;/strong&gt;を作成します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#defin UID&lt;/code&gt;の部分は、ご自身が取得したタグの識別子に置き換えてください。また、今回赤いLEDはアナログ出力に接続しているので、&lt;code&gt;AnalogWrite()&lt;/code&gt;を利用して光量を0〜255で指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;MFRC522.h&amp;gt;

constexpr uint8_t RST_PIN = 9;
constexpr uint8_t SS_PIN = 10;

#define UID &amp;quot;xx xx xx xx xx xx xx&amp;quot; // 取得した識別子を記述

int led_blue = 8;
int led_red = 3;

MFRC522 mfrc522(SS_PIN, RST_PIN);
MFRC522::MIFARE_Key key;

void setup() {
	  Serial.begin(9600);
	  pinMode(led_blue, OUTPUT);
	  pinMode(led_red, OUTPUT);
	  while (!Serial);
	  SPI.begin();
	  mfrc522.PCD_Init();
	  mfrc522.PCD_DumpVersionToSerial();
	  Serial.println(F(&amp;quot;Scan PICC to see UID, SAK, type, and data blocks...&amp;quot;));

	  dump_byte_array(key.keyByte, MFRC522::MF_KEY_SIZE);
}

void loop() {
    if ( ! mfrc522.PICC_IsNewCardPresent()) {
      	return;
    }
    if ( ! mfrc522.PICC_ReadCardSerial()) {
      	return;
    }

    String strBuf[mfrc522.uid.size];
    for (byte i = 0; i &amp;lt; mfrc522.uid.size; i++) {
      	strBuf[i] =  String(mfrc522.uid.uidByte[i], HEX);
      	if(strBuf[i].length() == 1){
        	strBuf[i] = &amp;quot;0&amp;quot; + strBuf[i];
      	}
    }

    String strUID = strBuf[0] + &amp;quot; &amp;quot; + strBuf[1] + &amp;quot; &amp;quot; + strBuf[2] + &amp;quot; &amp;quot; + strBuf[3] + &amp;quot; &amp;quot; + strBuf[4] + &amp;quot; &amp;quot; + strBuf[5] + &amp;quot; &amp;quot; + strBuf[6];
    if ( strUID.equalsIgnoreCase(UID) ){
	      Serial.println(&amp;quot;chantoku&amp;quot;);
	      digitalWrite(led_blue, HIGH); // 青いLEDを光らせる
	      delay(1000); // 1秒待つ
	      digitalWrite(led_blue, LOW); // 青いLEDを消す
    } else {
	      Serial.println(&amp;quot;error!&amp;quot;);
	      analogWrite(led_red, 180); // 赤いLEDを光らせる
	      delay(1000); // 1秒待つ
	      analogWrite(led_red, 0); // 赤いLEDを消す
    }
}

void dump_byte_array(byte *buffer, byte bufferSize) {
    for (byte i = 0; i &amp;lt; bufferSize; i++) {
        Serial.print(buffer[i] &amp;lt; 0x10 ? &amp;quot; 0&amp;quot; : &amp;quot; &amp;quot;);
        Serial.print(buffer[i], HEX);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほどと同様の手順でArduinoにプログラムを書き込みます。これで完成です！&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;さっそく登録したタグを識別できるか試してみましょう。&lt;/p&gt;

&lt;p&gt;アオリちゃん（ピンクの子）が登録したタグ、ホタルちゃん（緑の子）は登録していないタグです。
&lt;a href=&#34;https://gyazo.com/2a2e957605e230f3d539f331c718f9b4&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/2a2e957605e230f3d539f331c718f9b4.gif&#34; alt=&#34;https://gyazo.com/2a2e957605e230f3d539f331c718f9b4&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;登録したアオリちゃんをタッチした時は青、登録していないホタルちゃんをタッチした時は赤を光らせることができました！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;非接触通信、無線通信というと難しいイメージがありますが、かなり簡単に実装することができました！この機能を使ってタッチした時間を記録したり、タグの識別を利用して電気をつける場所を変えたりと、いろいろなことに活用できそうです。&lt;/p&gt;

&lt;p&gt;次回は&lt;strong&gt;Wi-Fiに接続してタッチした時間を記録するデバイスの実装方法&lt;/strong&gt;を紹介してみたいと思います。&lt;/p&gt;

&lt;p&gt;それではまた！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>くるくる回して値を入力！ロータリエンコーダでインプットの幅を広げよう</title>
      <link>https://dotstud.io/blog/mongoose-os-rotary-encoder/</link>
      <pubDate>Mon, 26 Mar 2018 01:00:43 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/mongoose-os-rotary-encoder/</guid>
      
      <description>

&lt;p&gt;どうも。森田(&lt;a href=&#34;https://twitter.com/morita_pac&#34;&gt;@morita_pac&lt;/a&gt;)です。&lt;/p&gt;

&lt;p&gt;ボタンを押してトリガー発動！センサー値をグラフにダイレクトアタック！IoTって最高かよ！&lt;/p&gt;

&lt;p&gt;ってみなさん感じていると思います。&lt;/p&gt;

&lt;p&gt;そこへ、新たなスパイスを投ずるべく、森田は&lt;u&gt;&lt;strong&gt;ロータリエンコーダ&lt;/strong&gt;&lt;/u&gt;をおすすめします。&lt;/p&gt;

&lt;h2 id=&#34;ロータリエンコーダってなにかね&#34;&gt;ロータリエンコーダってなにかね？&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;これです。&lt;/strong&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/154/1.png&#34; alt=&#34;&#34; /&gt;
回転の機械的変位量を電気信号に変換してくれます。つまり、&lt;u&gt;くるくるくるくる回してデジタル入力できるアイテム。&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;今回は&lt;strong&gt;クリック有り&lt;/strong&gt;（カチカチなってくれる）の&lt;strong&gt;インクリメンタル式&lt;/strong&gt;のロータリエンコーダを使って解説します。&lt;/p&gt;

&lt;p&gt;⇒ 参考: ロータリエンコーダ販売ページ（&lt;a href=&#34;https://jp.rs-online.com/web/c/passive-components/rotary-encoders/&#34;&gt;RSコンポーネンツ&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;さまざまな種類のロータリエンコーダがあるので、上記サイトなどを参照してみてください。今回利用したもの（EC12E2420801）も購入できます。&lt;/p&gt;

&lt;h2 id=&#34;インクリメンタル式って何&#34;&gt;インクリメンタル式って何！？&lt;/h2&gt;

&lt;p&gt;まだ引かないでください。。。&lt;/p&gt;

&lt;p&gt;まず、ロータリエンコーダには信号検出の異なる「インクリメンタル式」と「アブソリュート式」があります。&lt;/p&gt;

&lt;h3 id=&#34;アブソリュート式&#34;&gt;アブソリュート式&lt;/h3&gt;

&lt;p&gt;回転位置が&lt;strong&gt;絶対的な数値として出力される高精度な方式&lt;/strong&gt;で、&lt;u&gt;電源断時でも回転位置を保持しておけることが特徴&lt;/u&gt;です。その分お値段も少々お高めなものが多いです。&lt;/p&gt;

&lt;p&gt;回転方向も、数値の増減から判断できます。
&lt;img src=&#34;https://dotstud.io/img/blog/154/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;インクリメンタル式&#34;&gt;インクリメンタル式&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;回転した角度だけパルス（短時間の電流）出力される方式&lt;/strong&gt;で、今回使うロータリエンコーダの場合だと、&lt;u&gt;15度回転させるとカチッとする感触があり、その時1パルスが出力され、24パルス出力で1回転&lt;/u&gt;となります。
&lt;img src=&#34;https://dotstud.io/img/blog/154/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回転方向を検出するために、位相が異なるA層B層の2つの端子からパルスを出力する構造になっており、
例えば、&lt;u&gt;A→Bの順にパルスの変化があった場合は時計回り、B→Aの順にパルスの変化があった場合は反時計周りのように区別&lt;/u&gt;することができます。
&lt;img src=&#34;https://dotstud.io/img/blog/154/4.png&#34; alt=&#34;&#34; /&gt;
※イメージです。&lt;/p&gt;

&lt;h2 id=&#34;使えるようにしてみよう&#34;&gt;使えるようにしてみよう。&lt;/h2&gt;

&lt;p&gt;それでは、さっそくロータリエンコーダを使ってみるよ！&lt;/p&gt;

&lt;p&gt;今回は、ESP32、ESP8266などのボードにJavaScriptで書き込みができる「&lt;strong&gt;Mongoose OS&lt;/strong&gt;」を利用してみます。&lt;strong&gt;なぜなら僕はMongoose OSが好きだから&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;Arduino言語での開発に慣れていない方にとっては、シンプルでわかりやすく感じると思います。Arduino IDEを使った方法やサンプルコードも、先例がたくさんあるので調べてみてください！&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://sakura87.net/archives/2969&#34;&gt;Arduino Unoでロータリーエンコーダを使う│SAKURA87.net&lt;/a&gt;&lt;br /&gt;
⇒ 参考: &lt;a href=&#34;http://nn-hokuson.hatenablog.com/entry/2017/03/26/102145&#34;&gt;【Arduino】マウスホイール（ロータリーエンコーダ）の回転量を取得する│おもちゃラボ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mongoose OSを導入するまでの手順は下記の記事を参照してください。


&lt;section class=&#34;link&#34; id=&#34;145&#34;&gt;
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
          &lt;div class=&#34;link_content&#34;&gt;
          &lt;a href=&#34;https://dotstud.io/blog/mongoose-os-nefry-blink/&#34;&gt;&lt;/a&gt;
          &lt;img src=&#34;https://dotstud.io/img/blog/145/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
          &lt;/div&gt;
          &lt;div class=&#34;link_content&#34;&gt;
            &lt;div class=&#34;link_detail&#34;&gt;
              &lt;div class=&#34;link_title&#34;&gt;
                JavaScriptで開発できる！Mongoose OSでNefry BTをLチカしよう
              &lt;/div&gt;
              &lt;div class=&#34;link_date&#34;&gt;
                
                2018-02-08
              &lt;/div&gt;
              &lt;div class=&#34;link_desc&#34;&gt;
                JavaScriptでプログラミングできるMongoose OSを使ってNefry BTのLチカを試してみます！
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/section&gt;
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
      
      
  
&lt;/section&gt;
&lt;/p&gt;

&lt;h3 id=&#34;用意したもの&#34;&gt;用意したもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Mongoose OS（導入方法は&lt;a href=&#34;https://dotstud.io/blog/mongoose-os-nefry-blink/&#34;&gt;こちらの記事&lt;/a&gt;を参考）&lt;/li&gt;
&lt;li&gt;ロータリエンコーダ（EC12E2420801）&lt;/li&gt;
&lt;li&gt;ESP32-DevKitC&lt;/li&gt;
&lt;li&gt;いい感じのブレッドボード&lt;/li&gt;
&lt;li&gt;10KΩ抵抗 2本&lt;/li&gt;
&lt;li&gt;ジャンパワイヤ 数本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/154/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;

&lt;p&gt;下記の図を参考に配線してください。
&lt;img src=&#34;https://dotstud.io/img/blog/154/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;プログラム&#34;&gt;プログラム&lt;/h3&gt;

&lt;p&gt;&lt;u&gt;正回転（※）でプラス10、逆回転でマイナス10の数値をログに出力するプログラム&lt;/u&gt;です。コピーしてMongoose OSで書き込みます。それぞれのコードの詳細はコメントに記載します。&lt;/p&gt;

&lt;p&gt;※…正回転はエンコーダの位置アドレスが増加する回転方向のことです。今回利用したロータリエンコーダの場合は時計回りが正回転、反時計回りが逆回転です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;//GPIOのAPIを使えるようにします。
load(&#39;api_gpio.js&#39;);

//ロータリエンコーダのA,Bのピンアサイン
let pinA = 19;
let pinB = 18;

//A,Bの状態を読みます。
let stateA = GPIO.read(pinA);
let stateB = GPIO.read(pinB);

let count =50;
let rotate =0;

//おまじない
GPIO.set_mode(pinA,GPIO.MODE_INPUT);
GPIO.set_mode(pinB,GPIO.MODE_INPUT);

//プラス1(正回転)を判断するための関数です。
let getRotationActA = function(){
        let Acount = 0;
        let AA = GPIO.read(pinA);
        let AB = GPIO.read(pinB);
        if (AA === 0 &amp;amp;&amp;amp; AB === 1)
        {
            AA = GPIO.read(pinA);
            AB = GPIO.read(pinB);
            Acount = 1;
        }
   return Acount;
};

//マイナス1(逆回転)を判断するための関数です。
let getRotationActB = function(){
        let Bcount = 0;
        let BA = GPIO.read(pinA);
        let BB = GPIO.read(pinB);
        if (BA === 1 &amp;amp;&amp;amp; BB === 0)
        {
            BA = GPIO.read(pinA);
            BB = GPIO.read(pinB);
            Bcount = -1;
        }
   return Bcount;
};

//Aにパルスが来た時に動くイベントです。
GPIO.set_button_handler(pinA, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 100, function(x) {
  rotate = getRotationActA();
  if(rotate === 1){
  count = count +rotate*10;
  print(count);
  }
}, null);


//Bにパルスが来た時に動くイベントです。
GPIO.set_button_handler(pinB, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 100, function(x) {
  rotate = getRotationActB();
  if(rotate === -1){
  count = count +rotate*10;
  print(count);
  }
}, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;試してみよう&#34;&gt;試してみよう。&lt;/h2&gt;

&lt;p&gt;書き込めたら、実際に試してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/154/7.png&#34; alt=&#34;&#34; /&gt;
Mongoose OSのコンソールからロータリエンコーダの値を確認することができます。&lt;/p&gt;

&lt;p&gt;下記はOLEDディスプレイに値を表示するようにしてみました。
&lt;img src=&#34;https://gyazo.com/52dce8bbfa4e37382bc964e1aef3109f.gif&#34; alt=&#34;&#34; /&gt;
正回転で値が増え、逆回転で値が減っていきます！&lt;/p&gt;

&lt;p&gt;Mongoose OSの特徴とチャタリングの関係から、勢いよくロータリエンコーダを回すと正確に信号を捉えられません。解決できる方法があるぜ。という場合はご連絡くださいませ。&lt;/p&gt;

&lt;h2 id=&#34;さいごに&#34;&gt;さいごに&lt;/h2&gt;

&lt;p&gt;いかがでしたでしょうか。これで、&lt;strong&gt;入力に新たな選択肢が加わった&lt;/strong&gt;と思います。&lt;/p&gt;

&lt;p&gt;ロータリエンコーダにはボタン付きのものもあったりしますので、選択してボタンプッシュで送信のような機能が欲しい場合に使えると思います。&lt;/p&gt;

&lt;p&gt;初期搭載のスイッチやセンサからの入力に飽きてしまった方は、ぜひ試してみてください！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title>
      <link>https://dotstud.io/blog/raspberry-pi-case-making/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong&gt;ラズパイにはまってしまったラズパイ女子です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p&gt;

&lt;p&gt;しかしなかなか可愛いいケースがない……。&lt;strong&gt;ないなら、作ってしまえばいい！！！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p&gt;

&lt;h2 id=&#34;レーザーカッターを使える場所を探そう&#34;&gt;レーザーカッターを使える場所を探そう&lt;/h2&gt;

&lt;p&gt;今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong&gt;工作機械を気軽に利用できるFabスペース&lt;/strong&gt;を利用してみましょう！&lt;/p&gt;

&lt;p&gt;レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p&gt;

&lt;p&gt;何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p&gt;

&lt;h3 id=&#34;レーザーカッターが使える初心者向けオススメfabスペース&#34;&gt;レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3&gt;

&lt;p&gt;初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p&gt;

&lt;h4 id=&#34;fabcafe-https-fabcafe-com-tokyo&#34;&gt;&lt;a href=&#34;https://fabcafe.com/tokyo/&#34;&gt;◆FabCafe&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p&gt;

&lt;h4 id=&#34;iotlab-https-cami-jp-iotlab&#34;&gt;&lt;a href=&#34;https://cami.jp/iotlab/&#34;&gt;◆IoTLab&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p&gt;

&lt;h4 id=&#34;techshop-http-www-techshop-jp&#34;&gt;&lt;a href=&#34;http://www.techshop.jp/&#34;&gt;◆TechShop&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p&gt;

&lt;h2 id=&#34;ケースの形について調べてみよう&#34;&gt;ケースの形について調べてみよう&lt;/h2&gt;

&lt;p&gt;一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/1.png&#34; alt=&#34;&#34; /&gt;
「Raspberry Pi  ケース」を検索
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ケースの形によってはかなり難易度が高そうです……。&lt;/p&gt;

&lt;h3 id=&#34;初心者にも作りやすいケースの形&#34;&gt;初心者にも作りやすいケースの形&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li&gt;
&lt;li&gt;ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/2.png&#34; alt=&#34;&#34; /&gt;
上蓋と下蓋を支柱で支えるタイプのケース　　
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;部材を集めよう&#34;&gt;部材を集めよう&lt;/h2&gt;

&lt;h3 id=&#34;かわいいアクリルで作れば-かわいいケースになる-はず&#34;&gt;かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;かわいいアクリルで作ればかわいいケースになる&lt;/strong&gt;と信じて、素敵なアクリルを用意しましょう。&lt;/p&gt;

&lt;p&gt;アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong&gt;実際に店舗に行ってみるのがオススメ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href=&#34;https://www.miyukiacryl.tokyo/tokyo-acryl&#34;&gt;デザインアクリル専門店 ミユキアクリル&lt;/a&gt;」さんのような&lt;strong&gt;デザインアクリル専門店&lt;/strong&gt;もあるので、興味のある方は覗いてみましょう！&lt;/p&gt;

&lt;p&gt;※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/3.png&#34; alt=&#34;&#34; /&gt;
自分好みのアクリルを選ぼう
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p&gt;

&lt;p&gt;厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p&gt;

&lt;p&gt;好みのアクリルがない場合は、&lt;strong&gt;UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong&gt;という手もあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/4.png&#34; alt=&#34;&#34; /&gt;
UVプリンターでイラストや写真を転写
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p&gt;

&lt;h3 id=&#34;ネジやスペーサーなどのパーツ&#34;&gt;ネジやスペーサーなどのパーツ&lt;/h3&gt;

&lt;p&gt;支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/5.png&#34; alt=&#34;&#34; /&gt;
上：真鍮黒ネジ、シルバーの六角スペーサー の組み合わせ&lt;br /&gt;
下：プラネジ、白のプラスチックのスペーサー&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;必要なパーツ一覧&#34;&gt;必要なパーツ一覧&lt;/h3&gt;

&lt;p&gt;好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li&gt;
&lt;li&gt;ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li&gt;
&lt;li&gt;アクリル板固定・ネジ M3（8mm）8本&lt;/li&gt;
&lt;li&gt;アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li&gt;
&lt;li&gt;アクリル（今回は厚さ3mmのもの）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/parts.png&#34; alt=&#34;&#34; /&gt;
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;h3 id=&#34;step1-型の準備&#34;&gt;step1. 型の準備&lt;/h3&gt;

&lt;p&gt;Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p&gt;

&lt;p&gt;ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href=&#34;https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y&#34;&gt;&lt;strong&gt;こちらのaiデータ&lt;/strong&gt;&lt;/a&gt;をそのまま使うこともできます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/6.png&#34; alt=&#34;&#34; /&gt;
左：下蓋 / 右：上蓋
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラ：幅0.9mm × 高さ28mm&lt;/li&gt;
&lt;li&gt;GPIO：幅55mm × 高さ12mm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/7.png&#34; alt=&#34;&#34; /&gt;
上蓋にカメラとGPIOの部分を追加
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;レーザーカッターには切る順番があり、「&lt;strong&gt;彫刻 → 穴 → 切り落とし&lt;/strong&gt;」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p&gt;

&lt;p&gt;これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p&gt;

&lt;h3 id=&#34;step2-アクリルを裁断&#34;&gt;step2. アクリルを裁断&lt;/h3&gt;

&lt;p&gt;今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step3-組み立てる&#34;&gt;step3. 組み立てる&lt;/h3&gt;

&lt;p&gt;まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/9.png&#34; alt=&#34;&#34; /&gt;
短いスペーサーでラズパイを下蓋に固定
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p&gt;

&lt;h3 id=&#34;完成&#34;&gt;完成&lt;/h3&gt;

&lt;p&gt;自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src=&#34;https://dotstud.io/img/blog/142/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/12.png&#34; alt=&#34;&#34; /&gt;
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p&gt;

&lt;p&gt;日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong&gt;どこに連れて行ってもかわいいと言ってもらえる&lt;/strong&gt;ので作りがいがありました。何より愛着がわきますね〜！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>日本上陸！littleBits cloudBitモジュールでIFTTT連携してみた！</title>
      <link>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</link>
      <pubDate>Tue, 22 Aug 2017 19:43:42 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</guid>
      
      <description>

&lt;p&gt;littleBits cloudBitモジュールの技適が通りまして、ついに日本でも使えることになったということで、早速littleBits cloudBitモジュールを購入してIFTTTと連携してみました。
&lt;img src=&#34;https://dotstud.io/img/blog/119/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;littlebits-cloudbitモジュールとは&#34;&gt;littleBits cloudBitモジュールとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/2.png&#34; alt=&#34;&#34; /&gt;
littleBits cloudBitモジュールは、磁石でつなげて簡単に電子工作ができる知育ブロックlittleBitsのモジュールのひとつ、littleBits Cloudが橋渡しとなってインターネットとやり取りできるモジュールです。&lt;/p&gt;

&lt;p&gt;詳しくはこちら → &lt;a href=&#34;https://littlebits.cc/cloudstart&#34;&gt;Getting Started with your CloudBit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/3.png&#34; alt=&#34;&#34; /&gt;
橋渡しとなるlittleBits Cloudは、スマートフォンやPCからWEBアクセスできる CLOUD CONTROL APP や、LITTLEBITS APIによってREST APIでさらに深いところまで操作できるプログラミングできるLITTLEBITS APIといった入り口があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/4.png&#34; alt=&#34;&#34; /&gt;
今回ご紹介するのは、もうひとつ。ノンプログラミングでインターネットのいろいろなことに接続できる&lt;a href=&#34;https://ifttt.com/login&#34;&gt;IFTTT&lt;/a&gt;とlittleBitsの連携についてお伝えします。&lt;/p&gt;

&lt;p&gt;たとえば、littleBitsモジュールでボタンを押すとメールが送られたり、SNSでいいねが押されるとlittleBitsのLEDが反応するようなIoTの仕組みをさっと作ることができます。&lt;/p&gt;

&lt;h2 id=&#34;今回の仕組み&#34;&gt;今回の仕組み&lt;/h2&gt;

&lt;p&gt;今回の仕組みはGitHubでissueが上がるとBARGRAPH LEDが点灯する仕組みです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/5.png&#34; alt=&#34;&#34; /&gt;
ですが、ただBARGRAPH LEDが光るだけだと見落としてしまうので、100円ショップで買った光で動くソーラーゆらゆら（がいこつ）にLEDを照らして動かしてよりわかりやすくします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/6.png&#34; alt=&#34;&#34; /&gt;
このような仕組みです。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;littlebitsの準備&#34;&gt;littleBitsの準備&lt;/h3&gt;

&lt;p&gt;セットアップについてはすでに行われているものとします。&lt;a href=&#34;http://www.1ft-seabass.jp/memo/2017/08/09/cloudbit-setup-step-memo/&#34;&gt;cloudBitモジュールのセットアップについてのメモ&lt;/a&gt;についてもご参考下さい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/7.png&#34; alt=&#34;&#34; /&gt;
CLOUDBITパッケージに入っているものはcloudBitモジュール関連だけなので、別途写真のようにlittleBitから入力させるボタンモジュールや、出力を反応させるBARGRAPHモジュールは別途揃えておきましょう。また今回はソーラーゆらゆら（がいこつ）へうまくつなげるためにWIREモジュールも用意しておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CLOUDBITパッケージにあるもの

&lt;ul&gt;
&lt;li&gt;USB power adapter ケーブル&lt;/li&gt;
&lt;li&gt;USB POWER モジュール&lt;/li&gt;
&lt;li&gt;cloudBitモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;別途必要なもの

&lt;ul&gt;
&lt;li&gt;ボタンモジュール&lt;/li&gt;
&lt;li&gt;BARGRAPHモジュール&lt;/li&gt;
&lt;li&gt;WIREモジュール&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/8.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆらを準備します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/9.png&#34; alt=&#34;&#34; /&gt;
コンセントをつないだアダプターからUSBケーブルを差し込みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/10.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュールにUSBケーブルをつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/11.png&#34; alt=&#34;&#34; /&gt;
USB POWERモジュール→ボタンモジュール→cloudBitモジュールまでつないで、接続されるまで待ちます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/12.png&#34; alt=&#34;&#34; /&gt;
つづいて、cloudBitモジュールの先にWIREモジュールとBARGRAPH LEDモジュールをつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/13.png&#34; alt=&#34;&#34; /&gt;
ソーラーゆらゆら（がいこつ）のソーラーパネル部分にガッとBARGRAPH LEDモジュールを当てます。マスキングテープで補強します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/14.png&#34; alt=&#34;&#34; /&gt;
これで準備完了です。&lt;/p&gt;

&lt;h3 id=&#34;cloud-control-appの準備&#34;&gt;CLOUD CONTROL APPの準備&lt;/h3&gt;

&lt;p&gt;cloudBitを管理している CLOUD CONTROL APP ページにログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;iftttの準備&#34;&gt;IFTTTの準備&lt;/h3&gt;

&lt;p&gt;IFTTTもlittleBitsとの関連付けを行うのでログインしておきます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こちらで準備完了です。&lt;/p&gt;

&lt;h2 id=&#34;littlebits-cloudbitモジュールとiftttの関連付け&#34;&gt;littleBits CloudBitモジュールとIFTTTの関連付け&lt;/h2&gt;

&lt;p&gt;さきほどログインしたCLOUD CONTROL APP ページでlittleBits CloudBitモジュールとIFTTTの関連付けを行います。
&lt;img src=&#34;https://dotstud.io/img/blog/119/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下部のメニューでAUTOMATEを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AUTOMATEページに遷移するとIFTTTとのアクティベートを促されるので GO TO IFTTT.COM ボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;IFTTTのlittleBitsチャンネルに遷移するので、CONNECTを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;すでにIFTTTとCLOUD CONTROL APPがログインしてあるので、アクティベート確認ページに遷移します。AUTHORIZEボタンを押して認証します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ログインが完了します。これで、IFTTTでlittleBitsと連携することができます。&lt;/p&gt;

&lt;h2 id=&#34;githubサービスのiftttでの認証をする&#34;&gt;GitHubサービスのIFTTTでの認証をする&lt;/h2&gt;

&lt;p&gt;GitHubでもIFTTTで使えるようにしておきましょう。上部のSearchからgithubを検索します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Servicesに出てきたGitHubをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/119/25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubのページに移動するのでConnectボタンを押します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubのAuthrize IFTTTページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/119/27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Authrize IFTTTCHannelsボタンを押して認証を済ませておきます。&lt;/p&gt;

&lt;h2 id=&#34;littlebitsのifttt連携の設定&#34;&gt;littleBitsのIFTTT連携の設定&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/28.png&#34; alt=&#34;&#34; /&gt;
右上にある自分のプロフィールメニューからNew Appletを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/29.png&#34; alt=&#34;&#34; /&gt;
New Appletをつくる画面に行きます。thisボタンをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/30.png&#34; alt=&#34;&#34; /&gt;
Choose a serviceではgitと検索しGitHubをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/31.png&#34; alt=&#34;&#34; /&gt;
今回は自分にissueが来たときに動作するようにしたいので、Any new issueをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/32.png&#34; alt=&#34;&#34; /&gt;
つづいて動作のきっかけ this が作れたので、なにが起こるかの that を設定するため that ボタンを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/33.png&#34; alt=&#34;&#34; /&gt;
Choose action service画面になるので、littleBitsと検索し、littleBitsアクションをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/34.png&#34; alt=&#34;&#34; /&gt;
Choose action画面になるので、Set Output Levelをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/35.png&#34; alt=&#34;&#34; /&gt;
Complete action fields画面になるので以下のように設定します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Which cloudBit?

&lt;ul&gt;
&lt;li&gt;動かしたいcloudBit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Level

&lt;ul&gt;
&lt;li&gt;100&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Duration

&lt;ul&gt;
&lt;li&gt;20 seconds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/36.png&#34; alt=&#34;&#34; /&gt;
設定が終わったら、下の方のCreate Actionボタンを押します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/37.png&#34; alt=&#34;&#34; /&gt;
Review and finish画面に来るので、設定を確認します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/38.png&#34; alt=&#34;&#34; /&gt;
問題なければ、下の方のFinishボタンを押します。&lt;/p&gt;

&lt;p&gt;これで設定は完了です。&lt;/p&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;早速試しにissueをGitHubで作ってみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/119/39.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回は適当に作ってみます。
&lt;img src=&#34;https://dotstud.io/img/blog/119/40.png&#34; alt=&#34;&#34; /&gt;
issues発行します。&lt;/p&gt;

&lt;p&gt;多少タイムラグがあるので5～10秒ほど待ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/119/demo.gif&#34; alt=&#34;&#34; /&gt;
無事動きました！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ということで、技適が通り日本上陸となった、littleBits cloudBitモジュールのIFTTT連携をお伝えしました。&lt;/p&gt;

&lt;p&gt;今回はIoTでも実装に手間がかかるインターネット上の反応をlittleBitsに降ろす仕組みを軸にお伝えしましたがIFTTTとlittleBits Cloudの連携は手軽に作れますね。IoTにおけるいろいろな技術要素が裏側でしっかり作られています。&lt;/p&gt;

&lt;p&gt;もちろん、IFTTTと連携するとAmazon Dash Buttonのような、ボタンを押すとツイートがされるようなlittleBitsからインターネットを動かす仕組みについても実現可能です。&lt;/p&gt;

&lt;p&gt;littleBitsの持つブロックを組み合わせて電子工作ができる手軽さに加えて、IFTTTが組み合わさることでインターネットもあたかもブロックのように扱えてるlittleBits cloudBitモジュール、ぜひ試してみてください！&lt;/p&gt;

&lt;p&gt;※今回の図表の一部では&lt;a href=&#34;http://icooon-mono.com/&#34;&gt;アイコン素材ダウンロードサイト「icooon-mono」&lt;/a&gt;さんの画像を利用いたしました。ありがとうございます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ESP8266を使って京急が遅延すると光るガジェットを作ってみた</title>
      <link>https://dotstud.io/blog/pokio-esp-keikyu-chien/</link>
      <pubDate>Tue, 13 Jun 2017 19:28:32 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/pokio-esp-keikyu-chien/</guid>
      
      <description>

&lt;p&gt;こんにちは、京急が大好きなポキオです。&lt;/p&gt;

&lt;p&gt;普段はAndroidエンジニアをやってますが、週末は趣味でArduinoやESP8266を触って心を落ち着かせています。先日、「京急が遅延すると光るガジェット」を作って&lt;a href=&#34;https://iotlt.connpass.com/&#34;&gt;IoTLT&lt;/a&gt;で発表を行ってきました。&lt;/p&gt;

&lt;p&gt;今回は、そこで発表したガジェットの作成段階や、技術的な仕組みを紹介します。（発表後に一部パーツ・コーディングを変更しています）&lt;/p&gt;

&lt;h2 id=&#34;今回作るもの&#34;&gt;今回作るもの&lt;/h2&gt;

&lt;p&gt;ESP8266というWi-Fiモジュールを搭載した開発ボード「ESPr® Developer」を使って京急のホームページから運行情報を取得し、遅延していたらLEDを光らせる仕組みを作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/01_map.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Air（13-inch、Mid 2013）&lt;/li&gt;
&lt;li&gt;OS X Yosemite（v10.10.5）&lt;/li&gt;
&lt;li&gt;Arduino IDE 1.8.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ESPr® DeveloperESP8266&lt;/li&gt;
&lt;li&gt;マイコン内臓RGB LED&lt;/li&gt;
&lt;li&gt;光らせたいガジェット（今回はBトレインショーティ）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;主なパーツ&#34;&gt;主なパーツ&lt;/h2&gt;

&lt;h3 id=&#34;espr-developer&#34;&gt;ESPr® Developer&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/02_esper.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://www.switch-science.com/catalog/2500/&#34;&gt;スイッチサイエンス&lt;/a&gt;さんで売られている、ESP8266というWi-Fiモジュールを搭載した開発ボードです。素のESP8266を直接触るのはハードルが高いですが、USB-シリアル変換やレギュレータ、リセットスイッチなど実装済みで、Arduino IDEでも開発できるため便利です。&lt;/p&gt;

&lt;p&gt;ただし、筆者の開発環境ではArduino IDEからコードを流し込む際に、一手間必要でした。詳しくはこちら。&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;http://qiita.com/shanonim/items/68fab6dc28b72b31a258&#34;&gt;ESPr Developer（ESP-WROOM-02開発ボード）で &amp;ldquo;warning: espcomm_sync failed&amp;rdquo; と表示される場合の対処&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;マイコン内蔵rgb-led&#34;&gt;マイコン内蔵RGB LED&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/03_led.png&#34; alt=&#34;画像&#34; /&gt;
秋葉原の&lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-08412/&#34;&gt;秋月電子通商&lt;/a&gt;さんで1個40円で売られているものを使用します。通常のLEDは足が2本ですが、こちらは足が4本。これらを制御することで、様々な色でLEDを光らせることができます。ESP8266（Arduino）向けに便利なライブラリが公開されているので、今回はこれを使ってコーディングしていきます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/adafruit/Adafruit_NeoPixel&#34;&gt;Adafruit NeoPixel Library&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;bトレインショーティー&#34;&gt;Bトレインショーティー&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/04_train.png&#34; alt=&#34;画像&#34; /&gt;
&lt;a href=&#34;https://bandai-hobby.net/train/&#34;&gt;Bトレインショーティー&lt;/a&gt;はバンダイさんから発売されている、自分で組み立てるタイプの鉄道模型です。特徴は、何と言っても可愛さ。実車のディテールを表現しつつ、車両の長さをギュッと縮めてコミカルなルックスになっています。今回は（もちろん京急の）2100形をチョイス。京急の中で好きな車両の一つです。&lt;/p&gt;

&lt;h2 id=&#34;ガジェットを作ってみる&#34;&gt;ガジェットを作ってみる&lt;/h2&gt;

&lt;h3 id=&#34;京急の2100形車両の組み立て&#34;&gt;京急の2100形車両の組み立て&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/05_keikyu1.png&#34; alt=&#34;画像&#34; /&gt;
なにはともあれ、京急の車両を組み立てるところから始めます。Bトレインショーティーの京急2100形は、塗装済みで接着剤不要で組み立てができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/06_keikyu2.png&#34; alt=&#34;画像&#34; /&gt;
久しぶりのプラモデルにテンションがアガります。&lt;/p&gt;

&lt;h3 id=&#34;マイコン内蔵rgb-ledを埋め込む&#34;&gt;マイコン内蔵RGB LEDを埋め込む&lt;/h3&gt;

&lt;p&gt;出来上がった京急の車両にLEDを埋め込んでいきます。ここで便利なのがサンハヤトさんの&lt;a href=&#34;http://www.sunhayato.co.jp/material2/index.php/item?cell003=%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF%E8%A3%BD%E5%93%81&amp;amp;cell004=%E4%B8%AD%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF&amp;amp;name=%E8%96%84%E5%9E%8B%E3%83%A6%E3%83%8B%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB%E5%9F%BA%E6%9D%BF+UB-THN01&amp;amp;id=722&amp;amp;label=1&#34;&gt;ハサミで切れるユニバーサル基板&lt;/a&gt;です。
&lt;img src=&#34;https://dotstud.io/img/blog/099/07_universal1.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;謳い文句の通り、ハサミで自由にカットができて、今回のような小さい車両にも基板を収めることができます。
&lt;img src=&#34;https://dotstud.io/img/blog/099/08_universal2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こんな感じで簡単に、そしてその場で車両ピッタリの基板ができました。
&lt;img src=&#34;https://dotstud.io/img/blog/099/09_rgb_led.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;配線&#34;&gt;配線&lt;/h3&gt;

&lt;p&gt;マイコン内蔵RGB LEDは先述の通り足が4本あり、電源（VDD）とグラウンド（GND）に加えて、制御信号の入出力（DIN・DO）があります。DIN・DOは図のように数珠つなぎで配線します。
&lt;img src=&#34;https://dotstud.io/img/blog/099/10_rgb_led2.png&#34; alt=&#34;画像&#34; /&gt;&lt;/p&gt;

&lt;p&gt;電源とグラウンドは共通で、それぞれESPr® DeveloperのVOUTとGNDに接続します。大元のDINはPIN4に接続します。&lt;/p&gt;

&lt;h3 id=&#34;遅延情報の取得ロジック&#34;&gt;遅延情報の取得ロジック&lt;/h3&gt;

&lt;p&gt;WebAPI等は使用せずに、10分に一度、&lt;a href=&#34;http://unkou.keikyu.co.jp/&#34;&gt;京急の運行情報ページ&lt;/a&gt;にアクセスして情報を取得します。&lt;/p&gt;

&lt;p&gt;ESPr® Developerから運行情報の文言をHTTP-GETで取得して、その文言に&lt;strong&gt;特定の文字列&lt;/strong&gt;が含まれるかどうかで運行状態を推測します。具体的には・・・&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;「&lt;strong&gt;受託&lt;/strong&gt;」という文字列が含まれていたら、他社線からの振替輸送受託のために遅延していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;見合わせ&lt;/strong&gt;」という文字列が含まれていたら、運転見合わせが発生していると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;乱れ&lt;/strong&gt;」という文字列が含まれていたら、ダイヤが大幅に乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;遅れ&lt;/strong&gt;」や「&lt;strong&gt;運休&lt;/strong&gt;」が含まれていたら、ダイヤが少し乱れていると判断する&lt;/li&gt;
&lt;li&gt;「&lt;strong&gt;平常&lt;/strong&gt;」が含まれていたら、平常運転であると判断する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このような感じです。そして、運転見合わせであれば赤い点滅、ダイヤが少し乱れているときは黄色い点滅をさせるといった感じで、運行状態に応じてマイコン内蔵RGB LEDの光り方を変えることで、運行状態をひと目で把握することができます。&lt;/p&gt;

&lt;p&gt;ちなみに、他社線からの振替輸送受託が理由で京急が遅延しているときは、個人的にすこし残念な気持ちになるので、光り方を変えています（笑）&lt;/p&gt;

&lt;h3 id=&#34;espr-developerのコーディング&#34;&gt;ESPr® Developerのコーディング&lt;/h3&gt;

&lt;p&gt;かなり無理矢理ですが、こんな感じでコーディングしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;ESP8266WiFi.h&amp;gt;
#include &amp;lt;WiFiClient.h&amp;gt;
#include &amp;lt;Adafruit_NeoPixel.h&amp;gt;

#define PIN 4 // DINを接続しているPIN
#define NUMLED 4 // マイコン内蔵RGB LEDの個数
#define SSID &amp;quot;（Wi-FiアクセスポイントのSSID）&amp;quot;
#define PASSWORD &amp;quot;（Wi-Fiアクセスポイントのパスワード）&amp;quot;
#define KEIKYU_PAGE &amp;quot;unkou.keikyu.co.jp&amp;quot; // 運行情報のページ
#define INTERVAL_SEC 10 * 60 // ポーリング間隔

Adafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMLED, PIN, NEO_RGB + NEO_KHZ800);

void setup() {
  // Serialの初期化
  Serial.begin(115200);
  Serial.println(&amp;quot;&amp;quot;);

  // マイコン内蔵RGB LEDの初期化
  pixels.begin();
}

void loop() {
  // Wi-Fi接続開始
  connectWifi();

  // 京急の運行ページから運行情報取得
  String trainInfo = getTrainInfo();

  // Wi-Fi接続終了
  disconnectWifi();

  // 「受託」という文字が含まれていたら、他社からの振替輸送受託で遅延していると判断
  if (trainInfo.indexOf(&amp;quot;受託&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;振替輸送受託！&amp;quot;);
    blinkLikePartyPeople(INTERVAL_SEC);
    return;
  }

  // 「見合わせ」という文字が含まれていたら、運転見合わせが発生していると判断
  if (trainInfo.indexOf(&amp;quot;見合わせ&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;運転見合わせ！&amp;quot;);
    blinkRed(INTERVAL_SEC);
    return;
  }

  // 「乱れ」という文字が含まれていたら、ダイヤが大幅に乱れていると判断
  if (trainInfo.indexOf(&amp;quot;乱れ&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;大幅に乱れている！&amp;quot;);
    blinkYellowAndRed(INTERVAL_SEC);
    return;
  }

  // 「遅れ」「運休」という文字が含まれていたら、ダイヤが少し乱れていると判断
  if (trainInfo.indexOf(&amp;quot;遅れ&amp;quot;) &amp;gt; 0 || trainInfo.indexOf(&amp;quot;運休&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;遅延！&amp;quot;);
    blinkYellow(INTERVAL_SEC);
    return;
  }

  // 「平常」という文字が含まれていたら、平常運転をしていると判断
  if (trainInfo.indexOf(&amp;quot;平常&amp;quot;) &amp;gt; 0) {
    Serial.println(&amp;quot;たぶん平常通り運転！&amp;quot;);
    delay(INTERVAL_SEC * 1000);
    return;
  }

  // 運行情報取得エラーかもしれないので、10秒待ってもう一度取得する
  blinkWhite(10);
}

// Wi-Fi接続
void connectWifi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASSWORD);

  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(&amp;quot;.&amp;quot;);
    blinkWhite(3);
  }

  Serial.println(&amp;quot;Wi-Fi接続完了&amp;quot;);
}

// Wi-Fi切断
void disconnectWifi() {
  WiFi.disconnect();
  Serial.println(&amp;quot;Wi-Fi切断完了&amp;quot;);
}

// 運行情報の文字列取得
String getTrainInfo() {
  WiFiClient client;

  if ( !client.connect(KEIKYU_PAGE, 80) ) {
    // 接続エラー
    return String(&amp;quot;&amp;quot;);
  }

  // HTTP-GET
  // レスポンスのLengthが長すぎるとエラーになることがあったのでRangeを指定している
  client.print(String(&amp;quot;GET &amp;quot;) + &amp;quot;/&amp;quot; + &amp;quot; HTTP/1.1\r\n&amp;quot; +
               &amp;quot;Host: &amp;quot; + KEIKYU_PAGE + &amp;quot;\r\n&amp;quot; +
               &amp;quot;Range: bytes=8000-9000\r\n&amp;quot; +
               &amp;quot;Connection: close\r\n\r\n&amp;quot;);
  client.println();

  delay(1000);

  String body = &amp;quot;&amp;quot;;
  String trainInfo = &amp;quot;&amp;lt;!-- ======================== 運行情報 =================================== --&amp;gt;&amp;quot;;

  while (client.available()) {
    body += client.readStringUntil(&#39;\r&#39;);
  }

  // レスポンスから運行情報部分だけを切り抜く
  body = body.substring(body.indexOf(trainInfo) + trainInfo.length());
  body = body.substring(0, body.indexOf(trainInfo));

  return body;
}

// 白い点滅
void blinkWhite(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, i);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, i);
    }

    count++;
  }
}

//　黄色い点滅
void blinkYellow(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, 0);
    }

    count++;
  }
}

// 黄色と赤の点滅
void blinkYellowAndRed(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, 0, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, 0, 0);
    }

    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, i, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, i, 0);
    }

    count++;
    count++;
  }
}

// 赤い点滅
void blinkRed(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 256; i += 5) {
      setColor( i, 0, 0);
    }

    for (int i = 255; i &amp;gt;= 0; i -= 5) {
      setColor( i, 0, 0);
    }

    count++;
  }
}

// パリピな輝き
void blinkLikePartyPeople(int sec) {
  int count = 0;

  while (count &amp;lt; sec) {
    for (int i = 0; i &amp;lt; 20; i++) {
      setRandomColor();
      delay(50);
    }

    count++;
  }
}

// LEDを指定した色で光らせる
void setColor(int r, int g, int b) {
  for (int i = 0 ; i &amp;lt; NUMLED; i++) {
    pixels.setPixelColor(i, pixels.Color(r, g, b));
    pixels.show();
  }
  delay(10);
}

// LEDをランダムな色で光らせる
void setRandomColor() {
  for (int i = 0 ; i &amp;lt; NUMLED; i++) {
    pixels.setPixelColor(i, pixels.Color(64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 , 64 * random(1, 5) - 1 ));
    pixels.show();
  }
  delay(10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際に光らせてみたのがこちら。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/11_setting.png&#34; alt=&#34;画像&#34; /&gt;
情報取得中に実行される白い点滅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/12_late.png&#34; alt=&#34;画像&#34; /&gt;
運転見合わせ時に実行される赤い点滅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/099/13_transport.png&#34; alt=&#34;画像&#34; /&gt;
最後は他社線からの振替輸送受託時に実行されるパリピ点滅。画像では少しわかりづらいですね……。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は、京急が遅延していると光るガジェットをESPr® Developerをつかって作成しました。情報の取得方法はかなり力技でしたが、WEB上の情報を簡単に可視化できたことは良かったです。&lt;/p&gt;

&lt;p&gt;実際にこのガジェットは、職場のデスクで稼働していて、いつも京急の運行情報を知らせてくれます。今後は他社線バージョンの作成を検討しています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wio NodeとIFTTTで簡単IoT！紫外線情報を取得してみよう</title>
      <link>https://dotstud.io/blog/wionode-ifttt-uv-ornament/</link>
      <pubDate>Tue, 06 Jun 2017 20:26:13 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/wionode-ifttt-uv-ornament/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioライターのゆっきん（&lt;a href=&#34;https://twitter.com/yukkin4649&#34;&gt;@yukkin4649&lt;/a&gt;）です。普段はシステムエンジニアをしています！&lt;/p&gt;

&lt;p&gt;IoTLTでのびすけさんから「電子工作でかわいいもの作ってくれ」という無茶ぶりを受けたので（笑）、女子の天敵&lt;strong&gt;紫外線指数を光って知らせてくれるオーナメント&lt;/strong&gt;を作ってみます！&lt;/p&gt;

&lt;p&gt;今回は「Wio Node」というスマホから設定できるデバイスと、ノンプログラミングでサービス連携ができる「IFTTT」というWebサービスを使います。初心者の私でも簡単にできたので是非挑戦してみてください。&lt;/p&gt;

&lt;h2 id=&#34;wio-nodeとは&#34;&gt;Wio Nodeとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/wio.png&#34; alt=&#34;&#34; /&gt;
「Wio Node」とはSeeed Studio社が開発したIoTデバイスで、Wi-Fiモジュールが初期搭載されています。対応のモジュールをさすだけで使え、スマートフォンで設定できるシンプルな設計が特徴です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.seeedstudio.com/Wio-Node-p-2637.html&#34;&gt;公式サイト&lt;/a&gt;によると&lt;strong&gt;IoTアプリケーション構築までたったの５分&lt;/strong&gt;だそうです。如何に簡単にできるのかが伺えます。&lt;/p&gt;

&lt;h2 id=&#34;iftttとは&#34;&gt;IFTTTとは&lt;/h2&gt;

&lt;p&gt;「IFTTT」では多数あるWebサービス同士を連携させ、自分好みの連携機能を作成することが出来ます。例えば【&lt;strong&gt;Twitterでお気に入りしたツイートをEvernoteに保存する&lt;/strong&gt;】等があります。&lt;/p&gt;

&lt;p&gt;他の人が作成した連携（ここではレシピと呼ぶ）も利用することができ、カスタマイズも可能。今回はこの「IFTTT」を使って紫外線取得サービスとWio Nodeを連携します。&lt;/p&gt;

&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;① Wio Node本体（&lt;a href=&#34;https://dotstud.io/shop/wionode-social-remote-control/&#34;&gt;購入ページ&lt;/a&gt;）&lt;br /&gt;
② Grove LED Bar v2.0（型番：SEEED-104020006）&lt;br /&gt;
③給電用のMicro USBケーブル&lt;br /&gt;
④ スマートフォン（iOSまたはAndroid端末）&lt;br /&gt;
⑤ グリーンオーナメント SS（100円均一で購入）&lt;br /&gt;
⑥ 紙&lt;br /&gt;
⑦ テープ&lt;br /&gt;
⑧ ペン&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Air 11-inch Early 2014&lt;/li&gt;
&lt;li&gt;OS X El Capitan　v10.11.6&lt;/li&gt;
&lt;li&gt;iPhone6（iOS 10.3.1）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/2.png&#34; alt=&#34;&#34; /&gt;
ざっくりとした構成です。IFTTTを使って「Today&amp;rsquo;s weather report」からUV値を取得し、Wio NodeのLED Barで表示させます。&lt;/p&gt;

&lt;p&gt;それでは早速作っていきましょう。&lt;/p&gt;

&lt;h3 id=&#34;1-wio-nodeの設定&#34;&gt;1. Wio Nodeの設定&lt;/h3&gt;

&lt;h4 id=&#34;インストールとセットアップ&#34;&gt;インストールとセットアップ&lt;/h4&gt;

&lt;p&gt;ここではWio Node開発用アプリのインストールと設定をしていきます。Wio NodeはPC・モバイルバッテリー等からUSBケーブルで接続し給電しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/3.png&#34; alt=&#34;&#34; /&gt;
App Store等でWio Nodeアプリを検索し、インストールします。iOSでは「Wio Link」、Androidでは「Wio」と言う名称です。&lt;/p&gt;

&lt;p&gt;本記事ではiOSの「Wio Link」の画面で説明していきます。&lt;/p&gt;

&lt;p&gt;iOS: &lt;a href=&#34;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&#34;&gt;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&lt;/a&gt;&lt;br /&gt;
Android: &lt;a href=&#34;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&#34;&gt;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/4.png&#34; alt=&#34;&#34; /&gt;
インストール後、アプリを立ち上げるとログイン画面が表示されるので〔SIGN UP〕のタブに切り替えてメールアドレスとパスワードを入力し〔SIGN UP〕のボタンを押下します。２回目以降は〔LOG IN〕タブから登録した情報を入力してログインして下さい。&lt;/p&gt;

&lt;p&gt;※他のサービスと連携が上手くいかないこともあるのでGoogleアカウントやFacebookアカウントの連携によるユーザー登録は非推奨とします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/5.png&#34; alt=&#34;&#34; /&gt;
Device Listの画面が表示されたら、右上の〔+〕又は中央の〔Add Your First Device〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/6.png&#34; alt=&#34;&#34; /&gt;
デバイスの選択画面が表示されるので〔Wio Node〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/7.png&#34; alt=&#34;&#34; /&gt;
セットアップ画面の図と同様にWio Node本体のボタンを４秒程押下します。青いライトの光り方が変わることを確認後、次の手順に移ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/8.png&#34; alt=&#34;&#34; /&gt;
iPhoneの〔設定〕アプリを起動します。〔Wi-Fi〕設定画面でWi-FiをONにし、〔Wio_XXXXXX〕を選択します。XXXXXXには割り当てられた文字列が入ります。（Android版はアプリの画面内で選択します。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/9.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeアプリに戻り、〔Goto wifi list〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/10.png&#34; alt=&#34;&#34; /&gt;
現在利用できる任意のWi-Fiを選択します。表示されない場合は右上の〔Refresh〕を押下して下さい。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/11.png&#34; alt=&#34;&#34; /&gt;
選択したWi-Fiのパスワードを入力し、〔Join〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/12.png&#34; alt=&#34;&#34; /&gt;
この画面では、デバイスの名前をつけます。任意の名前を入力し、〔Start Wio-ing〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/13.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeが認識され、モジュールの設定画面に移りました。最初のセットアップは以上です。&lt;/p&gt;

&lt;p&gt;もしセットアップが上手くいかない場合は&lt;a href=&#34;https://dotstud.io/docs/wionode-wiosetup/&#34;&gt;こちら&lt;/a&gt;からセットアップしてみてください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;モジュールの設定&#34;&gt;モジュールの設定&lt;/h4&gt;

&lt;p&gt;続いて今回使うモジュールを設定していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/106/14.png&#34; alt=&#34;&#34; /&gt;
次にLED Barを取り付けます。Wio Node本体を画面と同じ向きに見た時、左側（PORT0）にLED Barを接続します。アプリ画面では、〔UART〕タブの〔LED Bar〕を選択し、〔Update Firmware〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/15.png&#34; alt=&#34;&#34; /&gt;
〔OK〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/16.png&#34; alt=&#34;&#34; /&gt;
設定が完了すると〔View API〕というリンクが表示されます。&lt;/p&gt;

&lt;p&gt;APIを試してみましょう。〔View API〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;apiを試してみる&#34;&gt;APIを試してみる&lt;/h4&gt;

&lt;p&gt;View APIのページではあらかじめ用意されているAPIを使ってWio Nodeとモジュールの挙動を試すことができます。
&lt;img src=&#34;https://dotstud.io/img/blog/106/17.png&#34; alt=&#34;&#34; /&gt;
今回利用する〔level〕APIの〔Test Request〕に「10」と入力します。〔GET〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/led.png&#34; alt=&#34;&#34; /&gt;
LED Barが10個すべて光りました！数値を変えると光るBarの個数が変わります。&lt;/p&gt;

&lt;p&gt;モジュールの設定は以上です。&lt;/p&gt;

&lt;h3 id=&#34;2-iftttの設定&#34;&gt;2. IFTTTの設定&lt;/h3&gt;

&lt;h4 id=&#34;インストールとセットアップ-1&#34;&gt;インストールとセットアップ&lt;/h4&gt;

&lt;p&gt;次にIFTTT側の設定をしていきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/18.png&#34; alt=&#34;&#34; /&gt;
最初にIFTTTのアプリをダウンロードします。&lt;strong&gt;ブラウザから設定する場合はアプリのインストールは不要&lt;/strong&gt;です。ブラウザで「IFTTT」を検索してIFTTTの画面に遷移してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/19.png&#34; alt=&#34;&#34; /&gt;
ダウンロード後、アプリを起動します。アカウントを持っていない場合は、〔Sign up〕を押下します。アカウントを既に取得している場合は、〔Sign in〕を押下してログインしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/20.png&#34; alt=&#34;&#34; /&gt;
アカウントを新規登録する場合はメールアドレスと任意のパスワードを入力し、〔Sign up〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;レシピを作成する&#34;&gt;レシピを作成する&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/21.png&#34; alt=&#34;&#34; /&gt;
それでは早速レシピを作ってみましょう。〔My Applets〕に移動し、右上の〔＋〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/22.png&#34; alt=&#34;&#34; /&gt;
IFTTTでは「if this then that」という構文を使って、サービスを連携させていきます。熊本弁で言うと「こぎゃん（こう）したら、あぎゃん（ああ）なる」みたいな感じです。&lt;/p&gt;

&lt;p&gt;まずは「こうしたら」のトリガー部分を作っていきましょう。最初に〔this〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/23.png&#34; alt=&#34;&#34; /&gt;
IFTTTでは連携に利用できるWebサービスのことをチャンネルと言います。&lt;/p&gt;

&lt;p&gt;トリガーとして利用できるチャンネルが表示されるので、「Wether Underground」チャンネルを検索し、選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/24.png&#34; alt=&#34;&#34; /&gt;
「Wether Underground」で利用できるトリガーの一覧が表示されます。今回は〔Today&amp;rsquo;s weather report〕を使うので、選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/25.png&#34; alt=&#34;&#34; /&gt;
「Today&amp;rsquo;s weather report」は今日の現在の天気情報を取得できます。この画面では取得する時間を設定します。好きな時間に設定してください。&lt;/p&gt;

&lt;p&gt;私の場合は昼休みで外に出る時の時間を設定しました。&lt;/p&gt;

&lt;p&gt;続いて「こうなる」の部分を作ります。
&lt;img src=&#34;https://dotstud.io/img/blog/106/26.png&#34; alt=&#34;&#34; /&gt;
「if this then that」の〔that〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/27.png&#34; alt=&#34;&#34; /&gt;
アクション（発動条件を満たした後の動作）として利用できるチャンネルが表示されます。〔Search services〕に「seeed」と入力して検索しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/28.png&#34; alt=&#34;&#34; /&gt;
「Seeed」チャンネルを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/29.png&#34; alt=&#34;&#34; /&gt;
〔connect〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/30.png&#34; alt=&#34;&#34; /&gt;
アカウント設定画面が表示されます。ここにWio Nodeで設定したアカウント情報を入力し、〔Sign in〕を押下します。&lt;/p&gt;

&lt;p&gt;Wio Node側でGoogleやFacebook連携でログインしていて上手く連携できない場合は、Wio Nodeのアプリからメールアドレスで登録しなおしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/31.png&#34; alt=&#34;&#34; /&gt;
「Seeed」チャンネルで利用できるアクションの一覧が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/32.png&#34; alt=&#34;&#34; /&gt;
一覧の下の方にある〔Drive any Grove〕を選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/33.png&#34; alt=&#34;&#34; /&gt;
詳細設定をしていきます。functionを選択するプルダウンでは〔level（float level）〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/34.png&#34; alt=&#34;&#34; /&gt;
次にFirst Parameterを設定します。〔Add Ingredient〕を押下すると、設定できる候補が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/35.png&#34; alt=&#34;&#34; /&gt;
今回取得するのはUV値なので〔UVindex〕を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/36.png&#34; alt=&#34;&#34; /&gt;
〔Next〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/37.png&#34; alt=&#34;&#34; /&gt;
タイトルが自動生成されるので、変更する場合は〔Edit title〕から編集します。最後に〔Finish〕を押下します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/38.png&#34; alt=&#34;&#34; /&gt;
これでレシピは完成です！&lt;/p&gt;

&lt;h3 id=&#34;3-オーナメント作り&#34;&gt;3. オーナメント作り&lt;/h3&gt;

&lt;p&gt;最後に見せ方の部分である、オーナメント作りをしていきます。&lt;/p&gt;

&lt;p&gt;では、グリーンオーナメントにWio Nodeを巻いていきます。この時、一度Wio NodeからUSBケーブルを抜いておくと良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/39.png&#34; alt=&#34;&#34; /&gt;
購入したグリーンオーナメントにもよりますが、グリーンオーナメントの中の構成を把握してWio Nodeを取り付けるとコードが目立たないようになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/40.png&#34; alt=&#34;&#34; /&gt;
今回の場合は、グリーンオーナメントの中心軸を避けたところにWio Nodeを設置し、コードを軸に這わせながら巻きつけていきます。巻きつけた後は、葉っぱでコードを隠します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/41.png&#34; alt=&#34;&#34; /&gt;
LEDもコードがなるべく見えないように周りの葉っぱで隠します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/42.png&#34; alt=&#34;&#34; /&gt;
次に目を用意します。自分の好きな目を書いてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/43.png&#34; alt=&#34;&#34; /&gt;
目を作成したら、グリーンオーナメントに装着します。両面テープや養生テープを使うと、目の位置等を簡単に変えられます。目の位置によって表情が変わるので好きな位置に取り付けましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/44.png&#34; alt=&#34;&#34; /&gt;
最後にUSBケーブルと接続します。オーナメントによりますが、USBケーブルに色が移ることもあるので気をつけてください。&lt;/p&gt;

&lt;p&gt;オーナメント作りはこれで完成です！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;カスタマイズ&#34;&gt;カスタマイズ&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/45.png&#34; alt=&#34;&#34; /&gt;
目だけでなく、ちょっとした花を付け加えるとより個性が出ます。色々試してみてください。&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;さて、一通り完成したので動作検証してみます。&lt;/p&gt;

&lt;p&gt;IFTTTの〔My Applets〕で自分の作成したアプレットが確認できます。今回はテストなので時間を12時45分にしました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/46.png&#34; alt=&#34;&#34; /&gt;
実行されるとIFTTTから通知が来ます。確認してみると正常に動いているようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/47.png&#34; alt=&#34;&#34; /&gt;
UVindexの値を確認すると「9」となっています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/106/48.png&#34; alt=&#34;&#34; /&gt;
LED Barは&amp;hellip;レベル9まで光っています！&lt;strong&gt;外に出る時は紫外線対策をしっかりしましょう！！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;p&gt;今回は「Wio Node」と「IFTTT」を使ってノンプログラミングでUV（紫外線）のレベルをLED Barで表示させました。初心者の方でも簡単にできたのではないでしょうか。「IFTTT」で取得する値を変えたりアクションを変えたりするともっと色んなことができそうですね。&lt;/p&gt;

&lt;p&gt;また、「IFTTT」で取得する値は0〜16ですが、現状は10以上の場合もLED Barは10までの表示です。これ以上細かい表示をする場合はプログラムを組んでみましょう。そちらの方も是非挑戦してみてください。&lt;/p&gt;

&lt;p&gt;最後まで読んで頂きありがとうございました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「Wio Node」で半田付けなしの電子工作！温度計作りでIoTはじめの一歩</title>
      <link>https://dotstud.io/blog/seeed-wionode-hands-on/</link>
      <pubDate>Fri, 21 Apr 2017 22:18:36 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/seeed-wionode-hands-on/</guid>
      
      <description>

&lt;p&gt;こんにちは、バックエンドエンジニアのちゃんとく（&lt;a href=&#34;https://twitter.com/tokutoku393&#34;&gt;@tokutoku393&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;今回は、難しいプログラミングや半田付けなしで簡単に試せる「Wio Node」を使って温度表示計を作ってみます！この記事は「&lt;strong&gt;&lt;a href=&#34;https://dotstudio.connpass.com/event/53388/&#34;&gt;WioNodeで始めよう！挫折しないIoT入門ハンズオン
&lt;/a&gt;&lt;/strong&gt;」の資料にもなっています。&lt;/p&gt;

&lt;p&gt;かなり長いですが、詳細な手順を載せていますので根気よく頑張りましょう！&lt;/p&gt;

&lt;h2 id=&#34;wio-nodeとは&#34;&gt;Wio Nodeとは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/01_wio_node.png&#34; alt=&#34;&#34; /&gt;
今回使うWio Nodeは、中国のSeeed Studio社が開発した&lt;strong&gt;Wi-Fiモジュール初期搭載のIoTデバイス&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Grove規格のモジュールをそのまま挿せるコネクタを搭載&lt;/strong&gt;していて、はんだづけなしで動かすことができます。モジュールのセットアップも&lt;strong&gt;公式のスマートフォンアプリから行うことができ&lt;/strong&gt;、電子工作初心者でも簡単に試せます。&lt;/p&gt;

&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;

&lt;p&gt;早速Wio Nodeを動かしてみましょう。今回は、温度センサと7セグメントディスプレイを使って簡易温度計を作ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/02_map.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeに接続したモジュール同士は一見つながっているように見えますが、&lt;strong&gt;内部で連携する仕組みはありません&lt;/strong&gt;。それぞれWi-Fiを使ってAPIからインプットやアウトプットを制御します。&lt;/p&gt;

&lt;p&gt;以下の手順で作っていきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wio Nodeのセットアップ&lt;/li&gt;
&lt;li&gt;Wio Nodeにモジュールを接続する&lt;/li&gt;
&lt;li&gt;アプリからAPIを試す&lt;/li&gt;
&lt;li&gt;Node.jsでプログラムを書く&lt;/li&gt;
&lt;li&gt;試してみる&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Wio Node -&amp;gt; &lt;a href=&#34;https://dotstud.io/shop/wionode-social-remote-control/&#34;&gt;購入ページ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Micro USBケーブル&lt;/li&gt;
&lt;li&gt;Grove 温度センサ（型番: SEEED-101020015）&lt;/li&gt;
&lt;li&gt;Grove 7セグメントディスプレイ（型番: SEEED-104030003）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;類似のセンサがたくさんありますので、型番をよくご確認ください。&lt;/strong&gt;（Wio Nodeに対応していない場合があります。）&lt;/p&gt;

&lt;h4 id=&#34;筆者の環境&#34;&gt;筆者の環境&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;MacBook Pro（Retina 13-inch、Early 2015）&lt;/li&gt;
&lt;li&gt;OS X El Capitan（v10.11.6）&lt;/li&gt;
&lt;li&gt;iOS10.31&lt;/li&gt;
&lt;li&gt;Node.js v7.9.0&lt;/li&gt;
&lt;li&gt;npm 4.5.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wio-nodeのセットアップ&#34;&gt;Wio Nodeのセットアップ&lt;/h3&gt;

&lt;p&gt;まずはWio Nodeの初期設定から進めていきます。&lt;/p&gt;

&lt;p&gt;Wio Nodeは&lt;strong&gt;モバイルバッテリ・PCなどからUSBケーブルで電源を供給しましょう&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;開発用アプリのインストール&#34;&gt;開発用アプリのインストール&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/02_wio_app.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeの開発には、公式からリリースされている「Wio Link」というアプリ（Androidの場合は「Wio」）を利用します。執筆時はiOS版は1.5.2、Android版は2.3.6がリリースされています。今回はiOS版を使っての紹介です。&lt;/p&gt;

&lt;p&gt;iOS: &lt;a href=&#34;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&#34;&gt;https://itunes.apple.com/jp/app/wio-link/id1054893491?mt=8&lt;/a&gt;&lt;br /&gt;
Android: &lt;a href=&#34;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&#34;&gt;https://play.google.com/store/apps/details?id=cc.seeed.iot.ap&amp;amp;hl=ja&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;アプリとwio-nodeの設定&#34;&gt;アプリとWio Nodeの設定&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/03_acount.png&#34; alt=&#34;&#34; /&gt;
アプリを開いたらまずはアカウントを作成しましょう。「SIGN UP」からメールアドレスとパスワードを設定し「Register」で登録します。ServerLocationはデフォルトのGlobalにしておきます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GmailやFacebookのアカウントを使った登録もできますが、他サービスとの連携でうまくいかないことがあるので非推奨です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/04_add_device.png&#34; alt=&#34;&#34; /&gt;
アカウントが作成されたらAdd Your First Deviceをタップし、Wio Nodeを選択します。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wi-fi設定&#34;&gt;Wi-Fi設定&lt;/h4&gt;

&lt;p&gt;続いてWi-Fi設定をします。&lt;strong&gt;手順が少しややこしいので注意してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;まずは簡単にWio Nodeがインターネットに繋がる仕組みを整理してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/05_internet.png&#34; alt=&#34;&#34; /&gt;
デバイスがインターネットに繋がるためには、&lt;strong&gt;インターネットに繋がる媒介（=アクセスポイント）&lt;/strong&gt;が必要です。私たちは普段ルータやポケットWi-Fi（モバイルルータ）を媒介にしていますね。&lt;/p&gt;

&lt;p&gt;Wio Nodeも同様に、インターネットに繋がるために&lt;strong&gt;アクセスポイントが必要&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/06_wifi_setup.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeに&lt;strong&gt;アクセスポイントの情報を教える必要がある&lt;/strong&gt;ので、アドホックモードでWio Nodeとスマートフォンを同じ回線に繋いだ状態にします。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;スマートフォンからWio Nodeにアクセスポイント情報を教えてあげる&lt;/strong&gt;と、その後は&lt;strong&gt;Wio Node自身がアクセスポイントに繋がります&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;接続手順が複雑になりますが、この仕組みを押さえておきましょう！&lt;/p&gt;

&lt;p&gt;アクセスポイントやWAN/LANについてよくわからない方は&lt;a href=&#34;https://dotstud.io/docs/network&#34;&gt;ドキュメント&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wi-fi設定手順&#34;&gt;Wi-Fi設定手順&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/06_func.png&#34; alt=&#34;&#34; /&gt;
まずは画面の指示にしたがってFuncボタン（写真親指側）を4秒以上長押しすると、青いランプがゆらゆらと光ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/07_wio_network.png&#34; alt=&#34;&#34; /&gt;
iOSのWi-Fi選択画面から、「Wio_XXXX」というSSIDを選択します。（Androidはアプリ内での選択です。）アドホックモードで&lt;strong&gt;Wio Nodeとスマートフォンが繋がっている状態&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/08_wifi_list.png&#34; alt=&#34;&#34; /&gt;
アプリに戻ると、続いてWi-Fiの接続を促されます。ネットワークリストから、部屋や会場のWi-Fi（利用するWi-Fi）を選択してパスワードを入力しましょう。&lt;strong&gt;アクセスポイント情報を教えてあげた状態&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/09_device_connect.png&#34; alt=&#34;&#34; /&gt;
Wio Nodeがインターネットに繋がり、登録が完了しました。デバイスに名前をつけておきます。（Android端末で認識がうまくいかない場合、&lt;strong&gt;機内モードにして試す&lt;/strong&gt;と解消することがあるようです。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;アプリからでは失敗する場合は、&lt;a href=&#34;https://dotstud.io/docs/wionode-wiosetup&#34;&gt;こちら&lt;/a&gt;を参考にWio-Setupというツールを試してみてください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;以上でWio Nodeのセットアップは完了です。同じデバイスとアクセスポイントを使う場合は、以後起動するだけで接続されるようになります！&lt;/p&gt;

&lt;h3 id=&#34;wio-nodeにモジュールを接続する&#34;&gt;Wio Nodeにモジュールを接続する&lt;/h3&gt;

&lt;p&gt;アプリから、接続するモジュールを登録します。
&lt;img src=&#34;https://dotstud.io/img/blog/095/10_display_connect.png&#34; alt=&#34;&#34; /&gt;
「PORT0」（左側）をタップして、下の「OUTPUT」から「4-Digit Display」を選択しましょう。&lt;strong&gt;似たようなモジュールがたくさんありますので、よく確認してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/11_temperature_connect.png&#34; alt=&#34;&#34; /&gt;
続いて温度センサを登録します。「PORT1」（右側）をタップして、「INPUT」から「Temperature Sensor」を選択します。&lt;/p&gt;

&lt;p&gt;アプリ画面を参考に、Wio Nodeにモジュールを接続します。
&lt;img src=&#34;https://dotstud.io/img/blog/095/12_module_connect.png&#34; alt=&#34;&#34; /&gt;
「PORT0」に7セグメントディスプレイ、「PORT1」に温度センサを接続しましょう。&lt;/p&gt;

&lt;p&gt;接続できたら、アプリ画面下部の「Update Firmware」をタップしましょう。読み込みのあと、「View API」というAPIサンプルページが表示されるようになります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updateが失敗する場合はモジュールの接続が左右間違っていないか今一度確認してください&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;アプリからapiを試す&#34;&gt;アプリからAPIを試す&lt;/h3&gt;

&lt;p&gt;「View API」のページでは、手軽にモジュールを操作するAPIを試すことができます。正しく接続できているか、試してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/095/13_display_api.png&#34; alt=&#34;&#34; /&gt;
まずは7セグメントディスプレイの「display_point」というAPIを試してみます。説明部分には、「&lt;strong&gt;POSTメソッドで1を送ると&amp;rdquo;:&amp;ldquo;が表示される&lt;/strong&gt;」とありますね。「Test Request」から1を送ってみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/14_display_demo.png&#34; alt=&#34;&#34; /&gt;
7セグメントディスプレイに&amp;rdquo;:&amp;ldquo;が表示されました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/15_temp_api.png&#34; alt=&#34;&#34; /&gt;
続いて温度センサのAPIを試します。温度の取得には値は必要ないので、そのままGETメソッドでRequestします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/16_temp_demo.png&#34; alt=&#34;&#34; /&gt;
現在の温度が返ってきました。（かなり暑いですね（笑））&lt;/p&gt;

&lt;p&gt;挙動が確認できたら、2つのモジュールを連携させるプログラムを書いていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-getメソッドとpostメソッド&#34;&gt;memo: GETメソッドとPOSTメソッド&lt;/h4&gt;

&lt;p&gt;HTTPリクエストにはいくつかのメソッド（送信方法）があります。GET、POSTの他にもPUTメソッド、DELETEメソッドなどがあり、最近主流の「RESTful API」という考え方では&lt;strong&gt;操作する内容によってメソッドを使い分ける&lt;/strong&gt;ことになっています。&lt;/p&gt;

&lt;p&gt;今回はメソッド名だけわかればプログラミング可能ですが、詳しく知りたい方は調べてみてください！&lt;/p&gt;

&lt;h3 id=&#34;node-jsでプログラムを書く&#34;&gt;Node.jsでプログラムを書く&lt;/h3&gt;

&lt;p&gt;センサの値を取得して、室温をディスプレイに表示するプログラムを書いていきましょう。プログラムはAPIを叩ければよいので、今回は&lt;strong&gt;Node.js&lt;/strong&gt;で作成します。&lt;/p&gt;

&lt;p&gt;プログラムの仕組みを理解するために、以下の手順で説明します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Node.jsのインストール&lt;/li&gt;
&lt;li&gt;プロジェクトの作成&lt;/li&gt;
&lt;li&gt;温度情報を取得する&lt;/li&gt;
&lt;li&gt;温度情報を表示したい文字列に変換する&lt;/li&gt;
&lt;li&gt;ディスプレイに温度を表示する&lt;/li&gt;
&lt;li&gt;3秒ごとに更新する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-コマンドラインの使い方&#34;&gt;memo: コマンドラインの使い方&lt;/h4&gt;

&lt;p&gt;Node.jsの実行やファイル操作はコマンドラインで行います。Macには「ターミナル」、Windowsには「コマンドプロンプト」というアプリケーションが最初から入っているので、立ち上げて使いましょう。&lt;/p&gt;

&lt;p&gt;初めてコマンドを使う方は、「ターミナル コマンド」などで検索すると基本的な使い方がわかりますよ！&lt;/p&gt;

&lt;p&gt;筆者はiTerm2というクライアントアプリにzshというシェルを入れています。（画面がちょっと違うくらいだと思ってください。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;1-node-jsのインストール&#34;&gt;1. Node.jsのインストール&lt;/h4&gt;

&lt;p&gt;まずはNode.jsのインストールから始めます。また&lt;code&gt;async/await&lt;/code&gt;という機能を使っているので、&lt;strong&gt;v7.6.0以上が必要&lt;/strong&gt;です。最新版をインストール済みの方は次項の「プロジェクトの作成」から始めてください。&lt;/p&gt;

&lt;p&gt;Node.jsのインストールには、簡単にバージョン管理ができる「&lt;strong&gt;nvm&lt;/strong&gt;」や「&lt;strong&gt;nodebrew&lt;/strong&gt;」を使うのが便利です。nodebrewを使ったインストール方法は下記を参照してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#node-js%E7%92%B0%E5%A2%83%E6%95%B4%E5%82%99&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;インストールが完了したら、Node.jsが正しく動くか確認してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/095/17_node_v.png&#34; alt=&#34;&#34; /&gt;
コマンドラインで&lt;code&gt;node -v&lt;/code&gt;を叩くとバージョンが出るようになったでしょうか？（v7.6.0以上ですよ！）&lt;/p&gt;

&lt;p&gt;Node.jsの環境構築はとても簡単なので、ウェブ開発が初めての方にもオススメです！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-コーディング無しで動かしてみる&#34;&gt;memo: コーディング無しで動かしてみる&lt;/h4&gt;

&lt;p&gt;サクッと試したい方は、githubの&lt;a href=&#34;https://github.com/dotstudio/wionode_handson&#34;&gt;完成プログラム&lt;/a&gt;をご覧ください。READMEの手順を進めるとコーディングなしで動かせます。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-プロジェクトの作成&#34;&gt;2. プロジェクトの作成&lt;/h4&gt;

&lt;p&gt;今回のWio Nodeのプログラムを置くプロジェクトを作成しましょう。&lt;/p&gt;

&lt;p&gt;適当なディレクトリに移動します。（私は&lt;code&gt;/Users/ユーザ名/workspace&lt;/code&gt;という作業ディレクトリを用意しています。参考まで。）
&lt;img src=&#34;https://dotstud.io/img/blog/095/18_mkdir.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;mkdir ディレクトリ名&lt;/code&gt;で新しいディレクトリを作成できます。&lt;code&gt;wio_temperature&lt;/code&gt;というディレクトリを作ってみました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/095/19_cd.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;cd ディレクトリ名&lt;/code&gt;で作成したディレクトリの下に移動します。&lt;/p&gt;

&lt;p&gt;Node.jsでは「npm」でモジュールを管理できます。&lt;code&gt;npm init -y&lt;/code&gt;を実行しましょう。&lt;code&gt;-y&lt;/code&gt;オプションで名前等をデフォルト値で作成してくれます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/20_npm_init.png&#34; alt=&#34;&#34; /&gt;
プロジェクト名やライブラリなどを管理する「&lt;strong&gt;package.json&lt;/strong&gt;」が作成されました。&lt;/p&gt;

&lt;p&gt;今回使用する「&lt;strong&gt;axios&lt;/strong&gt;」ライブラリをインストールします。&lt;code&gt;npm install axios --save&lt;/code&gt;を実行しましょう。&lt;code&gt;--save&lt;/code&gt;オプションをつけることでpackage.jsonに記載されます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/21_npm_install.png&#34; alt=&#34;&#34; /&gt;
axiosがインストールされ、package.jsonに追加されました。&lt;/p&gt;

&lt;p&gt;続いてプログラムを記述するファイルを作成します。&lt;code&gt;touch ファイル名&lt;/code&gt;でファイルが作成されます。（Windowsの場合はコマンドがないのでフォルダから作成してください。）
&lt;img src=&#34;https://dotstud.io/img/blog/095/22_touch.png&#34; alt=&#34;&#34; /&gt;
app.jsというファイルを作成しました。（&lt;code&gt;ls&lt;/code&gt;コマンドでカレントディレクトリのファイルが見れます。Windowsは&lt;code&gt;dir&lt;/code&gt;。）&lt;/p&gt;

&lt;p&gt;以上でプロジェクトの作成は完了です。ファイルにプログラムを書いていきましょう！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;memo-ファイルの編集とエディタについて&#34;&gt;memo: ファイルの編集とエディタについて&lt;/h4&gt;

&lt;p&gt;コマンドラインからでもファイルの編集はできますが、&lt;strong&gt;インデントやコードの補完が効かず作業しづらい&lt;/strong&gt;ので、テキストエディタを使うのがオススメです。&lt;/p&gt;

&lt;p&gt;下記記事ではVisual Studio Codeのインストール方法を紹介しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#visual-studio-code&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-温度情報を取得する&#34;&gt;3. 温度情報を取得する&lt;/h4&gt;

&lt;p&gt;まずは温度を取得するプログラムを書いていきます。&lt;code&gt;BASE_URL&lt;/code&gt;はドメインが違う場合があるので、アプリから確認して自身のものに置き換えてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const TOKEN = process.argv[2] || &#39;&#39;;
const BASE_PATH = `https://us.wio.seeed.io/v1/node`; // 自身のものをアプリで確認

/**
 * 温度取得
 */
 const getTemp = () =&amp;gt; {
     const ENDPOINT = `/GroveTempA0/temp`;
     const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${TOKEN}`;
     axios.request({method: &#39;get&#39;, baseURL: BASE_URL})
     .then((resp) =&amp;gt; console.log(resp));
 }

getTemp();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;axiosに温度取得APIのURLとオプションを渡し、返ってきた値を出力しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;&lt;/code&gt;の部分は、コマンドライン引数（実行時に渡す値）を取得しています。tokenなどの人に知られたくない値は、ファイルに直接書かないのがベターです。&lt;/p&gt;

&lt;p&gt;それでは正しく動くか試してみましょう。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;というコマンドで実行します。&lt;/p&gt;

&lt;p&gt;ご自身のtokenは&lt;strong&gt;アプリのView API画面から確認してください&lt;/strong&gt;。&lt;code&gt;?access_token=&lt;/code&gt;の後の文字列がtokenです。
&lt;img src=&#34;https://dotstud.io/img/blog/095/23_temp_test.png&#34; alt=&#34;&#34; /&gt;
温度センサの情報が返ってきたでしょうか？&lt;/p&gt;

&lt;p&gt;1番下に温度情報がありますね。この情報を使ってディスプレイに表示する文字列を作っていきます。&lt;/p&gt;

&lt;p&gt;エラーが出てしまった人は、「Node.js &amp;lt;エラーメッセージ&amp;gt;」で検索すると答えが見つかりやすいです。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-温度情報を表示したい文字列に変換する&#34;&gt;4. 温度情報を表示したい文字列に変換する&lt;/h4&gt;

&lt;p&gt;取得した温度情報を、ディスプレイに表示する文字列に作り変えるfunctionを作りましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, tempstr.length-1);
  }
  return `${temp_str}C`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;temp2digit()の引数には、先ほど受け取った情報の温度部分だけを渡します。&lt;/p&gt;

&lt;p&gt;数値を文字列に変換し、不要な&amp;rsquo;.&amp;lsquo;を取り除き、3桁にして、温度計らしく&amp;rsquo;C&amp;rsquo;を付けて返します。&lt;/p&gt;

&lt;p&gt;これを先ほど作ったgetTemp()と一緒に実行するようにしてみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const TOKEN = process.argv[2] || &#39;&#39;;
const BASE_PATH = `https://us.wio.seeed.io/v1/node`; // 自身のものをアプリで確認

/**
 * 温度取得
 */
 const getTemp = () =&amp;gt; {
     const ENDPOINT = `/GroveTempA0/temp`;
     const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${TOKEN}`;
     return axios.request({method: &#39;get&#39;, baseURL: BASE_URL}); // ここでは実行しない
 }

/**
 * 温度情報を文字列変換+Cを追加
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt;{
    let temp_str = `${temp}`;
    temp_str = temp_str.replace(&#39;.&#39;,&#39;&#39;);
    if(temp_str.length &amp;gt;= 4){
        temp_str = temp_str.substr(0,temp_str.length-1);
    }
    return `${temp_str}C`;
}

async function main(){ // async/awaitを使う
   const res = await getTemp();
   const temp = res.data.temperature;
   const text = temp2digit(temp);
   console.log(text);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではasync/awaitを使っています。awaitで指定したタスクの実行を待ってレスポンスを受け取り、asyncを付けたメソッドを一つのタスクとして処理するような機能です。Node.jsではv7.6.0から導入されました。&lt;/p&gt;

&lt;p&gt;実行を待たせるため、getTemp()では、APIの結果ではなくメソッドを返すだけに変更します。&lt;/p&gt;

&lt;p&gt;getTemp()で受け取ったobjectの子要素には&lt;code&gt;.&lt;/code&gt;でアクセスします。先ほどのレスポンスのdataの中のtemperatureが欲しいので&lt;code&gt;res.data.temperature&lt;/code&gt;となります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/24_temp2digit.png&#34; alt=&#34;&#34; /&gt;
温度計の文字列ができました！&lt;/p&gt;

&lt;p&gt;次はいよいよこの文字列をディスプレイに表示させます。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-ディスプレイに温度を表示する&#34;&gt;5. ディスプレイに温度を表示する&lt;/h4&gt;

&lt;p&gt;取得した温度の値を使って、ディスプレイに表示するAPIを叩きます。温度の区切りを表すため、最初に試した&amp;rsquo;:&amp;lsquo;を表示するAPIも使ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL})
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fourDigit()のstart_posにはディスプレイ表示の開始位置、charsには表示する文字を渡します。（詳しくはAPIの説明を読んでみてください）&lt;/p&gt;

&lt;p&gt;fourDigitPoint()には表示するかどうかの0/1を渡すようになっています。&lt;/p&gt;

&lt;p&gt;これまで作ったfunctionと繋げてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const BASE_PATH = &#39;https://us.wio.seeed.io/v1/node&#39;; // 自身のものをアプリで確認
const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;

/**
 * 温度を取得
 */
const getTemp = () =&amp;gt; {
  const ENDPOINT = `/GroveTempA0/temp`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;GET&#39;, baseURL: BASE_URL});
}

/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const temp2digit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, tempstr.length-1);
  }
  return `${temp_str}C`;
}

/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

async function main() =&amp;gt; {
  let res = getTemp();
  const temp = res.data.temperature;
  const text = temp2digit(temp);
  console.log(text);
  res = await fourDigit(0, text);
  res = await fourDigitPoint(1);
}

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらも試してみましょう。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行です。
&lt;img src=&#34;https://dotstud.io/img/blog/095/25_comp_demo.png&#34; alt=&#34;&#34; /&gt;
温度がディスプレイに表示されました！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;6-3秒ごとに更新する&#34;&gt;6. 3秒ごとに更新する&lt;/h4&gt;

&lt;p&gt;今のままではコマンドを実行した時しか処理が走りません。3秒ごとに実行するようプログラムを変えてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const INTERVAL = 3000;

/**
 * 繰り返し実行する
 */
setInterval(() =&amp;gt; {
  main()
  .catch((e) =&amp;gt; {
    if (e.response) console.log(e.response);
  })
}, INTERVAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;update()の実行部分をsetInterval()関数で繰り返すようにします。setInterval()の第二引数にミリ秒で数値を渡すと、その間隔ごとに実行されます。あとから変更しやすいよう、定数で宣言しておきましょう。&lt;/p&gt;

&lt;p&gt;catch()はエラーが発生するとエラーレスポンスを受け取ります。&lt;/p&gt;

&lt;p&gt;完成させたコードはこちら。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const axios = require(&#39;axios&#39;);
const BASE_PATH = &#39;https://us.wio.seeed.io/v1/node&#39;; // 自身のものをアプリで確認
const ACCESS_TOKEN = process.argv[2] || &#39;&#39;;
const INTERVAL = 3000;

/**
 * 温度を取得
 *
 * @return {object}
 */
const getTemp = () =&amp;gt; {
  const ENDPOINT = `/GroveTempA0/temp`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;GET&#39;, baseURL: BASE_URL});
}

/**
 * 取得した温度情報を表示する文字列に変換
 *
 * @param {number} temp
 * @return {string}
 */
const tempToDigit = (temp) =&amp;gt; {
  let temp_str = `${temp}`;
  temp_str = temp_str.replace(&#39;.&#39;, &#39;&#39;);
  if (temp_str.length &amp;gt;= 4) {
    temp_str = temp_str.substr(0, temp_str.length-1);
  }
  return `${temp_str}C`;
}

/**
 * ディスプレイに値を表示
 *
 * @param {number} start_pos
 * @param {strng} chars
 * @return {object}
 */
const fourDigit = (start_pos, chars) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_digits/${start_pos}/${chars}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL})
}

/**
 * : を表示/非表示
 * @param {number} display 0|1
 * @return {object}
 */
const fourDigitPoint = (display) =&amp;gt; {
  const ENDPOINT = `/Grove4DigitUART0/display_point/${display}`;
  const BASE_URL = `${BASE_PATH}${ENDPOINT}?access_token=${ACCESS_TOKEN}`;
  return axios.request({method: &#39;POST&#39;, baseURL: BASE_URL});
}

/**
 * メインの処理（同期）
 */
async function main() {
  let res = await getTemp();
  const temp = res.data.temperature;
  const text = tempToDigit(temp);
  console.log(text);
  res = await fourDigit(0, text);
  res = await fourDigitPoint(1);
}

/**
 * 繰り返し実行する
 */
setInterval(() =&amp;gt; {
  main()
  .catch((e) =&amp;gt; {
    if (e.response) console.log(e.response);
  })
}, INTERVAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;試してみる&#34;&gt;試してみる&lt;/h3&gt;

&lt;p&gt;完成コードを試してみます。ドキドキ。&lt;code&gt;node app.js &amp;lt;自分のtoken&amp;gt;&lt;/code&gt;で実行です。
&lt;img src=&#34;https://dotstud.io/img/blog/095/25_comp_demo.png&#34; alt=&#34;&#34; /&gt;
現在の室温が表示されます。&lt;/p&gt;

&lt;p&gt;3秒ごとに更新されるので、変化を試すため温度センサを手で温めてみます。
&lt;img src=&#34;https://dotstud.io/img/blog/095/26_warmer.png&#34; alt=&#34;&#34; /&gt;
少し温度が上がりました。処理を止めたい場合は&lt;code&gt;controll+c&lt;/code&gt;で終了します。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これでプログラムは完成です！やったー！！&lt;/strong&gt; お疲れ様でした！&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;補足-完成の一歩先へ&#34;&gt;補足: 完成の一歩先へ！&lt;/h4&gt;

&lt;p&gt;「簡単であっという間だった」というあなた！&lt;strong&gt;このガジェットを使ってできることはまだまだあります！&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;例1: Azure Web AppsなどのPaaSを使って常時稼働できるようにする&lt;/li&gt;
&lt;li&gt;例2: 温度情報をAmbientなどのウェブサービスを使ってグラフ化してみる&lt;/li&gt;
&lt;li&gt;例3: 一定の温度をトリガーにTwitterやSlackへ通知を送ってみる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記はほんの一例です。Wio Node対応モジュールもたくさんありますので、ここまでの知見を使って試してみましょう！&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いかがだったでしょうか？簡単と言いつつ、コマンドでの作業やウェブ開発の経験がない人には詰まる部分が多かったかもしれません。でも、これで&lt;strong&gt;InternetとThingsの連携ができるようになりました！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IoTの世界には、まだまだたくさんの楽しいデバイスやアイディアが待っています。&lt;strong&gt;作っても使っても楽しい電子工作をやっていきましょう！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最後まで読んでくださりありがとうございました！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>話題のWebBluetoothでGenuino101をブラウザからリモートコントロールしてみよう</title>
      <link>https://dotstud.io/blog/web-bluetooth-remote-blink/</link>
      <pubDate>Thu, 09 Mar 2017 18:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/web-bluetooth-remote-blink/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioの&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;のびすけ&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;最近WebBluetoothがChromeでデフォルトで利用できるようになったと知って、今回試してみたのでまとめてみました。&lt;/p&gt;

&lt;h2 id=&#34;webbluetoothとは&#34;&gt;WebBluetoothとは&lt;/h2&gt;

&lt;p&gt;WebブラウザのAPIでBluetoothが使えるようになるAPIです。正確にはBLE（Bluetooth Low Energy）というBluetooth4.0の機能を使えます。&lt;/p&gt;

&lt;p&gt;通常、BLEはデバイス間を接続して通信させる規格ですが、その性質上、サーバーサイドかつ低レイヤーなプログラミング言語や周辺知識を持っていないと取り扱うことが難しかったです。&lt;/p&gt;

&lt;p&gt;これまでにもNode.jsでは、&lt;a href=&#34;https://github.com/sandeepmistry/noble&#34;&gt;noble&lt;/a&gt;というBLEを扱えるモジュールや類似モジュールが存在しましたが、Node.jsはサーバーサイド言語なためホストマシンが必要でした。&lt;/p&gt;

&lt;p&gt;WebBluetoothはブラウザのJavaScriptからBLEを扱うことができるブラウザAPIです。&lt;/p&gt;

&lt;h3 id=&#34;何が嬉しいの&#34;&gt;何が嬉しいの？&lt;/h3&gt;

&lt;p&gt;WebBluetoothを使えることは、何が利点になるのでしょうか。&lt;/p&gt;

&lt;p&gt;大枠で捉えると、Webとデバイスの連携がしやすくなったことが挙げられます。&lt;/p&gt;

&lt;p&gt;Webブラウザ上のJavaScriptで開発が出来るため、 &lt;strong&gt;通常のWebサイトの機能にデバイスとの連携する機能を追加することができる&lt;/strong&gt;ようになります。&lt;/p&gt;

&lt;p&gt;現行のIoTデバイスはデータを取得するために付属の専用スマホアプリなどをインストールしてBLE通信をする必要があります。これは（スマートフォンの場合）スマホアプリの開発言語のJavaやSwiftからのみBLEを扱うことが出来たからです。&lt;/p&gt;

&lt;p&gt;WebBluetoothが広まれば、デバイスと連携するスマートフォンアプリケーション（以下、スマホアプリ）を開発しなくてもいい時代が来るかもしれません。Webとデバイスの連携が格段にしやすくなるので、Webの表現は圧倒的に広がるなと感じています。&lt;/p&gt;

&lt;p&gt;僕自身は2015年の終わりにWebBluetoothを知り、当時アツくなって発表などをしていました。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;0e2b2871b9d04aab980c1274a383f1cd&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;WebBluetoothの詳細については&lt;a href=&#34;https://www.w3.org/community/web-bluetooth/&#34;&gt;W3Cのページ&lt;/a&gt;などをご確認ください。&lt;/p&gt;

&lt;h2 id=&#34;webbluetoothとgenuino101でリモートlチカをしてみよう&#34;&gt;WebBluetoothとGenuino101でリモートLチカをしてみよう&lt;/h2&gt;

&lt;p&gt;それでは実際にWebBluetoothを使ってみまししょう。&lt;/p&gt;

&lt;p&gt;今回はGenuino101というBluetooth搭載のArduino互換ボードを利用してみます。&lt;/p&gt;

&lt;h3 id=&#34;作るもの&#34;&gt;作るもの&lt;/h3&gt;

&lt;p&gt;Androidのブラウザ（Google Chrome）からGenuino101に繋げたLEDをリモートで制御してみます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;instagram-media&#34; data-instgrm-captioned data-instgrm-version=&#34;7&#34; style=&#34; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:658px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&#34;&gt;&lt;div style=&#34;padding:8px;&#34;&gt; &lt;div style=&#34; background:#F8F8F8; line-height:0; margin-top:40px; padding:28.194444444444443% 0; text-align:center; width:100%;&#34;&gt; &lt;div style=&#34; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;&#34;&gt;&lt;/div&gt;&lt;/div&gt; &lt;p style=&#34; margin:8px 0 0 0; padding:0 4px;&#34;&gt; &lt;a href=&#34;https://www.instagram.com/p/BRMD2E3AxN_/&#34; style=&#34; color:#000; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none; word-wrap:break-word;&#34; target=&#34;_blank&#34;&gt;WebBluetoothがAndroid通常版Chromeでも使えるようになったのでリモートLチカ。 ブラウザでBluetooth使える感動噛みしめてる&lt;/a&gt;&lt;/p&gt; &lt;p style=&#34; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&#34;&gt;n0bisukeさん(@n0bisuke)がシェアした投稿 - &lt;time style=&#34; font-family:Arial,sans-serif; font-size:14px; line-height:17px;&#34; datetime=&#34;2017-03-03T19:54:26+00:00&#34;&gt;2017  3月 3 11:54午前 PST&lt;/time&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;script async defer src=&#34;//platform.instagram.com/en_US/embeds.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;ul id=&#34;env&#34;&gt;
    &lt;li&gt;Macbook Pro Early 2016&lt;/li&gt;
    &lt;li&gt;macOS Sierra v10.12.2&lt;/li&gt;
    &lt;li&gt;Arduino IDE v1.8.1&lt;/li&gt;
    &lt;li&gt;Android 6.0.1&lt;/li&gt;
    &lt;li&gt;Chrome 56&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;genuino101側&#34;&gt;Genuino101側&lt;/h3&gt;

&lt;p&gt;Genuino101側のソースコードはサンプルにあるものをそのまま使います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Copyright (c) 2016 Intel Corporation.  All rights reserved.
 * See the bottom of this file for the license terms.
 */

#include &amp;lt;CurieBLE.h&amp;gt;

BLEPeripheral blePeripheral;  // BLE Peripheral Device (the board you&#39;re programming)
BLEService ledService(&amp;quot;19B10000-E8F2-537E-4F6C-D104768A1214&amp;quot;); // BLE LED Service

// BLE LED Switch Characteristic - custom 128-bit UUID, read and writable by central
BLEUnsignedCharCharacteristic switchCharacteristic(&amp;quot;19B10001-E8F2-537E-4F6C-D104768A1214&amp;quot;, BLERead | BLEWrite);

const int ledPin = 13; // pin to use for the LED

void setup() {
  Serial.begin(9600);

  // set LED pin to output mode
  pinMode(ledPin, OUTPUT);

  // set advertised local name and service UUID:
  blePeripheral.setLocalName(&amp;quot;LED&amp;quot;);
  blePeripheral.setAdvertisedServiceUuid(ledService.uuid());

  // add service and characteristic:
  blePeripheral.addAttribute(ledService);
  blePeripheral.addAttribute(switchCharacteristic);

  // set the initial value for the characeristic:
  switchCharacteristic.setValue(0);

  // begin advertising BLE service:
  blePeripheral.begin();

  Serial.println(&amp;quot;BLE LED Peripheral&amp;quot;);
}

void loop() {
  // listen for BLE peripherals to connect:
  BLECentral central = blePeripheral.central();

  // if a central is connected to peripheral:
  if (central) {
    Serial.print(&amp;quot;Connected to central: &amp;quot;);
    // print the central&#39;s MAC address:
    Serial.println(central.address());

    // while the central is still connected to peripheral:
    while (central.connected()) {
      // if the remote device wrote to the characteristic,
      // use the value to control the LED:
      if (switchCharacteristic.written()) {
        if (switchCharacteristic.value()) {   // any value other than 0
          Serial.println(&amp;quot;LED on&amp;quot;);
          digitalWrite(ledPin, HIGH);         // will turn the LED on
        } else {                              // a 0 value
          Serial.println(F(&amp;quot;LED off&amp;quot;));
          digitalWrite(ledPin, LOW);          // will turn the LED off
        }
      }
    }

    // when the central disconnects, print it out:
    Serial.print(F(&amp;quot;Disconnected from central: &amp;quot;));
    Serial.println(central.address());
  }
}

/*
   Copyright (c) 2016 Intel Corporation.  All rights reserved.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードをArduino IDEでGenuino101に書き込めばBLEのペリフェラル（デバイス側）として起動してくれます。&lt;/p&gt;

&lt;p&gt;ソースコードの22行目の&lt;code&gt;blePeripheral.setLocalName(&amp;quot;LED&amp;quot;);&lt;/code&gt;でLEDと指定していますが、この文字列がBLEデバイスの表示名となります。&lt;/p&gt;

&lt;p&gt;Macからは&lt;a href=&#34;https://itunes.apple.com/jp/app/lightblue/id639944780?mt=12&#34;&gt;LightBlue&lt;/a&gt;などのアプリで確認することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/afc225feba5b36b39547e701171b8070.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ブラウザ側&#34;&gt;ブラウザ側&lt;/h3&gt;

&lt;p&gt;ソースコードは&lt;a href=&#34;https://github.com/n0bisuke/webbluetooth_sample/tree/gh-pages/remote_blink&#34;&gt;こちら&lt;/a&gt;にあげています。&lt;/p&gt;

&lt;p&gt;BLEはペリフェラル（デバイス）のUUID → ServiceのUUID → CharacteristicのUUIDという感じで接続していきます。&lt;/p&gt;

&lt;p&gt;Characteristicがデバイスの個別の機能だとしたら、Serviceは機能群というイメージで捉えると分かりやすいかもしれません。&lt;/p&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://codezine.jp/article/detail/9287&#34;&gt;CodeZineさんの記事など&lt;/a&gt;をご参照ください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const UUID = &#39;19b10000-e8f2-537e-4f6c-d104768a1214&#39;;
const SERVICE_UUID = &#39;19b10001-e8f2-537e-4f6c-d104768a1214&#39;;
let g_characteristic = {};
const $light = document.querySelector(&#39;#light&#39;);
const $bulb = document.querySelector(&#39;.bulb&#39;);

//接続後にon/off切り替え
const ledToggel = () =&amp;gt; {
  g_characteristic.readValue()
  .then((val) =&amp;gt; {
    let led_state = val.getUint8(0); //値読み取り
    led_state = led_state ? 0 : 1;
    g_characteristic.writeValue(new Uint8Array([led_state]));
    toggelClass(led_state);
  })
}

const main = () =&amp;gt; {
  return navigator.bluetooth.requestDevice({acceptAllDevices:true, optionalServices:[UUID]})
  .then(device =&amp;gt; {
    console.log(device);
    console.log(&#39;&amp;gt; Name:             &#39; + device.name);
    console.log(&#39;&amp;gt; Id:               &#39; + device.id);
    console.log(&#39;&amp;gt; Connected:        &#39; + device.gatt.connected);
    console.log(&#39;--デバイスに接続中です...--&#39;);
    return device.gatt.connect();
  })
  .then(server =&amp;gt; {
      console.log(&#39;Getting ___ Service...&#39;);
      return server.getPrimaryService(UUID);
  })
  .then(service =&amp;gt; {
      console.log(&#39;Getting ____ Characteristic...&#39;);
      return service.getCharacteristic(SERVICE_UUID);
    })
  .then(characteristic =&amp;gt; {
      g_characteristic = characteristic;
      $light.removeEventListener(&#39;click&#39;,main);
      $light.addEventListener(&#39;click&#39;,ledToggel);
      return characteristic;
    })
  .catch(error =&amp;gt; {
    console.log(&#39;Argh! &#39; + error);
  });
}

/**
 * domのclass付け替え(表示切り替え)
 */
function toggelClass(led_state){
  if(led_state){
    addClass(&#39;#ff0000&#39;);
  }else{
    removeClass();
  }
}

function removeClass(){
    $bulb.style.background = &#39;#bbb&#39;;
    $bulb.style.boxShadow = &#39;&#39;;
    $bulb.classList.remove(&amp;quot;light_up&amp;quot;);
}

function addClass(color){
    $bulb.style.background = color;
    $bulb.style.boxShadow = `0 -10px 100px ${color}`;
    $bulb.classList.add(&amp;quot;light_up&amp;quot;);
}

$light.addEventListener(&#39;click&#39;, main);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;21行目の&lt;code&gt;navigator.bluetooth.requestDevice()&lt;/code&gt;で周辺のデバイスを検索し、28行目の&lt;code&gt;device.gatt.connect()&lt;/code&gt;でデバイスに接続します。&lt;/p&gt;

&lt;p&gt;32行目の&lt;code&gt;server.getPrimaryService()&lt;/code&gt;でServiceに接続し、36行目の&lt;code&gt;service.getCharacteristic()&lt;/code&gt;でCharacteristic（機能）にアクセスできます。&lt;/p&gt;

&lt;p&gt;そこで接続が確立するとボタンを押すたびに10行目の&lt;code&gt;ledToggel()&lt;/code&gt;が呼ばれ、&lt;code&gt;.readValue()&lt;/code&gt;で値読みとり、&lt;code&gt;.writeValue()&lt;/code&gt;で値の書き込みができるようになります。&lt;/p&gt;

&lt;p&gt;これらのコードは&lt;a href=&#34;https://n0bisuke.github.io/webbluetooth_sample/remote_blink/index.html&#34;&gt;GitHub Pagesで動作するようにホスティングしてある&lt;/a&gt;ので実際の動作確認もできます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;いかがでしたか。&lt;/p&gt;

&lt;p&gt;WebBluetoothを使うことで&lt;strong&gt;ブラウザからBluetoothを使ってデバイスを制御する&lt;/strong&gt;ことができました。&lt;/p&gt;

&lt;p&gt;今後、この技術が普及することでWebブラウザとデバイスの距離がさらになくなっていくかもしれません。&lt;/p&gt;

&lt;p&gt;是非みなさんも試してみて、この可能性を実感してみて下さい。&lt;/p&gt;

&lt;p&gt;それでは。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ハードウェア知識ゼロでも大丈夫。「Gravity」で始める電子工作入門</title>
      <link>https://dotstud.io/blog/dfrobot-gravity-hands-on/</link>
      <pubDate>Tue, 21 Feb 2017 10:00:50 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/dfrobot-gravity-hands-on/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃちゃまるです。&lt;/p&gt;

&lt;p&gt;先日CodeZineさんで紹介した &lt;a href=&#34;http://codezine.jp/article/detail/9982&#34;&gt;ハードウェアの知識ゼロでもボードにセンサーをつなげられる「Gravity」シリーズ&lt;/a&gt; について、さらに詳しく使い方を説明していきたいと思います！&lt;/p&gt;

&lt;p&gt;※この記事は主に初心者の方・他のマイコンボードを使ってはみたが挫折してしまった方向けです。&lt;/p&gt;

&lt;h2 id=&#34;gravity-のおさらい&#34;&gt;「Gravity」のおさらい&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;Gravity&lt;/strong&gt;」とは中国・上海のハードウェア系企業であるDFRobotが作ったコネクタの規格、またそのコネクタを搭載したセンサー等を指します。&lt;/p&gt;

&lt;p&gt;簡単に言うと、開発ボードとコントローラー（ボタンなど）やセンサー（音センサーなど）を統一された規格でつなぐことができるシリーズです。つなぐ部分やコネクタ自体が色分けされているので、&lt;strong&gt;直感的に配線ができ、簡単に自分の思う通りのものができます&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本記事では&lt;a href=&#34;https://www.dfrobot.com/product-1454.html&#34;&gt;Gravity: Stater Kit for Arduino&lt;/a&gt;を題材にしています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/photo.png&#34; alt=&#34;Gravityシリーズ&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;開発環境を整える&#34;&gt;開発環境を整える&lt;/h2&gt;

&lt;p&gt;Gravityのコントローラーやセンサーを使うには、PCにIDE（書き込み用アプリケーション）を用意し、PCとマイコンボードをつなげる必要があります。まずは開発環境から整えていきましょう！&lt;/p&gt;

&lt;ul id=&#34;env&#34;&gt;
    &lt;li&gt;Macbook Air Early 2014&lt;/li&gt;
    &lt;li&gt;OS X El Capitan v10.11.6&lt;/li&gt;
    &lt;li&gt;Arduino IDE v1.6.12&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;arduino-ideをインストール&#34;&gt;Arduino IDEをインストール&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;Arduino - Software&lt;/a&gt;から「Arduino IDE」をダウンロードしてインストールします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/01.png&#34; alt=&#34;Download the Arduino IDE&#34; /&gt;
「Download the Arduino IDE」からお使いのOSを選択してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/02.png&#34; alt=&#34;JUST DOWNLOAD&#34; /&gt;
Arduino IDEはドネーションウェア（ユーザーが任意の利用料を開発者に寄付するライセンス形態のソフトウェア）なので、寄付金額を選択する画面に移動します。今回はグレーで書かれている「JUST DOWNLOAD」をクリックしてダウンロードを開始します。&lt;/p&gt;

&lt;h3 id=&#34;arduino-ideを起動&#34;&gt;Arduino IDEを起動&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/03.png&#34; alt=&#34;IDE初回起動画面&#34; /&gt;
Arduino IDEをダウンロード後初回起動すると、上のような画面がでてきます。このテキストエリアにコードを書いていきます。&lt;/p&gt;

&lt;p&gt;OSの言語を日本語以外に設定している場合、メニューバーの「Arduino」内の「Preferences」からArduino IDEの言語設定を変更できます。反映するにはOKを押した後アプリの再起動が必要です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/04.png&#34; alt=&#34;IDE画面説明&#34; /&gt;
基本的なArduino IDEの流れとしては、まずエディア部分にコードを書き、検証ボタンでコードを検証、その後「マイコンボードに書き込む」ボタンでマイコンにプログラムを送ります。エラーやメッセージなどはコンパイラ画面に出力されます。&lt;/p&gt;

&lt;h3 id=&#34;pcとマイコンボードをつなげる&#34;&gt;PCとマイコンボードをつなげる&lt;/h3&gt;

&lt;p&gt;PCとマイコンボードをつないで、PCからArduino IDE経由でプログラムを書き込めるようにします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/05.png&#34; alt=&#34;ボードを選択&#34; /&gt;
USBでDFRduinoとPCをつないだら、「ツール」から「Arduino/Genuino UNO」を選択するだけです。DFRduinoはArduinoと全く同じ（下で詳しく解説します）なので、これでボードと接続できました。&lt;/p&gt;

&lt;h2 id=&#34;マイコンボードにプログラムを書き込む&#34;&gt;マイコンボードにプログラムを書き込む&lt;/h2&gt;

&lt;p&gt;Arduino IDEではプログラムを書いたファイルのことを「スケッチ」と呼ぶのですが、実はアプリにいくつものスケッチサンプルが内蔵されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/06.png&#34; alt=&#34;&#34; /&gt;
上の「スケッチ例」を見るとかなりの量があります。今回は「01.Basics」内の「Blink」というスケッチを呼び出してみましょう。「Blink」をクリックすると自動的にプログラムが書かれたウィンドウが出てきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/07.png&#34; alt=&#34;Blinkサンプル&#34; /&gt;
たくさんの文字が書かれていますが、実際のプログラムは色がついている部分です（&lt;code&gt;/* */&lt;/code&gt; で囲まれている部分や&lt;code&gt;//&lt;/code&gt;と行の先頭にあるのはコメントなので、実際の挙動には関係しません）。ここに書く言語はC言語ベースの&lt;strong&gt;Arduino言語&lt;/strong&gt;です。C言語自体の記述方法（&lt;code&gt;if&lt;/code&gt;文や&lt;code&gt;for&lt;/code&gt;文など）はここでは解説しませんので、他のサイトを参考にしてください。&lt;/p&gt;

&lt;p&gt;さて、ここで本来なら「検証」ボタンを使ってプログラムに間違いがないかチェックするのですが、今回はサンプルスケッチを使っているのでエラーは出ません。一応画面左上の「検証」（チェックマークのボタン）を押してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/08.png&#34; alt=&#34;コンパイル完了&#34; /&gt;
「コンパイルが完了しました。」と同時に色々出てきました。このような画面が出たらとりあえず「プログラムの検証は成功した」と認識していれば大丈夫です。ちなみに「コンパイル」とは、人間が理解できるプログラミング言語からコンピュータが理解できる機械語へとプログラムを変換することを指します。&lt;/p&gt;

&lt;p&gt;コンパイルが完了したので、いよいよマイコンボードに書き込みましょう。「検証」の隣にある「マイコンボードに書き込む」（矢印マークのボタン）をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/09.png&#34; alt=&#34;ボード上のLED&#34; /&gt;
DFRduino UNOは上の赤で囲った部分がLEDとなっていて、さきほどのスケッチを書き込むとここが周期的に光ったり消えたりします。&lt;/p&gt;

&lt;p&gt;マイコンボードに書き込んだプログラムは、Arduino IDEで新しいスケッチを書き込まない限り動き続けます。LEDのチカチカを止めたいときは「ファイル」から「新規ファイル」を開いて、空のスケッチを書き込みます。&lt;/p&gt;

&lt;h3 id=&#34;シールドを取り付ける&#34;&gt;シールドを取り付ける&lt;/h3&gt;

&lt;p&gt;「シールド」とは、マイコンボードの機能を拡張させるアドオンボードのことを指します。今回使うマイコンボードの「DFRduino UNO R3」はArduino互換（Arduinoと全く同じ動きをするもので、作っている会社・団体が違うだけ）なので、まだこのままではGravityシリーズのセンサーやコントローラーを使うことはできません。そこで、このボードに重ねる形でGravity用シールド「I/O Sensor Expansion Shield v7.1」を乗せます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/10.png&#34; alt=&#34;シールドを重ねた写真&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このI/O Sensor Expansion Shield v7.1を詳しく見てみると、ピン（金属の出っ張っている部分）が「黒・赤・緑」や「黒・赤・青」に色分けされています。&lt;strong&gt;これがまさに、知識ゼロでもGravityで遊ぶことができる理由&lt;/strong&gt;です（後ほど配線をする際にこの色分けの恩恵を受けます）。この後のチュートリアルでは常にシールドをマイコンボードに乗せた状態で使います。&lt;/p&gt;

&lt;h2 id=&#34;プログラムの実行&#34;&gt;プログラムの実行&lt;/h2&gt;

&lt;p&gt;いよいよプログラムを実際に書いて実行していきましょう！&lt;/p&gt;

&lt;h3 id=&#34;デジタル信号を取得する&#34;&gt;デジタル信号を取得する&lt;/h3&gt;

&lt;p&gt;何かのデータを取得する際、センサーから送られてくる信号には「デジタル」と「アナログ」の二種類があります。デジタル信号は値が「0」もしくは「1」で、アナログ信号の場合は値が「0」から「1023」の1024段階で、センサーから送られています。信号を取得するモジュールのことを&lt;strong&gt;インプットデバイス&lt;/strong&gt;と呼びます。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Digital Push Button Module（以下ボタン）&lt;/p&gt;

&lt;h4 id=&#34;実行編&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;では手始めに、&lt;strong&gt;ボタンが押されているかどうかを確認する&lt;/strong&gt;プログラムを動かしてみましょう！&lt;/p&gt;

&lt;p&gt;まずは配線をします。ボタンに付属のコネクタを指し、もう片方をシールドのD側2番ピン（以下図参照）に、コネクタとピンの色が合うように挿してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/11.png&#34; alt=&#34;回路図-ボタン&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ボタンに付属している「黒・赤・緑」のコネクタは、デジタル信号を送るときに使います。今回はボタンが押されているか押されていないか、の2パターンの値が送られてきます。センサーやコントローラーの基盤の上に「D」や「A」と書かれていますが、これらもそれぞれデジタルかアナログかを示しています。&lt;/p&gt;

&lt;p&gt;次に、D側2番ピンにつながっているボタンが押されているかどうかを検知するプログラムをArduino IDEのエディタ部分に書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
	Serial.begin(9600);
	pinMode(2, INPUT);
}

void loop() {
	int buttonState = digitalRead(2);
	Serial.println(buttonState);
	delay(1);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「検証」と「ボードに書き込み」ボタンの列の右端の「シリアルモニタ」ボタン（虫眼鏡のアイコン）をクリックします。ここに&lt;code&gt;Serial.println()&lt;/code&gt;の括弧内の値が表示されるようになります。&lt;/p&gt;

&lt;!--![シリアルモニタスクショ](/img/blog/087/12.png)--&gt;

&lt;h4 id=&#34;プログラム解説編&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;Arduino IDEで作成するプログラムは大きく&lt;code&gt;void setup()&lt;/code&gt;と&lt;code&gt;void loop()&lt;/code&gt;の2つに分けることができます。&lt;code&gt;setup()&lt;/code&gt;に続く中括弧（&lt;code&gt;{}&lt;/code&gt;）の中は一度だけ実行され、&lt;code&gt;loop()&lt;/code&gt;内のコードは繰り返し実行されます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Serial.begin(9600);&lt;/code&gt;はシリアル通信の際データの転送速度を9600で指定しています。これはシリアルモニタを使用するのに必要です。おまじない的なものと解釈してもらって大丈夫です（笑）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pinMode()&lt;/code&gt;はどのピンを使ってどのようにデータを使うかを示しています。括弧内の一つ目にはピン番号を、二つ目には&lt;code&gt;INPUT&lt;/code&gt;（データを取得する）もしくは&lt;code&gt;OUTPUT&lt;/code&gt;（データを送信する）を指定します。今回の場合、&lt;strong&gt;D側2番ピン&lt;/strong&gt;からデータ（ボタンが押されたかどうか）を&lt;strong&gt;取得&lt;/strong&gt;したいので、&lt;code&gt;pinMode(2, INPUT);&lt;/code&gt;となります。ちなみにD側2番ピンの場合&lt;code&gt;2&lt;/code&gt;、A側2番ピンの場合&lt;code&gt;A2&lt;/code&gt;と書きます。&lt;/p&gt;

&lt;p&gt;以上が&lt;code&gt;setup()&lt;/code&gt;になります。次は&lt;code&gt;loop()&lt;/code&gt;内を見ていきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;digitalRead()&lt;/code&gt;を使うと、括弧内で指定したピンの値を読み取ることができます。今回は2番ピンを読み取りたいので&lt;code&gt;digitalRead(2)&lt;/code&gt;ですね。この値を&lt;code&gt;buttonState&lt;/code&gt;に入れておきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Serial.println()&lt;/code&gt;は括弧内の値をシリアルモニタに映します。&lt;code&gt;Serial.println(buttonState);&lt;/code&gt;の場合、&lt;code&gt;buttonState&lt;/code&gt;、つまりボタンが押されているかどうかを&lt;code&gt;0&lt;/code&gt;または&lt;code&gt;1&lt;/code&gt;でシリアルモニタに表示します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;delay()&lt;/code&gt;は括弧内の時間実行を遅らせます。時間の単位はミリ秒（1000分の1秒）です。&lt;code&gt;delay(1);&lt;/code&gt;を&lt;code&gt;loop()&lt;/code&gt;の最後に書くことによって、このプログラムを1ミリ秒ごとに実行するよう指定できます。&lt;/p&gt;

&lt;h3 id=&#34;アナログ信号を取得する&#34;&gt;アナログ信号を取得する&lt;/h3&gt;

&lt;p&gt;次はアナログ信号（0から1023までの値）を取得して、シリアルモニタで表示させてみましょう！こちらも先程と同様、センサーをインプットデバイスとして使います。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Analog Rotation Sensor（以下回転センサー）&lt;/p&gt;

&lt;h4 id=&#34;実行編-1&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;付属しているアナログ用（黒・赤・青）のコネクタで回転センサーとシールドのA側0番ピンをつなげます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/13.png&#34; alt=&#34;回路図-回転&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に以下のプログラムをエディタにコピーします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(9600);
}
void loop() {
  int sensorValue = analogRead(A0);
  Serial.println(sensorValue);
  delay(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作成したスケッチを検証後ボードに送信します。シリアルモニタを開いて回転センサーのツマミを回すと、0から1023の値が回転角度に合わせて表示されると思います。&lt;/p&gt;

&lt;!--![シリアルモニタスクショ](/img/blog/087/14.png)--&gt;

&lt;h4 id=&#34;プログラム解説編-1&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;前回は&lt;code&gt;digitalRead()&lt;/code&gt;を使いましたが、今回はアナログの値を取得したいので&lt;code&gt;analogRead()&lt;/code&gt;を使います。括弧内にはピン番号を入れます。&lt;/p&gt;

&lt;p&gt;記事がとんでもなく長くなってしまうので、既出のコードは解説しません。分からない方はお手数ですが上に戻って確認してください m(._.)m&lt;/p&gt;

&lt;h3 id=&#34;ledをチカチカさせる&#34;&gt;LEDをチカチカさせる&lt;/h3&gt;

&lt;p&gt;LEDを周期的にチカチカ光らせてみます。今回はピンにつないだものから値を取得するのではなく、値をピンにつないだものに送信します。このようなモジュールを&lt;strong&gt;アウトプットデバイス&lt;/strong&gt;と呼びます。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）&lt;/p&gt;

&lt;h4 id=&#34;実行編-2&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;赤LEDをシールドのD側13番につなげてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/15.png&#34; alt=&#34;回路図-LED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ledPin = 13;
void setup() {
  pinMode(ledPin, OUTPUT);
}
void loop() {
  digitalWrite(ledPin, HIGH);
  delay(1000);
  digitalWrite(ledPin, LOW);
  delay(1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検証→ボードに書き込みで、LEDが1秒周期でチカチカし始めます。&lt;/p&gt;

&lt;h4 id=&#34;プログラム解説編-2&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;digitalWrite()&lt;/code&gt;は、括弧内の一つ目に指定したピンに&lt;code&gt;HIGH&lt;/code&gt;もしくは&lt;code&gt;LOW&lt;/code&gt;の値を送ることができます。&lt;code&gt;HIGH&lt;/code&gt;は「1」、&lt;code&gt;LOW&lt;/code&gt;は「0」となります。&lt;/p&gt;

&lt;p&gt;また、プログラム内で13番ピンの情報を何回か使うので、最初に&lt;code&gt;int ledPin = 13;&lt;/code&gt;と変数に入れておいてあげると、後々ピンの番号を変更したいときに便利です。&lt;/p&gt;

&lt;h3 id=&#34;人感ライトを作る&#34;&gt;人感ライトを作る&lt;/h3&gt;

&lt;p&gt;ここの辺りから電子工作っぽい感じになりますよ！次はインプットデバイスとアウトプットデバイスを同時に使い、&lt;strong&gt;一つのモジュールから値を取得して、その値を別のモジュールに送る&lt;/strong&gt;ような仕組みを作ってみます！&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- PIR Sensor（以下人感センサー）→インプットデバイス&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）→アウトプットデバイス&lt;/p&gt;

&lt;h4 id=&#34;実行編-3&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;人感センサーで動きを確認したら、赤LEDを点灯します。どちらもデジタルで良さそう（動いている・動いていない、点灯している・点灯していない、のそれぞれ2つの状態しかない）なので、人感センサーをD側2番ピンに、赤LEDをD側13番ピンにつなげます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/16.png&#34; alt=&#34;回路図-人感LED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int sensorPin = 2;
int ledPin =  13;
int sensorState = 0;
void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(sensorPin, INPUT);
}

void loop() {
  sensorState = digitalRead(sensorPin);
  if (sensorState == HIGH) {
    digitalWrite(ledPin, HIGH);
} else {
    digitalWrite(ledPin, LOW);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検証→ボードに書き込んでみましょう。人感センサーに向かって動いたり手を振ったりするとLEDが付くはずです。&lt;/p&gt;

&lt;h4 id=&#34;プログラム解説編-3&#34;&gt;プログラム解説編&lt;/h4&gt;

&lt;p&gt;今回は変数を3つ作りました。ピン番号などは変数で管理すると、可読性も上がりピンの変更などもしやすいのでオススメです。最後に宣言した&lt;code&gt;sensorState&lt;/code&gt;は、人感センサーで読み取った値が入ります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;digitalRead()&lt;/code&gt;で読み取った値は&lt;code&gt;HIGH&lt;/code&gt;または&lt;code&gt;LOW&lt;/code&gt;でかえってきます。なので&lt;code&gt;sensorState == HIGH&lt;/code&gt;や&lt;code&gt;sensorState == LOW&lt;/code&gt;としてあげると、&lt;code&gt;HIGH&lt;/code&gt;のとき、&lt;code&gt;LOW&lt;/code&gt;のとき、と条件によって別々の挙動を指定することができます。&lt;/p&gt;

&lt;p&gt;まとめると、&lt;code&gt;digitalRead()&lt;/code&gt;で人感センサーからの値によって、赤LEDに&lt;code&gt;digitalWrite()&lt;/code&gt;でオンオフを指定しています。&lt;/p&gt;

&lt;h3 id=&#34;音でledをつける&#34;&gt;音でLEDをつける&lt;/h3&gt;

&lt;p&gt;だんだん慣れてきましたか？今度は音センサーを使って、一定の音量を超えたらLEDが光る仕組みを作りましょう！&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Analog Sound Sensor（以下音センサー）→インプットデバイス&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）→アウトプットデバイス&lt;/p&gt;

&lt;h4 id=&#34;実行編-4&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;音センサーの基盤上に「A」と書かれているので、シールドのA側0番ピンに指します。赤LEDはいままで通りD側なので、D側13番に指します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/17.png&#34; alt=&#34;回路図-音LED&#34; /&gt;&lt;/p&gt;

&lt;p&gt;いままではD側何番、A側何番、と指定してきましたが、実はD側・A側さえ合っていれば基本何番でも大丈夫です。いくつものモジュールを近いピン番号にくっつけすぎるとごちゃごちゃするので、適当に間隔を空けて配線すると楽ですよ。&lt;/p&gt;

&lt;p&gt;まずは以下のコードをエディタに入力してみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int soundPin = A0;
int ledPin = 13;

void setup() {
	pinMode(ledPin, OUTPUT);
	Serial.begin(9600);
}
void loop(){
	int soundState = analogRead(soundPin);
	Serial.println(soundState);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムを検証して実行すると、音センサーが返したアナログの値がシリアルモニタに出てきます。今回は音が「ある一定以上の音量になった場合」LEDを光らせたいので、その「ある一定」を見つける必要があります。周りの環境によって返ってくる音量の値が変わるので、自分がこれ以上音が鳴ったら光らせたい！という値を見つけてください。&lt;/p&gt;

&lt;p&gt;「ある一定」の数値が決まったらそれを反映させつつ以下のプログラムにします。先程まで使っていたコードは先頭に&lt;code&gt;//&lt;/code&gt;をつけることで無視することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int soundPin = A0;
int ledPin = 13;

void setup() {
	pinMode(ledPin, OUTPUT);
	// Serial.begin(9600);
}
void loop(){
	int soundState = analogRead(soundPin);
	// Serial.println(soundState);
	if (soundState &amp;gt; 「ある一定」の数値) {
		digitalWrite(ledPin, HIGH);
		delay(10000);
	} else {
		digitalWrite(ledPin, LOW);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もう一度検証→ボードに書き込むと、周りの音が一定ラインを超えるとLEDが光るようになります！&lt;/p&gt;

&lt;h3 id=&#34;ledをゆっくりと点灯させる&#34;&gt;LEDをゆっくりと点灯させる&lt;/h3&gt;

&lt;p&gt;序盤にLEDを点灯させるのをすでにやりましたが、今度は&lt;strong&gt;ゆっくりと&lt;/strong&gt;点灯させます。勘の良い方は「LEDにアナログの値を書き込めないのではないか」と気づくと思います。ゆっくり点灯ということはおそらく&lt;code&gt;analogWrite()&lt;/code&gt;を使うことは予想できますが、LEDはいままで&lt;code&gt;digitalWrite();&lt;/code&gt;で値を送っていたのでできないのではないか、と。&lt;/p&gt;

&lt;p&gt;そこで&lt;strong&gt;PWN&lt;/strong&gt;（Pulse Width Modulation・パルス幅変調）を使います。ググってみると何やら難しい話が出てきますが、簡単に言うと&lt;strong&gt;デジタル信号で擬似的にアナログデータを送る&lt;/strong&gt;ことができます。&lt;/p&gt;

&lt;p&gt;PWMに対応しているピンは、今回のシールド上ではD側のアスタリスク（&lt;code&gt;*&lt;/code&gt;）が付いている3番、5番、6番、9番、10番、11番です。&lt;/p&gt;

&lt;p&gt;使うパーツ：&lt;br /&gt;
- DFRduino UNO + I/O Sensor Expansion Shield v7.1&lt;br /&gt;
- Digital Piranha LED-R（以下赤LED）→アウトプットデバイス&lt;/p&gt;

&lt;h4 id=&#34;実行編-5&#34;&gt;実行編&lt;/h4&gt;

&lt;p&gt;赤LEDをシールドのD側10番につなげます。PWM対応なのを確認してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/087/18.png&#34; alt=&#34;回路図-LEDPWM&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プログラムは以下の通り。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ledPin = 10;

void setup() {
	pinMode(ledPin,OUTPUT);
}
void loop(){
	for (int value = 0 ; value &amp;lt; 255; value++) {
		analogWrite(ledPin, value);
		delay(5); }
  for (int value = 255; value &amp;gt;0; value--){
 		analogWrite(ledPin, value);
	delay(5); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;検証→ボードに書き込みで、ゆっくりLEDがついて、ゆっくりLEDが消えるようになります。プログラム自体はシンプルなので、解説は割愛します。&lt;/p&gt;

&lt;h2 id=&#34;お疲れ様でした&#34;&gt;お疲れ様でした！&lt;/h2&gt;

&lt;p&gt;ここまでかなり長い道のりでしたね！この記事を書くのにも結構時間かかりました（笑）&lt;/p&gt;

&lt;p&gt;この記事を通して、インプットデバイスから値を取得して、アウトプットデバイスに値を渡す、という処理をできるようになりました。これさえできるようになれば、後は好きなモジュールを使って作りたいものを作るだけです！&lt;/p&gt;

&lt;p&gt;この記事で学んだことだけでできるプロジェクトの一例として、&lt;strong&gt;流れている音楽の大きさを赤・青・緑のLEDで表す&lt;/strong&gt;なんてのはどうでしょうか。音センサーから値を取ってきて、いくつ以上の値で緑LEDを光らせて、いくつ以上で青を、いくつ以上で赤を…… と指定すればできそうですね！PWMを使うことで、さらに細かく音の大きさが表わせそうです。&lt;/p&gt;

&lt;p&gt;2017年2月23日開催の &lt;a href=&#34;https://dotstudio.connpass.com/event/49147/&#34;&gt;今度こそ挫折しない！知識ゼロからの電子工作ハンズオン&lt;/a&gt;イベントに来てくださっている方で、チュートリアルを早く終わってしまった方もぜひやってみてください！&lt;/p&gt;

&lt;p&gt;それではまた！お疲れ様でした！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>littleBits Arduinoモジュールでより細かく値を入出力して状況を伝えよう</title>
      <link>https://dotstud.io/blog/littlebits-arduino-analog-number/</link>
      <pubDate>Thu, 15 Dec 2016 10:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/littlebits-arduino-analog-number/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioライターの田中正吾です。電子回路のパーツを磁石でパチパチとつなげるだけで電子工作ができる「littleBits」の連載をLIGブログでおこなっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/235644&#34;&gt;littleBitsのArduinoモジュールで簡単にプログラミングをはじめてみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/259378&#34;&gt;ArduinoモジュールでLチカしてみた（Windows・Mac）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/268909&#34;&gt;ArduinoモジュールでON・OFFの入力値を取得してみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/280761&#34;&gt;Arduinoモジュールで入出力の連携をしてみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/295334&#34;&gt;シリアルモニタとNode.jsでlittleBits Arduinoモジュールを動かしてみよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://liginc.co.jp/315934&#34;&gt;littleBitsのボタンを押すとIFTTT経由でLINEにメッセージが飛ぶ仕組みを作ってみよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本記事では、これでの連載とは少し視点を変えて、 &lt;strong&gt;littleBits Arduinoモジュールでより細かく値を入出力するアナログ入出力&lt;/strong&gt; をご紹介します。では、さっそく始めていきましょう！&lt;/p&gt;

&lt;h2 id=&#34;より細かく状況を伝えるアナログ値&#34;&gt;より細かく状況を伝えるアナログ値&lt;/h2&gt;

&lt;p&gt;いままで、ボタンを押すと何かが起こるON/OFFの反応で説明していましたが、実は&lt;a href=&#34;http://jp.littlebits.com/kits/arduino-coding-kit/&#34;&gt;ARDUINO CODING KIT&lt;/a&gt;には、より細かく状況を伝えるアナログ値を扱う入出力モジュールがあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;たとえば、DIMMERモジュール（真ん中にあるダイヤル状のツマミのモジュール）は、ツマミを回すことで電気の流れが0～100%と変わります。またBAR GRAPHモジュール（右）は流れる電気によって光るLEDの数が変わります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;つまみを回しきったとき。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;半分ぐらいまでひねったとき。電流50%のときですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ON/OFFではセンサーが「反応した」「反応していない」という2つの情報しか伝えられませんでした。しかし、このように電流の量によって度合いを伝えることができると、たとえば光センサーモジュールを使ったときに明るさを「暗い」「やや暗い」「やや明るい」「とても明るい」といったように、より細かく伝えることができます。&lt;/p&gt;

&lt;h2 id=&#34;アナログ値をarduinoモジュールで計測してみる&#34;&gt;アナログ値をArduinoモジュールで計測してみる&lt;/h2&gt;

&lt;p&gt;それでは早速アナログ値をArduinoモジュールで計測してみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/05.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DIMMERモジュールをArduinoモジュールの入力2番目のA0に取り付けます。&lt;/p&gt;

&lt;p&gt;Arduinoモジュールでアナログ値を計測するには &lt;code&gt;analogRead&lt;/code&gt; 関数を使います。Arduinoモジュールで計測できるアナログ値は0%は0として、100%は1023として計測できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(9600);
}

void loop() {
  int sensorValue = analogRead(A0);
  if(sensorValue&amp;gt;0){
    Serial.println(sensorValue);
  }
  delay(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードを書き込んで、シリアルモニタで数値を見てみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DIMMERをひねると値が変わります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/07.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;シリアルプロッタのほうがよりわかりやすいですね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/08.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/09.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dimmerモジュールのツマミにあわせて点滅を変えてみる&#34;&gt;DIMMERモジュールのツマミにあわせて点滅を変えてみる&lt;/h2&gt;

&lt;p&gt;DIMMERモジュールのツマミの度合いが取れるようになったので、ツマミに合わせてBARGRAPHモジュールの点滅の仕方を変えてみましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このように、さきほどのDIMMERモジュールとArduinoモジュールをつないだものに、BAR GRAPHモジュールも加えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void setup() {
  Serial.begin(9600);
  pinMode(5,OUTPUT);
}

void loop() {
  int sensorValue = analogRead(A0);
  if(sensorValue&amp;gt;0){
    Serial.println(sensorValue);
    digitalWrite(5,HIGH);
    delay(sensorValue);
    digitalWrite(5,LOW);
  }
  delay(sensorValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように書いたコードをArduinoモジュールに書き込みます。&lt;/p&gt;

&lt;iframe width=&#34;715&#34; height=&#34;402&#34; src=&#34;https://www.youtube.com/embed/PircFP-OsQY&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;DIMMERモジュールのつまみに対応して、点滅の仕方が変わるようになりました。&lt;/p&gt;

&lt;h2 id=&#34;さらにサーボに変えてみる&#34;&gt;さらにサーボに変えてみる&lt;/h2&gt;

&lt;iframe width=&#34;715&#34; height=&#34;402&#34; src=&#34;https://www.youtube.com/embed/FVonwS3pb-E&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;http://jp.littlebits.com/kits/arduino-coding-kit/&#34;&gt;ARDUINO CODING KIT&lt;/a&gt;のサーボに変えてみました。LEDよりもわかりやすくなりますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サーボに顔をつけてみます。&lt;/p&gt;

&lt;iframe width=&#34;715&#34; height=&#34;402&#34; src=&#34;https://www.youtube.com/embed/coAm51UmCo0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;ツマミに合わせて顔がビクビクするものに早変わりします！　&lt;a href=&#34;https://liginc.co.jp/280761&#34;&gt;磁石で電子工作できる「littleBits」のArduinoモジュールで、入出力の連携をしてみよう&lt;/a&gt;で試した「三三七拍子するパンダ」はまだ動物らしい動きに見えましたが、この顔ネタはなかなかに気持ち悪いです。夢に出そう。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;今回はlittleBits Arduinoモジュールで &lt;strong&gt;より細かく値を入出力するアナログ入出力&lt;/strong&gt; をお伝えしました。ネタはひとつなのに、モジュールを付け替えるだけで光から動力へと変化します。工作物によって伝わる印象も変わるのがlittleBitsの面白いところです。&lt;/p&gt;

&lt;p&gt;そして、アナログ値を扱うとON/OFFよりも細かく状況を伝えることができたり、動きにもアクセントを持たせるたりすることができます。&lt;/p&gt;

&lt;p&gt;みなさんも、ぜひいろいろなことを試してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/060/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;littleBitsのハックには、LIGブログの&lt;a href=&#34;https://liginc.co.jp/series/littlebits&#34;&gt;littleBitsではじめるArduino&lt;/a&gt;連載、ならびに拙著『&lt;a href=&#34;http://www.1ft-seabass.jp/memo/2016/10/11/littlebits-book-release/?utm_content=bufferec8bb&amp;amp;utm_medium=social&amp;amp;utm_source=twitter.com&amp;amp;utm_campaign=buffer&#34;&gt;「littleBits」ではじめる電子工作&lt;/a&gt;』もぜひご参照ください。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>