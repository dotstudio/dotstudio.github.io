<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>handson on dotstudio（ドットスタジオ）</title><link>https://dotstud.io/series/handson/</link><description>Recent content in handson on dotstudio（ドットスタジオ）</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>© 2018 dotstudio inc.</copyright><lastBuildDate>Tue, 29 Jan 2019 02:11:45 +0900</lastBuildDate><atom:link href="/series/handson/" rel="self" type="application/rss+xml"/><item><title>電池が切れても消えないディスプレイって？電子ペーパーを使ってみた！</title><link>https://dotstud.io/blog/using-e-paper-module/</link><pubDate>Tue, 29 Jan 2019 02:11:45 +0900</pubDate><guid>https://dotstud.io/blog/using-e-paper-module/</guid><description>&lt;p>こんにちは、わくわくエンジニアの&lt;a href="https://dotstud.io/members/tomato/">佐々木さん&lt;/a>です。&lt;/p>
&lt;p>みなさんは&lt;strong>電子ペーパー&lt;/strong>を知っていますか？&lt;/p>
&lt;p>電子ペーパーはその名の通り、&lt;!-- raw HTML omitted -->紙のような見た目のディスプレイ&lt;!-- raw HTML omitted -->です。低消費電力であることや、最後に表示したものを電源がなくても保持し続けることが特徴として挙げられます。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->身近なものだとAmazonの&lt;a href="https://www.amazon.co.jp/Kindle-New%E3%83%A2%E3%83%87%E3%83%AB-%E9%9B%BB%E5%AD%90%E6%9B%B8%E7%B1%8D%E3%83%AA%E3%83%BC%E3%83%80%E3%83%BC-Wi-Fi-%E3%83%96%E3%83%A9%E3%83%83%E3%82%AF-%E3%82%AD%E3%83%A3%E3%83%B3%E3%83%9A%E3%83%BC%E3%83%B3%E6%83%85%E5%A0%B1%E3%81%A4%E3%81%8D%E3%83%A2%E3%83%87%E3%83%AB/dp/B0186FESEE/ref=sr_1_1?ie=UTF8&amp;amp;qid=1547970527&amp;amp;sr=8-1&amp;amp;keywords=kindle">Kindle&lt;/a>で採用されています。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>それでは実際に本題に入っていきましょう！&lt;/p>
&lt;h2 id="heading">電子ペーパーの仕組み&lt;/h2>
&lt;p>今回使用するのは&lt;a href="https://www.sengoku.co.jp/mod/sgk_cart/detail.php?code=EEHD-58WG">2.9inch e-Paper Module&lt;/a>という電子ペーパー。&lt;/p>
&lt;p>電子ペーパーは複数の表示方式がありますが、2.9inch e-Paper Moduleは&lt;strong>電気泳動方式&lt;/strong>というものが採用されているためこちらの説明をしたいと思います。&lt;/p>
&lt;p>電気泳動方式では、ディスプレイの中に&lt;strong>マイクロカプセル&lt;/strong>という&lt;!-- raw HTML omitted -->色を表現するための透明なカプセル&lt;!-- raw HTML omitted -->が隙間なく並んでいます。そのマイクロカプセルの中には色のついた粒子が入っており、かける電圧で粒子を移動させることによって、見える色を変えています。電源がなくなっても粒子は移動しないので、最後に表示したものを保持し続けることができます。&lt;/p>
&lt;p>従来は白黒のディスプレイが主流でしたが、現在では3色のディスプレイも多くなっています。&lt;/p>
&lt;h2 id="heading-1">使ったもの&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.sengoku.co.jp/mod/sgk_cart/detail.php?code=EEHD-58WG">2.9inch e-Paper Module&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/143395/abfea5c3-70e3-6e80-b108-841ff52824d0.jpeg" alt="20180810_165537.jpg">&lt;/p>
&lt;p>このディスプレイは白黒黄の3色を表現できるディスプレイになっています。この他にも、白黒や白黒赤などを表示することができるディスプレイもあります。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.switch-science.com/catalog/3646/">Raspberry Pi Zero WH&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/143395/62d5a886-b22e-f1bd-e436-cea221c7c1d8.jpeg" alt="20190120_192847.jpg">&lt;/p>
&lt;p>このRaspberry Pi Zero WHはIoTで使われるボードの１つです。&lt;/p>
&lt;h2 id="heading-2">ディスプレイに表示させてみよう&lt;/h2>
&lt;p>今回は&lt;a href="https://www.waveshare.com/w/upload/9/98/2.9inch-e-paper-module-user-manual-en.pdf">2.9inch e-Paper Module User Manual&lt;/a>を参考にして進めていきます。&lt;/p>
&lt;h3 id="heading-3">配線&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="center">GPIO&lt;/th>
&lt;th align="center">2.9inch e-Paper Module&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="center">3.3V&lt;/td>
&lt;td align="center">3.3V&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">GND&lt;/td>
&lt;td align="center">GND&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">MOSI&lt;/td>
&lt;td align="center">DIN&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">SCLK&lt;/td>
&lt;td align="center">CLK&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">CE0&lt;/td>
&lt;td align="center">CS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">25&lt;/td>
&lt;td align="center">DC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">17&lt;/td>
&lt;td align="center">RST&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="center">24&lt;/td>
&lt;td align="center">BUSY&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="heading-4">環境構築&lt;/h3>
&lt;p>以下のコマンドが今回プログラムを実行するのに必要なものをインストールするコマンドになります。&lt;/p>
&lt;p>ターミナルを開いて実行してください。&lt;/p>
&lt;pre>&lt;code>sudo apt-get install python-pip
sudo pip install spidev
sudo apt-get install libjpeg-dev
sudo pip install Image
&lt;/code>&lt;/pre>&lt;p>次に、&lt;strong>&lt;code>/boot/config.txt&lt;/code>&lt;/strong>を編集します。以下のコマンドを実行してください。&lt;/p>
&lt;p>&lt;strong>&lt;code>sudo nano /boot/config.txt&lt;/code>&lt;/strong>&lt;/p>
&lt;p>すると、nanoエディタが開くので、以下の手順を行なってください。&lt;/p>
&lt;ol>
&lt;li>番下に&lt;strong>&lt;code>dtparam=spi=on&lt;/code>&lt;/strong>を追加&lt;/li>
&lt;li>キーボードの &lt;strong>&lt;code>controlキー&lt;/code>&lt;/strong> と &lt;strong>&lt;code>xキー&lt;/code>&lt;/strong> を同時に押す&lt;/li>
&lt;li>&lt;strong>&lt;code>yキー&lt;/code>&lt;/strong>を押す&lt;/li>
&lt;li>&lt;strong>&lt;code>enterキー&lt;/code>&lt;/strong>を押す&lt;/li>
&lt;li>全て完了したら&lt;strong>&lt;code>reboot&lt;/code>&lt;/strong>コマンドで再起動&lt;/li>
&lt;/ol>
&lt;p>これで環境構築は完了です。&lt;/p>
&lt;h3 id="heading-5">プログラム&lt;/h3>
&lt;p>デモプログラムが公開されているため、&lt;a href="https://www.waveshare.com/wiki/File:2.9inch_e-paper_module_b_code.7z">こちら&lt;/a>からcurrentと書かれているものをダウンロードしてください。&lt;/p>
&lt;p>ダウンロードが完了したら以下のコマンドを実行してください。&lt;/p>
&lt;pre>&lt;code>sudo apt-get install p7zip-full
7z x 2.9inch_e-paper_module_b_code.7z
&lt;/code>&lt;/pre>&lt;p>上記のコマンドで出てきた中の&lt;strong>&lt;code>RaspberryPi/python2&lt;/code>&lt;/strong>を今回は使います。&lt;/p>
&lt;p>ターミナルで&lt;strong>&lt;code>RaspberryPi/python2&lt;/code>&lt;/strong>ディレクトリに移動して&lt;code>python main.py&lt;/code>**を実行すると、デモプログラムが起動します（※何も編集していない状態だとフォントが存在していないためエラーが発生します）。&lt;/p>
&lt;p>&lt;strong>&lt;code>nano main.py&lt;/code>&lt;/strong>でファイルを少し編集します。&lt;/p>
&lt;p>&lt;code>main.py&lt;/code>には以下のようなプログラムがあります。&lt;/p>
&lt;p>&lt;strong>main.py&lt;/strong>&lt;/p>
&lt;pre>&lt;code>font24 = ImageFont.truetype('/usr/share/fonts/truetype/wqy/wqy-microhei.ttc', 24)
font18 = ImageFont.truetype('/usr/share/fonts/truetype/wqy/wqy-microhei.ttc', 18)
&lt;/code>&lt;/pre>&lt;p>この&lt;strong>&lt;code>'/usr/share/fonts/truetype/wqy/wqy-microhei.ttc'&lt;/code>&lt;/strong>という部分を
&lt;strong>&lt;code>'/opt/vc/src/hello_pi/hello_font/Vera.ttf'&lt;/code>&lt;/strong>に変更します。&lt;/p>
&lt;p>もう一度&lt;code>python main.py&lt;/code>を実行すると、画面がピカピカし始め、Hello, worldなどが画像に表示されます。&lt;/p>
&lt;p>では、実際にプログラムを少し変えて見ていきましょう。&lt;/p>
&lt;p>&lt;strong>main.py&lt;/strong>&lt;/p>
&lt;pre>&lt;code>#!/usr/bin/python
# -*- coding:utf-8 -*-
import epd2in9b
import time
from PIL import Image,ImageDraw,ImageFont
import traceback
try:
# ディスプレイの初期化処理をしています。
epd = epd2in9b.EPD()
epd.init()
print &amp;quot;clear&amp;quot;
epd.Clear(0xFF)
# ディスプレイを横に使うように設定しています。
HBlackimage = Image.new('1', (epd2in9b.EPD_HEIGHT, epd2in9b.EPD_WIDTH), 255) # 298*126
HRedimage = Image.new('1', (epd2in9b.EPD_HEIGHT, epd2in9b.EPD_WIDTH), 255) # 298*126
print &amp;quot;Drawing&amp;quot;
drawblack = ImageDraw.Draw(HBlackimage)
drawred = ImageDraw.Draw(HRedimage)
# １つ目の引数でフォント、2つ目の引数でフォントのサイズを指定しています。
font30 = ImageFont.truetype('/opt/vc/src/hello_pi/hello_font/Vera.ttf', 30)
# １つ目の引数で座標、２つ目に表示させたい文字列、３つ目には上記のフォントを指定します。
drawblack.text((10, 0), 'Hello, World', font = font30)
# ディスプレイに表示させます。
epd.display(epd.getbuffer(HBlackimage), epd.getbuffer(HRedimage))
time.sleep(2)
print &amp;quot;read bmp file&amp;quot;
HBlackimage = Image.open('2in9b-b.bmp')
epd.display(epd.getbuffer(HBlackimage), epd.getbuffer(HRedimage))
time.sleep(2)
except Exception, e:
print 'traceback.format_exc():\n%s' % traceback.format_exc()
exit()
&lt;/code>&lt;/pre>&lt;p>このプログラムを実行すると以下のようになります。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/143395/45152d05-0b37-6d40-a992-2dc034553d67.gif" alt="20190121_002653.gif">&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/143395/c4b5f8b7-40c1-5145-5ba6-11c9b7a6f69a.gif" alt="20190121_002722.gif">&lt;/p>
&lt;h2 id="heading-6">まとめ&lt;/h2>
&lt;p>いかがでしたでしょうか？&lt;/p>
&lt;p>電子ペーパーは、低消費電力という特徴があるので、センサからとれるデータを一定時間ごとに表示したり、自分の好きなものを表示して持ち運んだりすることもできます。&lt;/p>
&lt;p>電子部品の販売店に売っていたりしますが、電子ペーパーの使い方はあまり広がっていないように感じるので、この記事を参考にぜひやってみてください！&lt;/p></description></item><item><title>ArduinoでTwitter連携！愛しのぬいぐるみトンピーちゃんに命を吹き込んでみた</title><link>https://dotstud.io/blog/arduino-nodejs-twitter-connect/</link><pubDate>Mon, 28 Jan 2019 00:51:35 +0900</pubDate><guid>https://dotstud.io/blog/arduino-nodejs-twitter-connect/</guid><description>&lt;p>皆さん、大好きなぬいぐるみが動き出したらいいなと思ったこと、ありませんか？&lt;/p>
&lt;p>今回は私の愛すべきお友達「トンピーちゃん」に命を吹き込むべく、プログラミング初心者の私がArduinoとTwitterの連携に挑戦してみました！&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->こちらです！！&lt;!-- raw HTML omitted -->
&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/721a8190-3ffc-8bca-c4b3-774ee58d45e9.gif" alt="ezgif.com-video-to-gif.gif">&lt;/p>
&lt;h2 id="heading">今回やること&lt;/h2>
&lt;h3 id="heading-1">実装の構成&lt;/h3>
&lt;p>&lt;a href="https://gyazo.com/a75b45dc702b385f5e32fcd3e39c5b64">&lt;img src="https://i.gyazo.com/a75b45dc702b385f5e32fcd3e39c5b64.png" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;p>ざっくりの構成です。Node.jsでTwitterの「#tonpy」というハッシュタグを監視し、「move #tonpy」「stop #tonpy」というツイートがあったらArduinoを経由してトンピーちゃんが動いたり止まったりします。&lt;/p>
&lt;h3 id="heading-2">用意するもの&lt;/h3>
&lt;h4 id="heading-3">■こぐまのトンピーちゃん&lt;/h4>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/210df088-f5f0-6f8a-e9ee-2a63f06e2364.jpeg" alt="トンピー.jpg">
愛用のトンピーちゃんです。乾電池を入れるとピーヒャラドンドンします。&lt;/p>
&lt;ul>
&lt;li>購入: &lt;a href="https://www.amazon.co.jp/%E3%82%A4%E3%83%AF%E3%83%A4-%E3%81%93%E3%81%90%E3%81%BE%E3%81%AE%E3%83%88%E3%83%B3%E3%83%94%E3%83%BC/dp/B0002U3OBA">Amazon.co.jp&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="arduino-uno">■Arduino Uno&lt;/h4>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/c26d230d-e320-b73d-f15f-32d813e1294f.jpeg" alt="Arduino Uno.jpg">
Arduino Unoは2010年に発売されたArduinoで、&lt;a href="https://store.arduino.cc/usa/arduino-uno-rev3">Arduinoの公式サイト&lt;/a>にも「&lt;strong>電子工作初心者に最適&lt;/strong>」と書いてあったのでこちらに決めました。&lt;/p>
&lt;p>購入にあたっては「Arduino 初心者」と調べヒットした「&lt;a href="https://www.amazon.co.jp/%E3%82%B9%E3%82%A4%E3%83%83%E3%83%81%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9-SSCI-GettingStartedArduinoKit-Arduino%E3%82%92%E3%81%AF%E3%81%98%E3%82%81%E3%82%88%E3%81%86%E3%82%AD%E3%83%83%E3%83%88/dp/B0025Y6C5G/ref=sr_1_fkmr1_2?ie=UTF8&amp;amp;qid=1544321570&amp;amp;sr=8-2-fkmr1&amp;amp;keywords=arduino+%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%82%AD%E3%83%83%E3%83%88">Arduinoをはじめようキット&lt;/a>」を購入しました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="fetfet-mosfet-2sjs527l-e-60v5a">■FET（FET MOSFET 2SJS527L-E 60V5A）&lt;/h4>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/88510174-eed9-e286-5343-3deeb08a7884.jpeg" alt="I-08315.jpg">&lt;/p>
&lt;p>FETはロードスイッチとも呼ばれ、簡単にいうと外部からの電圧によって電流の流れを制御できるスイッチのようなもののようです。小さな電力で動作させる事ができます。&lt;/p>
&lt;p>&lt;a href="https://dotstud.io/#%E5%9B%9E%E8%B7%AF%E3%82%92%E4%BD%9C%E6%88%90">回路を作成&lt;/a>で説明しますが、FETには「Pチャネル」と「Nチャネル」の2種類あります。今回はNチャネルのFETを利用します。&lt;/p>
&lt;ul>
&lt;li>購入: &lt;a href="http://akizukidenshi.com/catalog/g/gI-07145/">秋月電子&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="nodejspc">■Node.jsをインストールしたPC&lt;/h4>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/efcdf34b-504e-cc68-125a-0acadd815510.jpeg" alt="IMG_9204.jpg">&lt;/p>
&lt;p>今回はNode.jsでプログラムを動かします。下記記事を参考にインストールしてみてください！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>筆者PC: mac OS HighSierra バージョン10.13.6&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>Node.js: v10.10.0&lt;/li>
&lt;/ul>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-4">■その他&lt;/h4>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/eb369434-a5ff-e44a-c7b9-02a065030098.jpeg" alt="IMG_9206.jpg">&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dotstud.io/docs/breadboard/">ブレッドボード&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://localhost:1313/docs/jumperwire/#%E3%83%9F%E3%83%8E%E3%83%A0%E3%82%B7%E3%82%AF%E3%83%AA%E3%83%83%E3%83%97-%E3%83%AF%E3%83%8B%E5%8F%A3">ワニ口クリップ&lt;/a>&lt;/li>
&lt;li>抵抗（今回は220Ω）&lt;/li>
&lt;/ul>
&lt;h2 id="heading-5">トンピーちゃんを解体&lt;/h2>
&lt;p>まずはトンピーちゃんの導線を確認するため、少し解体します。
&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/69ccd688-afb6-0715-124a-44d886fe3178.jpeg" alt="IMG_6786.jpg">&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/84c4fcd7-8c65-a0dc-1a84-ee75b5c2ef48.jpeg" alt="IMG_9205.jpg">
電池の部分を取り外してみました。すると、導線は電池部分と本体でパックリ分かれている事が確認できました。今回はその部分にArduino Unoを繋げば回路の開/閉が制御できそうですね。&lt;/p>
&lt;h2 id="arduino-uno-1">Arduino Unoとトンピーちゃんを連携&lt;/h2>
&lt;h3 id="heading-6">回路を作成&lt;/h3>
&lt;p>Arduino Unoから直接ON/OFFを制御しようとすると、電流が少なく回路を開/閉できませんでした。そこでArduino Unoとトンピーちゃんの間に&lt;strong>FETを挿入&lt;/strong>します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>FETは、電圧の加え方の違いによって「Pチャネル」と「Nチャネル」の2種類に分かれます。今回はNチャネルのFETを利用します。&lt;/p>
&lt;p>また、回路の「+側」にFETを繋ぐことを「ハイサイド（スイッチ）」、-側に繋ぐことを「ローサイド（スイッチ）」と呼称します。今回はNチャネルなので、ローサイドにFETを繋ぎます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/d32c3f6f4b1de908ceced242cc2ba7f4.png" alt="Image from Gyazo">&lt;/p>
&lt;p>最終的に上記のような回路図になりました。&lt;/p>
&lt;h3 id="arduino-uno-2">Arduino Unoにプログラムを書き込む&lt;/h3>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/b544f541-a5ac-ee97-18a3-de3963210c92.png" alt="スクリーンショット 2018-12-18 12.35.58.png">
ArduinoをUSBケーブルでPCに繋ぎ、アプリケーションでArduino IDEを開きます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/da16043a-121e-52e2-e395-3121a8a3e48f.png" alt="スクリーンショット 2018-12-16 15.10.09.png">
ファイル→新規ファイルを選択します。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/2a42d894-497d-a0c4-5573-6a4c148fc5fe.png" alt="スクリーンショット 2018-12-16 15.09.45.png">
ツール→ボード→繋いだArduino（今回はArduino Uno）を選択します。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/9f5d63e2-454b-c637-ef5d-07550cccf8d5.png" alt="スクリーンショット 2018-12-16 15.11.33.png">
ツール→シリアルポート→接続したArduinoを選択します。&lt;/p>
&lt;p>下記コードを新規ファイルにコピー&amp;amp;ペーストします。&lt;/p>
&lt;pre>&lt;code>// pins
const int tonpyPin = 2;
void setup() {
// initialize serial:
Serial.begin(9600);
// make the pins outputs:
pinMode(tonpyPin, OUTPUT);
}
void loop() {
// if there's any serial available, read it:
while (Serial.available() &amp;gt; 0) {
char value = Serial.read();
if (value == 'p') {
digitalWrite(tonpyPin, HIGH);
} else if (value == 'q'){
digitalWrite(tonpyPin, LOW);
} else{
digitalWrite(tonpyPin, LOW);
}
Serial.println(value);
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/8ec32eee-c610-137c-febd-9408f22db6e1.png" alt="スクリーンショット 2018-12-10 9.25.26.png">
左上にある「→」ボタンを押してマイコンボードに書き込みます。&lt;/p>
&lt;p>これでArduino Unoからの信号（p: スイッチON、q: スイッチOFF）でトンピーちゃんが動く/止まるようになりました。&lt;/p>
&lt;p>これをツイートと連動できれば完成です！&lt;/p>
&lt;h2 id="nodejs">Node.jsのプログラム&lt;/h2>
&lt;p>ハッシュタグ「#tonpy」を取得し、さらに「move」「stop」のツイートがあったらArduino Unoに送るプログラムを作成します。&lt;/p>
&lt;h3 id="twitter-api">Twitter APIの準備&lt;/h3>
&lt;p>API使用には&lt;a href="https://developer.twitter.com/">Twitter Developer&lt;/a>へ登録する必要があります。登録の際、用途など英文で書く部分がありました（筆者はGoogle翻訳を駆使しました）。&lt;/p>
&lt;p>手順については下記の記事に詳しく書かれており、そちらに沿って登録しました。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="https://qiita.com/kngsym2018/items/2524d21455aac111cdee">Twitter API 登録 (アカウント申請方法) から承認されるまでの手順まとめ　※2018年9月時点の情報&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="tweetnodejs">Tweetを取得するNode.jsのプログラムを作成&lt;/h3>
&lt;h4 id="heading-7">■ディレクトリを用意&lt;/h4>
&lt;p>任意の保存場所にフォルダを用意します。今回はDesktopにTonpyフォルダを作りました。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="js">■JSファイルを作成&lt;/h4>
&lt;p>作成したフォルダに任意の名前のJSファイルを用意します。今回は「app.js」としました。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="twitter-api-1">■Twitter APIを使用するモジュールのインストール&lt;/h4>
&lt;p>Node.jsでTwitter APIが使用できるよう&lt;a href="https://www.npmjs.com/package/twitter">Twitterモジュール&lt;/a>をnpmでインストールします。ターミナルで作成したフォルダを開き、下記コマンドを叩きます。&lt;/p>
&lt;pre>&lt;code>$ npm install twitter
&lt;/code>&lt;/pre>&lt;p>これでNode.jsでTwitter APIが使用できるようになりました。&lt;/p>
&lt;p>実際に使用する際はJSファイル内で最初に下記のように書くとTwitter APIが呼び出されます。&lt;/p>
&lt;pre>&lt;code>const Twitter = require('twitter');
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-8">■ツイートを取得するプログラムを作成&lt;/h4>
&lt;p>TwitterAPIには「REST API」と「Streaming API」の2種類があります。&lt;/p>
&lt;p>REST APIはエンドポイントへリクエストして初めて結果が得られるものに対して、Streaming APIはレートのリミットなくツイートを受信し続ける事ができます。&lt;/p>
&lt;p>今回はツイートを常に監視し該当のツイートがあったら結果を取得する、という事がしたいので&lt;strong>Streaming API&lt;/strong>を使用します。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">twitter&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;twitter&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;fs&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">twitter&lt;/span>({
&lt;span style="color:#a6e22e">consumer_key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,&lt;span style="color:#75715e">//Dev Accountで取得したkeyを書く
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">consumer_secret&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">access_token_key&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;span style="color:#a6e22e">access_token_secret&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
});
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tweetText&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;w&amp;#39;&lt;/span>;
&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">stream&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;statuses/filter&amp;#39;&lt;/span>, {&lt;span style="color:#a6e22e">track&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#e6db74">&amp;#34;#tonpy &amp;#34;&lt;/span>}, (&lt;span style="color:#a6e22e">stream&lt;/span>) =&amp;gt; {&lt;span style="color:#75715e">//Streaming APIを呼び出す
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">stream&lt;/span>.&lt;span style="color:#a6e22e">on&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;data&amp;#39;&lt;/span>, (&lt;span style="color:#a6e22e">tweet&lt;/span>) =&amp;gt; {
&lt;span style="color:#a6e22e">tweetText&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">tweet&lt;/span>.&lt;span style="color:#a6e22e">text&lt;/span>;
(&lt;span style="color:#f92672">~&lt;/span>&lt;span style="color:#a6e22e">tweetText&lt;/span>.&lt;span style="color:#a6e22e">indexOf&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;move&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">?&lt;/span> (&lt;span style="color:#a6e22e">tweetText&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;p&amp;#39;&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#f92672">~&lt;/span>&lt;span style="color:#a6e22e">tweetText&lt;/span>.&lt;span style="color:#a6e22e">indexOf&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;stop&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">?&lt;/span> (&lt;span style="color:#a6e22e">tweetText&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;q&amp;#39;&lt;/span>) &lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#a6e22e">tweetText&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;w&amp;#39;&lt;/span>);
});
&lt;span style="color:#a6e22e">stream&lt;/span>.&lt;span style="color:#a6e22e">on&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;error&amp;#39;&lt;/span>, (&lt;span style="color:#a6e22e">error&lt;/span>) =&amp;gt; {&lt;span style="color:#75715e">//エラー
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">Error: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">error&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;span style="color:#a6e22e">stream&lt;/span>.&lt;span style="color:#a6e22e">destroy&lt;/span>();
});
});
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ツイートを取得するNode.jsのプログラムが完成しました。&lt;/p>
&lt;h3 id="arduino">Arduinoに送るプログラムを作成&lt;/h3>
&lt;h4 id="heading-9">■シリアル通信をするモジュールのインストール&lt;/h4>
&lt;p>PCとArduino間でシリアル通信をするために、シリアルポートでシリアル通信を行うモジュールもnpmでインストールします。&lt;/p>
&lt;p>シリアルポートとは&lt;strong>シリアル通信を行う時の接続口&lt;/strong>のことで、今回はArduinoと接続したPCのUSBポートにあたります。&lt;/p>
&lt;p>ターミナルで下記コマンドを叩きます。&lt;/p>
&lt;pre>&lt;code>$ npm install serialport
&lt;/code>&lt;/pre>&lt;p>これでNode.jsでシリアルポートを制御できるようになりました。&lt;/p>
&lt;p>使用する際はJSファイル内で最初に下記のように呼び出します。&lt;/p>
&lt;pre>&lt;code>const Serialport = require('serialport');
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-10">■シリアルポートの名前を調べる&lt;/h4>
&lt;p>プログラム内では、USBポートに挿しているArduino Uno（ttyデバイス）を指定します。&lt;/p>
&lt;p>ターミナルで下記コマンドを打ち、PCのシリアルポートに接続されている機器を表示します。&lt;/p>
&lt;pre>&lt;code>$ ls -l /dev/tty.*
&lt;/code>&lt;/pre>&lt;p>Auduino Unoを挿し、もう一度先ほどのコマンドを打ちます。新しく出てきたttyデバイス名がArduino Unoです。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="-arduino-unonodejs">■ Arduino Unoに送るNode.jsのプログラムを作成&lt;/h4>
&lt;p>下記がシリアル通信するためのコードです。ツイートを取得するためのJSファイルの続きに記述してください。&lt;/p>
&lt;p>1行目の&lt;code>/dev/tty.xxx&lt;/code>には上記のシリアルポート名を記入してください。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">port&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">SerialPort&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/dev/tty.xxx&amp;#39;&lt;/span>,{
&lt;span style="color:#a6e22e">baudRate&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">9600&lt;/span>&lt;span style="color:#75715e">//baudRate:9600は1秒に最大9600ビットを送信するという意味
&lt;/span>&lt;span style="color:#75715e">&lt;/span>});
&lt;span style="color:#a6e22e">port&lt;/span>.&lt;span style="color:#a6e22e">write&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;main screen turn on&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">err&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Error on write: &amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>);
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;message written&amp;#39;&lt;/span>);
});
&lt;span style="color:#a6e22e">port&lt;/span>.&lt;span style="color:#a6e22e">on&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;open&amp;#39;&lt;/span>, () =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Serial open.&amp;#39;&lt;/span>);
&lt;span style="color:#a6e22e">setInterval&lt;/span>(&lt;span style="color:#a6e22e">write&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>);
});
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span> &lt;span style="color:#f92672">=&lt;/span> () =&amp;gt; {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">Input to Arduino: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">tweetText&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
&lt;span style="color:#a6e22e">port&lt;/span>.&lt;span style="color:#a6e22e">write&lt;/span>(&lt;span style="color:#a6e22e">tweetText&lt;/span>, (&lt;span style="color:#a6e22e">error&lt;/span>) =&amp;gt; {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">error&lt;/span>) {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#e6db74">Error: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">error&lt;/span>.&lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>);
}
});
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでツイート情報を取得し、Arduinoに信号を送る事ができるようになりました。&lt;/p>
&lt;h3 id="heading-11">完成コード&lt;/h3>
&lt;p>ツイートを取得するプログラム、Arduinoを制御するプログラムを合わせた完成コードは下記のようになります。&lt;/p>
&lt;pre>&lt;code>//-----------------------------------------------
// twitterからツイートを取得
//-----------------------------------------------
const twitter = require(&amp;quot;twitter&amp;quot;);
const client = new twitter({
consumer_key: '',//Dev Accountで取得したkeyを書く
consumer_secret: '',
access_token_key: '',
access_token_secret: '',
});
let tweetText ='w';
client.stream('statuses/filter', {track:&amp;quot;#tonpy &amp;quot;}, (stream) =&amp;gt; {
stream.on('data', (tweet) =&amp;gt; {
tweetText = tweet.text;
(~tweetText.indexOf('move')) ? (tweetText = 'p') : (~tweetText.indexOf('stop')) ? (tweetText = 'q') : (tweetText = 'w');
});
stream.on('error', (error) =&amp;gt; {
console.error(`Error: ${error.message}`);
stream.destroy();
});
});
//-----------------------------------------------
// Node.jsからArduinoに送信
//----------------------------------------------
const SerialPort = require('serialport');
const port = new SerialPort('/dev/tty.xxx',{
baudRate: 9600
});
port.on('open', () =&amp;gt; {
console.log('Serial open.');
setInterval(write, 1000);
});
port.on('data', (data) =&amp;gt; {
console.log(`Data from Arduino: ${data}`);
});
const write = () =&amp;gt; {
console.log(`Input to Arduino: ${tweetText}`);
port.write(tweetText, (error) =&amp;gt; {
if(error) {
console.error(`Error: ${error.message}`);
}
});
}
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="nodejs-1">■Node.jsを実行する&lt;/h4>
&lt;p>Node.jsは、ファイルのある場所で下記コマンドで実行します。&lt;/p>
&lt;pre>&lt;code>$ node app.js
&lt;/code>&lt;/pre>&lt;p>&lt;code>app.js&lt;/code>部分は、ご自身が作成したファイル名に置き換えてください。「Serial open」がターミナル上に表示されたら無事実行されています。&lt;/p>
&lt;h2 id="heading-12">動かしてみる&lt;/h2>
&lt;p>Node.jsを起動しながら、ツイートしてみましょう……。「&lt;strong>#tonpy move&lt;/strong>」!!!!!
&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/309368/9c8c2611-d9b2-e7dd-3710-8d2011c2b424.gif" alt="ezgif.com-video-to-gif.gif">&lt;/p>
&lt;p>う、動いたーーーー！！！（少々タイムラグがありますが……。）&lt;/p>
&lt;p>初めてのIoTとっっても楽しかったです！電子工作やNode.jsの勉強にもなり一石二鳥ですね。&lt;/p>
&lt;p>これから色々作っていきたいです！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>【ハンズオン資料】GR-LYCHEEとOpenCVで画像認識やってみよう</title><link>https://dotstud.io/blog/gr-lychee-opencv-handson/</link><pubDate>Thu, 13 Dec 2018 05:17:31 +0900</pubDate><guid>https://dotstud.io/blog/gr-lychee-opencv-handson/</guid><description>&lt;p>この記事は12/07の&lt;a href="https://ai-iot-bol-fukui.connpass.com/event/109573/">AI×IoT ハンズオン with IoTLT&amp;amp;ふくもく会 in 福井&lt;/a>向け資料です。記事を読んで試せる内容になっているので、終了後や参加されていない方もぜひ試してみてください！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>この記事はがじぇっとるねさすさんの「&lt;a href="http://gadget.renesas.com/ja/product/e-ai/mnist_tutorial.html">e-AIトランスレータ チュートリアル GRボードで実行してみよう！&lt;/a>」を参考に作成しています。&lt;/p>
&lt;h2 id="heading">今回やってみること&lt;/h2>
&lt;p>PythonとTensorflow、数字認識のデータライブラリMNISTを使い、数字認識する学習モデルを作成します。&lt;strong>Pythonなしでもコピペで試せる内容&lt;/strong>になっています。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/233/result.gif" alt="demo">&lt;/p>
&lt;h3 id="heading-1">用意するもの&lt;/h3>
&lt;h4 id="gr-lychee">■マイコンボード「GR-LYCHEE」&lt;/h4>
&lt;p>&lt;img src="https://i.gyazo.com/714caa81da618bf491f460087f27d3cb.jpg" alt="">&lt;/p>
&lt;p>がじぇっとるねさす（通称がじぇるね）が提供している高性能マイコンボードです。電子工作でよく使われるArduino UNOとピンが互換になっていて、Wi-Fi・BLE通信モジュール「ESP32」を搭載しています。&lt;/p>
&lt;p>わりと手軽にIoTプロトタイピングを試せる高性能マイコンボード、な立ち位置です。（ちゃんとく所感）&lt;/p>
&lt;ul>
&lt;li>購入: &lt;a href="http://akizukidenshi.com/catalog/g/gM-12850/">秋月電子&lt;/a>（¥10,580）&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="usbmicrob">■USBケーブル（microB）&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>PCとGR-LYCHEEの通信（プログラムの書き込み、カメラ映像の出力など）には、Android端末などに使われているmicroBタイプのUSBケーブルを使います。&lt;/p>
&lt;ul>
&lt;li>購入: &lt;a href="http://akizukidenshi.com/catalog/g/gC-09312/">秋月電子&lt;/a>（¥100）&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h2 id="heading-2">事前準備&lt;/h2>
&lt;h3 id="displayapp">「DisplayApp」をインストール&lt;/h3>
&lt;p>GR-LYCHEEのカメラで映している映像を確認するために利用します。&lt;/p>
&lt;p>&lt;a href="http://gadget.renesas.com/ja/product/lychee.html#displayapp">&lt;img src="https://i.gyazo.com/5cf7140ebfb5221592c1ca7f6aa7f839.png" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;p>がじぇるね公式ページの&lt;a href="http://gadget.renesas.com/ja/product/lychee.html#displayapp">こちら&lt;/a>からご自身のOSに合ったものをダウンロードし、ZIPファイルを展開します。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="macos">■MacOSの方&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>ZIPファイルを展開し、Macの方は「アプリケーション」に移動させます。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="windows">■Windowsの方&lt;/h4>
&lt;p>展開したファイル内の「〜.exe」をダブルクリックで実行します。インストーラが起動するので、手順通り進めます。&lt;/p>
&lt;h2 id="heading-3">はじめてのプログラムを書き込んでみる&lt;/h2>
&lt;p>最初のプログラムとして、Lチカをやってみます。LEDチカチカの略で、入門向けのプログラムとして汎用的に紹介されています。&lt;/p>
&lt;p>簡単なプログラムを書き込むことで、ボードが正常に動くか試す際に利用することも多いです。WebでいうHello, worldです。&lt;/p>
&lt;h3 id="web">Webコンパイラの準備&lt;/h3>
&lt;p>GRシリーズでは「Webコンパイラ」という、ブラウザ上で利用できるコンパイラが利用できます。面倒な環境構築が不要なので楽チンですね。&lt;/p>
&lt;p>&lt;a href="http://gadget.renesas.com/ja/">がじぇるねのページ&lt;/a>から、「ログイン」または「ゲストログイン」をクリックし移動します。
&lt;img src="https://i.gyazo.com/bcf47b506593c244633350381c30422f.png" alt="compiler">&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>プロジェクト作成画面になるので、「LYCHEE」でフィルターをかけてみます。
&lt;img src="https://i.gyazo.com/9fbdd84ff53037965a358bc646d3923c.png" alt="create project">
「GR-LYCHEE_mbed…」と「GR-LYCHEE_Sketch…」という2タイプあるので、&lt;strong>Sketchの方を選択&lt;/strong>します（mbed OSのプログラムを利用したいときは前者を選びましょう）。&lt;/p>
&lt;h3 id="heading-4">プログラム&lt;/h3>
&lt;p>メニュー左側の「〜.cpp」という拡張子のファイルがメインのプログラムファイルになります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「〜.cpp」をダブルクリックすると、中央に編集画面が表示されます。&lt;/p>
&lt;p>表示されたサンプルコードを&lt;strong>一旦全て消してから&lt;/strong>、下記のプログラムを貼り付けます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code> #define INTERVAL 50
void setup()
{
Serial.begin(9600);
pinMode(LED_RED, OUTPUT);
pinMode(LED_ORANGE, OUTPUT);
pinMode(LED_YELLOW, OUTPUT);
pinMode(LED_GREEN, OUTPUT);
pinMode(USER_BUTTON0, INPUT);
}
void loop()
{
while(digitalRead(USER_BUTTON0) == 0){
digitalWrite(LED_GREEN, 1);
delay(INTERVAL);
digitalWrite(LED_GREEN, 0);
delay(INTERVAL);
Serial.println(&amp;quot;I'm LYCHEE!&amp;quot;);
}
digitalWrite(LED_RED, 1);
delay(INTERVAL);
digitalWrite(LED_RED, 0);
digitalWrite(LED_ORANGE, 1);
delay(INTERVAL);
digitalWrite(LED_ORANGE, 0);
digitalWrite(LED_YELLOW, 1);
delay(INTERVAL);
digitalWrite(LED_YELLOW, 0);
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>貼り付けたら、右側の「ビルド実行」ボタンをクリックし、記述したプログラムをコンパイルします。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>コンパイルが完了すると、「コンパイルが完了しました」というメッセージと実行ログが表示されるので、「&lt;strong>閉じる&lt;/strong>」ボタンで完了します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「〜.bin」というファイルが作成されているので、右クリックしダウンロードします。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="pcgr-lychee">PCとGR-LYCHEEを接続&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>GR-LYCHEEとPCをUSBケーブルで接続しましょう。GR-LYCHEEのUSBソケットは&lt;strong>真ん中の方&lt;/strong>です。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>PCに「MBED」という名前で認識されます。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="windows-1">■デバイスが認識されない（Windows）&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;a href="https://os.mbed.com/docs/latest/tutorials/windows-serial-driver.html">こちら&lt;/a>のページから「Arm Mbed Windows serial port driver」をクリックし、インストールしてください。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-5">プログラムを書き込み&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>ダウンロードした「〜.bin」ファイルを「MBED」にドラッグ＆ドロップでコピーします。コピー後、ファイルはMBEDフォルダ内には表示されません。&lt;/p>
&lt;h3 id="heading-6">再起動して実行&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>リセットボタンを押し、GR-LYCHEEを再起動させます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/233/blink.gif" alt="blink">&lt;/p>
&lt;p>Lチカプログラムが実行されました！&lt;/p>
&lt;h2 id="gr-lycheedisplayapp">GR-LYCHEEカメラの映像をdisplayAppに表示&lt;/h2>
&lt;p>&lt;img src="https://dotstud.io/img/blog/233/display.gif" alt="display">&lt;/p>
&lt;p>GR-LYCHEEにカメラを取り付けて、PC上で映る映像を確認してみましょう。&lt;/p>
&lt;h3 id="heading-7">カメラの取り付け&lt;/h3>
&lt;h4 id="heading-8">■カメラ本体&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;ol>
&lt;li>カメラ本体のソケット部を持ち上げます&lt;/li>
&lt;li>フレキシブルケーブルの無地面を上に、ソケットに差し込みます&lt;/li>
&lt;li>ソケット部を元に戻します&lt;/li>
&lt;/ol>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="gr-lychee-1">■GR-LYCHEE&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;ol>
&lt;li>GR-LYCHEE背面のソケット部を上にずらします&lt;/li>
&lt;li>フレキシブルケーブルの文字面を上に、ソケットに差し込みます&lt;/li>
&lt;li>ソケット部を下に戻します&lt;/li>
&lt;/ol>
&lt;h3 id="heading-9">プログラム&lt;/h3>
&lt;p>Webコンパイラでプログラムを下記に置き換え、先ほど同様書き込みます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code> #include &amp;amp;lt;Arduino.h&amp;amp;gt;
#include &amp;amp;lt;Camera.h&amp;amp;gt;
#include &amp;quot;DisplayApp.h&amp;quot;
#define LOOP_WAITTIME 17 // 17ms for 60 fps of camera spec.
Camera camera(640, 480);
static DisplayApp display_app;
void setup() {
Serial.begin(9600);
Serial.println(&amp;quot;start&amp;quot;);
camera.begin();
}
void loop() {
static unsigned long last_time = millis();
while ((millis() - last_time) &amp;lt; LOOP_WAITTIME);
last_time = millis();
display_app.SendJpeg(camera.getJpegAdr(), (int)camera.createJpeg());
delay(1);
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;h3 id="usb">USBを付け替えて実行&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>書き込んだら、GR-LYCHEE側のUSBソケットを外側に付け替えます。（通信用）&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>DisplayAppでシリアルポートを選択します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/233/display.gif" alt="display">
カメラの画像がDisplayAppに表示されます。高画質！&lt;/p>
&lt;h2 id="heading-10">数字認識の学習モデルを作ろう&lt;/h2>
&lt;p>MNISTとTensorflowを使って学習モデルを作り、カメラに映った数字を判定するプログラムを作成してみます。&lt;/p>
&lt;p>&lt;strong>Python+Tensorflowをインストールせず試してみたい&lt;/strong>、という方は、「&lt;a href="#%E5%AE%8C%E6%88%90%E3%82%B3%E3%83%BC%E3%83%89">完成コード&lt;/a>」の章から進めてください。&lt;/p>
&lt;h3 id="heading-11">作業用ディレクトリを作成&lt;/h3>
&lt;p>今回のプログラムを試すディレクトリ（フォルダ）を作ります。&lt;/p>
&lt;p>プログラムを実行する上では&lt;strong>今どこで作業しているか&lt;/strong>というのが重要です。最初のうちはわかりづらいので、意識するようにしましょう。&lt;/p>
&lt;p>コマンドラインに不慣れである方は、下記記事を参照してみてください。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="windows-2">■Windowsの方&lt;/h4>
&lt;ol>
&lt;li>デスクトップで右クリックし、&lt;code>gr-tutorial&lt;/code>というファイルを作成&lt;/li>
&lt;li>Windowsメニューから「コマンドラインプロンプト」を検索し開く（「cmd」で候補にでてきます）&lt;/li>
&lt;li>下記コマンドを1行ずつ実行（&lt;code>$&lt;/code>は不要。コマンドラインであることを表しています）&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>$ cd Desktop
$ cd gr-tutorial
&lt;/code>&lt;/pre>&lt;p>&lt;code>cd&lt;/code>はディレクトリを移動するコマンドです。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="mac">■Macの方&lt;/h4>
&lt;ol>
&lt;li>「ターミナル」を起動（⌘+スペースで「ターミナル」を検索すると便利）&lt;/li>
&lt;li>下記コマンドを1行ずつ順に打ち込む（&lt;code>$&lt;/code>は不要。コマンドラインであることを表しています）&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>$ cd ~/Desktop
$ mkdir gr-tutorial
$ cd gr-tutorial
&lt;/code>&lt;/pre>&lt;p>デスクトップに「gr-tutorial」というフォルダができているかと思います（右クリックで作成してもOKです）。&lt;code>cd&lt;/code>コマンドは移動するコマンド、&lt;code>mkdir&lt;/code>コマンドはディレクトリを作成するコマンドです。&lt;/p>
&lt;h3 id="pythontensorflow">Python＆Tensorflow環境構築&lt;/h3>
&lt;p>今回はご自身の環境に、以下の内容を用意し進めます。&lt;/p>
&lt;ul>
&lt;li>Python実行環境&lt;/li>
&lt;li>Tensorflow&lt;/li>
&lt;/ul>
&lt;p>環境構築はおそらく&lt;strong>このハンズオンで1番大変なところ&lt;/strong>です。乗り越えたらサクッと試せるようになるので頑張りましょう！&lt;/p>
&lt;p>PCの状態に合わせて場合分けしましたので、ご自身に合う部分を読んでください。&lt;/p>
&lt;h3 id="heading-12">まずは現在の環境を確認する&lt;/h3>
&lt;p>下記コマンドを試して、PythonとTensorFlowがインストールされているか確認しましょう。コマンドは&lt;code>$&lt;/code>マークの後ろの部分です。（↓の場合は&lt;code>python -V&lt;/code>と打ち込む）&lt;/p>
&lt;pre>&lt;code>$ python -V
Python X.X.X
&lt;/code>&lt;/pre>&lt;p>Pythonのバージョンが表示されればOKです。「command not found」や「実行する〜〜が見つかりません」などと表示された方は、インストールされていない（または正しくインストールできていない）のでPythonの環境構築手順を進めます。&lt;/p>
&lt;p>インストールされていなかった方は、「&lt;a href="#Python%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">Pythonをインストール&lt;/a>」へ進んでください。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>続いて、Tensorflowモジュールがインストールされているかの確認です。&lt;code>pip list&lt;/code>と打ち込んでみましょう。（表示されるものは一例）&lt;/p>
&lt;pre>&lt;code>$ pip list
Package Version
---------------------- ---------
absl-py 0.6.1
bleach 1.5.0
html5lib 0.9999999
Markdown 3.0.1
nose 1.3.7
numpy 1.15.3
pip 18.1
protobuf 3.6.1
setuptools 39.0.1
six 1.11.0
tensorflow 1.5.0
…
&lt;/code>&lt;/pre>&lt;p>一覧に&lt;code>tensorflow&lt;/code>とあればOKです。バージョンが古い場合は、下記コマンドで更新をしておきましょう（最新は1.5系です）。&lt;/p>
&lt;ul>
&lt;li>Python2系の場合&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>$ pip install --upgrade tensorflow
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Python3系の場合&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>$ pip3 install --upgrade tensorflow
&lt;/code>&lt;/pre>&lt;p>PythonがインストールされているがTensorflowはインストールされていない場合は、「&lt;a href="#tensorflow%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">Tensorflowをインストール&lt;/a>」へ進んでください。&lt;/p>
&lt;p>どちらもインストールされていた場合は、「&lt;a href="#MNIST%E3%81%A7%E5%AD%A6%E7%BF%92%E3%83%A2%E3%83%87%E3%83%AB%E3%82%92%E4%BD%9C%E6%88%90">MNISTで学習モデルを作成&lt;/a>」へ進みます。&lt;/p>
&lt;h3 id="python">Pythonをインストール&lt;/h3>
&lt;h4 id="windows-3">■Windowsの方&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;a href="https://www.python.org/downloads/windows/">Pythonの公式ページ&lt;/a>へ移動し、インストールしたいPythonのバージョンをクリックします。（Tensorflowがうまく動かないので&lt;strong>Python3.7系は避けてください&lt;/strong>。3.6.xがオススメです。）&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>移動先のページ下部のリストから、「Windows x86-64 web-based installer」をダウンロードします。32bit版の場合は「Windows x86 web-based installer」を選択してください。&lt;/p>
&lt;p>ダウンロードされたパッケージを実行し、「&lt;strong>Add Python xxx to PATH&lt;/strong>」をチェックしてインストールを実行します。&lt;/p>
&lt;p>完了したら、コマンドプロンプトで&lt;code>python -V&lt;/code>を打ち、任意のバージョンが表示されるか確認します。&lt;/p>
&lt;pre>&lt;code>$ python -V
Python X.X.X
&lt;/code>&lt;/pre>&lt;p>表示されない方はコマンドプロンプトを再起動して試してみてください。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="mac-1">■Macの方&lt;/h4>
&lt;p>デフォルトでPython2系がインストールされているはずですが、何かのタイミングで消してしまった可能性があります。&lt;/p>
&lt;p>ターミナルで下記コマンドを実行し、Homebrewがインストールされているか確認します。&lt;/p>
&lt;pre>&lt;code>$ brew -v
Homebrew x.x.x
&lt;/code>&lt;/pre>&lt;p>インストールされていない場合は下記コマンドを実行します。&lt;/p>
&lt;pre>&lt;code>$ /usr/bin/ruby -e &amp;quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code>&lt;/pre>&lt;p>続いてHomebrewでpyenvをインストールします。pyenvはPythonのバージョン管理を行うツールです。&lt;/p>
&lt;pre>&lt;code>$ brew install pyenv
&lt;/code>&lt;/pre>&lt;p>インストールされたら下記コマンドで確認します。&lt;/p>
&lt;pre>&lt;code>$ pyenv -v
pyenv x.x.x
&lt;/code>&lt;/pre>&lt;p>pyenvでPythonをインストールします。バージョンは任意のものでよいですが、Tensorflowがうまく動かないので&lt;strong>3.7系は避けてください&lt;/strong>。&lt;/p>
&lt;pre>&lt;code>$ pyenv install 3.6.7
&lt;/code>&lt;/pre>&lt;p>完了したら、選択したバージョンを設定します。&lt;/p>
&lt;pre>&lt;code>$ pyenv global 3.6.7
&lt;/code>&lt;/pre>&lt;p>ターミナルで下記コマンドを実行し、バージョンが表示されるか確認してみてください。&lt;/p>
&lt;pre>&lt;code>$ python -V
Python 3.6.7
&lt;/code>&lt;/pre>&lt;h3 id="tensorflow">TensorFlowをインストール&lt;/h3>
&lt;p>コマンドラインで下記コマンドを実行します。&lt;/p>
&lt;pre>&lt;code>$ pip install tensorflow
&lt;/code>&lt;/pre>&lt;p>だらだらと実行文が表示され、最後の行に &lt;code>Successfully installed tensorflow-X.X.X&lt;/code>などと表示されればOKです。&lt;/p>
&lt;p>&lt;code>pip list&lt;/code>というコマンドを打って、インストールされたか確認してみます。（表示されるものは一例）&lt;/p>
&lt;pre>&lt;code>$ pip list
Package Version
---------------------- ---------
absl-py 0.6.1
bleach 1.5.0
html5lib 0.9999999
Markdown 3.0.1
nose 1.3.7
numpy 1.15.3
pip 18.1
protobuf 3.6.1
setuptools 39.0.1
six 1.11.0
tensorflow 1.5.0
…
&lt;/code>&lt;/pre>&lt;p>一覧に、&lt;code>tensorflow&lt;/code>とあればOKです。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-13">■実行したらエラーが出た&lt;/h4>
&lt;p>長い実行文が表示されたあと、最後の一行が下記のようなエラー文になることがあります。&lt;/p>
&lt;pre>&lt;code>Could not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/tensorflow-1.11.0.dist-info' Consider using the --user option or check the permissions.
&lt;/code>&lt;/pre>&lt;p>下記コマンドを再度実行します。&lt;/p>
&lt;pre>&lt;code>$ sudo pip install tensorflow
&lt;/code>&lt;/pre>&lt;p>パスワードを求められるので、PCのユーザのパスワードを入力します。（入力したパスワードは表示されません）&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-14">■エラーが出てインストールが実行されない①&lt;/h4>
&lt;p>&lt;code>pip install tensorflow&lt;/code>を実行すると、&lt;code>command not found&lt;/code>といったエラーが出る場合があります。以下のコマンドを実行し、pipをインストールします。&lt;/p>
&lt;pre>&lt;code>$ python -m ensurepip
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-15">■エラーが出てインストールが実行されない②&lt;/h4>
&lt;p>&lt;code>pip install tensorflow&lt;/code>を実行すると、下記のようなエラーが出る場合があります。&lt;/p>
&lt;pre>&lt;code>Could not find a version that satisfies the requirement tensorflow (from versions: )
No matching distribution found for tensorflow
&lt;/code>&lt;/pre>&lt;p>以下のコマンドを再度実行しましょう。&lt;/p>
&lt;ul>
&lt;li>Python2系&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>$ pip install --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.11.0-py2-none-any.wh
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Python3系&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>$ python3 -m pip install --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.5.0-py3-none-any.whl
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="list">■インストールしたのにlistに表示されない&lt;/h4>
&lt;p>主にMacで、Python環境がPC上に複数あり、意図する場所にインストールできていない可能性があります。&lt;/p>
&lt;p>主に下記の記事を参考にしてみてください。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="https://qiita.com/ta_ta_ta_miya/items/e24394c6b0022405a126">pyenvでPythonがSystemバージョンから切り替わらない時の対処&lt;/a>&lt;/li>
&lt;li>参考: &lt;a href="https://qiita.com/mckyhrs/items/94a2db3506287df0420e">pythonのバージョンが切り替わらない&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="mnist">MNISTで学習モデルを作成&lt;/h3>
&lt;p>画像認識向けに、大量の画像を自分で収集し学習用に加工するのはとても大変です。&lt;/p>
&lt;p>MNIST（Mixed National Institute of Standards and Technology database）は、手書き数字画像60,000枚とテスト画像10,000枚を集めたデータセットです。&lt;/p>
&lt;p>手軽に入手でき簡単に扱えるので、AI入門のサンプルデータとしてオススメです。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="mnistpython">■MNIST用Pythonコードを作成&lt;/h4>
&lt;p>作成した作業用ディレクトリに、コマンドか右クリックなどで&lt;code>mnist_softmax_for_e-ai.py&lt;/code>というファイルを作成します。&lt;/p>
&lt;p>プログラム向けのエディタでファイルを開き、下記のプログラムを貼り付けます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code> &amp;quot;&amp;quot;&amp;quot;A very simple MNIST classifier.
See extensive documentation at
https://www.tensorflow.org/get_started/mnist/beginners
&amp;quot;&amp;quot;&amp;quot;
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import argparse
import sys
from tensorflow.examples.tutorials.mnist import input_data
import tensorflow as tf
FLAGS = None
def main(_):
# Import data
mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot=True)
# Create the model
x = tf.placeholder(tf.float32, [None, 784])
#Add Renesas 2 --------- ----------
# change
# x_ = tf.placeholder(tf.float32, [None, 784])
# x = tf.reshape(x_, [-1])
# --------- ----------
W = tf.Variable(tf.zeros([784, 10]))
b = tf.Variable(tf.zeros([10]))
y = tf.matmul(x, W) + b
# Define loss and optimizer
y_ = tf.placeholder(tf.float32, [None, 10])
# The raw formulation of cross-entropy,
#
# tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(tf.nn.softmax(y)),
# reduction_indices=[1]))
#
# can be numerically unstable.
#
# So here we use tf.nn.softmax_cross_entropy_with_logits on the raw
# outputs of 'y', and then average across the batch.
cross_entropy = tf.reduce_mean(
tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y))
train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)
sess = tf.InteractiveSession()
tf.global_variables_initializer().run()
# Train
for _ in range(1000):
batch_xs, batch_ys = mnist.train.next_batch(100)
sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})
# Test trained model
correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
print(sess.run(accuracy, feed_dict={x: mnist.test.images,
y_: mnist.test.labels}))
#Add Renesas 1 --------- ----------
import os
#Save Learned AI
out_dir = &amp;quot;./tf_LearnedModel&amp;quot;
if os.path.isdir(out_dir) is False:
os.makedirs(out_dir)
saver = tf.train.Saver()
saver.save(sess, out_dir+&amp;quot;/tf_LearnedModel&amp;quot;)
# --------- ----------
if __name__ == '__main__':
parser = argparse.ArgumentParser()
parser.add_argument('--data_dir', type=str, default='/tmp/tensorflow/mnist/input_data',
help='Directory for storing input data')
FLAGS, unparsed = parser.parse_known_args()
tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)
&amp;lt;/code&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>今回はがじぇるねさんの&lt;a href="http://gadget.renesas.com/ja/product/e-ai/mnist_tutorial.html#%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92%E3%81%AE%E5%AE%9F%E8%A1%8C">チュートリアルのサンプルコード&lt;/a>をお借りしました！&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="tensorflow-1">■Tensorflowで実行&lt;/h4>
&lt;p>下記コマンドで学習モデルを作成します。&lt;/p>
&lt;pre>&lt;code>$ python mnist_softmax_for_e-ai.py
&lt;/code>&lt;/pre>&lt;p>pythonコマンドはPythonで書かれたプログラムを実行するコマンドです。ファイルの中のプログラムが実行され、学習モデルが作成されます。&lt;/p>
&lt;p>Windowsの方は&lt;code>dir&lt;/code>、Macの方は&lt;code>ls&lt;/code>というコマンドを実行し、「tf_LearnedModel」というフォルダが作成されたことを確認してください。&lt;/p>
&lt;pre>&lt;code>$ ls
mnist_softmax_for_e-ai.py
tf_LearnedModel/
&lt;/code>&lt;/pre>&lt;p>Windowsは&lt;code>dir tf_LearnedModel&lt;/code>、Macは&lt;code>ls tf_LearnedModel&lt;/code>のコマンドを実行すると、4つのファイルが入っていることがわかります。&lt;/p>
&lt;pre>&lt;code>$ ls tf_LearnedModel
checkpoint
tf_LearnedModel.data-00000-of-00001
tf_LearnedModel.index
tf_LearnedModel.meta
&lt;/code>&lt;/pre>&lt;h3 id="gr">学習モデルをGRボードで扱う&lt;/h3>
&lt;p>&lt;img src="https://i.gyazo.com/045295f6fe6ebda3cbed3d0150650c27.png" alt="Image from Gyazo">
Webコンパイラを開き、右側のリストから「e-AI Translator」をクリックします。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/1ae615bd6f71338dab09647185d3bcb5.png" alt="Image from Gyazo">
アップロードボタンを押し、先ほど作成された「tf_LearnedModel」を選択します。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/2d54b87b9a6c9852f31c1afb14132614.png" alt="Image from Gyazo">
その他はデフォルト選択のまま、「トランスレート」をクリックします。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/27fe23312950242e2eee4ff2e6e7ee79.png" alt="Image from Gyazo">
表示されたプログラムを全て選択してコピーします。&lt;/p>
&lt;h2 id="heading-16">完成コード&lt;/h2>
&lt;p>上記で生成されたプログラムに、displayAppに表示させるためのコードを加えたプログラムです。USBケーブルは真ん中に接続し、GR-LYCHEEに書き込みましょう。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code> #ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
#include &amp;quot;eAI_translated/Typedef.h&amp;quot;
#include &amp;quot;eAI_translated/input_image_0.h&amp;quot;
#include &amp;quot;eAI_translated/layer_graph.h&amp;quot;
TPrecision* dnn_compute(TPrecision* input_img);
#ifdef __cplusplus
}
#endif
// To monitor realtime on PC, you need DisplayApp on following site.
// Connect USB0(not for mbed interface) to your PC
// os.mbed.com/.../
using namespace cv;
#define IMAGE_HW 320
#define IMAGE_VW 240
#define INPUT_HEIGHT 28
#define INPUT_WIDTH 28
Camera camera(IMAGE_HW, IMAGE_VW);
DisplayApp display_app;
void paste(cv::Mat dst, cv::Mat src, int x, int y, int width, int height) {
cv::Mat resized_img;
cv::resize(src, resized_img, cv::Size(width, height));
if (x &amp;gt;= dst.cols || y &amp;gt;= dst.rows) return;
int w = (x &amp;gt;= 0) ? std::min(dst.cols - x, resized_img.cols) : std::min(std::max(resized_img.cols + x, 0), dst.cols);
int h = (y &amp;gt;= 0) ? std::min(dst.rows - y, resized_img.rows) : std::min(std::max(resized_img.rows + y, 0), dst.rows);
int u = (x &amp;gt;= 0) ? 0 : std::min(-x, resized_img.cols - 1);
int v = (y &amp;gt;= 0) ? 0 : std::min(-y, resized_img.rows - 1);
int px = std::max(x, 0);
int py = std::max(y, 0);
cv::Mat roi_dst = dst(cv::Rect(px, py, w, h));
cv::Mat roi_resized = resized_img(cv::Rect(u, v, w, h));
roi_resized.copyTo(roi_dst);
}
int max_array(TPrecision* array, int length){
int i;
float max = array[0];
int index = 0;
for(i = 0; i &amp;lt; length; i++){
if(array[i] &amp;gt; max){
max = array[i];
index = i;
}
}
return index;
}
void setup() {
Serial.begin(9600);
camera.begin();
}
void loop() {
Scalar red(0, 0, 255), green(0, 255, 0), blue(255, 0, 0);
Scalar yellow = red + green;
Scalar white = Scalar::all(255);
Scalar black = Scalar::all(0);
Scalar pink = Scalar(154, 51, 255);
Mat img_raw(IMAGE_VW, IMAGE_HW, CV_8UC2, camera.getImageAdr());
Mat pic, gray;
cvtColor(img_raw, pic, COLOR_YUV2BGR_YUYV); //covert YUV to RGB
cvtColor(img_raw, gray, COLOR_YUV2GRAY_YUYV); //covert from YUV to GRAY
Mat roi(gray, Rect(80, 0, 240, 240));
threshold(roi, roi, 90, 255, THRESH_BINARY);
resize(roi, roi, Size(INPUT_WIDTH, INPUT_HEIGHT));
for(int i = 0; i &amp;lt; 784; i++){
data_in[i] = 1 - (float)roi.data[i] / 255;
}
TPrecision *prediction;
TPrecision *input_img;
TsInt i;
input_img = data_in;
prediction = (TPrecision*) (intptr_t) dnn_compute( input_img);
// Drawing
rectangle(pic, Rect(0, 0, 80, 240), white, FILLED);
rectangle(pic, Rect(80, 0, 240, 240), red, 2);
Mat roi2;
cvtColor(roi, roi2, COLOR_GRAY2BGR);
paste(pic, roi2, 5, 5, roi2.rows, roi2.cols);
rectangle(pic, Rect(4, 4, 30, 30), red, 1);
int max_index = max_array(prediction, 10);
for(i = 0;i &amp;lt; 10;i++){
Serial.print(i); Serial.print(&amp;quot;:&amp;quot;);
Serial.println(prediction[i]);
stringstream ss;
ss &amp;lt;&amp;lt; i;
if(max_index == i){
putText(pic, ss.str(), Point(0, 20 * i + 50), FONT_HERSHEY_SCRIPT_SIMPLEX, 0.5, pink, 1);
rectangle(pic, Rect(20, 20 * i + 40, prediction[i] * 80, 10), pink, FILLED);
} else {
putText(pic, ss.str(), Point(0, 20 * i + 50), FONT_HERSHEY_SCRIPT_SIMPLEX, 0.5, black, 1);
rectangle(pic, Rect(20, 20 * i + 40, prediction[i] * 80, 10), blue, FILLED);
}
}
size_t jpegSize = camera.createJpeg(320, 240, pic.data,
Camera::FORMAT_RGB888);
display_app.SendJpeg(camera.getJpegAdr(), jpegSize);
delay(10);
}
&amp;lt;/code&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>これまでの手順と同様、書き込んでみましょう。&lt;/p>
&lt;h2 id="heading-17">手書き数字の認識を試してみる&lt;/h2>
&lt;p>USBケーブルを外側につけかえ、試してみます。&lt;/p>
&lt;h3 id="displayapp-1">displayAppで表示&lt;/h3>
&lt;p>紙に書く文字は、マッキーペンなどで太くハッキリと書いてみてください。&lt;/p>
&lt;p>カメラに数字を映すと……&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/233/result.gif" alt="demo">&lt;/p>
&lt;p>数字を推論してくれます。お疲れ様でした！&lt;/p>
&lt;h3 id="heading-18">シリアルモニタで表示&lt;/h3>
&lt;p>GR-LYCHEEで実行されている内容を、シリアル通信を介してPCで確認してみます。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="mac-2">■Macの方&lt;/h4>
&lt;p>下記コマンドを実行し、USB接続されている場所を調べます。&lt;/p>
&lt;pre>&lt;code>$ ls /dev/tty.usb*
/dev/tty.usbmodem~~~
&lt;/code>&lt;/pre>&lt;p>接続されている場所をコピーし、下記コマンドで接続します。&lt;/p>
&lt;pre>&lt;code>$ screen /dev/tty.usbmodem~~~~ 9600
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="windows-4">■Windowsの方&lt;/h4>
&lt;p>「TeraTerm」というシリアル通信対応のソフトをダウンロード＆インストールします。「Arduino IDE」がインストールされている方は、そちらでも確認できます。&lt;/p>
&lt;p>下記リンクを参考に、TeraTermを起動しシリアル接続します。&lt;/p>
&lt;p>参考: &lt;a href="https://www.j-oosk.com/teraterm/serial/346/">Tera Termでシリアル接続を行う手順&lt;/a>&lt;/p>
&lt;h2 id="heading-19">参考情報&lt;/h2>
&lt;p>がじぇるねさんのページでは、その他のGR-LYCHEEチュートリアルも紹介されています。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://gadget.renesas.com/ja/product/lychee_sp/4.html">Webカメラにしてみよう!&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://gadget.renesas.com/ja/product/lychee_sp/5.html">Bluetoothでスマホとつなげよう!&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://gadget.renesas.com/ja/product/lychee_sp/8.html">OpenCTの応用 輪郭検出、HSV色空間&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ぜひ試してみてください！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>加速度センサとマイコン内蔵LEDで魔法の杖を作ってみた！</title><link>https://dotstud.io/blog/halloween-gadget-witch-stick/</link><pubDate>Wed, 31 Oct 2018 10:07:13 +0900</pubDate><guid>https://dotstud.io/blog/halloween-gadget-witch-stick/</guid><description>&lt;p>みなさんこんにちは。トボリです。&lt;/p>
&lt;p>私は電子工作が大好きで、いろいろいじったり、&lt;a href="http://toboli.hatenablog.com/">ブログ&lt;/a>を書いたりして暮らしています。&lt;/p>
&lt;p>&lt;strong>ところで、みなさん魔法は好きですか？&lt;/strong>&lt;/p>
&lt;p>電子工作と魔法ってかなり相性いいと思うんですよ。勝手に光る、勝手に動く、勝手にしゃべる……とか！&lt;/p>
&lt;p>気づけばもう10月31日。そう、本日はハロウィンです！電子工作を愛し、電子工作に愛された者として、このイベントで魔法っぽいものを作りたい！！&lt;/p>
&lt;p>魔法といえば、そう、杖ですよね！！&lt;/p>
&lt;p>ということで、今回はみんなが一度は憧れたであろう、&lt;strong>『魔法の杖』&lt;/strong> を作ってみました！&lt;/p>
&lt;h2 id="heading">「振ると光る杖」を作ることにした&lt;/h2>
&lt;p>『魔法の杖』っていうからには、できるだけかっこいいことがしたい！
トボリも想像力だけは無駄に豊かなので、うきうきいろんな機能をイメージしました。&lt;/p>
&lt;p>家電を操作したり、一振りでカーテン開けられたりできたらいいなあ～！何か浮かせられたらもっとおもしろいかも……。&lt;/p>
&lt;p>しかし。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->時間と技術力は限られている！！&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>今のトボリの技術力でハロウィンまでに作れそうなものといえば、「振ると光る」杖です。&lt;/p>
&lt;p>想像よりだいぶスケールが小さくなりましたが、どんなにささやかな物でもまずは作ることが大事！
と自分に言い聞かせ、とにかく作ってみることにしました！&lt;/p>
&lt;h2 id="heading-1">用意するもの&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>電子工作初心者の味方、Arduinoを使って作ろうと思います！&lt;/p>
&lt;p>また、なぜミニブレッドボードを使用するかというと……これを見てください！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>たまたま買った電池ボックスとミニブレッドボードのサイズがほぼ同じ！&lt;/p>
&lt;p>これを見た瞬間、絶対に使おう！と固く決意したのです。
（本当はユニバーサル基板に半田付けしてたんですが、完成間近にピンヘッダの取り付けミスが発覚し、安心安全のブレッドボードでやり直したという経緯があります。つらい。）&lt;/p>
&lt;h2 id="heading-2">魔法の杖を作る&lt;/h2>
&lt;p>魔法の杖は、下記の3ステップで作って行きます！&lt;/p>
&lt;ol>
&lt;li>プログラムを書く&lt;/li>
&lt;li>ブレッドボードに回路を作る&lt;/li>
&lt;li>見た目をそれっぽく造形する&lt;/li>
&lt;/ol>
&lt;h3 id="heading-3">プログラムを書く&lt;/h3>
&lt;p>&lt;a href="https://dotstud.io/docs/arduinoide-setup/">Arduino IDE&lt;/a>を使ってプログラムを書いていきます。&lt;/p>
&lt;p>加速度センサのサンプルプログラムと、フルカラーLEDのサンプルプログラムをただ合体しただけのお手軽コードです！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;pre>&lt;code> Adafruit_NeoPixel pixels = Adafruit_NeoPixel(1, PIN, NEO_GRB + NEO_KHZ800);
MMA8452Q accel;
void setup() {
Serial.begin(9600);
Serial.println(&amp;quot;MMA8452Q Test Code!&amp;quot;);
pixels.begin();
pixels.show();
accel.init();
}
void loop() {
if(accel.available()) {
accel.read();
printCalculatedAccels();
printOrientation();
Serial.println();
}
}
void printOrientation() {
byte pl = accel.readPL();
switch (pl) {
case PORTRAIT_U:
Serial.print(&amp;quot;Portrait Up&amp;quot;);
break;
case PORTRAIT_D:
Serial.print(&amp;quot;Portrait Down&amp;quot;);
break;
case LANDSCAPE_R:
Serial.print(&amp;quot;Landscape Right&amp;quot;);
rainbow(20);
break;
case LANDSCAPE_L:
Serial.print(&amp;quot;Landscape Left&amp;quot;);
rainbow(20);
break;
case LOCKOUT:
Serial.print(&amp;quot;Flat&amp;quot;);
pixels.show();
break;
}
}
void rainbow(uint8_t wait) {
uint16_t i, j;
for(j=0; j&amp;amp;lt;256; j++) {
for(i=0; i&amp;amp;lt;pixels.numPixels(); i++) {
pixels.setPixelColor(i, Wheel((i+j) &amp;amp; 255));
}
pixels.show();
delay(wait);
}
}
uint32_t Wheel(byte WheelPos) {
WheelPos = 255 - WheelPos;
if(WheelPos &amp;amp;lt; 85) {
return pixels.Color(255 - WheelPos * 3, 0, WheelPos * 3);
}
if(WheelPos &amp;amp;lt; 170) {
WheelPos -= 85;
return pixels.Color(0, WheelPos * 3, 255 - WheelPos * 3);
}
WheelPos -= 170;
return pixels.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}
&amp;lt;/code&amp;gt;
&amp;lt;/pre&amp;gt;
&lt;/code>&lt;/pre>
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-4">ブレッドボードに回路を作る&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>まずはブレッドボードに配線していきます！配線図はこんな感じ。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>実際に配線したものがこちらです！
LEDの部分だけ基板から離れてしまうので、後で半田付けをします。&lt;/p>
&lt;p>みなさん半田付けって好きですか？トボリは電子工作作業の中で半田付けが一番好きです！
半田の香りは下手なアロマより癒される気がします。&lt;/p>
&lt;h3 id="heading-5">見た目をそれっぽく造形する&lt;/h3>
&lt;p>杖はそれっぽい形になればなんでもいいので、3Dプリンタを使える方は使ってもいいし、お好きなやり方で大丈夫です！今回は、粘土をこねて作ってみたので、参考までに材料と作り方も載せておきます！&lt;/p>
&lt;h4 id="-">■ 用意するもの&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>石粉粘土・トイレットペーパーの芯・市販のスティックを用意します。これらは全て百均で買うことができました！いい時代ですね！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>この市販のスティックを分解し、筒状の棒だけ取り出します。&lt;/p>
&lt;h4 id="--1">■ 杖の形に造形する&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>市販の棒とトイレットペーパーの芯をくっつけます。トイレットペーパーの芯の先に切れ込みを入れて、画像のように内側に折り込みます。トイレットペーパーの芯に棒を差し込んで、テープで固定します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>中に基板を入れ、筒の中にLEDのワイヤーを通してから、LEDを半田付けします。&lt;/p>
&lt;p>動作チェックをして問題なさそうだったら、どんどん土台に石粉粘土を貼り付けていきます！少しずつ貼り付けて、時々手でなでて滑らかにしていきます。&lt;/p>
&lt;p>乾いたら、カッターで傷をつけ、茶色と黒のアクリル絵の具をインスピレーションに従っていい感じに塗ります。&lt;/p>
&lt;h4 id="--2">■ 完成！&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>できた～～～！！！
どう見ても、魔法の杖！！少なくとも自分にとっては手塩にかけた最愛の杖！！&lt;/p>
&lt;h2 id="heading-6">魔法を発動する&lt;/h2>
&lt;p>さっそく魔法を発動していきましょう！
左右に杖を振ると……虹色の光が出ます！やった～～！魔法っぽい！
&lt;img src="https://dotstud.io/img/blog/228/demo.gif" alt="">&lt;/p>
&lt;h2 id="heading-7">次こそはもっとうまく作りたい……それが電子工作沼&lt;/h2>
&lt;p>LEDとセンサーひとつですが、結構楽しいものができました！&lt;/p>
&lt;p>でも、やっぱり本当はこうしたい……もっとかっこいい機能搭載したい……という欲望はとめどなく溢れ、「次こそもっといいものを！」という気持ちになります。&lt;/p>
&lt;p>もうこうなったらズブズブですよね。&lt;!-- raw HTML omitted -->電子工作沼&lt;!-- raw HTML omitted -->に。このハロウィンは今自分が作れる楽しいものを作りまくって、一緒に電子工作沼で溺れましょう！&lt;/p>
&lt;p>ではでは、トボリでした！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>【あのバズマイコンを最速？レポート】極小マイコンのトリリオンノード・エンジンを使ってみた！</title><link>https://dotstud.io/blog/trillion-node-engine-sugoi/</link><pubDate>Fri, 05 Oct 2018 02:39:17 +0900</pubDate><guid>https://dotstud.io/blog/trillion-node-engine-sugoi/</guid><description>&lt;p>こんにちは、宇宙エンジニアのたくろーどんです。&lt;/p>
&lt;p>夏休みなので「何かハッカソンに出てみたい！モノづくりしたい！」と思いつつ、&lt;a href="http://www.mcpc-jp.org/">MCPC（モバイルコンピューティング推進コンソーシアム）&lt;/a>が主催する&lt;strong>第1回ナノコン応用ハッカソン&lt;/strong>に参加しました。&lt;/p>
&lt;p>なんとこのハッカソンで&lt;strong>これから流行りそうな凄い開発ボード&lt;/strong>に出会ったので、紹介します。その名も&lt;!-- raw HTML omitted -->&lt;strong>トリリオンノード・エンジン&lt;/strong>&lt;!-- raw HTML omitted -->です。&lt;/p>
&lt;h2 id="heading">「トリリオンノード・エンジン」のここが凄い！&lt;/h2>
&lt;h3 id="heading-1">小さい！&lt;/h3>
&lt;p>特筆すべきポイントは、&lt;strong>トリリオンノード・エンジンの小ささ&lt;/strong>でしょう。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/d8655c77-c996-4684-adb8-61f8799cbce4.jpeg" alt="P_20180831_162041_vHDR_On.jpg">&lt;/p>
&lt;p>そうです、写真でわかるように&lt;strong>本当に小さい&lt;/strong>です。
決して、手が大きいわけではありません。&lt;/p>
&lt;h3 id="heading-2">拡張性が高い！&lt;/h3>
&lt;p>ハッカソンの際は、写真のようにキットが渡されました。
&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/ab86e180-f0c0-afdd-c320-baa25fa92140.jpeg" alt="P_20180831_100142_vHDR_On.jpg">
トリリオンノード・エンジンは、&lt;strong>リーフ&lt;/strong>というパーツで構成され、そのリーフの1つ1つに&lt;strong>センサモジュールやBLE（Bluetooth）、Wi-Fi&lt;/strong>といった機能を持っています。それを&lt;!-- raw HTML omitted -->&lt;strong>重ねていくことで簡単に機能を拡張することができる&lt;/strong>&lt;!-- raw HTML omitted -->仕組みです。&lt;/p>
&lt;p>プログラムは&lt;strong>Arduino IDE&lt;/strong>で書きます。これは、Arduinoを触ったことがある人にやさしいですね。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/0c71d1f5-486a-a6c7-d408-1aafa14afcdf.jpeg" alt="P_20180831_100406_vHDR_On.jpg">
評価用キットなので、すべてのリーフが入っているわけではありません。今後は、もっとリーフが増えるようです。例えば、&lt;strong>Groveセンサ用のリーフ&lt;/strong>も予定されているそうです。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/725d14ea-0149-83c4-87bd-cdade631bf64.jpeg" alt="P_20181001_002408_vHDR_On.jpg">
Arduinoシールドのリーフもあります。プロトタイプをつくる際に役立ちますね。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/6bd3b78b-ca6c-7bce-83bd-cb8a76319c44.jpeg" alt="P_20181001_002538_vHDR_On.jpg">
「29TH Leaf」というリーフを使えば基板に直接実装できます。これもArduino互換リーフの一つです。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/371ec114-1346-7596-1d0e-f2c12fa5d0e1.jpeg" alt="P_20181001_002505_vHDR_On.jpg">
電源はUSB給電だけなく、&lt;strong>専用のリーフで単3電池やボタン電池駆動&lt;/strong>させることができます。実装には一手間かかるので、専用のリーフがあるのはとてもありがたいですね。&lt;/p>
&lt;p>例えば&lt;strong>ウェアラブルなものをつくりたい&lt;/strong>と思ったときに、必要な電圧にもよりますが電源回路を実装する必要がなくなります。&lt;/p>
&lt;p>重ねるだけでなく、横方向につなげるリーフもあります。発想の幅が広がりますね。&lt;/p>
&lt;h2 id="heading-3">試してみた&lt;/h2>
&lt;p>加速度センサとLEDテープを組み合わせてLチカさせてみました。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/44f0d940-e547-66b5-bc20-020f64550d0d.gif" alt="84472b66eb294f495cb1060bfda8c512.gif">&lt;/p>
&lt;p>ハッカソンでは、犬につけてコミュニケーションを加速させることを目的としたウェアラブルデバイスを考えました（完成には程遠かったですが……）。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/973f6f0e-7487-ba0d-2aef-e2f245826ef9.jpeg" alt="42142867_568541853564424_1201723650328231936_n.jpg">&lt;/p>
&lt;p>&lt;strong>このサイズだから出来ることを考えてみると、様々なところに応用できそう&lt;/strong>ですね。&lt;/p>
&lt;h2 id="twitter">そして平成最後の夏、Twitterでバズった&lt;/h2>
&lt;p>&lt;strong>「トリリオンノード・エンジンが凄い！」といったことをつぶやいてみたら、バズりました&lt;/strong>。
小型で使いやすそうなマイコンに対する関心の高さがうかがえます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>そしてバズったら**「トリリオンノード・エンジンの普及に貢献した」としてハッカソンで特別賞を貰いました**。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/212276/aa12c34d-e3f2-a9df-92b8-f4eccb6befb9.jpeg" alt="IMG_20181001_011537_066.jpg">&lt;/p>
&lt;p>人生、何が起こるかわからないですね。&lt;/p>
&lt;h2 id="heading-4">まとめ&lt;/h2>
&lt;p>まだまだドキュメントの整備や使用例はこれからのようです。
来年から販売予定だそうなので、目が離せませんね！&lt;/p></description></item><item><title>気分はセレブ！手を叩くとディナーを出してくれるデバイスを作ろう</title><link>https://dotstud.io/blog/device-of-celebrity-dinner/</link><pubDate>Thu, 27 Sep 2018 12:34:10 +0900</pubDate><guid>https://dotstud.io/blog/device-of-celebrity-dinner/</guid><description>&lt;p>こんにちは、たいしょーです。&lt;/p>
&lt;p>いきなりですが、&lt;!-- raw HTML omitted -->高級なレストランで指パッチンや手を叩いて合図するとウェイターがディナーを出してくれるシーン&lt;!-- raw HTML omitted -->を見たことありませんか？&lt;/p>
&lt;h2 id="heading">憧れのシーンを実現したい&lt;/h2>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/a7be6476-4059-9a5e-b3d6-9aeaff37db85.png" alt="image">&lt;/p>
&lt;p>どこで見たかわからないけどなんとなく想像できる人も多いと思います。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->**で、私はそのシーンをめっちゃ再現したいわけです。**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>何も言わずとも合図を送るだけで自分の好みを把握したウェイターがスッとディナーを出してくれる&amp;hellip;そんなセレブ気分を味わいたい…………！
しかし、高級レストランに行くお金もなければ、行けたとしても恥ずかしくてそんなことやる勇気も出ないので自宅で再現してみましょう。&lt;/p>
&lt;h2 id="heading-1">設計&lt;/h2>
&lt;p>先ほどのイメージ画像通り「合図するとディナーを出してくれる」のが完成イメージですが、より具体的な実現方法を考えてみます。&lt;/p>
&lt;p>考えた結果、&lt;!-- raw HTML omitted -->手を叩いたことをセンサーで認識して、「&lt;strong>Amazon Dash Button&lt;/strong>」を押すことでディナーをネット注文することにしました。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/0af2d3f4-e6a0-9053-7048-c3968bef281e.jpeg" alt="概要図">&lt;/p>
&lt;h2 id="heading-2">準備するもの&lt;/h2>
&lt;h3 id="heading-3">準備するものリスト&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">名前&lt;/th>
&lt;th align="center">個数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">Amazon Dash Button　&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">Arduino Uno&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">&lt;a href="http://www.aitendo.com/product/4070">拍手制御スイッチ [AKIT-107]&lt;/a>&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">&lt;a href="http://www.aitendo.com/product/3277">トランジスタ（S8050）&lt;/a>&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">デジタル・マイクロサーボ SG90&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">ジャンパー線（オス）&lt;/td>
&lt;td align="center">最低6本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">太い輪ゴム&lt;/td>
&lt;td align="center">1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">半田付けセット&lt;/td>
&lt;td align="center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>手を叩くことを認識するセンサー部分は、aitendo様に「&lt;strong>拍手制御スイッチ&lt;/strong>」というまんま目的に合った素敵キットがあったので注文しました。&lt;/p>
&lt;h2 id="heading-4">拍手制御スイッチを組み立てる&lt;/h2>
&lt;h3 id="heading-5">半田付けする&lt;/h3>
&lt;p>&amp;lt;font color=&amp;quot;Red&amp;rdquo;, font size=&amp;quot;3&amp;quot;&amp;gt;**はやく半田付けをしたい人も、このセクションの【注意点!!】を読んでから半田付けをはじめてください。**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>拍手制御スイッチは自分で部品を半田付けするキットで届くので組み立てていきましょう。&lt;/p>
&lt;p>半田付けの基本については村田製作所様のこちらのページが参考になります。&lt;/p>
&lt;p>&lt;a href="https://www.murata.com/ja-jp/campaign/ads/japan/elekids/ele/craft/knack/soldering">電子工作のコツ/はんだ付け | 村田製作所 - Murata&lt;/a>&lt;/p>
&lt;p>さて、今回用意した半田付けセットはこちら。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/8f09c0ef-4ad5-ef26-4aed-b5a74f2b4fd3.jpeg" alt="はんだセット">&lt;/p>
&lt;p>はんだは&lt;strong>線径0.6mm&lt;/strong>のもの、半田ごては温度を&lt;strong>350度&lt;/strong>に設定したものを用意しました。
洗濯バサミみたいな道具はヒートシンクといい、半田ごての熱から熱に弱い部品を守るものですが今回は使いませんでした。&lt;/p>
&lt;p>どの部品を基板のどこにつけるかなのですが、aitendo様のWebページに&lt;a href="http://www.aitendo.com/product/4070">部品リストと回路図&lt;/a>が載っているのでこれを見ながら組み立てて行くしかありません……。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->**これが滅茶苦茶大変です。**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>オススメのやり方は最初に部品リストの順番通りに部品を並べてから半田付けを始めることです。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/7ff3ab54-423f-7402-cad2-c53d798258f9.jpeg" alt="部品並べ">&lt;/p>
&lt;p>抵抗などは下記のページで抵抗値を入力して5本色帯カラーコードに変換しながら照らし合わせると間違いづらいです。&lt;/p>
&lt;p>&lt;a href="http://www.desmots.net/hitme/audio/iroobi.php">抵抗 - カラーコード（4本・5本色帯）変換 - 計算ツール&lt;/a>&lt;/p>
&lt;h3 id="font-colorredfont">&lt;!-- raw HTML omitted -->注意点!!&lt;!-- raw HTML omitted -->&lt;/h3>
&lt;p>さて、いよいよ半田付け・・・&lt;strong>と、ちょっと待ってください!!&lt;/strong>&lt;/p>
&lt;p>部品を整理したら&lt;!-- raw HTML omitted -->&lt;strong>&lt;!-- raw HTML omitted -->Q4の場所につけるトランジスタ（S9014）をトランジスタ（S8050）に差し替えてください。&lt;!-- raw HTML omitted -->&lt;/strong>&lt;!-- raw HTML omitted -->
組み立ててから気づいたのですが、ここの部品をすり替えないと組み上がった後正常に動作しません。（予備に2つ基板を買って試しましたがどちらも同じ結果でした）&lt;/p>
&lt;p>部品を差し替えたら今度こそ半田付けをします。&lt;/p>
&lt;p>&lt;strong>電解コンデンサ、LED、ダイオード&lt;/strong>は取り付け向きが決まっているので注意しましょう。
電解コンデンサ、LEDは2本ある足の長い方が+側。ダイオードは黒く模様がついている方向を基板の模様と合わせてください。&lt;/p>
&lt;p>無事、組み終わったものがこちらです。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/7d0c5023-7edd-ee18-68de-ce8716f791c5.jpeg" alt="センサ完成">&lt;/p>
&lt;h3 id="heading-6">試してみる&lt;/h3>
&lt;p>図のような簡単な回路を組んで、ちゃんと動くか試して見ましょう。
拍手スイッチの&lt;strong>Power（入力電圧）は5Vではなく3.3V&lt;/strong>であることに注意してください。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/ff0c1050-c860-4a07-46e8-7ef7e59306d4.png" alt="AKIT_TEST.png">&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->今回Fritzing用に拍手制御スイッチ（AKIT-107）のカスタムパーツを作りましたので&lt;a href="https://github.com/TakedaHiromasa/Fritzing/blob/master/aitendo_AKIT-107.fzpz">こちら&lt;/a>からDLできます。
よかったらどうぞ。&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>回路を組んだらセンサの上で手を叩いて見ます。手を叩くたびにLEDが点灯・消灯すれば成功です！&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/50c1369b-9a73-538a-d7da-c8730fc0f0d0.gif" alt="Claptest.gif">&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->（これが楽しくて、30分ぐらいセンサーの上で手を叩いてました。）&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h2 id="heading-7">サーボの原点合わせ&lt;/h2>
&lt;p>今回用意した「デジタル・マイクロサーボ SG90」は「Amazon Dash Button」を押すのに使います。まずはサーボの原点合わせを行いましょう。&lt;/p>
&lt;p>今回使用するSG90は0~180°まで回るのですが、買った初期状態ではどこを向いているのかわからないので原点として初めに&lt;strong>90°&lt;/strong>に位置合わせを行います。&lt;/p>
&lt;p>まず以下のようにサーボとArduinoを繋ぎましょう。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/7de1f622-c738-1667-9575-601c877556e3.png" alt="sarvo.png">&lt;/p>
&lt;p>そして以下のプログラムを書き込んで実行します。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;Servo.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
Servo myservo;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
myservo.attach( &lt;span style="color:#ae81ff">10&lt;/span> );
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>() {
myservo.write( &lt;span style="color:#ae81ff">90&lt;/span> );
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでサーボの原点が決まったので、付属のホーンを以下のように真上を向くようにつけます。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/a66bca6c-f673-4f92-adea-23871a836489.jpeg" alt="DSC_0577.JPG">&lt;/p>
&lt;h3 id="heading-8">全体の配線&lt;/h3>
&lt;p>いよいよ全体の配線！
以下のように配線します。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/16a09bda-31dc-1e91-ec16-cdaa9535296b.png" alt="全体">&lt;/p>
&lt;p>「サーボ」と「Amazon Dash Button」は輪ゴムで合体させました。&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/aa85d4a4-ac2d-4800-dcfe-f248b70bbe7c.png" alt="Screenshot_2018-09-17-00-05-37.png">&lt;/p>
&lt;h3 id="heading-9">プログラム&lt;/h3>
&lt;p>以下のプログラムを書き込みます。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;Servo.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
Servo myservo;
&lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">interruptsw&lt;/span>()
{
flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
myservo.attach( &lt;span style="color:#ae81ff">10&lt;/span> );
attachInterrupt(&lt;span style="color:#ae81ff">0&lt;/span>, interruptsw, CHANGE);
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span>(flag &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
myservo.write( &lt;span style="color:#ae81ff">45&lt;/span> );
delay(&lt;span style="color:#ae81ff">500&lt;/span>);
flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}&lt;span style="color:#66d9ef">else&lt;/span>{
myservo.write( &lt;span style="color:#ae81ff">90&lt;/span> );
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回のプログラムのポイントは&lt;strong>割り込み処理&lt;/strong>と&lt;strong>volatile&lt;/strong>です。&lt;/p>
&lt;h3 id="heading-10">割り込み処理&lt;/h3>
&lt;p>割り込み処理とは簡単に言えば、**「イベントが起こった時に、コンピュータがどんな処理をしていようと無理やり別の処理を割り込ませる」**というもの。&lt;/p>
&lt;p>今回のプログラムの場合**attachInterrupt(0, interruptsw, CHANGE);**で、&lt;strong>どのピンのどんなイベントを監視するか指定&lt;/strong>しています。指定の仕方は、**attachInterrupt([監視するピン], [割り込ませる処理], [反応するイベントの種類]);**です。&lt;/p>
&lt;p>Arduino Unoでは監視するピンは&lt;strong>0か１&lt;/strong>しか指定できなく、それぞれ&lt;strong>pin2, pin3&lt;/strong>に対応しています。&lt;/p>
&lt;p>今回のプログラムの**attachInterrupt(0, interruptsw, CHANGE);&lt;strong>とは&lt;/strong>「&lt;!-- raw HTML omitted -->2pin&lt;!-- raw HTML omitted -->の信号が&lt;!-- raw HTML omitted -->CHANGE&lt;!-- raw HTML omitted -->（変化するたび）&lt;!-- raw HTML omitted -->interruptsw&lt;!-- raw HTML omitted -->を実行してね」**という指定をしていることになります。&lt;/p>
&lt;h3 id="volatile">volatile&lt;/h3>
&lt;p>volatileとは**「この変数に関係する部分は消さないで！」**という指定。&lt;/p>
&lt;p>どういうことかというと、プログラムをよく見てもらうと&lt;!-- raw HTML omitted -->volatileをつけているflagという変数はloop()の中で、何の計算にも使われていません（足すとか引くとか）。&lt;!-- raw HTML omitted -->loop()の中では、**if(flag == 1)**の部分でフラグが１になることを待っていますが、コンピュータはかしこい？ので、&lt;/p>
&lt;p>&lt;strong>flagはloop()の中で計算に使ってない&lt;/strong>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>↓&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>**計算に使ってないならflagの値が増えたり減ったりすることは一生ないんじゃね？**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>↓&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>じゃあ「flag == 1」になることはありえんね、無駄なんでif文消しまーす&lt;/strong>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>↓&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;strong>俺優秀☆&lt;/strong>&lt;/p>
&lt;p>という具合に&lt;strong>最悪の場合勝手にif文を消します&lt;/strong>。
私たちからすれば「そこは割り込みが起こった時に1が代入されるんだけど・・・」と思いますがコンピュータは知ったこっちゃありません。ということで、計算には使ってないけど割り込みなどで確実に値が変化する変数については&lt;strong>volatile&lt;/strong>をつけて消されないようにしてあげます。&lt;/p>
&lt;h2 id="heading-11">実際に使ってみる&lt;/h2>
&lt;p>さて、難しい話はこれぐらいにして早速完成したデバイスを使ってみましょう！&lt;/p>
&lt;p>より雰囲気を出すために&lt;!-- raw HTML omitted -->フリー素材のおじさまウェイターの画像をA3用紙4枚刷りで印刷し、そこにデバイスを貼り付けました。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;img src="https://qiita-image-store.s3.amazonaws.com/0/259617/f505fed2-0763-3db7-4e7c-6e9df474b17e.jpeg" alt="DSC_0571.JPG">&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->いざ起動・・・・！！！&lt;!-- raw HTML omitted -->&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->**無事、手を叩いただけでディナーが届きました！！！！！**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>「シーチキン」の「Amazon Dash Button」を使ったのでシーチキンが届きました。今回使った拍手センサは使い方も簡単なので、他にも音で動くデバイスを作ってみると面白いと思います！&lt;/p>
&lt;p>それでは、みなさん良きセレブライフをー！&lt;/p></description></item><item><title>【ハンズオン資料】Nefry BTと人感センサで防犯LINE BOTを作ってみよう</title><link>https://dotstud.io/blog/nefrybt-handson-pir-linebot/</link><pubDate>Thu, 30 Aug 2018 09:40:24 +0900</pubDate><guid>https://dotstud.io/blog/nefrybt-handson-pir-linebot/</guid><description>&lt;p>この記事は8/30の&lt;a href="https://algyan.connpass.com/event/90564/">IoT超入門！「Nefry BT」無料お試し体験ハンズオン！&lt;/a>向け資料です。&lt;strong>記事を読んで試せる内容&lt;/strong>になっているので、参加されていない方もぜひ試してみてください！&lt;/p>
&lt;p>最終的にはこんなものが出来上がります。&lt;/p>
&lt;p>&lt;a href="https://gyazo.com/a2548f0ff2534496f75b85e87b5b629d">&lt;img src="https://i.gyazo.com/a2548f0ff2534496f75b85e87b5b629d.gif" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="heading">今回やってみること&lt;/h2>
&lt;p>&lt;strong>人が近づくと自分のLINEに通知がくる仕組み&lt;/strong>を、Nefry BT、LINE（、Azure）を使って作ってみます。近づくと点灯する玄関の防犯ライトに近いイメージです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-1">用意するもの&lt;/h3>
&lt;h4 id="nefry-bt">■Nefry BT＆ディスプレイ&lt;/h4>
&lt;p>Nefry BTは「ESP-WROOM-32」というWi-Fi・BLE通信モジュールを搭載した、Arduinoと同じように開発できるマイコンボードです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;a href="https://dotstud.io/docs/grove/">Grove&lt;/a>という刺すだけで配線できるモジュール対応のコネクタを搭載していて、&lt;strong>ハードウェアをあまり意識せず&lt;/strong>に開発できます。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="grove-pir">■Grove PIRモーションセンサ&lt;/h4>
&lt;p>刺すだけで配線できる&lt;a href="https://dotstud.io/docs/grove/">Grove&lt;/a>シリーズの、人感センサです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="arduino-ide">■Arduino IDE&lt;/h4>
&lt;p>開発（プログラムの書き込み）には&lt;a href="https://www.arduino.cc/en/Main/Software">Arduino IDE&lt;/a>というフリーソフトウェアを利用します。&lt;/p>
&lt;p>&lt;a href="https://dotstud.io/docs/arduinoide-setup/">こちら&lt;/a>の手順を見ながらご自身のPCにインストールしてください。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="line">■LINEアカウント&lt;/h4>
&lt;p>今回はLINE通知の機能を作成します。LINEアカウントをご用意ください。&lt;/p>
&lt;p>また、PCから設定する際にメールアドレスでのログインが必要になります。あらかじめスマートフォンアプリでメールアドレスを設定しておいてください。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="azure">■Azureアカウント&lt;/h4>
&lt;p>WIP&lt;/p>
&lt;h2 id="heading-2">事前準備（セットアップ）&lt;/h2>
&lt;h3 id="nefry-btwi-fi">Nefry BTのWi-Fi設定&lt;/h3>
&lt;p>まずはNefry BTがインターネットにつながるよう、会場のWi-Fi情報をNefry BTに教えてあげます。&lt;/p>
&lt;p>Nefry BTとPCを直接通信させ（アドホックモード）、立ち上がるNefryポータル（設定ウィンドウ）からSSIDとパスワードを入力する手順です。&lt;a href="https://dotstud.io/docs/nefrybt-setup-wifi/">こちら&lt;/a>の手順を見ながら進めてみてください。&lt;/p>
&lt;p>一度設定したら、同じWi-Fiを使っている間は起動するだけで接続されます。Wi-Fi情報は5つまで保存でき、消去もできます。&lt;/p>
&lt;h3 id="arduino-ide-1">開発環境（Arduino IDE）にボードを追加&lt;/h3>
&lt;p>Nefty BTの開発にはフリーソフトウェアの&lt;a href="https://www.arduino.cc/en/Main/Software">Arduino IDE&lt;/a>を利用します。インストールがまだの方は「&lt;a href="https://dotstud.io/docs/arduinoide-setup/">Arduino IDEのインストール&lt;/a>」を見ながら進めてください。&lt;/p>
&lt;p>Arduino IDEには、Nefry BTのボード情報の追加が必要です。「&lt;a href="https://dotstud.io/docs/nefrybt-setup-arduino-ide/">環境構築（Arduino IDE）&lt;/a>」を見ながら追加してください。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="heading-3">はじめてのプログラムを書き込んでみる&lt;/h2>
&lt;p>まずはNefry BTに簡単なプログラムを書き込んでみましょう。Nefry BTは、最初から下記の機能が搭載されています。&lt;/p>
&lt;ul>
&lt;li>内蔵フルカラーLED&lt;/li>
&lt;li>スイッチ（SW/RST）&lt;/li>
&lt;/ul>
&lt;h3 id="l">まずはLチカ&lt;/h3>
&lt;p>最初のプログラムとして、Lチカをやってみます。LEDチカチカの略で、Webでいう”Hello, World!”です。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="arduino-ide-2">■Arduino IDEでプログラムを書く&lt;/h4>
&lt;p>Arduino IDEを立ち上げ、メニューから&lt;strong>&lt;code>ファイル &amp;gt; 新規ファイル&lt;/code>&lt;/strong>を選択します。下記のような画面が開きます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>エディタ部分に、下記のプログラムをコピーして貼り付けましょう。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;Nefry.h&amp;gt;
void setup() {
}
void loop() {
Nefry.setLed(0, 0, 255); //色合いをRGBで指定
Nefry.ndelay(1000); //1秒待つ
Nefry.setLed(0, 0, 0); //LEDをオフにする
Nefry.ndelay(1000); //1秒待つ
}
&lt;/code>&lt;/pre>&lt;p>下記でプログラムの内容を解説しています。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-4">■ボードを選択&lt;/h4>
&lt;p>メニューの&lt;strong>&lt;code>ツール &amp;gt; ボード &amp;gt; Nefry BT R2 / R3&lt;/code>&lt;/strong>を選択します。この際、ボードは使っているリビジョンに合わせて選択してください。（参照：&lt;a href="https://dotstud.io/docs/nefrybt-setup-revision/">リビジョンを確認&lt;/a>）&lt;/p>
&lt;p>例えば、使っている基板がR3の場合は&lt;strong>&lt;code>ツール &amp;gt; ボード &amp;gt; Nefry BT R2 / R3&lt;/code>&lt;/strong>を選択します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-5">■シリアルポートを選択&lt;/h4>
&lt;p>Nefry BTをPCのUSBポートにさします。プログラムはこのポートを介して、シリアル通信でNefry BTに流し込まれます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/docs/nefrybt/power_supply.png" alt="">&lt;/p>
&lt;p>Macの場合は、メニューの&lt;strong>&lt;code>ツール &amp;gt; シリアルポート &amp;gt; /dev/cu.usbserial-xxxxxx&lt;/code>&lt;/strong>を選択します。環境によっては&lt;strong>&lt;code>/dev/tty.usbserial-xxxxxx&lt;/code>&lt;/strong>などの場合もあります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Windowsの場合は、&lt;strong>&lt;code>ツール &amp;gt; シリアルポート &amp;gt; /dev/COM-XX&lt;/code>&lt;/strong>を選択します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-6">■名前をつけて保存&lt;/h4>
&lt;p>&lt;strong>&lt;code>ファイル&amp;gt;名前をつけて保存&lt;/code>&lt;/strong>を選択して保存します。「NefryLedBlink」など、後からみてわかりやすい名前がオススメです。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-7">■プログラムを書き込む&lt;/h4>
&lt;p>「✔️」を押してプログラムをコンパイルします。
&lt;img src="https://dotstud.io/img/docs/nefrybt/compile.png" alt="">
この手順は省略しても大丈夫ですが、シンタックス（文法）チェックをしてくれるので実施するのがオススメです。&lt;/p>
&lt;p>左上の「→」ボタンを押してNefry BTにプログラムを書き込みます。
&lt;img src="https://dotstud.io/img/docs/nefrybt/write.png" alt="">&lt;/p>
&lt;p>ESP32モジュールの特性上、書き込みに1分ほどかかります。エラーが出てしまうときは、「&lt;a href="https://dotstud.io/docs/nefrybt-error-handling-2/">コンパイルは成功するのに書き込みが失敗する&lt;/a>」を参照してください。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-8">■動作を確認&lt;/h4>
&lt;p>起動したら、「青いLEDが1秒ごとに光る」ことを確認しましょう。&lt;/p>
&lt;p>&lt;a href="https://gyazo.com/801e9ff4982f3326e6f1c3a133fd8de3">&lt;img src="https://i.gyazo.com/801e9ff4982f3326e6f1c3a133fd8de3.gif" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-9">■プログラムの解説&lt;/h4>
&lt;p>プログラムの要所を説明していきます。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;Nefry.h&amp;gt;
&lt;/code>&lt;/pre>&lt;p>冒頭でライブラリを読み込んでいます。Nefry BTのライブラリでできることは「&lt;a href="https://dotstud.io/docs/nefrybt-liblary/">Nefryのライブラリ&lt;/a>」を参照してください。&lt;/p>
&lt;pre>&lt;code>void setup() {
}
&lt;/code>&lt;/pre>&lt;p>起動時に処理される部分です。今回はなにもしません。&lt;/p>
&lt;pre>&lt;code>void loop() {
Nefry.setLed(0, 0, 255); //色合いをRGBで指定
Nefry.ndelay(1000); //1秒待つ
Nefry.setLed(0, 0, 0); //LEDをオフにする
Nefry.ndelay(1000); //1秒待つ
}
&lt;/code>&lt;/pre>&lt;p>起動時に繰り返し実行する部分です。&lt;/p>
&lt;p>&lt;code>Nefry.setLed()&lt;/code>という関数で、光らせる色合いをRGBの順で指定します。始めにR=0, G=0, B=255を渡しているので、青く光ります。&lt;/p>
&lt;p>続いて&lt;code>Nefry.ndelay()&lt;/code>という関数で次の処理まで指定した時間待ちます。Arduinoでは時間はミリ秒で指定するので、1000は1秒です。&lt;/p>
&lt;p>&lt;code>Nefry.setLed()&lt;/code>に0, 0, 0を渡すことで、LEDはオフになります。オンとオフのあと1秒ずつ待つことで、点滅を表現しています。&lt;/p>
&lt;h3 id="l-1">スイッチを押したらLチカ&lt;/h3>
&lt;h4 id="arduino-ide-3">■Arduino IDEでプログラムを書く&lt;/h4>
&lt;p>同様の手順で新規ファイルを作成し、下記のプログラムをNefry BTに書き込みます。おさらいがてら、やってみましょう。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;Nefry.h&amp;gt;
void setup() {
// スイッチを有効化
Nefry.enableSW();
}
void loop() {
// スイッチが押されたら
if (Nefry.readSW()) {
Nefry.setLed(255, 0, 0);
Nefry.ndelay(1000);
}
// 青色に戻す
Nefry.setLed(0, 0, 255);
}
&lt;/code>&lt;/pre>&lt;p>下記でプログラムの内容を解説しています。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-10">■動作を確認&lt;/h4>
&lt;p>スイッチ（RSTではない方）を押したら、LEDが赤く光ることを確認します。&lt;/p>
&lt;p>&lt;a href="https://gyazo.com/73185cad56d6374e6ad394eafbfef51d">&lt;img src="https://i.gyazo.com/73185cad56d6374e6ad394eafbfef51d.gif" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-11">■プログラムの解説&lt;/h4>
&lt;p>プログラムの要所を説明します。&lt;/p>
&lt;pre>&lt;code>void setup() {
// スイッチを有効化
Nefry.enableSW();
}
&lt;/code>&lt;/pre>&lt;p>起動時の処理では、&lt;code>Nefry.enableSW()&lt;/code>という関数でスイッチを有効化しています。マイコンボードでは、入力・出力に使うピンなどは&lt;code>setup()&lt;/code>関数内で有効化します。&lt;/p>
&lt;pre>&lt;code>void loop() {
// スイッチが押されたら
if (Nefry.readSW()) {
Nefry.setLed(255, 0, 0);
Nefry.ndelay(1000);
}
// 青色に戻す
Nefry.setLed(0, 0, 255);
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>if(){}&lt;/code>という条件式で、スイッチが押されたことを取得します。スイッチが押されたら1秒間赤いLEDを光らせます。スイッチが押されている以外のときは、青色のLEDを光らせます。&lt;/p>
&lt;h2 id="grove">オフラインでGroveセンサを試す&lt;/h2>
&lt;p>次は、配線してセンサのデータを取得してみます。&lt;strong>まずはインターネットに繋がらない電子工作&lt;/strong>、です。&lt;/p>
&lt;p>エラーの切り分け（どこでエラーが起こっているか）を特定するために、自分で開発するときもステップバイステップでできているか確認しつつ進めるのがオススメです。&lt;/p>
&lt;h3 id="grove-pir-1">Grove PIRモーションセンサを接続&lt;/h3>
&lt;p>Groveは刺すだけで配線できるのでGNDや信号線などの確認は必要ありませんが、デジタル・アナログ・I2Cなどの通信方法はGroveモジュールによって違います。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>PIRモーションセンサの製造元・SeeedStudioの&lt;a href="http://wiki.seeedstudio.com/Grove-PIR_Motion_Sensor/">Wikiページ&lt;/a>を見てみると、デジタルで読みとることがわかります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Nefry BTのデジタル入力に対応する、「D2」というソケットに差し込みます。少し硬いですが、カチッと言うまで押し込めます。&lt;strong>配線作業は常に電源オフの状態&lt;/strong>で行います。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-12">プログラムを書き込む&lt;/h3>
&lt;h4 id="heading-13">■プログラム&lt;/h4>
&lt;p>以下のプログラムをNefry BTに書き込みます。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;Nefry.h&amp;gt;
#define PIR_MOTION_SENSOR D2
void setup()
{
pinMode(PIR_MOTION_SENSOR, INPUT);
}
void loop()
{
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code>&lt;/pre>&lt;p>書き込み手順は、上記の「&lt;a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%82%92%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B">はじめてのプログラムを書き込んでみる&lt;/a>」を参照してくださいね。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-14">■動作を確認&lt;/h4>
&lt;p>メニューの&lt;strong>&lt;code>ツール&amp;gt;シリアルモニタ&lt;/code>&lt;/strong>を選択して開きます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>右下のbps設定を「115200bps」に変更します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>人感センサに手をかざすと、シリアルモニタに「誰かきたよ」というメッセージが流れます。&lt;/p>
&lt;p>&lt;a href="https://gyazo.com/adaf9534c9e944f3131336058a304671">&lt;img src="https://i.gyazo.com/adaf9534c9e944f3131336058a304671.gif" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-15">■プログラムの解説&lt;/h4>
&lt;p>プログラムの要所を解説します。&lt;/p>
&lt;pre>&lt;code>#define PIR_MOTION_SENSOR D2
&lt;/code>&lt;/pre>&lt;p>&lt;code>#define&lt;/code>で、配線したピンの場所を定義しています。「PIR_MOTION_SENSOR」という名前の箱に「D2」という値を入れているイメージです。&lt;/p>
&lt;p>こうしておくことで、あとでピンの場所を変えても、ここの値だけ変更すればOKになります。&lt;/p>
&lt;pre>&lt;code>void setup()
{
pinMode(PIR_MOTION_SENSOR, INPUT);
}
&lt;/code>&lt;/pre>&lt;p>setup関数内ではスイッチのとき同様、今回使うピンを有効化しています。&lt;code>pinMode({ピンの場所}, {モード})&lt;/code>で指定します。&lt;/p>
&lt;pre>&lt;code>void loop()
{
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code>&lt;/pre>&lt;p>loop関数では、モーションセンサに入力があったとき/それ以外のときで処理を分けています。&lt;/p>
&lt;p>&lt;code>digitalRead({ピン番号})&lt;/code>で指定したピンの信号を読み取っていて、戻り値は「人を検知している = HIGH」「検知していない = LOW」です。&lt;/p>
&lt;p>&lt;code>if(digitalRead(PIR_MOTION_SENSOR)) {}&lt;/code> の部分は&lt;code>if(digitalRead(PIR_MOTION_SENSOR) == HIGH) {&lt;/code>と同義で、比較演算子を省略するとHIGHのときにに実行されます。&lt;/p>
&lt;p>200ミリ秒待つことで、0.2秒に1回センサの値をチェックするようになっています。&lt;/p>
&lt;h2 id="line-1">LINEに通知してみる&lt;/h2>
&lt;p>それでは、人感センサが検知したら（= 人が来たら）自分のLINEに通知がくるようにしてみましょう。LINEが提供している、LINE Notifyというサービスを使っていきます。&lt;/p>
&lt;h3 id="line-2">LINEの設定&lt;/h3>
&lt;h4 id="line-notify">■LINE Notifyアカウントと友達になる&lt;/h4>
&lt;p>LINE Notifyでは、「LINE Notify」というアカウントからメッセージが届きます。&lt;/p>
&lt;p>&lt;img src="https://i.gyazo.com/109f4aa667871bcdb82342d6e2ac3233.png" alt="">&lt;/p>
&lt;p>まずはQRコードを読み取り、アカウントと友達になっておきましょう。&lt;/p>
&lt;h4 id="heading-16">■トークンを作成&lt;/h4>
&lt;p>自分のLINEと紐付けるために、トークン（鍵のようなもの）を発行します。&lt;/p>
&lt;p>&lt;a href="https://notify-bot.line.me/my/">LINE Notifyの設定ページ&lt;/a>にいき、「トークンを発行する」ボタンを押します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>下記のようなウィンドウが表示されます。「トークン名」にはLINE Notifyが何のサービスと連携したかわかる名前をつけましょう。通知するルームは、今回は「1:1」を選択します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>トークンが発行されたら、コピーしてメモしておきます（あとで使います）。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-17">プログラムを書き込む&lt;/h3>
&lt;h4 id="heading-18">■プログラム&lt;/h4>
&lt;p>以下のプログラムをNefry BTに書き込みます。すごく長いですが、後ほど説明します。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;NefryLineNotify.h&amp;gt;
#define PIR_MOTION_SENSOR D2
String auth, message;
void setup() {
pinMode(PIR_MOTION_SENSOR, INPUT);
Nefry.setStoreTitle(&amp;quot;LINE Auth&amp;quot;,0);
Nefry.setStoreTitle(&amp;quot;LINEMessage&amp;quot;,1);
auth = Nefry.getStoreStr(0);
message = Nefry.getStoreStr(1);
Nefry.enableSW();
}
void loop() {
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
if (!LineNotify.send(auth, message)) {
Nefry.setLed(255, 0, 0);
}
Nefry.ndelay(1000*30);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code>&lt;/pre>&lt;p>書き込み手順は、上記の「&lt;a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%82%92%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B">はじめてのプログラムを書き込んでみる&lt;/a>」を参照してくださいね。&lt;/p>
&lt;h3 id="nefry-bt-1">Nefry BTにトークン情報を設定&lt;/h3>
&lt;p>ディスプレイに表示されているIPアドレスに接続し、&lt;a href="https://dotstud.io/docs/nefrybt-basic-portal/">Nefryポータル&lt;/a>を開きます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「DataStore」のページに行くと2つのフォームが用意されているので、「LINE Auth」には先ほどコピーしたトークン、「LINEMessage」には送りたいメッセージを入力します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="heading-19">■動作を確認&lt;/h4>
&lt;p>さっそく完成したものを動かしてみましょう。&lt;/p>
&lt;p>センサに人が近づくと……&lt;/p>
&lt;p>&lt;a href="https://gyazo.com/a2548f0ff2534496f75b85e87b5b629d">&lt;img src="https://i.gyazo.com/a2548f0ff2534496f75b85e87b5b629d.gif" alt="Image from Gyazo">&lt;/a>&lt;/p>
&lt;p>LINEに通知されました！&lt;/p>
&lt;p>完成できた方、お疲れ様でした〜！&lt;/p>
&lt;h3 id="heading-20">プログラムの解説&lt;/h3>
&lt;p>例のすごく長いコードについて、要所を説明します。大事なところはちょっとだけです。&lt;/p>
&lt;pre>&lt;code>void setup() {
pinMode(PIR_MOTION_SENSOR, INPUT);
Nefry.setStoreTitle(&amp;quot;LINE Auth&amp;quot;,0);
Nefry.setStoreTitle(&amp;quot;LINEMessage&amp;quot;,1);
auth = Nefry.getStoreStr(0);
message = Nefry.getStoreStr(1);
Nefry.enableSW();
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>Nefry.setStoreTitle({タイトル}, {チャンネル番号})&lt;/code>関数を使い、Nefry BTのDataStore機能に場所を作っています。この値はNefryポータル側から入力でき、変更があってもプログラムを書き換える必要はありません。&lt;/p>
&lt;p>また値を&lt;code>getStoreStr({チャンネル番号})&lt;/code>で、ポータル側で設定した値を受け取っています。&lt;/p>
&lt;pre>&lt;code>void loop() {
if(digitalRead(PIR_MOTION_SENSOR)) {
Nefry.println(&amp;quot;誰かきたよ&amp;quot;);
if (!LineNotify.send(auth, message)) {
Nefry.setLed(255, 0, 0);
}
Nefry.ndelay(1000*30);
} else {
Nefry.println(&amp;quot;監視中&amp;quot;);
}
delay(200);
}
&lt;/code>&lt;/pre>&lt;p>先ほど同様人感センサが検知したとき、という条件文を作っています。&lt;code>LineNotify.send()&lt;/code>関数を使い、もし送れなかったときは赤いLEDを光らせるという処理をしています（&lt;code>!&lt;/code>は&lt;code>!==&lt;/code>と同義で、&lt;code>FALSE&lt;/code>が返ったときに実行されます）。&lt;/p>
&lt;p>何度も連続してLINEが来るとウザいので、一度送ったあとは30秒待ちます。&lt;/p>
&lt;p>~~LINE送信を実装している部分です、が、これ以降は&lt;strong>気にしなくていいです&lt;/strong>。この部分は&lt;a href="https://dotstud.io/docs/nefrybt-default/">初期プログラム&lt;/a>をコピーして作っています。たぶん近々ライブラリ化されます。~~&lt;/p>
&lt;p>LINE Notifyがライブラリ化されたので編集しました！&lt;/p>
&lt;h2 id="-">応用課題: データをクラウドに送ってみる（ロギング）&lt;/h2>
&lt;p>WIP（追記します）&lt;/p>
&lt;h2 id="heading-21">関連情報&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://dotstud.io/shop/nefry-bt-set/">Nefr BTの購入&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Nefry BTはこちらから購入できます（送料無料）。その他にも千石電商、ツクモ、若松通商、共立電子などの実店舗やECサイトで購入できます。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://dotstud.io/docs/nefrybt/">Nefry BTドキュメント&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Nefry BTでは、IFTTTを使ったWebサービスとの連携や、その他のクラウドサービスとの連携も簡単です。ディスプレイを使ったイラスト描画や、100以上あるGroveモジュールの活用なども、ぜひ試してみてください。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://www.facebook.com/groups/nefry">Nefryユーザーグループ（FB）&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Nefryユーザ同士が交流するページです。質問を投稿して解決した事例もたくさんありますので、困った際などはぜひお気軽にご利用ください。開発者もよく登場します。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://nefry.connpass.com/event/97692/">Nefry User Meetup!&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Nefryユーザによる開催イベントです。ハンズオンやLT会、もくもく会などを実施しています。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://dotstudio.connpass.com/">dotstudioイベント&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>dotstudioによる開催イベントです。Nefry BT以外の題材を扱うことも多いです。&lt;/p>
&lt;/blockquote>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>PWM制御をマスターしよう！Node-REDでサーボモータを遠隔制御する方法＆初ハンズオンレポート</title><link>https://dotstud.io/blog/nefry-servo-handson-takudooon/</link><pubDate>Thu, 12 Jul 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/nefry-servo-handson-takudooon/</guid><description>&lt;h2 id="heading">暑さ本番、いよいよ大好きな生ビールの季節がやってまいりました！&lt;/h2>
&lt;p>みなさまいかがお過ごしでしょうか？どうも、宇宙エンジニアの&lt;a href="https://dotstud.io/members/takudooon">たくろーどん&lt;/a>です。毎日、暑いですね。&lt;/p>
&lt;p>さて先日、&lt;strong>初めてハンズオンイベント&lt;strong>を企画・実施してみました！題して、「&lt;/strong>【IoT】PWM制御をマスター！Nefry BT+Node-REDでサーボモータを遠隔制御&lt;/strong>&lt;a href="https://dotstudio.connpass.com/event/91695/">&lt;/a>」！&lt;/p>
&lt;p>「モノづくりをしたい！」「こんなものをつくりたい！」と思っても「&lt;strong>こういう技術がつかえる&lt;/strong>」ということを知らないと、なかなかモノづくりが進みません。&lt;/p>
&lt;p>なので、動くものを作りたいときに便利な&lt;!-- raw HTML omitted -->&lt;strong>サーボモータとその制御方法であるPWM制御&lt;/strong>をマスターし、&lt;strong>PCからサーボモータを遠隔制御をしよう&lt;/strong>&lt;!-- raw HTML omitted -->というのがハンズオンの目論見です。&lt;/p>
&lt;p>では、ちらっとハンズオンの内容を振り返ってみたいと思います。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="pwm">PWM制御を用いたプログラムの書き方&lt;/h2>
&lt;h3 id="pwm-1">PWM制御について&lt;/h3>
&lt;p>&lt;a href="https://dotstud.io/docs/pulse-width-modulation/">PWM制御の大まかな説明&lt;/a>は以前、ドキュメントに書きました。ようするに、PWM制御は「&lt;strong>パルスのオン・オフ繰り返し切り替えることで出力される電力を制御&lt;/strong>」するという意味です。&lt;/p>
&lt;p>でも結局のところ、「&lt;strong>PWM制御ってどんなイメージやねん！&lt;/strong>」と多くの方が思うでしょう。&lt;/p>
&lt;p>なので、これがわかりやすいのではないかという説明を思いつきました。それが、下記の動画です。
&lt;img src="https://dotstud.io/img/blog/187/2.gif" alt="">&lt;/p>
&lt;p>例えば、自宅から最寄りの駅まで走らなければならない状況を考えます。まるで、小学校の算数にでてくるたかしくんの問題を彷彿させますね。知らんけど。&lt;/p>
&lt;ul>
&lt;li>100%の力で走れば5分で駅につく ≒ 100%出力されるので、5V出力される&lt;/li>
&lt;li>全力で走って途中で歩くと9分で駅に着く（全体的に80%の力で走る） ≒ 80%出力されるので、4V出力される&lt;/li>
&lt;li>全力で走って途中で歩くと10分で駅に着く（全体的に50%の力で走る） ≒ 50%出力されるので、2.5V出力される&lt;/li>
&lt;li>全力で走って途中で歩くと15分で駅に着く（全体的に10%の力で走る） ≒ 10%出力されるので、0.5V出力される&lt;/li>
&lt;/ul>
&lt;p>というようなイメージです。自宅から駅まで走る場合は走る速さの具合によって、到着時間が伸びます。しかし、電圧の場合は実行電圧（実際に出力される電圧）は下がっていきます。&lt;/p>
&lt;h3 id="esp32">ESP32開発ボードでのプログラムについて&lt;/h3>
&lt;p>&lt;a href="https://dotstud.io/docs/nefrybt">Nefry BT&lt;/a>のようなESP32を搭載しているような開発ボードでPWM制御する場合は、ledc関数を使います。&lt;strong>ESP32ではArduinoでつかうようなanalogWrite関数が実装されていない&lt;/strong>とのことなので注意しましょう（ただし、今後変更される可能性があります）。&lt;/p>
&lt;p>例えば、下記のようなプログラムになります。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">
&lt;span style="color:#75715e">//基本Iotは2.4GHz帯を使うこと
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span>&lt;span style="color:#75715e">&amp;lt;Nefry.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span>&lt;span style="color:#75715e">&amp;#34;esp32-hal-ledc.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//PWM信号の周波数をPWMをつくっているクロック周波数で割ったもの
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//ledcSetupでPWMの範囲を8bitに設定したとき、0～255　10bitのときは0～1023となる、2進数の話
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">define PWM_BITWIDTH 16&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//わかりやすいように角度に変換する関数/////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deg2pw&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> deg, &lt;span style="color:#66d9ef">int&lt;/span> bit){
&lt;span style="color:#66d9ef">double&lt;/span> ms &lt;span style="color:#f92672">=&lt;/span> ((&lt;span style="color:#66d9ef">double&lt;/span>) deg &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">90.0&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0.95&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">90.0&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1.45&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>) (ms &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">20.0&lt;/span> &lt;span style="color:#f92672">*&lt;/span> pow(&lt;span style="color:#ae81ff">2&lt;/span>, bit));
}
&lt;span style="color:#75715e">//////////////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
Serial.begin(&lt;span style="color:#ae81ff">115200&lt;/span>);
&lt;span style="color:#75715e">//ledcSetup(チャンネル数(0～),周波数(たとえばPWMサイクル20mHzなら50Hzになるという意味(SG90の場合))、分解能は任意(ただし限度はある))
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ledcSetup(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">50&lt;/span>,PWM_BITWIDTH);
ledcAttachPin(&lt;span style="color:#960050;background-color:#1e0010">ピ&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">ン&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">番&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">号&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>);&lt;span style="color:#75715e">//left_motor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Nefry.enableSW();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>(){
&lt;span style="color:#66d9ef">if&lt;/span>((Nefry.readSW())){
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(&lt;span style="color:#ae81ff">90&lt;/span>, PWM_BITWIDTH));
delay(&lt;span style="color:#ae81ff">800&lt;/span>);
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(&lt;span style="color:#ae81ff">0&lt;/span>, PWM_BITWIDTH));
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="heading-1">プログラムの書き方&lt;/h3>
&lt;p>プログラムを詳しく見てましょう。&lt;/p>
&lt;p>ledc関数を使うため、ライブラリ「esp32-hal-ledc.h」を最初にインクルードします。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span>&lt;span style="color:#75715e">&amp;#34;esp32-hal-ledc.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ライブラリ「esp32-hal-ledc.h」を使うときの主な関数は以下に示すものです。&lt;/p>
&lt;ol>
&lt;li>ledcSetup（チャンネル,周波数,分解能）&lt;/li>
&lt;li>ledcAttachPin（ピン番号,チャンネル）：チャンネルはピン番号の識別番号です&lt;/li>
&lt;li>ledcWrite（チャンネル,パルス幅）：設定した角度になるように与えるべきパルス幅を算出する関数&lt;/li>
&lt;/ol>
&lt;p>実際の記述は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
Serial.begin(&lt;span style="color:#ae81ff">115200&lt;/span>);
ledcSetup(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">50&lt;/span>,PWM_BITWIDTH);
ledcAttachPin(A2,&lt;span style="color:#ae81ff">0&lt;/span>);&lt;span style="color:#75715e">//left_motor
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Nefry.enableSW();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>分解能は&lt;strong>どれだけ細かく制御するのか&lt;/strong>を表しているイメージです。これは&lt;strong>ビット数&lt;/strong>で表します。&lt;/p>
&lt;p>例えば、分解能を&lt;strong>8ビットとするれば0〜255バイト&lt;/strong>（2の8乗）、&lt;strong>10ビットなら0〜1023バイト&lt;/strong>（2の10乗）となります。&lt;/p>
&lt;p>これを、どのようにPWM制御に使えるのか説明します。PWM制御とは一定電圧の入力から&lt;strong>パルス列のオンとオフの一定周期を作り、オンの時間幅を変化させる電力制御方式&lt;/strong>のことです。つまり、&lt;strong>実効電圧を変化させる&lt;/strong>ことができます。&lt;/p>
&lt;p>なので、例えば、最大5[V]の出力を考えたとき、&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分解能8ビットだと0→0[V]、127→2.5[V]、255→5[V]&lt;/strong>&lt;/li>
&lt;li>&lt;strong>分解能10ビットだと0→0[V]、511→2.5[V]、1023→5[V]&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>と表せます。分解能が大きい方が、細かい制御ができることがわかるかと思います。&lt;/p>
&lt;h2 id="node-redmqtt">Node-RED×MQTTでサーボモータを遠隔制御&lt;/h2>
&lt;h3 id="node-red">Node-REDとは&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;a href="https://nodered.jp/">Node-RED&lt;/a>はハードウェアデバイス/APIおよびオンラインサービスを接続するためのツールです。ウェブ上で、フローチャートのように直感的にプログラムをつくることができます。そして、最終的に自分が欲しい仕組みを作り上げるというものです。&lt;/p>
&lt;p>Node-REDを使うには大まかに2パターンあります。&lt;/p>
&lt;ul>
&lt;li>自分のPC上でローカルで動かす（今回はこちらで進めていきます）&lt;/li>
&lt;li>外部のサービスを利用する（IBMクラウドやenebularなど）&lt;/li>
&lt;/ul>
&lt;p>導入方法は、&lt;a href="https://qiita.com/minwinmin/private/6c13d2c912d0d7e8e197">こちら&lt;/a>で説明していますので参考にしてください。&lt;/p>
&lt;p>また、後ほどNode-REDにフローのコードを貼り付ける必要があるので簡単に貼り付け方法を説明します。&lt;/p>
&lt;p>まずフローのコードをコピーし、Node-REDを立ち上げたら右上のメニュー（3本線）をクリックします。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>すると上記のような画面があらわれます。「読み込み」をクリックして、あらわれた画面にコピーしたコードを貼り付ければ完了です。&lt;/p>
&lt;h3 id="mqtt">MQTTとは&lt;/h3>
&lt;p>MQTTとは、&lt;strong>多数のデバイスの間で短いメッセージを頻繁に送受信する&lt;/strong>ことを想定した通信プロトコルです。つまりインフラのようなもの、もしくはメッセージを送受信するので土管のようなものをイメージすると良いかと思います。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>MQTTは先ほど説明したような仕組みの名前です。なので、実際にメッセージを送受信するためにはMQTTブローカーが必要です。イメージは下記の画像のようになります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>MQTTブローカーを用意するには、いくつか方法があります（&lt;a href="http://acro-engineer.hatenablog.com/entry/2015/06/19/120000">こちらのサイト&lt;/a>にまとめられています）。今回、ハンズオンでつかったの以下の2パターンです。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ローカルホストでMQTTブローカーをたてる&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://github.com/mcollina/mosca">Mosca&lt;/a>を利用する -&amp;gt; MQTT brokerのためのライブラリ（IBMクラウドのような外部サービスでNode-REDを使う場合、うまくいきませんでした）&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://test.mosquitto.org/">mosquitto&lt;/a>のテストサーバーを利用する&lt;/strong>&lt;/li>
&lt;li>これから記載するプログラムはこちらを使っています。&lt;/li>
&lt;/ul>
&lt;h3 id="node-red-1">Node-REDのフローのコード&lt;/h3>
&lt;p>下記のNode-REDのフローのコードを、Node-REDにコピーして使いましょう。&lt;/p>
&lt;pre>&lt;code>[
{
&amp;quot;id&amp;quot;: &amp;quot;7878093f.d68778&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;debug&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;active&amp;quot;: true,
&amp;quot;tosidebar&amp;quot;: true,
&amp;quot;console&amp;quot;: false,
&amp;quot;tostatus&amp;quot;: false,
&amp;quot;complete&amp;quot;: &amp;quot;payload&amp;quot;,
&amp;quot;x&amp;quot;: 522.0130081176758,
&amp;quot;y&amp;quot;: 161.99999809265137,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;22ca4d97.8e3382&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;inject&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;payload&amp;quot;: &amp;quot;{\&amp;quot;motor\&amp;quot;:1}&amp;quot;,
&amp;quot;payloadType&amp;quot;: &amp;quot;json&amp;quot;,
&amp;quot;repeat&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;crontab&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;once&amp;quot;: false,
&amp;quot;onceDelay&amp;quot;: 0.1,
&amp;quot;x&amp;quot;: 220.01303100585938,
&amp;quot;y&amp;quot;: 244.00000190734863,
&amp;quot;wires&amp;quot;: [
[
&amp;quot;6b18ace.785b854&amp;quot;
]
]
},
{
&amp;quot;id&amp;quot;: &amp;quot;6b18ace.785b854&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt out&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;,
&amp;quot;qos&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;retain&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;3890dddf.26f532&amp;quot;,
&amp;quot;x&amp;quot;: 508.0130386352539,
&amp;quot;y&amp;quot;: 293.9999957084656,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;e0581ff4.bce8a&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;inject&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;payload&amp;quot;: &amp;quot;{\&amp;quot;motor\&amp;quot;:0}&amp;quot;,
&amp;quot;payloadType&amp;quot;: &amp;quot;json&amp;quot;,
&amp;quot;repeat&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;crontab&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;once&amp;quot;: false,
&amp;quot;onceDelay&amp;quot;: 0.1,
&amp;quot;x&amp;quot;: 220.01303100585938,
&amp;quot;y&amp;quot;: 344.00000190734863,
&amp;quot;wires&amp;quot;: [
[
&amp;quot;6b18ace.785b854&amp;quot;
]
]
},
{
&amp;quot;id&amp;quot;: &amp;quot;3dccf617.5970da&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt in&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;/sub/NefryBT/SAMPLE&amp;quot;,
&amp;quot;qos&amp;quot;: &amp;quot;2&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;cd2e6f9.ab8069&amp;quot;,
&amp;quot;x&amp;quot;: 235.09634399414062,
&amp;quot;y&amp;quot;: 159.3697967529297,
&amp;quot;wires&amp;quot;: [
[
&amp;quot;7878093f.d68778&amp;quot;
]
]
},
{
&amp;quot;id&amp;quot;: &amp;quot;f5c8b0fb.93d8&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;Node-RED上に文字列表示&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 237.09635162353516,
&amp;quot;y&amp;quot;: 114.08594131469727,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;47872155.bfb16&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;MQTTブローカー側に文字列を送信&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 265.0130310058594,
&amp;quot;y&amp;quot;: 206.0104217529297,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;d5a5e79d.ec27a8&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;MQTTブローカー側に文字列を送信するためのフロー&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 609.0130004882812,
&amp;quot;y&amp;quot;: 257.0104160308838,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;3700aeb9.5a7ec2&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;comment&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;782bda22.769d84&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;ｍosquittoのテストサーバーを利用&amp;quot;,
&amp;quot;info&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;x&amp;quot;: 265.0130310058594,
&amp;quot;y&amp;quot;: 52.010416984558105,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;3890dddf.26f532&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt-broker&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;http://test.mosquitto.org/&amp;quot;,
&amp;quot;port&amp;quot;: &amp;quot;1883&amp;quot;,
&amp;quot;clientid&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;usetls&amp;quot;: false,
&amp;quot;compatmode&amp;quot;: true,
&amp;quot;keepalive&amp;quot;: &amp;quot;60&amp;quot;,
&amp;quot;cleansession&amp;quot;: true,
&amp;quot;birthTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;birthQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;birthPayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;closePayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;willPayload&amp;quot;: &amp;quot;&amp;quot;
},
{
&amp;quot;id&amp;quot;: &amp;quot;cd2e6f9.ab8069&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt-broker&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;http://test.mosquitto.org/&amp;quot;,
&amp;quot;port&amp;quot;: &amp;quot;1883&amp;quot;,
&amp;quot;clientid&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;usetls&amp;quot;: false,
&amp;quot;compatmode&amp;quot;: true,
&amp;quot;keepalive&amp;quot;: &amp;quot;60&amp;quot;,
&amp;quot;cleansession&amp;quot;: true,
&amp;quot;birthTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;birthQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;birthPayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;closePayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;willPayload&amp;quot;: &amp;quot;&amp;quot;
}
]
&lt;/code>&lt;/pre>&lt;h3 id="nefry-bt">Nefry BTのプログラム&lt;/h3>
&lt;p>下記がNefry BT側のプログラムになります。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//Nefryがwifiにつながっているか確認、2.4Ghzにつなごう
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//できたtest.mosquitto.orgで使える！
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;Nefry.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;WiFiClient.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;PubSubClient.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;ArduinoJson.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span>&lt;span style="color:#75715e">&amp;#34;esp32-hal-ledc.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">define URL &amp;#34;mosquitto.org&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">define PWM_BITWIDTH 16&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deg2pw&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> deg, &lt;span style="color:#66d9ef">int&lt;/span> bit){
&lt;span style="color:#66d9ef">double&lt;/span> ms &lt;span style="color:#f92672">=&lt;/span> ((&lt;span style="color:#66d9ef">double&lt;/span>) deg &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">90.0&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0.95&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">90.0&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1.45&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>) (ms &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">20.0&lt;/span> &lt;span style="color:#f92672">*&lt;/span> pow(&lt;span style="color:#ae81ff">2&lt;/span>, bit));
}
IPAddress endpoint;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> port &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1883&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pubTopic;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>subTopic;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>deviceName;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>mqtt_server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">test.mosquitto.org&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
WiFiClient httpsClient;
PubSubClient &lt;span style="color:#a6e22e">mqttClient&lt;/span>(httpsClient);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
ledcSetup(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">50&lt;/span>,PWM_BITWIDTH);
ledcAttachPin(A2,&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#75715e">//// NefryBT設定画面まわり ////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// NefryBT
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pubTopic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">/pub/NefryBT/SAMPLE&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
subTopic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">/sub/NefryBT/SAMPLE&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
deviceName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">NefryBT_SAMPLE&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 複数台で利用する場合は必ずかぶらないように変更する
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ローカルホストでMQTTブローカーを立てている場合は、パソコンのIPAddress型に収納。配列っぽく入れる。ここはその都度確認すること
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//endpoint指定部
&lt;/span>&lt;span style="color:#75715e">&lt;/span> endpoint[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>;
endpoint[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">168&lt;/span>;
endpoint[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">43&lt;/span>;
endpoint[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#75715e">//// 以下通常処理 ////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
Serial.begin(&lt;span style="color:#ae81ff">115200&lt;/span>);
&lt;span style="color:#75715e">//mqttClient.setServer()関数でMQTTブローカーを指定する
&lt;/span>&lt;span style="color:#75715e">&lt;/span> mqttClient.setServer(mqtt_server, port);
mqttClient.setCallback(mqttCallback);
connectMQTT();
}
&lt;span style="color:#75715e">//MQTTがちゃんと動いているか、つながっているかを判断
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">connectMQTT&lt;/span>() {
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">connectMQTT&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.println(deviceName);
&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mqttClient.connected()) {
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (mqttClient.connect(deviceName)) {
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Connected.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">int&lt;/span> qos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
mqttClient.subscribe(subTopic, qos);
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Subscribed.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
} &lt;span style="color:#66d9ef">else&lt;/span> {
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Failed. Error state=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.print(mqttClient.state());
&lt;span style="color:#75715e">// Wait 5 seconds before retrying
&lt;/span>&lt;span style="color:#75715e">&lt;/span> delay(&lt;span style="color:#ae81ff">5000&lt;/span>);
}
}
}
&lt;span style="color:#75715e">///////////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">char&lt;/span> pubMessage[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">mqttCallback&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> topic, byte&lt;span style="color:#f92672">*&lt;/span> payload, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> length) {
String str &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Received. topic=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.println(topic);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">+&lt;/span>) {
Serial.print((&lt;span style="color:#66d9ef">char&lt;/span>)payload[i]);
str &lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>)payload[i];
}
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
StaticJsonBuffer&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">200&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> jsonBuffer;
JsonObject&lt;span style="color:#f92672">&amp;amp;&lt;/span> root &lt;span style="color:#f92672">=&lt;/span> jsonBuffer.parseObject(str);
&lt;span style="color:#75715e">// 読み取った文字列をパース
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>root.success()) {
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">parseObject() failed&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#75715e">//Node-REDから文字列を読み取ってくる部分//////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> message &lt;span style="color:#f92672">=&lt;/span> root[&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">message&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> motor &lt;span style="color:#f92672">=&lt;/span> root[&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">motor&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>];
&lt;span style="color:#75715e">////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">motor = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.println(motor);
&lt;span style="color:#75715e">///サーボモータを動かす処理//////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>( motor &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> ){
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">115&lt;/span>; i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">+&lt;/span>){
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(i, PWM_BITWIDTH));
}
delay(&lt;span style="color:#ae81ff">800&lt;/span>);
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(&lt;span style="color:#ae81ff">90&lt;/span>, PWM_BITWIDTH));
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>; i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65&lt;/span>; &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#f92672">-&lt;/span>i){&lt;span style="color:#75715e">//0～180°の位置で考える、90度が基準点としてそこからどう動くかを考える
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(i, PWM_BITWIDTH));
}
delay(&lt;span style="color:#ae81ff">800&lt;/span>);
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(&lt;span style="color:#ae81ff">90&lt;/span>, PWM_BITWIDTH));
}
Nefry.ndelay(&lt;span style="color:#ae81ff">1000&lt;/span>);
}
&lt;span style="color:#75715e">//////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//mqttを動かしている部分///////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">mqttLoop&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mqttClient.connected()) {
connectMQTT();
}
mqttClient.loop();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>() {
mqttLoop();
}
&lt;span style="color:#75715e">//////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="heading-2">動作させてみると……&lt;/h3>
&lt;p>このように、PC上から遠隔でサーボモータを制御できるようになります。
&lt;img src="https://dotstud.io/img/blog/187/5.gif" alt="">&lt;/p>
&lt;h2 id="node-redmqttui">Node-RED×MQTTでサーボモータをUI（ブラウザ）から制御&lt;/h2>
&lt;p>先ほどのプログラムはNode-RED上のボタンを押すとある角度回転するというものでした。次はそれを発展させて、&lt;strong>ブラウザから操作して角度を遠隔で制御&lt;/strong>してみます。&lt;/p>
&lt;p>ハンズオンでは、製作途中にタイムアップしてしまいました。少し難易度高めです。&lt;/p>
&lt;h3 id="node-red-2">Node-REDのフローのコード&lt;/h3>
&lt;p>下記のNode-REDのフローのコードをNode-REDにコピーして使いましょう。&lt;/p>
&lt;pre>&lt;code>[
{
&amp;quot;id&amp;quot;: &amp;quot;f2dc1b0b.520f98&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt out&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;fab71764.66ef78&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;topic&amp;quot;: &amp;quot;servo/pan&amp;quot;,
&amp;quot;qos&amp;quot;: &amp;quot;1&amp;quot;,
&amp;quot;retain&amp;quot;: &amp;quot;false&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;954b988c.ec1e08&amp;quot;,
&amp;quot;x&amp;quot;: 520,
&amp;quot;y&amp;quot;: 400,
&amp;quot;wires&amp;quot;: []
},
{
&amp;quot;id&amp;quot;: &amp;quot;954b988c.ec1e08&amp;quot;,
&amp;quot;type&amp;quot;: &amp;quot;mqtt-broker&amp;quot;,
&amp;quot;z&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;name&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;broker&amp;quot;: &amp;quot;https://test.mosquitto.org/&amp;quot;,
&amp;quot;port&amp;quot;: &amp;quot;1883&amp;quot;,
&amp;quot;clientid&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;usetls&amp;quot;: false,
&amp;quot;compatmode&amp;quot;: true,
&amp;quot;keepalive&amp;quot;: &amp;quot;60&amp;quot;,
&amp;quot;cleansession&amp;quot;: true,
&amp;quot;birthTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;birthQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;birthPayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closeTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;closePayload&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willTopic&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;willQos&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;willPayload&amp;quot;: &amp;quot;&amp;quot;
}
]
&lt;/code>&lt;/pre>&lt;h3 id="nefry-bt-1">Nefry BTのプログラム&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">
&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;Nefry.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;WiFiClient.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;PubSubClient.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;ArduinoJson.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//esp32でPWMを使えるようにするためのライブラリー//
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span>&lt;span style="color:#75715e">&amp;#34;esp32-hal-ledc.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//分解能//////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">define PWM_BITWIDTH 16&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//PWM制御：周波数-&amp;gt;角度に変換(プログラムするときにわかりやすい)//
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deg2pw&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> deg, &lt;span style="color:#66d9ef">int&lt;/span> bit){
&lt;span style="color:#66d9ef">double&lt;/span> ms &lt;span style="color:#f92672">=&lt;/span> ((&lt;span style="color:#66d9ef">double&lt;/span>) deg &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">90.0&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">0.95&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">90.0&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1.45&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>) (ms &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">20.0&lt;/span> &lt;span style="color:#f92672">*&lt;/span> pow(&lt;span style="color:#ae81ff">2&lt;/span>, bit));
}
&lt;span style="color:#75715e">////////////////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
IPAddress endpoint;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> port &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1883&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pubTopic;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>subTopic;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>deviceName;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>mqtt_server &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">test.mosquitto.org&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
WiFiClient httpsClient;
PubSubClient &lt;span style="color:#a6e22e">mqttClient&lt;/span>(httpsClient);
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
ledcSetup(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">50&lt;/span>,PWM_BITWIDTH);
ledcAttachPin(A1,&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#75715e">//// NefryBT設定 ////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// NefryBT
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pubTopic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">/pub/NefryBT/SAMPLE&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
subTopic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">/sub/NefryBT/SAMPLE&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
deviceName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">NefryBT_SAMPLE&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 複数台で利用する場合は必ずかぶらないように変更する
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ローカルホストならパソコンのIPAddress型に収納。配列っぽく入れる。ここはその都度確認すること
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//mosquittoのテストサーバーを使うときは下記のednpointは気にしなくて大丈夫です
&lt;/span>&lt;span style="color:#75715e">&lt;/span> endpoint[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>;
endpoint[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">168&lt;/span>;
endpoint[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
endpoint[&lt;span style="color:#ae81ff">3&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#75715e">////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
Serial.begin(&lt;span style="color:#ae81ff">115200&lt;/span>);
mqttClient.setServer(mqtt_server, port);
mqttClient.setCallback(mqttCallback);
connectMQTT();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">connectMQTT&lt;/span>() {
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">connectMQTT&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.println(deviceName);
&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mqttClient.connected()) {
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (mqttClient.connect(deviceName)) {
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Connected.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">int&lt;/span> qos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
mqttClient.subscribe(subTopic, qos);
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Subscribed.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
} &lt;span style="color:#66d9ef">else&lt;/span> {
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Failed. Error state=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.print(mqttClient.state());
&lt;span style="color:#75715e">// Wait 5 seconds before retrying
&lt;/span>&lt;span style="color:#75715e">&lt;/span> delay(&lt;span style="color:#ae81ff">5000&lt;/span>);
}
}
}
&lt;span style="color:#66d9ef">char&lt;/span> pubMessage[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">mqttCallback&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> topic, byte&lt;span style="color:#f92672">*&lt;/span> payload, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> length) {
String str &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">Received. topic=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.println(topic);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">+&lt;/span>) {
Serial.print((&lt;span style="color:#66d9ef">char&lt;/span>)payload[i]);
str &lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>)payload[i];
}
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
StaticJsonBuffer&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">200&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> jsonBuffer;
JsonObject&lt;span style="color:#f92672">&amp;amp;&lt;/span> root &lt;span style="color:#f92672">=&lt;/span> jsonBuffer.parseObject(str);
&lt;span style="color:#75715e">// パースが成功かどうか判断
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>root.success()) {
Serial.println(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">parseObject() failed&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> message &lt;span style="color:#f92672">=&lt;/span> root[&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">message&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> takudooon &lt;span style="color:#f92672">=&lt;/span> root[&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">takudooon&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>];
Serial.print(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">takudooon = &lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
Serial.println(takudooon);
&lt;span style="color:#66d9ef">if&lt;/span>( takudooon &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> ){
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">115&lt;/span>; i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">+&lt;/span>){
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(i, PWM_BITWIDTH));
}
delay(&lt;span style="color:#ae81ff">800&lt;/span>);
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(&lt;span style="color:#ae81ff">90&lt;/span>, PWM_BITWIDTH));
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>; i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65&lt;/span>; &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#f92672">-&lt;/span>i){&lt;span style="color:#75715e">//0～180°の位置で考える、90度が基準点としてそこからどう動くかを考える
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(i, PWM_BITWIDTH));
}
delay(&lt;span style="color:#ae81ff">800&lt;/span>);
ledcWrite(&lt;span style="color:#ae81ff">0&lt;/span>,deg2pw(&lt;span style="color:#ae81ff">90&lt;/span>, PWM_BITWIDTH));
}
Nefry.ndelay(&lt;span style="color:#ae81ff">1000&lt;/span>);
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">mqttLoop&lt;/span>() {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mqttClient.connected()) {
connectMQTT();
}
mqttClient.loop();
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>() {
mqttLoop();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="heading-3">操作画面を用意&lt;/h3>
&lt;p>それぞれのプログラムが準備できたら、Node-REDの画面から、&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>URLの「&lt;code>http://localhost:1880&lt;/code>」を「&lt;code>http://localhost:1880/ui&lt;/code>」と記述すると以下のような操作画面があらわれます。ここから、直感的にサーボモータの角度を遠隔制御できるようになります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-4">実際に動かすと……&lt;/h3>
&lt;p>このようになります。
&lt;img src="https://dotstud.io/img/blog/187/8.gif" alt="">&lt;/p>
&lt;h2 id="heading-5">おわりに&lt;/h2>
&lt;p>いろいろな技術を知ることでモノづくりの幅が増え、作ってみたいものを自由に作れるようになってもらえればな、と思います。&lt;/p>
&lt;p>では！&lt;/p></description></item><item><title>M5Stack+GPS+臭気センサをつかってトイレの臭いマップをつくりたい！</title><link>https://dotstud.io/blog/m5stack-toilet-smell-map/</link><pubDate>Thu, 28 Jun 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/m5stack-toilet-smell-map/</guid><description>&lt;h2 id="1">公衆トイレ1級判定士を目指します！&lt;/h2>
&lt;p>ある日の出来事、お出掛け中……&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>公衆トイレに急いで駆け込む 三└(┐卍^o^)卍ﾄﾞｩﾙﾙﾙﾙﾙ&lt;/p>
&lt;p>すると……&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>気分、萎え萎え……。みなさん、こんな経験ありませんか？&lt;/p>
&lt;p>お出掛け中に公衆トイレにお世話になるも、臭いがひどくて気分が下がってしまうなんてことありますよね？&lt;/p>
&lt;p>良い（無臭）公衆トイレと悪い（悪臭）公衆トイレが、どこにあるのか分かったらいいなぁ……。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>ということで、そんな公衆トイレマップが作れるようなデバイスをつくってみたいと思います。
たぶん、僕は先駆者なので&lt;strong>公衆トイレ1級判定士&lt;/strong>と名乗ることにします。&lt;/p>
&lt;h2 id="heading">とりあえずつくってみる&lt;/h2>
&lt;p>今回はM5Stackというとても便利な開発ボードを使ってデバイスを作成していきます（&lt;a href="https://codezine.jp/article/detail/10853">M5Stackが便利な話はこちらの記事が参考になります&lt;/a>）。&lt;/p>
&lt;p>下記がイメージ図です。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>M5Stackの拡張ボードのGPSを使って位置情報を取得し、臭気センサ（&lt;a href="http://akizukidenshi.com/catalog/g/gP-00989/">TGS2450&lt;/a>）で計測した値と紐づけます。そして、&lt;a href="https://ambidata.io/">Ambient&lt;/a>（IoT可視化サービス）を使って地図上にマッピングし、良い（無臭）公衆トイレと悪い（悪臭）公衆トイレを可視化していくといった具合です。&lt;/p>
&lt;h2 id="heading-1">今回使用する電子部品たち&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.switch-science.com/catalog/3648/">M5Stack Gray
&lt;/a>（今回はM5Stack BasicでもOK）&lt;/li>
&lt;li>&lt;a href="https://www.switch-science.com/catalog/3861/">M5Stack用GPSモジュール&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://akizukidenshi.com/catalog/g/gP-00989/?customer=z">TGS2450&lt;/a>（臭気センサ）&lt;/li>
&lt;li>&lt;a href="http://akizukidenshi.com/catalog/g/gI-04268/">2SC1815Y&lt;/a>（トランジスタ、60V150mA）&lt;/li>
&lt;li>抵抗&lt;/li>
&lt;li>ユニバーサル基板&lt;/li>
&lt;li>ジャンパワイヤ&lt;/li>
&lt;/ul>
&lt;h2 id="heading-2">実装&lt;/h2>
&lt;h3 id="arduino">とりあえずArduinoで臭気センサを動かしてみる&lt;/h3>
&lt;p>まず安定感のあるArduinoで臭気センサが動くをことを確認してみます。&lt;/p>
&lt;p>TGS2450のデータシートにあるサンプル回路を試してみたのですがうまくいきませんでした（要検証）。なので、検索した結果、トランジスタを2つ使用した回路が良く使われているようです。&lt;/p>
&lt;p>回路図は以下の通りです。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>配線がジャングルになりながらも……&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>下記のプログラムを動かすと……&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;Arduino.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>() {
pinMode(&lt;span style="color:#ae81ff">3&lt;/span>,OUTPUT);
pinMode(&lt;span style="color:#ae81ff">4&lt;/span>,OUTPUT);
Serial.begin(&lt;span style="color:#ae81ff">115200&lt;/span>);
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>() {
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>; i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">+&lt;/span>){
delay(&lt;span style="color:#ae81ff">242&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">4&lt;/span>,HIGH);
delay(&lt;span style="color:#ae81ff">8&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">4&lt;/span>,LOW);
}
delay(&lt;span style="color:#ae81ff">237&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">3&lt;/span>,HIGH);
delay(&lt;span style="color:#ae81ff">3&lt;/span>);
val &lt;span style="color:#f92672">=&lt;/span> analogRead(&lt;span style="color:#ae81ff">5&lt;/span>);
delay(&lt;span style="color:#ae81ff">2&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">3&lt;/span>,LOW);
digitalWrite(&lt;span style="color:#ae81ff">4&lt;/span>,HIGH);
delay(&lt;span style="color:#ae81ff">8&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">4&lt;/span>,LOW);
val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1023&lt;/span> &lt;span style="color:#f92672">-&lt;/span> val;
val &lt;span style="color:#f92672">=&lt;/span> val &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
Serial.println(val);
&lt;span style="color:#75715e">// 3msec loop
&lt;/span>&lt;span style="color:#75715e">&lt;/span> delay(&lt;span style="color:#ae81ff">3000&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>自室ではこのようにデータが取れました。部屋の中では約345、ユニットバスの中では約360です。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>これをM5Stackに応用していきます。&lt;/p>
&lt;h3 id="m5stack">M5Stackに実装&lt;/h3>
&lt;p>M5StackにGPSモジュールをスタックします。そして、先ほどの回路図に従って回路をつくり、ジャンパワイヤを使ってM5Stackとつなげます。&lt;/p>
&lt;p>配線後は以下の様になります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="heading-3">プログラム&lt;/h2>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;M5Stack.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;TinyGPS++.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#&lt;/span>&lt;span style="color:#75715e">include&lt;/span> &lt;span style="color:#75715e">&amp;lt;Ambient.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
WiFiClient client;
Ambient ambient;
&lt;span style="color:#75715e">//臭気の強度が代入される変数////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#75715e">/////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//デザリングパスワード/////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//屋外で使用するのでスマートフォンのデザリングを使用します
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//これでAmbientにデータを送信できます
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//const char* ssid = &amp;#34;yourSSID&amp;#34;;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">//const char* password = &amp;#34;yourPW&amp;#34;;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//Ambientの設定//////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> channelId &lt;span style="color:#f92672">=&lt;/span> yourID; &lt;span style="color:#75715e">// AmbientのチャネルID
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> writeKey &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">yourWriteKey&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// ライトキー
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//GPSの設定/////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>HardwareSerial &lt;span style="color:#a6e22e">GPS_s&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>);
TinyGPSPlus gps;
&lt;span style="color:#75715e">////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setup&lt;/span>(){
&lt;span style="color:#75715e">//WiFi////////////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> WiFi.begin(ssid, password); &lt;span style="color:#75715e">// Wi-Fi APに接続
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (WiFi.status() &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#f92672">=&lt;/span> WL_CONNECTED) { &lt;span style="color:#75715e">// Wi-Fi AP接続待ち
&lt;/span>&lt;span style="color:#75715e">&lt;/span> delay(&lt;span style="color:#ae81ff">100&lt;/span>);
}
&lt;span style="color:#75715e">//////////////////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//臭気センサ//////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> pinMode(&lt;span style="color:#ae81ff">21&lt;/span>,OUTPUT);
pinMode(&lt;span style="color:#ae81ff">22&lt;/span>,OUTPUT);
&lt;span style="color:#75715e">//////////////////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Serial.begin(&lt;span style="color:#ae81ff">115200&lt;/span>);
M5.begin();
GPS_s.begin(&lt;span style="color:#ae81ff">9600&lt;/span>);
ambient.begin(channelId, writeKey, &lt;span style="color:#f92672">&amp;amp;&lt;/span>client);
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>(){
&lt;span style="color:#66d9ef">char&lt;/span> buf[&lt;span style="color:#ae81ff">16&lt;/span>];
M5.Lcd.setCursor(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">70&lt;/span>);
M5.Lcd.setTextColor(WHITE, BLACK);
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>gps.location.isUpdated()){
&lt;span style="color:#66d9ef">while&lt;/span>(GPS_s.available()&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span>(gps.encode(GPS_s.read())){
&lt;span style="color:#66d9ef">break&lt;/span>;
}
}
}
Serial.printf(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">lat: %f, lng: %f&lt;/span>&lt;span style="color:#ae81ff">\r&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, gps.location.lat(), gps.location.lng());
M5.Lcd.printf(&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">lat: %f, lng: %f&lt;/span>&lt;span style="color:#ae81ff">\r&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, gps.location.lat(), gps.location.lng());
&lt;span style="color:#75715e">//GPS測定と臭気の測定&amp;amp;Ambientへ送信////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(M5.BtnA.wasPressed()){
&lt;span style="color:#75715e">//臭気をAmbientに送信///////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//計測データの平均値を送信//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>; i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#f92672">+&lt;/span>){
delay(&lt;span style="color:#ae81ff">242&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">22&lt;/span>,HIGH);
delay(&lt;span style="color:#ae81ff">8&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">22&lt;/span>,LOW);
}
delay(&lt;span style="color:#ae81ff">237&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">21&lt;/span>,HIGH);
delay(&lt;span style="color:#ae81ff">3&lt;/span>);
val &lt;span style="color:#f92672">=&lt;/span> analogRead(&lt;span style="color:#ae81ff">36&lt;/span>);
delay(&lt;span style="color:#ae81ff">2&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">21&lt;/span>,LOW);
digitalWrite(&lt;span style="color:#ae81ff">22&lt;/span>,HIGH);
delay(&lt;span style="color:#ae81ff">8&lt;/span>);
digitalWrite(&lt;span style="color:#ae81ff">22&lt;/span>,LOW);
val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1023&lt;/span> &lt;span style="color:#f92672">-&lt;/span> val;
val &lt;span style="color:#f92672">=&lt;/span> val &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
Serial.println(val);
&lt;span style="color:#75715e">// 3msec loop
&lt;/span>&lt;span style="color:#75715e">&lt;/span> delay(&lt;span style="color:#ae81ff">3000&lt;/span>);
ambient.set(&lt;span style="color:#ae81ff">1&lt;/span>,val);
&lt;span style="color:#75715e">/////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//経度・緯度をAmbientを送信///////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> dtostrf(gps.location.lat(),&lt;span style="color:#ae81ff">12&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,buf);
ambient.set(&lt;span style="color:#ae81ff">9&lt;/span>, buf);
dtostrf(gps.location.lng(), &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, buf);
ambient.set(&lt;span style="color:#ae81ff">10&lt;/span>, buf);
ambient.send();
&lt;span style="color:#75715e">/////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#75715e">//////////////////////////////////////////////////
&lt;/span>&lt;span style="color:#75715e">&lt;/span> m5.update();
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="heading-4">動作確認&lt;/h2>
&lt;p>実際に完成したデバイスを動かしてみます。&lt;/p>
&lt;p>M5Stackのボタンを押すと計測されたデータと位置情報がAmbientに表示されるようになりました。自室で試してみたところ以下の図のようになりました（具体的な地名は隠してあります）。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>屋内なのでGPSに誤差があるようですね。ですが、臭気の強さが強いほど赤く、弱いほど青くマッピングされていることがわかります。&lt;/p>
&lt;p>しかし、疑問があります。それは、**「臭気センサの値が高すぎる！」**ということです。&lt;/p>
&lt;p>Arduinoの値が信頼できそうなので、明らかにM5Stackで検出した値は間違っていると考えられます。回路は変更していないのですが……「なんでだろう？」という感じです……。&lt;/p>
&lt;h2 id="heading-5">とりあえずフィールドワーク&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>とりあえず、完成した（？）デバイスをもってフィールドワークに出かけてみます。公衆トイレを探しに行きます（在籍している大学で探します）。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>意外と公衆トイレはないものですね……。臭気の数値は正しい値ではないので、この臭気マップは参考になりませんが……&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>このデバイスにはどうやら改良が必要のようです……。&lt;/p>
&lt;h2 id="heading-6">おわりに&lt;/h2>
&lt;p>M5Stackと拡張モジュールのGPSを使うと簡単に位置情報を取得できることがわかりました。また、Ambientを使えばマッピングも自由自在です。&lt;/p>
&lt;p>さらにセンサを組み合わせて使えば、ロガーのようなものが簡単につくれるでしょう。&lt;/p>
&lt;p>しかし、今回は周期を計測する回路がArduinoでは正常で、M5Stackではうまく計測データがとれないという問題がおこりました。おそらく回路を改良する必要があると思います。&lt;/p>
&lt;p>どうやら、公衆トイレ1級判定士の道のりはまだまだ長いようです……。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></description></item><item><title>7セグメントディスプレイをArduinoで光らせよう！シフトレジスタでのピンの増やし方</title><link>https://dotstud.io/blog/segment-display-shift-register/</link><pubDate>Mon, 04 Jun 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/segment-display-shift-register/</guid><description>&lt;p>電子工作が趣味なAndroidエンジニアのとまとと申します。&lt;/p>
&lt;p>Arduinoはなんでもできて便利ですが、制御ピンの数に限りがあります。そのため、ピンをたくさん使いたいときは困ってしまいますよね。&lt;/p>
&lt;p>例えばLEDを100個くらい用意してそれぞれ一つずつパターンを決めて制御したいとき、当然ピンが足りなくなりますよね……。&lt;/p>
&lt;p>そんなときのために&lt;strong>制御ピンを増やすことができる方法&lt;/strong>を今回は紹介します！今回はたくさんのピンの制御が必要な7セグメントLEDディスプレイを少ないピンで光らせて見たいと思います。&lt;/p>
&lt;h2 id="heading">準備するもの&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>今回はArduino Uno、7セグメントLEDに加えて、出力を増やすことのできるシフトレジスタや、スイッチングをすることのできるトランジスタを使って行きます。&lt;/p>
&lt;h3 id="37led-72381bshttpakizukidenshicomcatalogggi-09084">小型3桁赤色7セグメントLED表示器 7ｍｍ高（&lt;a href="http://akizukidenshi.com/catalog/g/gI-09084/">2381BS&lt;/a>）&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>7セグメントLEDは7個のLEDを八の字に組み合わせた電子部品で、それぞれのLEDを独立して制御することにより、数字などを表現することができます。&lt;/p>
&lt;p>今回は2381BSという型番のものを使って行きます！&lt;/p>
&lt;h3 id="874hc595httpakizukidenshicomcatalogggi-08605">8ビットシフトレジスタ（&lt;a href="http://akizukidenshi.com/catalog/g/gI-08605/">74HC595&lt;/a>）&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>シフトレジスタは、簡単に説明すると&lt;strong>一つの出力を複数に増やすことのできる電子部品&lt;/strong>のことです。&lt;/p>
&lt;p>マイコンボードのピンは個数が限られているので、複数のセンサ等を使いたいときはシフトレジスタを用いることにより、資源を有効に使うことができます。&lt;/p>
&lt;p>また、シフトレジスタは出力を増やす以外にも複数の入力を１つにまとめることもできます。&lt;/p>
&lt;h3 id="c1815httpakizukidenshicomcatalogggi-04268-8">トランジスタ（&lt;a href="http://akizukidenshi.com/catalog/g/gI-04268/">C1815&lt;/a>） 8個&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>トランジスタには3本の端子があり、それぞれベース、コレクタ、エミッタと呼ばれます。コレクタ、エミッタ間を導通するかを、ベースに流すか流さないかで制御することができます。今回はこれをスイッチとして使います。&lt;/p>
&lt;p>今回使うC1815は平らな面から見て左から順にエミッタ、コレクタ、ベースとなっています。&lt;/p>
&lt;h3 id="heading-1">その他&lt;/h3>
&lt;ul>
&lt;li>カーボン抵抗（&lt;a href="http://akizukidenshi.com/catalog/g/gR-16151/">150Ω&lt;/a>） × 8&lt;/li>
&lt;li>カーボン抵抗（&lt;a href="http://akizukidenshi.com/catalog/g/gR-16273/">25KΩ&lt;/a>） × 8&lt;/li>
&lt;li>ブレッドボード&lt;/li>
&lt;li>ジャンパ線&lt;/li>
&lt;li>Arduino Unoまたは互換機&lt;/li>
&lt;/ul>
&lt;h2 id="heading-2">配線してみよう&lt;/h2>
&lt;p>今回は初心者の方に取ってはあまり馴染みのないパーツも多いと思うので、それぞれ基本の回路の組み方から見ていきたいと思います。&lt;/p>
&lt;p>とにかく7セグの回路が知りたい！と言う方は「&lt;strong>7セグとトランジスタ、シフトレジスタの配線方法&lt;/strong>」の項目を見てみてください。&lt;/p>
&lt;h3 id="heading-3">トランジスタの配線方法&lt;/h3>
&lt;p>まずはトランジスタの使い方から見てみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>コレクタに制御したいピン（LEDなど）をつなぎ、ベースに制御するピン（Arduinoの13番など）をつなぎます。最後に、エミッタをGNDに繋げば回路の完成です。ベースのオンオフによってLEDをつけたり消したりすることができます。&lt;/p>
&lt;h3 id="heading-4">シフトレジスタの配線方法&lt;/h3>
&lt;p>シフトレジスタの回路の組み方は次のようになります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>シフトレジスタの16番・10番を5Vに、13番・8番をGNDに繋いでいます。14、12、11番はそれぞれ、Arduinoの制御ピン（11、10、9番）に繋いでいます。&lt;/p>
&lt;p>余ってる8つのピンをLEDのアノード（+）に繋ぎ、LEDのカソード（−）を抵抗を経由してGNDに繋げば完成です。&lt;/p>
&lt;h3 id="7">7セグとトランジスタ、シフトレジスタの配線方法&lt;/h3>
&lt;p>さて、いよいよ7セグを光らせてみましょう！回路は以下の図です。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>配線がかなり多くなるので、&lt;a href="http://akizukidenshi.com/catalog/g/gP-02315/">短いジャンパ&lt;/a>を駆使するのがオススメです。&lt;/p>
&lt;p>これで回路は完成です。&lt;/p>
&lt;h2 id="heading-5">プログラムを書き込もう&lt;/h2>
&lt;p>では、次のプログラムをコピペしてArduino IDEを使ってボードに書き込みましょう！&lt;code>int num = 7&lt;/code>には光らせたい数字を代入します。&lt;/p>
&lt;p>プログラムの仕様は回路の組み方によって変わるため、今回は同じように組んでください。&lt;/p>
&lt;pre>&lt;code>#define DATA 11
#define LATCH 10
#define CLOCK 9
// 0b10000000 DP
// 0b01000000 D
// 0b00100000 E
// 0b00010000 F
// 0b00001000 A
// 0b00000100 G
// 0b00000010 C
// 0b00000001 B
static const int num[] {
0b01111011, //ZERO
0b00000011, //ONE
0b01101101, //TWO
0b01001111, //THREE
0b00010111, //FOUR
0b01011110, //FIVE
0b01110110, //SIX
0b00001011, //SEVEN
0b01111111, //EIGHT
0b01011111, //NINE
};
int count;
void setup()
{
count = 0;
pinMode(DATA, OUTPUT);
pinMode(LATCH, OUTPUT);
pinMode(CLOCK, OUTPUT);
pinMode(1, OUTPUT);
pinMode(2, OUTPUT);
pinMode(3, OUTPUT);
}
void loop()
{
digitalWrite(1, HIGH);
digitalWrite(2, HIGH);
digitalWrite(3, HIGH);
digitalWrite(LATCH, LOW);
shiftOut(DATA, CLOCK, 8, num[count]);
digitalWrite(LATCH, HIGH);
delay(1000);
if (count == 9)
count = 0;
else
count++;
}
&lt;/code>&lt;/pre>&lt;h3 id="heading-6">プログラムの解説&lt;/h3>
&lt;p>プログラムの一部を解説していきます。&lt;/p>
&lt;pre>&lt;code>#define DATA 11
#define LATCH 10
#define CLOCK 9
// 0b10000000 DP
// 0b01000000 D
// 0b00100000 E
// 0b00010000 F
// 0b00001000 A
// 0b00000100 G
// 0b00000010 C
// 0b00000001 B
static const int num[] {
0b01111011, //ZERO
0b00000011, //ONE
0b01101101, //TWO
0b01001111, //THREE
0b00010111, //FOUR
0b01011110, //FIVE
0b01110110, //SIX
0b00001011, //SEVEN
0b01111111, //EIGHT
0b01011111, //NINE
};
int count; // カウンタ
&lt;/code>&lt;/pre>&lt;p>ここでは使うピンと、7セグを光らせるパターンの定義をしています。&lt;/p>
&lt;pre>&lt;code>void setup()
{
count = 0;
pinMode(DATA, OUTPUT);
pinMode(LATCH, OUTPUT);
pinMode(CLOCK, OUTPUT);
pinMode(1, OUTPUT);
pinMode(2, OUTPUT);
pinMode(3, OUTPUT);
}
&lt;/code>&lt;/pre>&lt;p>ここでは、Arduinoから出力をするピンを指定します。&lt;/p>
&lt;pre>&lt;code>void loop()
{
digitalWrite(1, HIGH);
digitalWrite(2, HIGH);
digitalWrite(3, HIGH);
digitalWrite(LATCH, LOW);
shiftOut(DATA, CLOCK, 8, num[count]);
digitalWrite(LATCH, HIGH);
delay(1000);
if (count == 9)
count = 0;
else
count++;
}
&lt;/code>&lt;/pre>&lt;p>ここで、1、2、3番ピンを全てHIGHにしていますが、LOWに切り替えることにより各7セグを制御することができます。&lt;/p>
&lt;p>表示したい数字の配列を読み込み、&lt;code>shiftOut()&lt;/code>で光らせたいLEDのピンを指定します。&lt;/p>
&lt;p>LATCHピンをLOWにすることにより、&lt;code>shiftOut()&lt;/code>でデータを送ることができ、送信後HIGHにすることにより、実際にそれぞれのLEDを光らせることができます。&lt;/p>
&lt;h2 id="heading-7">試してみる&lt;/h2>
&lt;p>上記のコードで&lt;code>int num = 7&lt;/code>を試してみると、このような感じで光らせることができます！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="heading-8">まとめ&lt;/h2>
&lt;p>シフトレジスタを用いた回路は電子工作をやりはじめた人には難しいかもしれませんが、初歩的なものの組み合わせでできているのでこの記事を見て試してみるのも面白いと思います。&lt;/p>
&lt;p>また今回使ったシフトレジスタは一つだけでしたが、複数組み合わせて身近なLCDディスプレイやLEDキューブ、自作のロボットの制御などのようなものを実現することができます。考え方次第でなんでも作ることができると思います！&lt;/p>
&lt;p>ぜひ試してみてください！&lt;/p></description></item><item><title>Raspberry Piとサーボモータで踊るはにわ制作</title><link>https://dotstud.io/blog/dancing-haniwa-servo-raspi/</link><pubDate>Fri, 01 Jun 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/dancing-haniwa-servo-raspi/</guid><description>&lt;p>あ、どうもはにわと申します。
港町横浜で専門学生やってるものづくりがそこそこ好きなメガネです。&lt;/p>
&lt;p>今回はですねタイトルと名前にあるように動く&lt;strong>┌|∵|┘&lt;/strong>←を作りたいと思うんですよね。&lt;/p>
&lt;p>なぜ作るか……なんですけども&lt;strong>何か大層なことを考えて趣味でものづくりする人ってそうそういない&lt;/strong>と思うんです（┌|∵|┘が作りたいだけ←）。&lt;/p>
&lt;p>今回はRaspberry Piとサーボモータを使って、&lt;strong>踊る┌|∵|┘&lt;/strong>を作ってみます！&lt;/p>
&lt;h2 id="raspberry-pi">Raspberry Pi？サーボモータ？┌|∵|┘？&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「&lt;a href="https://www.raspberrypi.org/">&lt;strong>Raspberry Pi&lt;/strong>&lt;/a>」は、Arduinoに似た何でもできると噂のつよいボードです。
強さの秘訣は内部でLinux OSが動いたり、直接ディスプレイやキーボード、マウス等を接続できたりすることで、超小型のパソコンと考えてもらって大丈夫です！&lt;/p>
&lt;p>LANケーブルを接続すればネットにも繋がり、中にはWi-Fiモジュールが搭載されていて無線で繋がるものもあります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「&lt;strong>サーボモータ&lt;/strong>」は、
普通のモータとは違い回転角度・速度を細かく調整することができ、ラジコンの翼の制御やロボットのアームの制御などに使われます。&lt;/p>
&lt;p>PWMという方法で制御するのですが、詳細は、ドキュメントの「&lt;a href="https://dotstud.io/docs/pulse-width-modulation/">PWM制御&lt;/a>」を参考にしてください。&lt;/p>
&lt;p>そして&lt;strong>┌|∵|┘&lt;/strong>です！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>みなさん知ってますよね！？可愛いですよねうん。説明不要ですようん。&lt;/p>
&lt;h2 id="heading">今回使うもの、欲しいもの&lt;/h2>
&lt;h3 id="raspberry-pi3httpakizukidenshicomcatalogggm-10414">&lt;a href="http://akizukidenshi.com/catalog/g/gM-10414/">Raspberry Pi3&lt;/a>&lt;/h3>
&lt;p>[&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="9g-sg-90httpakizukidenshicomcatalogggm-08761">&lt;a href="http://akizukidenshi.com/catalog/g/gM-08761/">マイクロサーボ9g SG-90&lt;/a>&lt;/h3>
&lt;p>[&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-1">ジャンパピン&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>各機器をつなぎ合わせるために使用します。うーん説明終わり！&lt;/p>
&lt;p>Amazon等で「&lt;a href="https://www.amazon.co.jp/s/ref=nb_sb_noss_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;url=search-alias%3Daps&amp;amp;field-keywords=%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%91%E3%83%94%E3%83%B3&amp;amp;rh=i%3Aaps%2Ck%3A%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%91%E3%83%94%E3%83%B3">&lt;strong>ジャンパピン&lt;/strong>&lt;/a>」などと検索してみると、かなり安価で大量に手に入ることがわかります。こんないらねえよ！と思いますよね？私も思います。&lt;/p>
&lt;h3 id="heading-2">ブレッドボード&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>「&lt;a href="https://www.amazon.co.jp/s/ref=nb_sb_noss_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;url=search-alias%3Daps&amp;amp;field-keywords=%E3%83%96%E3%83%AC%E3%83%83%E3%83%89%E3%83%9C%E3%83%BC%E3%83%89">&lt;strong>ブレッドボード&lt;/strong>&lt;/a>」と検索するとこんな感じの穴あきの板が手に入ります。ここに先ほどのピン等をさしていきます。&lt;/p>
&lt;p>ブレッドボードの使い方がよくわからない、という方は、ドキュメントの「&lt;a href="https://dotstud.io/docs/breadboard">&lt;strong>ブレッドボード&lt;/strong>&lt;/a>」を参照してください。&lt;/p>
&lt;h2 id="heading-3">実際に動かす&lt;/h2>
&lt;h3 id="heading-4">配線&lt;/h3>
&lt;p>こういった感じに配線していきましょう。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>モータを動かすにはパワーを使うため通常は別で電源を用意することが多いですが、1個だけでしたらラズパイからの給電で動くので接続していきましょう。&lt;/p>
&lt;p>SG90の黒をラズパイの「&lt;strong>GND&lt;/strong>」へ、SG90の赤はラズパイの「&lt;strong>5V&lt;/strong>」へ、そして黄色をラズパイの任意のピンへ接続します。今回は2番ピンに接続しておきましょう。近いですし。&lt;/p>
&lt;p>慣習的に5Vを赤、GNDを黒、その他はそれぞれ違う色のジャンパで繋ぐと見やすいです。わかりやすさって大事！！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>ラズパイのボード上にはピン名称の記載がありませんが、「&lt;a href="https://www.google.co.jp/search?q=raspberry+pi+%E3%83%94%E3%83%B3%E3%82%A2%E3%82%B5%E3%82%A4%E3%83%B3&amp;amp;safe=off&amp;amp;rlz=1C5CHFA_enJP706JP706&amp;amp;source=lnms&amp;amp;tbm=isch&amp;amp;sa=X&amp;amp;ved=0ahUKEwjRkLTTw6rbAhWIx7wKHYGRAMEQ_AUICigB&amp;amp;biw=1163&amp;amp;bih=895">Raspberry Pi ピンアサイン&lt;/a>」などと検索すると調べることができます。&lt;/p>
&lt;h3 id="heading-5">プログラム&lt;/h3>
&lt;p>ラズパイの初期設定等はとても詳しく説明してくださってる方がたくさんいるので割愛します！！！Python3とpipがあればOKです。&lt;/p>
&lt;p>SSH接続とかNotepad++とかで遠隔で書き込むのもありですが、それができる人は自分で頑張ってください。今回はラズパイに直接書き込んでいきましょう！&lt;/p>
&lt;p>ラズパイへ電源、HDMI、キーボードを接続しログイン。&lt;/p>
&lt;p>シェルが起動しましたら&lt;/p>
&lt;pre>&lt;code>$ pip3 install RPi.GPIO
&lt;/code>&lt;/pre>&lt;p>とPython上でGPIOを操作できるライブラリを落とします。&lt;/p>
&lt;pre>&lt;code>$ touch motor_test.py
$ nano motor_test.py
&lt;/code>&lt;/pre>&lt;p>でファイルを作成して編集モードにし、以下を記述していきます。&lt;/p>
&lt;pre>&lt;code>import RPi.GPIO as GPIO
import time
GPIO.setmode(GPIO.BCM)
gp_out = 2 // SG90の黄色を刺したピン
GPIO.setup(gp_out, GPIO.OUT)
motor = GPIO.PWM(gp_out, 50)
motor.start(0.0)
bot = 2.5
mid = 7.2
top = 12.0
motor.ChangeDutyCycle(bot)
time.sleep(0.5)
motor.ChangeDutyCycle(top)
time.sleep(0.5)
motor.ChangeDutyCycle(mid)
time.sleep(0.5)
GPIO.cleanup()
&lt;/code>&lt;/pre>&lt;p>ctrl + x で終了し、yキーで保存します。&lt;/p>
&lt;h3 id="heading-6">確認&lt;/h3>
&lt;p>プログラムを書き込めたら、動かしてみましょう。配線を確認し次のコマンドを叩きましょう。&lt;/p>
&lt;pre>&lt;code>$ python3 motor_test.py
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://dotstud.io/img/blog/170/9.gif" alt="">
おお！動いた！という事で&lt;code>ChangeDutyCycle()&lt;/code>の中身を変えることで好きな角度に変えることができます。とりあえずの指標として0、90、180度をtop、mid、botという変数に入れていますが、直接数値を入力してもOKです。&lt;/p>
&lt;h2 id="heading-7">モータを増やす。&lt;/h2>
&lt;p>一つのサーボモータを動かすことには成功しました。なので次はもっと増やしてみましょう。&lt;/p>
&lt;p>具体的には上のプログラムの使いまわしで大丈夫です。使うモータ毎に名前とどのピンを使うかを記述し、&lt;code>名前.ChangeDutyCycle()&lt;/code>とすると対応するサーボモータが作動するようになります。&lt;/p>
&lt;h3 id="heading-8">配線&lt;/h3>
&lt;p>では全部で3台動くように追加していきましょう！ラズパイからの給電ではSG90を3台も動かせないので、単3電池2本を追加して電力を補強しつつこういった感じに配線します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>電池の赤（+）をブレッドボードの+列へ、黒（-）をｰ列へ刺します。&lt;/p>
&lt;p>各サーボモータの赤をブレッドボードの+列に、サーボモーターの黒をブレッドボードの-列に、ラズパイのGNDをボードの-列へ接続し電源を確保します。&lt;/p>
&lt;p>そしてサーボモータの黄色はGPIO端子の対応するところ（今回は2、3、4番ピン）にぶっ刺します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Oh…ｺﾞﾁｬｺﾞﾁｬ……&lt;/p>
&lt;h3 id="heading-9">プログラム&lt;/h3>
&lt;p>さっき書いたプログラムのように記述します。さっきのを書き換えてもOKです！&lt;/p>
&lt;pre>&lt;code>import RPi.GPIO as GPIO
import time
GPIO.setmode(GPIO.BCM)
gp_out = 2
GPIO.setup(gp_out, GPIO.OUT)
right = GPIO.PWM(gp_out, 50)
right.start(0.0)
gp_out = 3
GPIO.setup(gp_out, GPIO.OUT)
left = GPIO.PWM(gp_out, 50)
left.start(0.0)
gp_out = 4
GPIO.setup(gp_out, GPIO.OUT)
chest = GPIO.PWM(gp_out, 50)
chest.start(0.0)
bot = 2.5
mid = 7.2
top = 12.0
right.ChangeDutyCycle(bot)
left.ChangeDutyCycle(bot)
time.sleep(0.5)
chest.ChangeDutyCycle(mid)
time.sleep(0.5)
right.ChangeDutyCycle(top)
chest.ChangeDutyCycle(bot)
time.sleep(0.5)
chest.ChangeDutyCycle(top)
right.ChangeDutyCycle(bot)
left.ChangeDutyCycle(top)
time.sleep(0.5)
chest.ChangeDutyCycle(mid)
right.ChangeDutyCycle(top)
left.ChangeDutyCycle(bot)
time.sleep(0.5)
GPIO.cleanup()
&lt;/code>&lt;/pre>&lt;p>こんな感じで！もう好きにやっちゃってくださいな。&lt;/p>
&lt;h2 id="heading-10">図工&lt;/h2>
&lt;p>それでは本題である&lt;strong>┌|∵|┘&lt;/strong>を作ります！皆さん童心に帰って好きな素材で作ってください！&lt;/p>
&lt;p>私は今回牛乳パックで作成していきます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>( ＾ω＾)&lt;!-- raw HTML omitted -->
≡⊃⊂≡&lt;!-- raw HTML omitted -->
こうしてこうして&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>( ＾ω＾)&lt;!-- raw HTML omitted -->
⊃ .. ⊂&lt;!-- raw HTML omitted -->
こうじゃ&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h2 id="heading-11">やったぜ&lt;/h2>
&lt;p>さあさあここまで来たんです！動かしましょうよ！ね！
&lt;strong>┌|∵|┘起動!!!!!&lt;/strong>
&lt;img src="https://dotstud.io/img/blog/170/14.gif" alt="">&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;!-- raw HTML omitted -->
と、いう事で好きにパーツを作ってもらえればどんなものも躍らせられますね……！！踊り自体もPythonで記述しているので、forやifを駆使すれば複雑な踊りだっていけます。ここから皆さんの創造力が試されますぞ！&lt;/p>
&lt;p>それでは長くなりましたがお疲れ様です！皆もなんか動かしてみようぜ！！&lt;/p></description></item><item><title>非接触ICタグで遊ぼう！ArduinoでRFIDリーダRC522を使う方法</title><link>https://dotstud.io/blog/arduino-use-rfid-reader/</link><pubDate>Wed, 09 May 2018 08:30:26 +0900</pubDate><guid>https://dotstud.io/blog/arduino-use-rfid-reader/</guid><description>&lt;p>こんにちは、ちゃんとくです。&lt;/p>
&lt;p>みなさんは「&lt;strong>認証機能&lt;/strong>」というとどんなイメージを持つでしょうか？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Webページを開いて、IDとパスワードを入力して、ログインして……。「&lt;strong>めんどくさい！もっと簡単に認証したい！&lt;/strong>」ということもありますよね。&lt;/p>
&lt;p>そんなときは&lt;strong>非接触ICタグ&lt;/strong>を使って、&lt;strong>ピッとして認証できる装置&lt;/strong>を作ってみましょう！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>今回はArduinoとRFIDリーダを使って、非接触ICタグをかざすと登録されたユーザかどうか判定するデバイスを作ってみます！&lt;/p>
&lt;p>※ただし今回の実装は&lt;strong>セキュリティ対策を施していない&lt;/strong>ので、ご家庭内や趣味の範囲でお試しください。&lt;/p>
&lt;h2 id="rfidnfcic">RFID？NFC？非接触IC？&lt;/h2>
&lt;p>「&lt;strong>RFID&lt;/strong>」とは、電磁界や電波を用いて情報を埋め込んだRFタグとやりとりする無線通信技術です。「&lt;strong>NFC&lt;/strong>」はRFタグの規格の一つで、正式名称は&lt;strong>Near Field Communication&lt;/strong>（近距離無線通信）と言います。&lt;/p>
&lt;p>非接触ICは、&lt;strong>読み取り端末にかざすことで通信ができる電池レスのIC&lt;/strong>です（電池内臓の場合もあります）。&lt;/p>
&lt;p>世界で利用されているMifare（マイフェア）カードやTaspoでは「ISO/IEC 14443 Type A」というNFCの規格、日本で利用されている交通系ICカードでは「FeliCa」という規格が主に利用されています。&lt;/p>
&lt;p>今回利用するRFIDリーダライタのRFID-RC522では、&lt;strong>FeliCa規格のICは読み取ることができません&lt;/strong>。FeliCaを利用したい場合はSony製の&lt;a href="https://www.sony.co.jp/Products/felica/consumer/index.html">PaSoRi&lt;/a>やFeliCaリーダライタ&lt;a href="https://www.switch-science.com/catalog/353/">RC-S620S&lt;/a>などを使ってみてください。&lt;/p>
&lt;h2 id="heading">今回使うもの&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>今回はArduinoまたは互換ボード（写真はGenuino 101）、RFIDリーダライタRC522、その他に判定用のLEDやブレッドボード、ジャンパワイヤを利用します。&lt;/p>
&lt;h3 id="arduino">Arduino/互換ボード&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Arduinoや互換ボードを利用すると、RC522ライブラリをそのまま使えて簡単です。写真ではGenuino 101（※）を使っていますが、今回使うピンの配置はArduino Unoと全く同じです。&lt;/p>
&lt;p>Arduino Mega、Nano v3、Microなども利用できますが、ピンの接続箇所が変わるので今回利用する&lt;a href="https://github.com/miguelbalboa/rfid">&lt;strong>MFRC522ライブラリ&lt;/strong>&lt;/a>の&lt;a href="https://github.com/miguelbalboa/rfid#pin-layout">Pin Layout&lt;/a>を参考に配線してください。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->※Genuino 101はBluetooth搭載のIntel製ボードで、色が好きなので多用しています。ディスコンになってしまったけど……。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h3 id="rfid-rc522">RFID-RC522&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>安価で入手しやすいRFIDリーダライタです。&lt;a href="https://github.com/miguelbalboa/rfid">ライブラリ&lt;/a>側でドキュメントとサンプルコードが用意されていて、Arduinoで扱いやすいです。過出力や電波の不要輻射を防ぐため、3.3Vで利用します。&lt;/p>
&lt;p>※RFID-RC522では、&lt;strong>FeliCa規格のICは読み取ることができません&lt;/strong>。FeliCaを利用したい場合はSony製の&lt;a href="https://www.sony.co.jp/Products/felica/consumer/index.html">PaSoRi&lt;/a>やFeliCaリーダライタ&lt;a href="https://www.switch-science.com/catalog/353/">RC-S620S&lt;/a>などを使ってみてください。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>例えばAmazonで「&lt;strong>RC522&lt;/strong>」を検索すると、&lt;!-- raw HTML omitted -->価格帯の違うものがたくさんでてきます&lt;!-- raw HTML omitted -->。&lt;strong>お届け時期&lt;/strong>や&lt;strong>発送元&lt;/strong>（Amazon.co.jpからだと安心かも）、&lt;strong>送料&lt;/strong>、&lt;strong>レビュー&lt;/strong> などに注意して購入しましょう！&lt;/p>
&lt;p>ちゃんとくは急いでいたので、Amazon.co.jpが発送する翌日受け取りできるものを購入しました。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>ピンヘッダは未実装の状態で届くので、好きな角度の方をはんだづけしておきます（かっこいい！と思ってくの字型のピンヘッダを使いましたが、タグによってはジャンパが邪魔してタッチしづらいです……）。&lt;/p>
&lt;h3 id="rfidnfc">RFID/NFCタグ&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>こちらもAmazonで「&lt;strong>NFCタグ&lt;/strong>」などと検索してみると、かなり安価で手に入ることがわかります。ステッカーを使えば、手持ちのキーホルダーなどを簡単にキーにすることができますね！&lt;/p>
&lt;p>RC522のセットを購入した場合はカードとキーホルダーがついてきますし、「&lt;strong>とりあえず試したいだけ&lt;/strong>」「&lt;strong>認識させたいICタグが既にある&lt;/strong>」という場合は購入しなくて大丈夫です。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>ちゃんとくは、**シオカラーズの2人（Splatoon）**に協力してもらおうと思います！！&lt;/p>
&lt;p>これは任天堂のamiiboというフィギュアなんですが、&lt;strong>ゲーム用のNFCを搭載&lt;/strong>していてRFIDリーダで情報を読み取ることができます。&lt;/p>
&lt;h2 id="heading-1">識別子を取得する&lt;/h2>
&lt;h3 id="heading-2">配線&lt;/h3>
&lt;p>&lt;a href="https://github.com/miguelbalboa/rfid">MFRC522ライブラリ&lt;/a>の&lt;a href="https://github.com/miguelbalboa/rfid#pin-layout">&lt;strong>Pin Layout&lt;/strong>&lt;/a>を参考に、ArduinoとRC522を接続していきます。Arduino Mega、Nano v3、Microなども利用できますが、ピンの接続箇所が変わるのでライブラリのREADMEを参照してください。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th align="left">Signal&lt;/th>
&lt;th align="left">MFRC522 Reader/PCD Pin&lt;/th>
&lt;th align="left">Arduino Uno Pin&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td align="left">RST/Reset&lt;/td>
&lt;td align="left">RST&lt;/td>
&lt;td align="left">9&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">SPI SS&lt;/td>
&lt;td align="left">SDA(SS)&lt;/td>
&lt;td align="left">10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">SPI MOSI&lt;/td>
&lt;td align="left">MOSI&lt;/td>
&lt;td align="left">11 / ICSP-4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">SPI MISO&lt;/td>
&lt;td align="left">MISO&lt;/td>
&lt;td align="left">12 / ICSP-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td align="left">SPI SCK&lt;/td>
&lt;td align="left">SCK&lt;/td>
&lt;td align="left">13/ICSP-3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記の表の通り、RC522のSignalの名前の部分を見て、対応するArduino Unoのピンに接続します。&lt;/p>
&lt;p>その他、RC522の「GND」はArduinoの「GND」へ、RC522の「3.3V」はArduinoの「3.3V」へ接続します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>慣習的に3.3Vを赤、GNDを黒、その他はそれぞれ違う色のジャンパで繋ぐと見やすいです。書いてある通りに繋ぐだけなので、落ち着いて接続しましょう！（IRQというピンは今回は使用しません）&lt;/p>
&lt;p>ブレッドボードの使い方がよくわからない、という方は、ドキュメントの「&lt;a href="https://dotstud.io/docs/breadboard/">&lt;strong>ブレッドボード&lt;/strong>&lt;/a>」を参照してください。&lt;/p>
&lt;h3 id="heading-3">プログラム&lt;/h3>
&lt;p>&lt;a href="https://www.arduino.cc/en/main/software">Arduino IDE&lt;/a>というソフトを使い、Arduinoにプログラムを書き込みます。インストール方法は、ドキュメントの「&lt;a href="https://dotstud.io/docs/arduinoide-setup/">&lt;strong>Arduino IDEをPCにインストール&lt;/strong>&lt;/a>」を参照してください。&lt;/p>
&lt;p>まずArduino IDEに、今回利用する&lt;a href="https://github.com/miguelbalboa/rfid">&lt;strong>MFRC522ライブラリ&lt;/strong>&lt;/a>をインストールします。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ ライブラリマネージャを開く&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>[スケッチ] &amp;gt; [ライブラリをインクルード] &amp;gt; [ライブラリを管理]を選択します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ MFRC522ライブラリをインストール&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>「MFRC」と検索し、MFRC522ライブラリをインストールします。&lt;/p>
&lt;p>エディタには下記のプログラムを貼り付けます。ライブラリの&lt;a href="https://github.com/miguelbalboa/rfid/blob/master/examples/DumpInfo/DumpInfo.ino">DumpInfoのサンプルコード&lt;/a>をそのまま利用しています。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;MFRC522.h&amp;gt;
constexpr uint8_t RST_PIN = 9; // Configurable, see typical pin layout above
constexpr uint8_t SS_PIN = 10; // Configurable, see typical pin layout above
MFRC522 mfrc522(SS_PIN, RST_PIN); // Create MFRC522 instance
void setup() {
Serial.begin(9600); // Initialize serial communications with the PC
while (!Serial); // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
SPI.begin(); // Init SPI bus
mfrc522.PCD_Init(); // Init MFRC522
mfrc522.PCD_DumpVersionToSerial(); // Show details of PCD - MFRC522 Card Reader details
Serial.println(F(&amp;quot;Scan PICC to see UID, SAK, type, and data blocks...&amp;quot;));
}
void loop() {
// Look for new cards
if ( ! mfrc522.PICC_IsNewCardPresent()) {
return;
}
// Select one of the cards
if ( ! mfrc522.PICC_ReadCardSerial()) {
return;
}
// Dump debug info about the card; PICC_HaltA() is automatically called
mfrc522.PICC_DumpToSerial(&amp;amp;(mfrc522.uid));
}
&lt;/code>&lt;/pre>&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>[ツール] &amp;gt; [ボード]は「&lt;strong>Arduino/Genuino 101&lt;/strong>」、[シリアルポート]は&lt;strong>Arduinoを接続したUSBポート&lt;/strong>を選択します（Windowsの方はCOMポート番号）。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>左上の「➡︎」をクリックしてプログラムを書き込みます。&lt;/p>
&lt;h3 id="heading-4">確認&lt;/h3>
&lt;p>プログラムを書き込めたら、タグの情報を確認します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>[ツール] &amp;gt; [シリアルモニタ]を開きます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>シリアルモニタを開いた状態でRFIDリーダにタグをかざすと、タグの情報が表示されます。&lt;/p>
&lt;p>登録したいタグをかざし、「&lt;strong>Card UID:&lt;/strong>」以降の部分（画像では消してある部分）をコピーしておきましょう。&lt;/p>
&lt;h2 id="heading-5">識別子を元に動作を変える&lt;/h2>
&lt;p>識別子を取得したNFCタグを「&lt;strong>認証するユーザ&lt;/strong>」、それ以外のタグを「&lt;strong>認証しないユーザ&lt;/strong>」として、Arduino側の動作を変えてみます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>認証するユーザの場合はLEDを青に、認証しないユーザの場合はLEDを赤に光らせるプログラムを作ってみます。&lt;/p>
&lt;h3 id="heading-6">配線&lt;/h3>
&lt;p>回路に、青と赤のLEDを追加します。配線するときは、一旦Arduinoを電源から外します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>青いLEDのアノード（＋側・脚が長い方）を8番ピンに、赤いLEDのアノードをアナログの3番ピンに繋ぎ、カソード（ー側）をそれぞれGNDに接続します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>─ 配線した状態（上の図とLEDの向きが逆になっています）&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-7">プログラム&lt;/h3>
&lt;p>先ほど取得した&lt;strong>タグの識別子とマッチしたら青いLED、それ以外は赤いLEDを光らせるプログラム&lt;/strong>を作成します。&lt;/p>
&lt;p>&lt;code>#defin UID&lt;/code>の部分は、ご自身が取得したタグの識別子に置き換えてください。また、今回赤いLEDはアナログ出力に接続しているので、&lt;code>AnalogWrite()&lt;/code>を利用して光量を0〜255で指定します。&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;MFRC522.h&amp;gt;
constexpr uint8_t RST_PIN = 9;
constexpr uint8_t SS_PIN = 10;
#define UID &amp;quot;xx xx xx xx xx xx xx&amp;quot; // 取得した識別子を記述
int led_blue = 8;
int led_red = 3;
MFRC522 mfrc522(SS_PIN, RST_PIN);
MFRC522::MIFARE_Key key;
void setup() {
Serial.begin(9600);
pinMode(led_blue, OUTPUT);
pinMode(led_red, OUTPUT);
while (!Serial);
SPI.begin();
mfrc522.PCD_Init();
mfrc522.PCD_DumpVersionToSerial();
Serial.println(F(&amp;quot;Scan PICC to see UID, SAK, type, and data blocks...&amp;quot;));
dump_byte_array(key.keyByte, MFRC522::MF_KEY_SIZE);
}
void loop() {
if ( ! mfrc522.PICC_IsNewCardPresent()) {
return;
}
if ( ! mfrc522.PICC_ReadCardSerial()) {
return;
}
String strBuf[mfrc522.uid.size];
for (byte i = 0; i &amp;lt; mfrc522.uid.size; i++) {
strBuf[i] = String(mfrc522.uid.uidByte[i], HEX);
if(strBuf[i].length() == 1){
strBuf[i] = &amp;quot;0&amp;quot; + strBuf[i];
}
}
String strUID = strBuf[0] + &amp;quot; &amp;quot; + strBuf[1] + &amp;quot; &amp;quot; + strBuf[2] + &amp;quot; &amp;quot; + strBuf[3] + &amp;quot; &amp;quot; + strBuf[4] + &amp;quot; &amp;quot; + strBuf[5] + &amp;quot; &amp;quot; + strBuf[6];
if ( strUID.equalsIgnoreCase(UID) ){
Serial.println(&amp;quot;chantoku&amp;quot;);
digitalWrite(led_blue, HIGH); // 青いLEDを光らせる
delay(1000); // 1秒待つ
digitalWrite(led_blue, LOW); // 青いLEDを消す
} else {
Serial.println(&amp;quot;error!&amp;quot;);
analogWrite(led_red, 180); // 赤いLEDを光らせる
delay(1000); // 1秒待つ
analogWrite(led_red, 0); // 赤いLEDを消す
}
}
void dump_byte_array(byte *buffer, byte bufferSize) {
for (byte i = 0; i &amp;lt; bufferSize; i++) {
Serial.print(buffer[i] &amp;lt; 0x10 ? &amp;quot; 0&amp;quot; : &amp;quot; &amp;quot;);
Serial.print(buffer[i], HEX);
}
}
&lt;/code>&lt;/pre>&lt;p>先ほどと同様の手順でArduinoにプログラムを書き込みます。これで完成です！&lt;/p>
&lt;h2 id="heading-8">試してみる&lt;/h2>
&lt;p>さっそく登録したタグを識別できるか試してみましょう。&lt;/p>
&lt;p>アオリちゃん（ピンクの子）が登録したタグ、ホタルちゃん（緑の子）は登録していないタグです。
&lt;a href="https://gyazo.com/2a2e957605e230f3d539f331c718f9b4">&lt;img src="https://i.gyazo.com/2a2e957605e230f3d539f331c718f9b4.gif" alt="https://gyazo.com/2a2e957605e230f3d539f331c718f9b4">&lt;/a>&lt;/p>
&lt;p>登録したアオリちゃんをタッチした時は青、登録していないホタルちゃんをタッチした時は赤を光らせることができました！&lt;/p>
&lt;h2 id="heading-9">まとめ&lt;/h2>
&lt;p>非接触通信、無線通信というと難しいイメージがありますが、かなり簡単に実装することができました！この機能を使ってタッチした時間を記録したり、タグの識別を利用して電気をつける場所を変えたりと、いろいろなことに活用できそうです。&lt;/p>
&lt;p>次回は&lt;strong>Wi-Fiに接続してタッチした時間を記録するデバイスの実装方法&lt;/strong>を紹介してみたいと思います。&lt;/p>
&lt;p>それではまた！&lt;/p></description></item><item><title>くるくる回して値を入力！ロータリエンコーダでインプットの幅を広げよう</title><link>https://dotstud.io/blog/mongoose-os-rotary-encoder/</link><pubDate>Mon, 26 Mar 2018 01:00:43 +0900</pubDate><guid>https://dotstud.io/blog/mongoose-os-rotary-encoder/</guid><description>&lt;p>どうも。森田(&lt;a href="https://twitter.com/morita_pac">@morita_pac&lt;/a>)です。&lt;/p>
&lt;p>ボタンを押してトリガー発動！センサー値をグラフにダイレクトアタック！IoTって最高かよ！&lt;/p>
&lt;p>ってみなさん感じていると思います。&lt;/p>
&lt;p>そこへ、新たなスパイスを投ずるべく、森田は&lt;!-- raw HTML omitted -->&lt;strong>ロータリエンコーダ&lt;/strong>&lt;!-- raw HTML omitted -->をおすすめします。&lt;/p>
&lt;h2 id="heading">ロータリエンコーダってなにかね？&lt;/h2>
&lt;p>&lt;strong>これです。&lt;/strong>
&lt;img src="https://dotstud.io/img/blog/154/1.png" alt="">
回転の機械的変位量を電気信号に変換してくれます。つまり、&lt;!-- raw HTML omitted -->くるくるくるくる回してデジタル入力できるアイテム。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>今回は&lt;strong>クリック有り&lt;/strong>（カチカチなってくれる）の&lt;strong>インクリメンタル式&lt;/strong>のロータリエンコーダを使って解説します。&lt;/p>
&lt;p>⇒ 参考: ロータリエンコーダ販売ページ（&lt;a href="https://jp.rs-online.com/web/c/passive-components/rotary-encoders/">RSコンポーネンツ&lt;/a>）&lt;/p>
&lt;p>さまざまな種類のロータリエンコーダがあるので、上記サイトなどを参照してみてください。今回利用したもの（EC12E2420801）も購入できます。&lt;/p>
&lt;h2 id="heading-1">インクリメンタル式って何！？&lt;/h2>
&lt;p>まだ引かないでください。。。&lt;/p>
&lt;p>まず、ロータリエンコーダには信号検出の異なる「インクリメンタル式」と「アブソリュート式」があります。&lt;/p>
&lt;h3 id="heading-2">アブソリュート式&lt;/h3>
&lt;p>回転位置が&lt;strong>絶対的な数値として出力される高精度な方式&lt;/strong>で、&lt;!-- raw HTML omitted -->電源断時でも回転位置を保持しておけることが特徴&lt;!-- raw HTML omitted -->です。その分お値段も少々お高めなものが多いです。&lt;/p>
&lt;p>回転方向も、数値の増減から判断できます。
&lt;img src="https://dotstud.io/img/blog/154/2.png" alt="">&lt;/p>
&lt;h3 id="heading-3">インクリメンタル式&lt;/h3>
&lt;p>&lt;strong>回転した角度だけパルス（短時間の電流）出力される方式&lt;/strong>で、今回使うロータリエンコーダの場合だと、&lt;!-- raw HTML omitted -->15度回転させるとカチッとする感触があり、その時1パルスが出力され、24パルス出力で1回転&lt;!-- raw HTML omitted -->となります。
&lt;img src="https://dotstud.io/img/blog/154/3.png" alt="">&lt;/p>
&lt;p>回転方向を検出するために、位相が異なるA層B層の2つの端子からパルスを出力する構造になっており、
例えば、&lt;!-- raw HTML omitted -->A→Bの順にパルスの変化があった場合は時計回り、B→Aの順にパルスの変化があった場合は反時計周りのように区別&lt;!-- raw HTML omitted -->することができます。
&lt;img src="https://dotstud.io/img/blog/154/4.png" alt="">
※イメージです。&lt;/p>
&lt;h2 id="heading-4">使えるようにしてみよう。&lt;/h2>
&lt;p>それでは、さっそくロータリエンコーダを使ってみるよ！&lt;/p>
&lt;p>今回は、ESP32、ESP8266などのボードにJavaScriptで書き込みができる「&lt;strong>Mongoose OS&lt;/strong>」を利用してみます。&lt;strong>なぜなら僕はMongoose OSが好きだから&lt;/strong>です。&lt;/p>
&lt;p>Arduino言語での開発に慣れていない方にとっては、シンプルでわかりやすく感じると思います。Arduino IDEを使った方法やサンプルコードも、先例がたくさんあるので調べてみてください！&lt;/p>
&lt;p>⇒ 参考: &lt;a href="https://sakura87.net/archives/2969">Arduino Unoでロータリーエンコーダを使う│SAKURA87.net&lt;/a>&lt;!-- raw HTML omitted -->
⇒ 参考: &lt;a href="http://nn-hokuson.hatenablog.com/entry/2017/03/26/102145">【Arduino】マウスホイール（ロータリーエンコーダ）の回転量を取得する│おもちゃラボ&lt;/a>&lt;/p>
&lt;p>Mongoose OSを導入するまでの手順は下記の記事を参照してください。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-5">用意したもの&lt;/h3>
&lt;ul>
&lt;li>Mongoose OS（導入方法は&lt;a href="https://dotstud.io/blog/mongoose-os-nefry-blink/">こちらの記事&lt;/a>を参考）&lt;/li>
&lt;li>ロータリエンコーダ（EC12E2420801）&lt;/li>
&lt;li>ESP32-DevKitC&lt;/li>
&lt;li>いい感じのブレッドボード&lt;/li>
&lt;li>10KΩ抵抗 2本&lt;/li>
&lt;li>ジャンパワイヤ 数本&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dotstud.io/img/blog/154/5.png" alt="">&lt;/p>
&lt;h3 id="heading-6">配線&lt;/h3>
&lt;p>下記の図を参考に配線してください。
&lt;img src="https://dotstud.io/img/blog/154/6.png" alt="">&lt;/p>
&lt;h3 id="heading-7">プログラム&lt;/h3>
&lt;p>&lt;!-- raw HTML omitted -->正回転（※）でプラス10、逆回転でマイナス10の数値をログに出力するプログラム&lt;!-- raw HTML omitted -->です。コピーしてMongoose OSで書き込みます。それぞれのコードの詳細はコメントに記載します。&lt;/p>
&lt;p>※…正回転はエンコーダの位置アドレスが増加する回転方向のことです。今回利用したロータリエンコーダの場合は時計回りが正回転、反時計回りが逆回転です。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js:init.js" data-lang="js:init.js">&lt;span style="color:#75715e">//GPIOのAPIを使えるようにします。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">load&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;api_gpio.js&amp;#39;&lt;/span>);
&lt;span style="color:#75715e">//ロータリエンコーダのA,Bのピンアサイン
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">pinA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">19&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">pinB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>;
&lt;span style="color:#75715e">//A,Bの状態を読みます。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stateA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">stateB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">50&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">rotate&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#75715e">//おまじない
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">set_mode&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>,&lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">MODE_INPUT&lt;/span>);
&lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">set_mode&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>,&lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">MODE_INPUT&lt;/span>);
&lt;span style="color:#75715e">//プラス1(正回転)を判断するための関数です。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">getRotationActA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">Acount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">AA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">AB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">AA&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">AB&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#a6e22e">AA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>);
&lt;span style="color:#a6e22e">AB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>);
&lt;span style="color:#a6e22e">Acount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Acount&lt;/span>;
};
&lt;span style="color:#75715e">//マイナス1(逆回転)を判断するための関数です。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">getRotationActB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">Bcount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">BA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">BB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">BA&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">BB&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
{
&lt;span style="color:#a6e22e">BA&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>);
&lt;span style="color:#a6e22e">BB&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>);
&lt;span style="color:#a6e22e">Bcount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Bcount&lt;/span>;
};
&lt;span style="color:#75715e">//Aにパルスが来た時に動くイベントです。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">set_button_handler&lt;/span>(&lt;span style="color:#a6e22e">pinA&lt;/span>, &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">PULL_UP&lt;/span>, &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">INT_EDGE_NEG&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#a6e22e">rotate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getRotationActA&lt;/span>();
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">rotate&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">rotate&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#a6e22e">count&lt;/span>);
}
}, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;span style="color:#75715e">//Bにパルスが来た時に動くイベントです。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">set_button_handler&lt;/span>(&lt;span style="color:#a6e22e">pinB&lt;/span>, &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">PULL_UP&lt;/span>, &lt;span style="color:#a6e22e">GPIO&lt;/span>.&lt;span style="color:#a6e22e">INT_EDGE_NEG&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#a6e22e">rotate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">getRotationActB&lt;/span>();
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">rotate&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>){
&lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span> &lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#a6e22e">rotate&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#a6e22e">count&lt;/span>);
}
}, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="heading-8">試してみよう。&lt;/h2>
&lt;p>書き込めたら、実際に試してみましょう。
&lt;img src="https://dotstud.io/img/blog/154/7.png" alt="">
Mongoose OSのコンソールからロータリエンコーダの値を確認することができます。&lt;/p>
&lt;p>下記はOLEDディスプレイに値を表示するようにしてみました。
&lt;img src="https://gyazo.com/52dce8bbfa4e37382bc964e1aef3109f.gif" alt="">
正回転で値が増え、逆回転で値が減っていきます！&lt;/p>
&lt;p>Mongoose OSの特徴とチャタリングの関係から、勢いよくロータリエンコーダを回すと正確に信号を捉えられません。解決できる方法があるぜ。という場合はご連絡くださいませ。&lt;/p>
&lt;h2 id="heading-9">さいごに&lt;/h2>
&lt;p>いかがでしたでしょうか。これで、&lt;strong>入力に新たな選択肢が加わった&lt;/strong>と思います。&lt;/p>
&lt;p>ロータリエンコーダにはボタン付きのものもあったりしますので、選択してボタンプッシュで送信のような機能が欲しい場合に使えると思います。&lt;/p>
&lt;p>初期搭載のスイッチやセンサからの入力に飽きてしまった方は、ぜひ試してみてください！&lt;/p></description></item><item><title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title><link>https://dotstud.io/blog/raspberry-pi-case-making/</link><pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate><guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid><description>&lt;p>こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong>ラズパイにはまってしまったラズパイ女子です&lt;/strong>。&lt;/p>
&lt;p>ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p>
&lt;p>しかしなかなか可愛いいケースがない……。&lt;strong>ないなら、作ってしまえばいい！！！&lt;/strong>&lt;/p>
&lt;p>ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p>
&lt;h2 id="heading">レーザーカッターを使える場所を探そう&lt;/h2>
&lt;p>今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong>工作機械を気軽に利用できるFabスペース&lt;/strong>を利用してみましょう！&lt;/p>
&lt;p>レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p>
&lt;p>何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p>
&lt;h3 id="fab">レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3>
&lt;p>初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p>
&lt;h4 id="fabcafehttpsfabcafecomtokyo">&lt;a href="https://fabcafe.com/tokyo/">◆FabCafe&lt;/a>&lt;/h4>
&lt;p>渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p>
&lt;h4 id="iotlabhttpscamijpiotlab">&lt;a href="https://cami.jp/iotlab/">◆IoTLab&lt;/a>&lt;/h4>
&lt;p>できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p>
&lt;h4 id="techshophttpwwwtechshopjp">&lt;a href="http://www.techshop.jp/">◆TechShop&lt;/a>&lt;/h4>
&lt;p>プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p>
&lt;h2 id="heading-1">ケースの形について調べてみよう&lt;/h2>
&lt;p>一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>ケースの形によってはかなり難易度が高そうです……。&lt;/p>
&lt;h3 id="heading-2">初心者にも作りやすいケースの形&lt;/h3>
&lt;ul>
&lt;li>凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li>
&lt;li>ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li>
&lt;/ul>
&lt;p>ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="heading-3">部材を集めよう&lt;/h2>
&lt;h3 id="heading-4">かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3>
&lt;p>&lt;strong>かわいいアクリルで作ればかわいいケースになる&lt;/strong>と信じて、素敵なアクリルを用意しましょう。&lt;/p>
&lt;p>アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong>実際に店舗に行ってみるのがオススメ&lt;/strong>です。&lt;/p>
&lt;p>ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href="https://www.miyukiacryl.tokyo/tokyo-acryl">デザインアクリル専門店 ミユキアクリル&lt;/a>」さんのような&lt;strong>デザインアクリル専門店&lt;/strong>もあるので、興味のある方は覗いてみましょう！&lt;/p>
&lt;p>※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p>
&lt;p>厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p>
&lt;p>好みのアクリルがない場合は、&lt;strong>UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong>という手もあります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p>
&lt;h3 id="heading-5">ネジやスペーサーなどのパーツ&lt;/h3>
&lt;p>支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="heading-6">必要なパーツ一覧&lt;/h3>
&lt;p>好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p>
&lt;ul>
&lt;li>ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li>
&lt;li>ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li>
&lt;li>アクリル板固定・ネジ M3（8mm）8本&lt;/li>
&lt;li>アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li>
&lt;li>アクリル（今回は厚さ3mmのもの）&lt;/li>
&lt;/ul>
&lt;p>アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/142/parts.png" alt="">
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p>
&lt;h2 id="heading-7">作り方&lt;/h2>
&lt;h3 id="step1-">step1. 型の準備&lt;/h3>
&lt;p>Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p>
&lt;p>ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href="https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y">&lt;strong>こちらのaiデータ&lt;/strong>&lt;/a>をそのまま使うこともできます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p>
&lt;ul>
&lt;li>カメラ：幅0.9mm × 高さ28mm&lt;/li>
&lt;li>GPIO：幅55mm × 高さ12mm&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;p>レーザーカッターには切る順番があり、「&lt;strong>彫刻 → 穴 → 切り落とし&lt;/strong>」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p>
&lt;p>これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p>
&lt;h3 id="step2-">step2. アクリルを裁断&lt;/h3>
&lt;p>今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/142/8.png" alt="">&lt;/p>
&lt;h3 id="step3-">step3. 組み立てる&lt;/h3>
&lt;p>まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p>
&lt;h3 id="heading-8">完成&lt;/h3>
&lt;p>自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src="https://dotstud.io/img/blog/142/10.png" alt="">
&lt;img src="https://dotstud.io/img/blog/142/11.png" alt="">&lt;/p>
&lt;h2 id="heading-9">まとめ&lt;/h2>
&lt;p>&lt;img src="https://dotstud.io/img/blog/142/12.png" alt="">
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p>
&lt;p>日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong>どこに連れて行ってもかわいいと言ってもらえる&lt;/strong>ので作りがいがありました。何より愛着がわきますね〜！&lt;/p></description></item><item><title>日本上陸！littleBits cloudBitモジュールでIFTTT連携してみた！</title><link>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</link><pubDate>Tue, 22 Aug 2017 19:43:42 +0900</pubDate><guid>https://dotstud.io/blog/littlebits-cloudbit-ifttt-blink/</guid><description>&lt;p>littleBits cloudBitモジュールの技適が通りまして、ついに日本でも使えることになったということで、早速littleBits cloudBitモジュールを購入してIFTTTと連携してみました。
&lt;img src="https://dotstud.io/img/blog/119/1.png" alt="">&lt;/p>
&lt;h2 id="littlebits-cloudbit">littleBits cloudBitモジュールとは&lt;/h2>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/2.png" alt="">
littleBits cloudBitモジュールは、磁石でつなげて簡単に電子工作ができる知育ブロックlittleBitsのモジュールのひとつ、littleBits Cloudが橋渡しとなってインターネットとやり取りできるモジュールです。&lt;/p>
&lt;p>詳しくはこちら → &lt;a href="https://littlebits.cc/cloudstart">Getting Started with your CloudBit&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/3.png" alt="">
橋渡しとなるlittleBits Cloudは、スマートフォンやPCからWEBアクセスできる CLOUD CONTROL APP や、LITTLEBITS APIによってREST APIでさらに深いところまで操作できるプログラミングできるLITTLEBITS APIといった入り口があります。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/4.png" alt="">
今回ご紹介するのは、もうひとつ。ノンプログラミングでインターネットのいろいろなことに接続できる&lt;a href="https://ifttt.com/login">IFTTT&lt;/a>とlittleBitsの連携についてお伝えします。&lt;/p>
&lt;p>たとえば、littleBitsモジュールでボタンを押すとメールが送られたり、SNSでいいねが押されるとlittleBitsのLEDが反応するようなIoTの仕組みをさっと作ることができます。&lt;/p>
&lt;h2 id="heading">今回の仕組み&lt;/h2>
&lt;p>今回の仕組みはGitHubでissueが上がるとBARGRAPH LEDが点灯する仕組みです。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/5.png" alt="">
ですが、ただBARGRAPH LEDが光るだけだと見落としてしまうので、100円ショップで買った光で動くソーラーゆらゆら（がいこつ）にLEDを照らして動かしてよりわかりやすくします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/6.png" alt="">
このような仕組みです。&lt;/p>
&lt;h2 id="heading-1">準備&lt;/h2>
&lt;h3 id="littlebits">littleBitsの準備&lt;/h3>
&lt;p>セットアップについてはすでに行われているものとします。&lt;a href="http://www.1ft-seabass.jp/memo/2017/08/09/cloudbit-setup-step-memo/">cloudBitモジュールのセットアップについてのメモ&lt;/a>についてもご参考下さい。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/7.png" alt="">
CLOUDBITパッケージに入っているものはcloudBitモジュール関連だけなので、別途写真のようにlittleBitから入力させるボタンモジュールや、出力を反応させるBARGRAPHモジュールは別途揃えておきましょう。また今回はソーラーゆらゆら（がいこつ）へうまくつなげるためにWIREモジュールも用意しておきます。&lt;/p>
&lt;ul>
&lt;li>CLOUDBITパッケージにあるもの
&lt;ul>
&lt;li>USB power adapter ケーブル&lt;/li>
&lt;li>USB POWER モジュール&lt;/li>
&lt;li>cloudBitモジュール&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>別途必要なもの
&lt;ul>
&lt;li>ボタンモジュール&lt;/li>
&lt;li>BARGRAPHモジュール&lt;/li>
&lt;li>WIREモジュール&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/8.png" alt="">
ソーラーゆらゆらを準備します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/9.png" alt="">
コンセントをつないだアダプターからUSBケーブルを差し込みます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/10.png" alt="">
USB POWERモジュールにUSBケーブルをつなぎます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/11.png" alt="">
USB POWERモジュール→ボタンモジュール→cloudBitモジュールまでつないで、接続されるまで待ちます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/12.png" alt="">
つづいて、cloudBitモジュールの先にWIREモジュールとBARGRAPH LEDモジュールをつなぎます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/13.png" alt="">
ソーラーゆらゆら（がいこつ）のソーラーパネル部分にガッとBARGRAPH LEDモジュールを当てます。マスキングテープで補強します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/14.png" alt="">
これで準備完了です。&lt;/p>
&lt;h3 id="cloud-control-app">CLOUD CONTROL APPの準備&lt;/h3>
&lt;p>cloudBitを管理している CLOUD CONTROL APP ページにログインしておきます。
&lt;img src="https://dotstud.io/img/blog/119/15.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/16.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/17.png" alt="">&lt;/p>
&lt;h3 id="ifttt">IFTTTの準備&lt;/h3>
&lt;p>IFTTTもlittleBitsとの関連付けを行うのでログインしておきます。
&lt;img src="https://dotstud.io/img/blog/119/18.png" alt="">&lt;/p>
&lt;p>こちらで準備完了です。&lt;/p>
&lt;h2 id="littlebits-cloudbitifttt">littleBits CloudBitモジュールとIFTTTの関連付け&lt;/h2>
&lt;p>さきほどログインしたCLOUD CONTROL APP ページでlittleBits CloudBitモジュールとIFTTTの関連付けを行います。
&lt;img src="https://dotstud.io/img/blog/119/19.png" alt="">&lt;/p>
&lt;p>下部のメニューでAUTOMATEを押します。
&lt;img src="https://dotstud.io/img/blog/119/20.png" alt="">&lt;/p>
&lt;p>AUTOMATEページに遷移するとIFTTTとのアクティベートを促されるので GO TO IFTTT.COM ボタンを押します。
&lt;img src="https://dotstud.io/img/blog/119/21.png" alt="">&lt;/p>
&lt;p>IFTTTのlittleBitsチャンネルに遷移するので、CONNECTを押します。
&lt;img src="https://dotstud.io/img/blog/119/22.png" alt="">&lt;/p>
&lt;p>すでにIFTTTとCLOUD CONTROL APPがログインしてあるので、アクティベート確認ページに遷移します。AUTHORIZEボタンを押して認証します。
&lt;img src="https://dotstud.io/img/blog/119/23.png" alt="">&lt;/p>
&lt;p>ログインが完了します。これで、IFTTTでlittleBitsと連携することができます。&lt;/p>
&lt;h2 id="githubifttt">GitHubサービスのIFTTTでの認証をする&lt;/h2>
&lt;p>GitHubでもIFTTTで使えるようにしておきましょう。上部のSearchからgithubを検索します。
&lt;img src="https://dotstud.io/img/blog/119/24.png" alt="">&lt;/p>
&lt;p>Servicesに出てきたGitHubをクリックします。
&lt;img src="https://dotstud.io/img/blog/119/25.png" alt="">&lt;/p>
&lt;p>GitHubのページに移動するのでConnectボタンを押します。
&lt;img src="https://dotstud.io/img/blog/119/26.png" alt="">&lt;/p>
&lt;p>GitHubのAuthrize IFTTTページに移動します。
&lt;img src="https://dotstud.io/img/blog/119/27.png" alt="">&lt;/p>
&lt;p>Authrize IFTTTCHannelsボタンを押して認証を済ませておきます。&lt;/p>
&lt;h2 id="littlebitsifttt">littleBitsのIFTTT連携の設定&lt;/h2>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/28.png" alt="">
右上にある自分のプロフィールメニューからNew Appletを選択します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/29.png" alt="">
New Appletをつくる画面に行きます。thisボタンをクリックします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/30.png" alt="">
Choose a serviceではgitと検索しGitHubをクリックします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/31.png" alt="">
今回は自分にissueが来たときに動作するようにしたいので、Any new issueをクリックします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/32.png" alt="">
つづいて動作のきっかけ this が作れたので、なにが起こるかの that を設定するため that ボタンを押します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/33.png" alt="">
Choose action service画面になるので、littleBitsと検索し、littleBitsアクションをクリックします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/34.png" alt="">
Choose action画面になるので、Set Output Levelをクリックします。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/35.png" alt="">
Complete action fields画面になるので以下のように設定します。&lt;/p>
&lt;ul>
&lt;li>Which cloudBit?
&lt;ul>
&lt;li>動かしたいcloudBit&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Level
&lt;ul>
&lt;li>100&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Duration
&lt;ul>
&lt;li>20 seconds&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/36.png" alt="">
設定が終わったら、下の方のCreate Actionボタンを押します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/37.png" alt="">
Review and finish画面に来るので、設定を確認します。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/38.png" alt="">
問題なければ、下の方のFinishボタンを押します。&lt;/p>
&lt;p>これで設定は完了です。&lt;/p>
&lt;h2 id="heading-2">動かしてみる&lt;/h2>
&lt;p>早速試しにissueをGitHubで作ってみましょう。
&lt;img src="https://dotstud.io/img/blog/119/39.png" alt="">&lt;/p>
&lt;p>今回は適当に作ってみます。
&lt;img src="https://dotstud.io/img/blog/119/40.png" alt="">
issues発行します。&lt;/p>
&lt;p>多少タイムラグがあるので5～10秒ほど待ってみます。&lt;/p>
&lt;p>&lt;img src="https://dotstud.io/img/blog/119/demo.gif" alt="">
無事動きました！&lt;/p>
&lt;h2 id="heading-3">まとめ&lt;/h2>
&lt;p>ということで、技適が通り日本上陸となった、littleBits cloudBitモジュールのIFTTT連携をお伝えしました。&lt;/p>
&lt;p>今回はIoTでも実装に手間がかかるインターネット上の反応をlittleBitsに降ろす仕組みを軸にお伝えしましたがIFTTTとlittleBits Cloudの連携は手軽に作れますね。IoTにおけるいろいろな技術要素が裏側でしっかり作られています。&lt;/p>
&lt;p>もちろん、IFTTTと連携するとAmazon Dash Buttonのような、ボタンを押すとツイートがされるようなlittleBitsからインターネットを動かす仕組みについても実現可能です。&lt;/p>
&lt;p>littleBitsの持つブロックを組み合わせて電子工作ができる手軽さに加えて、IFTTTが組み合わさることでインターネットもあたかもブロックのように扱えてるlittleBits cloudBitモジュール、ぜひ試してみてください！&lt;/p>
&lt;p>※今回の図表の一部では&lt;a href="http://icooon-mono.com/">アイコン素材ダウンロードサイト「icooon-mono」&lt;/a>さんの画像を利用いたしました。ありがとうございます。&lt;/p></description></item></channel></rss>