<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nodejs on dotstudio（ドットスタジオ）</title><link>https://dotstud.io/series/nodejs/</link><description>Recent content in Nodejs on dotstudio（ドットスタジオ）</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>© 2018 dotstudio inc.</copyright><lastBuildDate>Mon, 28 Jan 2019 00:51:35 +0900</lastBuildDate><atom:link href="/series/nodejs/" rel="self" type="application/rss+xml"/><item><title>ArduinoでTwitter連携！愛しのぬいぐるみトンピーちゃんに命を吹き込んでみた</title><link>https://dotstud.io/blog/arduino-nodejs-twitter-connect/</link><pubDate>Mon, 28 Jan 2019 00:51:35 +0900</pubDate><guid>https://dotstud.io/blog/arduino-nodejs-twitter-connect/</guid><description>
&lt;p&gt;皆さん、大好きなぬいぐるみが動き出したらいいなと思ったこと、ありませんか？&lt;/p&gt;
&lt;p&gt;今回は私の愛すべきお友達「トンピーちゃん」に命を吹き込むべく、プログラミング初心者の私がArduinoとTwitterの連携に挑戦してみました！&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;4&#34;&gt;こちらです！！&lt;/font&gt;
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/721a8190-3ffc-8bca-c4b3-774ee58d45e9.gif&#34; alt=&#34;ezgif.com-video-to-gif.gif&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;今回やること&#34;&gt;今回やること&lt;/h2&gt;
&lt;h3 id=&#34;実装の構成&#34;&gt;実装の構成&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://gyazo.com/a75b45dc702b385f5e32fcd3e39c5b64&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/a75b45dc702b385f5e32fcd3e39c5b64.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ざっくりの構成です。Node.jsでTwitterの「#tonpy」というハッシュタグを監視し、「move #tonpy」「stop #tonpy」というツイートがあったらArduinoを経由してトンピーちゃんが動いたり止まったりします。&lt;/p&gt;
&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの&lt;/h3&gt;
&lt;h4 id=&#34;こぐまのトンピーちゃん&#34;&gt;■こぐまのトンピーちゃん&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/210df088-f5f0-6f8a-e9ee-2a63f06e2364.jpeg&#34; alt=&#34;トンピー.jpg&#34; /&gt;
愛用のトンピーちゃんです。乾電池を入れるとピーヒャラドンドンします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;購入: &lt;a href=&#34;https://www.amazon.co.jp/%E3%82%A4%E3%83%AF%E3%83%A4-%E3%81%93%E3%81%90%E3%81%BE%E3%81%AE%E3%83%88%E3%83%B3%E3%83%94%E3%83%BC/dp/B0002U3OBA&#34;&gt;Amazon.co.jp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arduino-uno&#34;&gt;■Arduino Uno&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/c26d230d-e320-b73d-f15f-32d813e1294f.jpeg&#34; alt=&#34;Arduino Uno.jpg&#34; /&gt;
Arduino Unoは2010年に発売されたArduinoで、&lt;a href=&#34;https://store.arduino.cc/usa/arduino-uno-rev3&#34;&gt;Arduinoの公式サイト&lt;/a&gt;にも「&lt;strong&gt;電子工作初心者に最適&lt;/strong&gt;」と書いてあったのでこちらに決めました。&lt;/p&gt;
&lt;p&gt;購入にあたっては「Arduino 初心者」と調べヒットした「&lt;a href=&#34;https://www.amazon.co.jp/%E3%82%B9%E3%82%A4%E3%83%83%E3%83%81%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9-SSCI-GettingStartedArduinoKit-Arduino%E3%82%92%E3%81%AF%E3%81%98%E3%82%81%E3%82%88%E3%81%86%E3%82%AD%E3%83%83%E3%83%88/dp/B0025Y6C5G/ref=sr_1_fkmr1_2?ie=UTF8&amp;amp;qid=1544321570&amp;amp;sr=8-2-fkmr1&amp;amp;keywords=arduino+%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%88%E3%82%AD%E3%83%83%E3%83%88&#34;&gt;Arduinoをはじめようキット&lt;/a&gt;」を購入しました。&lt;/p&gt;
&lt;p&gt;&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/d7099cb0-97aa-8ff1-4e3d-b959e8139fb4.jpeg&#34;&gt;
─ Arduinoをはじめようキット
&lt;/center&gt;
Arduino Unoの他にブレッドボードや抵抗など電子工作を始めるにあたり必要なもの一式が揃っているため、すぐに始める事ができます。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;fet-pch-mosfet-2sjs527l-e-60v5a&#34;&gt;■FET（Pch MOSFET 2SJS527L-E 60V5A）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/88510174-eed9-e286-5343-3deeb08a7884.jpeg&#34; alt=&#34;I-08315.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;FETはロードスイッチとも呼ばれ、簡単にいうと外部からの電圧によって電流の流れを制御できるスイッチのようなもののようです。小さな電力で動作させる事ができます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/#回路を作成&#34;&gt;回路を作成&lt;/a&gt;で説明しますが、FETには「Pチャネル」と「Nチャネル」の2種類あります。今回はNチャネルのFETを利用します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;購入: &lt;a href=&#34;http://akizukidenshi.com/catalog/g/gI-07145/&#34;&gt;秋月電子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;node-jsをインストールしたpc&#34;&gt;■Node.jsをインストールしたPC&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/efcdf34b-504e-cc68-125a-0acadd815510.jpeg&#34; alt=&#34;IMG_9204.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;今回はNode.jsでプログラムを動かします。下記記事を参考にインストールしてみてください！&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;136&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/nodejs-install-use-nodebrew/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/136/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.jsを始めよう！nodebrewを使って5分で環境構築
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-12-15
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
nodebrewを使ったNode.jsのインストール方法をまとめました。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;ul&gt;
&lt;li&gt;筆者PC: mac OS HighSierra バージョン10.13.6&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Node.js: v10.10.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;その他&#34;&gt;■その他&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/eb369434-a5ff-e44a-c7b9-02a065030098.jpeg&#34; alt=&#34;IMG_9206.jpg&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/docs/breadboard/&#34;&gt;ブレッドボード&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/docs/jumperwire/#%E3%83%9F%E3%83%8E%E3%83%A0%E3%82%B7%E3%82%AF%E3%83%AA%E3%83%83%E3%83%97-%E3%83%AF%E3%83%8B%E5%8F%A3&#34;&gt;ワニ口クリップ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;抵抗（今回は220Ω）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;トンピーちゃんを解体&#34;&gt;トンピーちゃんを解体&lt;/h2&gt;
&lt;p&gt;まずはトンピーちゃんの導線を確認するため、少し解体します。
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/69ccd688-afb6-0715-124a-44d886fe3178.jpeg&#34; alt=&#34;IMG_6786.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/84c4fcd7-8c65-a0dc-1a84-ee75b5c2ef48.jpeg&#34; alt=&#34;IMG_9205.jpg&#34; /&gt;
電池の部分を取り外してみました。すると、導線は電池部分と本体でパックリ分かれている事が確認できました。今回はその部分にArduino Unoを繋げば回路の開/閉が制御できそうですね。&lt;/p&gt;
&lt;h2 id=&#34;arduino-unoとトンピーちゃんを連携&#34;&gt;Arduino Unoとトンピーちゃんを連携&lt;/h2&gt;
&lt;h3 id=&#34;回路を作成&#34;&gt;回路を作成&lt;/h3&gt;
&lt;p&gt;Arduino Unoから直接ON/OFFを制御しようとすると、電流が少なく回路を開/閉できませんでした。そこでArduino Unoとトンピーちゃんの間に&lt;strong&gt;FETを挿入&lt;/strong&gt;します。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/230/fet.png&#34; alt=&#34;fet&#34;&gt;
&lt;/center&gt;
&lt;p&gt;FETは、電圧の加え方の違いによって「Pチャネル」と「Nチャネル」の2種類に分かれます。今回はNチャネルのFETを利用します。&lt;/p&gt;
&lt;p&gt;また、回路の「+側」にFETを繋ぐことを「ハイサイド（スイッチ）」、-側に繋ぐことを「ローサイド（スイッチ）」と呼称します。今回はNチャネルなので、ローサイドにFETを繋ぎます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/d32c3f6f4b1de908ceced242cc2ba7f4.png&#34; alt=&#34;Image from Gyazo&#34; /&gt;&lt;/p&gt;
&lt;p&gt;最終的に上記のような回路図になりました。&lt;/p&gt;
&lt;h3 id=&#34;arduino-unoにプログラムを書き込む&#34;&gt;Arduino Unoにプログラムを書き込む&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/b544f541-a5ac-ee97-18a3-de3963210c92.png&#34; alt=&#34;スクリーンショット 2018-12-18 12.35.58.png&#34; /&gt;
ArduinoをUSBケーブルでPCに繋ぎ、アプリケーションでArduino IDEを開きます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/da16043a-121e-52e2-e395-3121a8a3e48f.png&#34; alt=&#34;スクリーンショット 2018-12-16 15.10.09.png&#34; /&gt;
ファイル→新規ファイルを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/2a42d894-497d-a0c4-5573-6a4c148fc5fe.png&#34; alt=&#34;スクリーンショット 2018-12-16 15.09.45.png&#34; /&gt;
ツール→ボード→繋いだArduino（今回はArduino Uno）を選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/9f5d63e2-454b-c637-ef5d-07550cccf8d5.png&#34; alt=&#34;スクリーンショット 2018-12-16 15.11.33.png&#34; /&gt;
ツール→シリアルポート→接続したArduinoを選択します。&lt;/p&gt;
&lt;p&gt;下記コードを新規ファイルにコピー&amp;amp;ペーストします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// pins
const int tonpyPin = 2;
void setup() {
// initialize serial:
Serial.begin(9600);
// make the pins outputs:
pinMode(tonpyPin, OUTPUT);
}
void loop() {
// if there&#39;s any serial available, read it:
while (Serial.available() &amp;gt; 0) {
char value = Serial.read();
if (value == &#39;p&#39;) {
digitalWrite(tonpyPin, HIGH);
} else if (value == &#39;q&#39;){
digitalWrite(tonpyPin, LOW);
} else{
digitalWrite(tonpyPin, LOW);
}
Serial.println(value);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/8ec32eee-c610-137c-febd-9408f22db6e1.png&#34; alt=&#34;スクリーンショット 2018-12-10 9.25.26.png&#34; /&gt;
左上にある「→」ボタンを押してマイコンボードに書き込みます。&lt;/p&gt;
&lt;p&gt;これでArduino Unoからの信号（p: スイッチON、q: スイッチOFF）でトンピーちゃんが動く/止まるようになりました。&lt;/p&gt;
&lt;p&gt;これをツイートと連動できれば完成です！&lt;/p&gt;
&lt;h2 id=&#34;node-jsのプログラム&#34;&gt;Node.jsのプログラム&lt;/h2&gt;
&lt;p&gt;ハッシュタグ「#tonpy」を取得し、さらに「move」「stop」のツイートがあったらArduino Unoに送るプログラムを作成します。&lt;/p&gt;
&lt;h3 id=&#34;twitter-apiの準備&#34;&gt;Twitter APIの準備&lt;/h3&gt;
&lt;p&gt;API使用には&lt;a href=&#34;https://developer.twitter.com/&#34;&gt;Twitter Developer&lt;/a&gt;へ登録する必要があります。登録の際、用途など英文で書く部分がありました（筆者はGoogle翻訳を駆使しました）。&lt;/p&gt;
&lt;p&gt;手順については下記の記事に詳しく書かれており、そちらに沿って登録しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考: &lt;a href=&#34;https://qiita.com/kngsym2018/items/2524d21455aac111cdee&#34;&gt;Twitter API 登録 (アカウント申請方法) から承認されるまでの手順まとめ　※2018年9月時点の情報&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tweetを取得するnode-jsのプログラムを作成&#34;&gt;Tweetを取得するNode.jsのプログラムを作成&lt;/h3&gt;
&lt;h4 id=&#34;ディレクトリを用意&#34;&gt;■ディレクトリを用意&lt;/h4&gt;
&lt;p&gt;任意の保存場所にフォルダを用意します。今回はDesktopにTonpyフォルダを作りました。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;jsファイルを作成&#34;&gt;■JSファイルを作成&lt;/h4&gt;
&lt;p&gt;作成したフォルダに任意の名前のJSファイルを用意します。今回は「app.js」としました。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;twitter-apiを使用するモジュールのインストール&#34;&gt;■Twitter APIを使用するモジュールのインストール&lt;/h4&gt;
&lt;p&gt;Node.jsでTwitter APIが使用できるよう&lt;a href=&#34;https://www.npmjs.com/package/twitter&#34;&gt;Twitterモジュール&lt;/a&gt;をnpmでインストールします。ターミナルで作成したフォルダを開き、下記コマンドを叩きます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install twitter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでNode.jsでTwitter APIが使用できるようになりました。&lt;/p&gt;
&lt;p&gt;実際に使用する際はJSファイル内で最初に下記のように書くとTwitter APIが呼び出されます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Twitter = require(&#39;twitter&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;ツイートを取得するプログラムを作成&#34;&gt;■ツイートを取得するプログラムを作成&lt;/h4&gt;
&lt;p&gt;TwitterAPIには「REST API」と「Streaming API」の2種類があります。&lt;/p&gt;
&lt;p&gt;REST APIはエンドポイントへリクエストして初めて結果が得られるものに対して、Streaming APIはレートのリミットなくツイートを受信し続ける事ができます。&lt;/p&gt;
&lt;p&gt;今回はツイートを常に監視し該当のツイートがあったら結果を取得する、という事がしたいので&lt;strong&gt;Streaming API&lt;/strong&gt;を使用します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const twitter = require(&amp;quot;twitter&amp;quot;);
const fs = require(&amp;quot;fs&amp;quot;);
const client = new twitter({
consumer_key: &#39;&#39;,//Dev Accountで取得したkeyを書く
consumer_secret: &#39;&#39;,
access_token_key: &#39;&#39;,
access_token_secret: &#39;&#39;,
});
let tweetText =&#39;w&#39;;
client.stream(&#39;statuses/filter&#39;, {track:&amp;quot;#tonpy &amp;quot;}, (stream) =&amp;gt; {//Streaming APIを呼び出す
stream.on(&#39;data&#39;, (tweet) =&amp;gt; {
tweetText = tweet.text;
(~tweetText.indexOf(&#39;move&#39;)) ? (tweetText = &#39;p&#39;) : (~tweetText.indexOf(&#39;stop&#39;)) ? (tweetText = &#39;q&#39;) : (tweetText = &#39;w&#39;);
});
stream.on(&#39;error&#39;, (error) =&amp;gt; {//エラー
console.error(`Error: ${error.message}`);
stream.destroy();
});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ツイートを取得するNode.jsのプログラムが完成しました。&lt;/p&gt;
&lt;h3 id=&#34;arduinoに送るプログラムを作成&#34;&gt;Arduinoに送るプログラムを作成&lt;/h3&gt;
&lt;h4 id=&#34;シリアル通信をするモジュールのインストール&#34;&gt;■シリアル通信をするモジュールのインストール&lt;/h4&gt;
&lt;p&gt;PCとArduino間でシリアル通信をするために、シリアルポートでシリアル通信を行うモジュールもnpmでインストールします。&lt;/p&gt;
&lt;p&gt;シリアルポートとは&lt;strong&gt;シリアル通信を行う時の接続口&lt;/strong&gt;のことで、今回はArduinoと接続したPCのUSBポートにあたります。&lt;/p&gt;
&lt;p&gt;ターミナルで下記コマンドを叩きます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install serialport
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでNode.jsでシリアルポートを制御できるようになりました。&lt;/p&gt;
&lt;p&gt;使用する際はJSファイル内で最初に下記のように呼び出します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Serialport = require(&#39;serialport&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;シリアルポートの名前を調べる&#34;&gt;■シリアルポートの名前を調べる&lt;/h4&gt;
&lt;p&gt;プログラム内では、USBポートに挿しているArduino Uno（ttyデバイス）を指定します。&lt;/p&gt;
&lt;p&gt;ターミナルで下記コマンドを打ち、PCのシリアルポートに接続されている機器を表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls -l /dev/tty.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Auduino Unoを挿し、もう一度先ほどのコマンドを打ちます。新しく出てきたttyデバイス名がArduino Unoです。&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;arduino-unoに送るnode-jsのプログラムを作成&#34;&gt;■ Arduino Unoに送るNode.jsのプログラムを作成&lt;/h4&gt;
&lt;p&gt;下記がシリアル通信するためのコードです。ツイートを取得するためのJSファイルの続きに記述してください。&lt;/p&gt;
&lt;p&gt;1行目の&lt;code&gt;/dev/tty.xxx&lt;/code&gt;には上記のシリアルポート名を記入してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const port = new SerialPort(&#39;/dev/tty.xxx&#39;,{
baudRate: 9600//baudRate:9600は1秒に最大9600ビットを送信するという意味
});
port.write(&#39;main screen turn on&#39;, function(err) {
if (err) {
return console.log(&#39;Error on write: &#39;, err.message);
}
console.log(&#39;message written&#39;);
});
port.on(&#39;open&#39;, () =&amp;gt; {
console.log(&#39;Serial open.&#39;);
setInterval(write, 1000);
});
const write = () =&amp;gt; {
console.log(`Input to Arduino: ${tweetText}`);
port.write(tweetText, (error) =&amp;gt; {
if(error) {
console.error(`Error: ${error.message}`);
}
});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでツイート情報を取得し、Arduinoに信号を送る事ができるようになりました。&lt;/p&gt;
&lt;h3 id=&#34;完成コード&#34;&gt;完成コード&lt;/h3&gt;
&lt;p&gt;ツイートを取得するプログラム、Arduinoを制御するプログラムを合わせた完成コードは下記のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//-----------------------------------------------
// twitterからツイートを取得
//-----------------------------------------------
const twitter = require(&amp;quot;twitter&amp;quot;);
const client = new twitter({
consumer_key: &#39;&#39;,//Dev Accountで取得したkeyを書く
consumer_secret: &#39;&#39;,
access_token_key: &#39;&#39;,
access_token_secret: &#39;&#39;,
});
let tweetText =&#39;w&#39;;
client.stream(&#39;statuses/filter&#39;, {track:&amp;quot;#tonpy &amp;quot;}, (stream) =&amp;gt; {
stream.on(&#39;data&#39;, (tweet) =&amp;gt; {
tweetText = tweet.text;
(~tweetText.indexOf(&#39;move&#39;)) ? (tweetText = &#39;p&#39;) : (~tweetText.indexOf(&#39;stop&#39;)) ? (tweetText = &#39;q&#39;) : (tweetText = &#39;w&#39;);
});
stream.on(&#39;error&#39;, (error) =&amp;gt; {
console.error(`Error: ${error.message}`);
stream.destroy();
});
});
//-----------------------------------------------
// Node.jsからArduinoに送信
//----------------------------------------------
const SerialPort = require(&#39;serialport&#39;);
const port = new SerialPort(&#39;/dev/tty.xxx&#39;,{
baudRate: 9600
});
port.on(&#39;open&#39;, () =&amp;gt; {
console.log(&#39;Serial open.&#39;);
setInterval(write, 1000);
});
port.on(&#39;data&#39;, (data) =&amp;gt; {
console.log(`Data from Arduino: ${data}`);
});
const write = () =&amp;gt; {
console.log(`Input to Arduino: ${tweetText}`);
port.write(tweetText, (error) =&amp;gt; {
if(error) {
console.error(`Error: ${error.message}`);
}
});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&#34;node-jsを実行する&#34;&gt;■Node.jsを実行する&lt;/h4&gt;
&lt;p&gt;Node.jsは、ファイルのある場所で下記コマンドで実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node app.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;部分は、ご自身が作成したファイル名に置き換えてください。「Serial open」がターミナル上に表示されたら無事実行されています。&lt;/p&gt;
&lt;h2 id=&#34;動かしてみる&#34;&gt;動かしてみる&lt;/h2&gt;
&lt;p&gt;Node.jsを起動しながら、ツイートしてみましょう……。「&lt;strong&gt;#tonpy move&lt;/strong&gt;」!!!!!
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/309368/9c8c2611-d9b2-e7dd-3710-8d2011c2b424.gif&#34; alt=&#34;ezgif.com-video-to-gif.gif&#34; /&gt;&lt;/p&gt;
&lt;p&gt;う、動いたーーーー！！！（少々タイムラグがありますが……。）&lt;/p&gt;
&lt;p&gt;初めてのIoTとっっても楽しかったです！電子工作やNode.jsの勉強にもなり一石二鳥ですね。&lt;/p&gt;
&lt;p&gt;これから色々作っていきたいです！&lt;/p&gt;
&lt;style&gt;
.caution {
border: 1px solid #BFBFBF;
padding: 1em 2em;
margin: 2em 0;
color: #474747;
background: whitesmoke;/*背景色*/
border-left: double 7px #0B0B61;/*左線*/
font-size: 90%;
}
.caution &gt; p {
font-weight: bold;
margin: 0 0 10px 0;
padding: 0;
}
blockquote {
font-size:80%;
}
.accbox {
margin: 2em 0;
padding: 0;
max-width: 710px;
}
.accbox label {
display: block;
margin: 1.5px 0;
padding : 11px 12px;
color :#ffffff;
font-weight: bold;
background :#2f2f2f;
cursor :pointer;
transition: all 0.5s;
}
.accbox label:hover {
background :#A4A4A4;
}
.accbox input {
display: none;
}
.accbox .accshow {
height: 0;
padding: 0;
overflow: hidden;
opacity: 0;
transition: 0.8s;
}
.cssacc:checked + .accshow {
height: auto;
padding: 5px;
background: #eaeaea;
opacity: 1;
}
&lt;/style&gt;</description></item><item><title>Moddable SDKを使ってJavaScriptでIoT開発してみた</title><link>https://dotstud.io/blog/developed-iot-using-moddable/</link><pubDate>Thu, 24 Jan 2019 00:51:35 +0900</pubDate><guid>https://dotstud.io/blog/developed-iot-using-moddable/</guid><description>
&lt;p&gt;どうも。&lt;a href=&#34;https://dotstud.io/members/horihiro&#34;&gt;ほりひろ&lt;/a&gt; です。
dotstudioブログでは、初めましてですね。&lt;/p&gt;
&lt;p&gt;JavaScript や IoT が好きな、でも実は半田付けも抵抗値の計算もろくにできないレベルの週末プログラマーです。
普段は某クラウドベンダーのサポートエンジニアをしています。
よろしくお願いします。&lt;/p&gt;
&lt;p&gt;Twitterアカウントは&lt;a href=&#34;https://twitter.com/hori__hiro&#34;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;
&lt;p&gt;年末に自分の中で話題になっていた、&lt;u&gt;&lt;strong&gt;Moddable SDK&lt;/strong&gt;&lt;/u&gt;というものをようやく触ってみました。&lt;/p&gt;
&lt;h2 id=&#34;moddable-sdk-xs&#34;&gt;Moddable SDK &amp;amp; XS&lt;/h2&gt;
&lt;h3 id=&#34;moddable-sdk&#34;&gt;Moddable SDK&lt;/h3&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/237/1.png&#34; alt=&#34;1&#34;&gt;
&lt;/center&gt;
&lt;p&gt;Moddable SDK は、&lt;strong&gt;JavaScript コードを ESP32 や ESP8266 といったマイコン上で動作させるためのビルド環境やライブラリー群&lt;/strong&gt;のこと、、、だと思います。&lt;/p&gt;
&lt;p&gt;これは Moddable 社から提供されていますが、&lt;u&gt;下記 GitHub リポジトリで公開されているので、無料で手に入れられます。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Moddable-OpenSource/moddable&#34;&gt;https://github.com/Moddable-OpenSource/moddable&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;xs&#34;&gt;XS&lt;/h3&gt;
&lt;p&gt;XS は、&lt;strong&gt;Moddable SDK で生成される JavaScript ランタイム環境&lt;/strong&gt; （ドキュメントには &lt;strong&gt;virtual machine&lt;/strong&gt; と記載）で、なんと &lt;a href=&#34;https://github.com/Moddable-OpenSource/moddable#modern-software-development-for-microcontrollers&#34;&gt;ES2018 に 99% 以上準拠&lt;/a&gt;しているらしいです。すごいですね！&lt;/p&gt;
&lt;p&gt;※一部準拠していない部分は、注意事項として&lt;strong&gt;&lt;a href=&#34;https://github.com/Moddable-OpenSource/moddable/blob/public/documentation/xs/XS%20Conformance.md#caveat&#34;&gt;こちら&lt;/a&gt;&lt;/strong&gt;に記載されています。&lt;/p&gt;
&lt;p&gt;これは&lt;a href=&#34;http://www.moddable.com/XS7-TC-39.php&#34;&gt;公式ドキュメント&lt;/a&gt;にある画像です。「XS は一番小さい」って意味でしょうね。シャレてます。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/237/2.png&#34; alt=&#34;2&#34;&gt;
&lt;/center&gt;
&lt;p&gt;ざっくりとした理解ですが、Moddable SDK のビルドツールで、自分が書いた JavaScript や C のソースコードと組み込みのクラスが含まれた XS を、一つのバイナリーにビルドし、マイコンに書き込んでいるようです。&lt;/p&gt;
&lt;p&gt;これまで JavaScript でのマイコン制御というと、以前から ホスト PC とマイコンをシリアル接続し、ホストPC上の Node.js と Johnny-Five を使ってマイコンを制御する方法があり、最近では obniz の制御をネットワークを介して JavaScript などから行う方法がありますが、いずれもマイコンの外に JavaScript の実行環境を用意する必要があります。&lt;/p&gt;
&lt;p&gt;一方で、Moddable SDK では、&lt;u&gt;JavaScript 実行環境である XS がマイコン上で動作することができます。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;この点は、&lt;strong&gt;これまでの実行環境とは大きく違うところですね！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;開発環境の構築&#34;&gt;開発環境の構築&lt;/h2&gt;
&lt;p&gt;基本的に、公式のリポジトリに記載された &lt;a href=&#34;https://github.com/Moddable-OpenSource/moddable/blob/public/documentation/Moddable%20SDK%20-%20Getting%20Started.md&#34;&gt;構築手順&lt;/a&gt;通りに実施することで、ビルド ツールなどの環境が構築できます。&lt;/p&gt;
&lt;p&gt;構築手順は macOS/Linux/Windows の各プラットフォーム向けにまとまっており、それぞれが、下記の 3 つのパートに分かれて記載されています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mcconfig&lt;/code&gt; や &lt;code&gt;xsbug&lt;/code&gt; などの開発ツールのビルド&lt;/li&gt;
&lt;li&gt;ESP8266 向けの開発環境の構築&lt;/li&gt;
&lt;li&gt;ESP32 向けの開発環境の構築&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;いずれのプラットフォームでも 1. は必須ですが、2. と 3. は手持ちのボードに合わせて、どちらかを実施するだけでよいです。&lt;/p&gt;
&lt;p&gt;私は Windows 用の環境構築をしましたが、Windows 向けの開発環境構築では、&lt;u&gt;&lt;strong&gt;Windows ネイティブのコマンドを使用することをお勧めします。&lt;/strong&gt;&lt;/u&gt;
WSL から &lt;code&gt;git clone&lt;/code&gt; などをすると、&lt;a href=&#34;https://github.com/Moddable-OpenSource/moddable/issues/110&#34;&gt;&lt;strong&gt;開発ツールがビルドできない&lt;/strong&gt;&lt;/a&gt;ようで、これに丸一日ハマりました。&lt;/p&gt;
&lt;p&gt;あと、ビルドツールの実行は、必ず&lt;code&gt;開発者コマンドプロンプト for VS2017&lt;/code&gt; を起動し、そのコマンドプロンプトの中でしましょう。&lt;/p&gt;
&lt;h2 id=&#34;サンプル-コード&#34;&gt;サンプル コード&lt;/h2&gt;
&lt;p&gt;マイコンのサンプルと言えば Lチカですが、手元に LED がなかったので、とりあえず ESP32 上での非同期実行を試してみます。&lt;/p&gt;
&lt;h3 id=&#34;ファイルの用意&#34;&gt;ファイルの用意&lt;/h3&gt;
&lt;p&gt;プロジェクト ディレクトリに下記のような構造で、ファイルを作ります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── esp
│ ├── console.c
│ └── console.js
├── main.js
└── manifest.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;main-js&#34;&gt;main.js&lt;/h3&gt;
&lt;p&gt;1 秒おきに &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;10&lt;/code&gt; の数字を、1.5 秒おきに &lt;code&gt;a&lt;/code&gt; から &lt;code&gt;z&lt;/code&gt; の文字を、シリアル コンソールに出力するプログラムです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js:main.js&#34;&gt;import Timer from &#39;timer&#39;;
import console from &amp;quot;console&amp;quot;;
const a = &#39;a&#39;;
const z = &#39;z&#39;;
let c = a;
let i = 0;
Timer.repeat(() =&amp;gt; {
console.log(`${String(Date.now()).padStart(15)}:${i}`);
i = (i &amp;gt;= 10) ? 0 : i + 1;
}, 1000);
Timer.repeat(() =&amp;gt; {
console.log(`${String(Date.now()).padStart(15)}:${c}`);
c = (c &amp;gt;= z) ? a : String.fromCharCode(c.charCodeAt(0) + 1);
}, 1500);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Web ブラウザーや Node.js なら、定期的な処理を書くなら &lt;code&gt;setInterval&lt;/code&gt; を使うところだと思いますが、Moddable SDK / XS では、グローバルに &lt;code&gt;setInterval&lt;/code&gt; が定義されていません。&lt;/p&gt;
&lt;p&gt;代わりに、&lt;code&gt;Timer&lt;/code&gt; オブジェクトの &lt;code&gt;repeat&lt;/code&gt; メソッドを使って、同じ処理が似たような感じで書くことができます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js:browser&amp;amp;nodejs&#34;&gt;setInterval(() =&amp;gt; {
:
}, 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js:XS&#34;&gt;import Timer from &#39;timer&#39;;
Timer.repeat(() =&amp;gt; {
:
}, 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;console-js-console-c&#34;&gt;console.js /console.c&lt;/h3&gt;
&lt;p&gt;実は XS では &lt;code&gt;console&lt;/code&gt; オブジェクトもないので、とりあえず、下記の JS ファイルと C ファイルで、シリアルコンソールに 1 行出力できるメソッドを定義しておきます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c:esp/console.js&#34;&gt;class Console @ &amp;quot;xs_console_destructor&amp;quot; {
constructor() {
}
static log() @ &amp;quot;xs_console_log&amp;quot;
}
Object.freeze(Console.prototype);
export default Console;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JS ファイルはタダのラッパーで、処理本体は C ファイルで定義しています。
JS ファイル内で &lt;code&gt;@ ～&lt;/code&gt; と書くと、C ファイルで宣言した関数とバインディングされます。
これは、XS 独自の実装のようです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c:esp/console.c&#34;&gt;#include &amp;quot;xsAll.h&amp;quot;
#include &amp;quot;xs.h&amp;quot;
void xs_console_destructor(void)
{
}
void xs_console_log(xsMachine *the)
{
int argc = xsToInteger(xsArgc), i;
for (i = 0; i &amp;lt; argc; i++) {
char *str = xsToString(xsArg(i));
do {
uint8_t c = c_read8(str);
if (!c) {
ESP_putc(&#39;\n&#39;);
break;
}
ESP_putc(c);
str++;
} while (1);
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;manifest-json&#34;&gt;manifest.json&lt;/h3&gt;
&lt;p&gt;最後は manifest ファイルです。
正直言うと、ここはあまり把握できていません :sweat:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;include&lt;/code&gt; で Moddable SDK で用意されている manifest を、ベースの manifest として読み込み、全プラットフォーム共通のモジュールとして &lt;code&gt;main&lt;/code&gt;(.js) を、&lt;code&gt;esp32&lt;/code&gt; 向けには、&lt;code&gt;./esp/console&lt;/code&gt;(.js) をロードする設定を書いています。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json:manifest.json&#34;&gt;{
&amp;quot;include&amp;quot;: &amp;quot;$(MODDABLE)/examples/manifest_base.json&amp;quot;,
&amp;quot;modules&amp;quot;: {
&amp;quot;*&amp;quot;: [
&amp;quot;./main&amp;quot;,
]
},
&amp;quot;platforms&amp;quot;: {
&amp;quot;esp32&amp;quot;: {
&amp;quot;modules&amp;quot;: {
&amp;quot;*&amp;quot;: [
&amp;quot;./esp/console&amp;quot;,
],
}
}
},
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上の &lt;code&gt;manifest.json&lt;/code&gt; では &lt;code&gt;Timer&lt;/code&gt; クラスをロードしていませんが、&lt;code&gt;main.js&lt;/code&gt; では問題なく import することができます。
これは、Moddable SDK に含まれるベースの manifest でロード設定がされているためです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json:$(MODDABLE)/examples/manifest_base.json(抜粋)&#34;&gt;{
:
(略)
:
&amp;quot;platforms&amp;quot;: {
:
(略)
:
&amp;quot;esp32&amp;quot;: {
&amp;quot;include&amp;quot;: &amp;quot;$(BUILD)/devices/esp32/manifest.json&amp;quot;
},
}
:
(略)
:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-json:$(BUILD)/devices/esp32/manifest.json(抜粋)&#34;&gt;{
:
(略)
:
&amp;quot;modules&amp;quot;: {
&amp;quot;*&amp;quot;: [
&amp;quot;$(MODULES)/base/time/*&amp;quot;,
&amp;quot;$(MODULES)/base/time/esp/*&amp;quot;,
&amp;quot;$(MODULES)/base/timer/*&amp;quot;,
&amp;quot;$(MODULES)/base/timer/mc/*&amp;quot;,
]
},
&amp;quot;preload&amp;quot;: [
&amp;quot;time&amp;quot;,
&amp;quot;timer&amp;quot;,
],
:
(略)
:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ちなみに manifest についてツイートしたところ、公式アカウントからも返事がありました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ドキュメントは定期的にメンテナンスされそうです。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;The manifest documentation (&lt;a href=&#34;https://t.co/HTYtMXR33N&#34;&gt;https://t.co/HTYtMXR33N&lt;/a&gt;) is a good place to start, but we&amp;#39;ll put a document with more details together soon. If you have any specific questions, we&amp;#39;d be happy to answer those as well.&lt;/p&gt; Moddable (@moddabletech) &lt;a href=&#34;https://twitter.com/moddabletech/status/1086084032008413184?ref_src=twsrc%5Etfw&#34;&gt;2019年1月18日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h2 id=&#34;実行してみる&#34;&gt;実行してみる&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;manifest.json&lt;/code&gt; があるディレクトリで、&lt;code&gt;mcconfig&lt;/code&gt; コマンドを実行します。
大抵は、XS のビルドから始まるので、書き込みが完了するまでだいぶ時間がかかると思います。&lt;/p&gt;
&lt;p&gt;書き込みが完了すると、シリアルモニターに自動的に接続し、&lt;code&gt;console.log&lt;/code&gt; の出力内容が表示されます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; mcconfig -m -p esp32
rm: cannot remove &#39;/root/Projects/moddable/build/tmp/esp32/release/xsProj/sdkconfig&#39;: No such file or directory
# Running GENCONFIG...
fatal: Not a git repository (or any of the parent directories): .git
including /root/esp32/esp-idf/components/bootloader/Makefile.projbuild...
:
(略)
:
MONITOR
--- idf_monitor on /dev/ttyUSB0 115200 ---
--- Quit: Ctrl+] | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
ets Jun 8 2016 00:22:57
rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0018,len:4
load:0x3fff001c,len:636
load:0x40078000,len:6192
load:0x40080000,len:5152
0x40080000: _iram_start at /root/esp32/esp-idf/components/freertos/xtensa_vectors.S:1685
entry 0x40080264
0x40080264: _Level5Vector at ??:?
1010:1
1510:a
2010:2
3010:3
3011:b
4010:4
4510:c
5010:5
6010:6
:
(略)
:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定した時間間隔で、コールバック関数が実行されています！ :tada::tada::tada:
ES2017 で入った &lt;code&gt;String.prototype.padStart&lt;/code&gt; も正常に動作しているようです。&lt;/p&gt;
&lt;p&gt;なお、マイコンには時計がないので、&lt;code&gt;Date.now()&lt;/code&gt; は起動時からの時間を返します。&lt;/p&gt;
&lt;h3 id=&#34;デバッグ実行&#34;&gt;デバッグ実行&lt;/h3&gt;
&lt;p&gt;先ほど実行したコマンド &lt;code&gt;mcconfig -m -p esp32&lt;/code&gt; にデバッグ オプション &lt;code&gt;-d&lt;/code&gt; を追加すると、デバッグ ビルドを実行し、デバッグ ツールである &lt;code&gt;xsbug&lt;/code&gt; が自動で起動します。&lt;/p&gt;
&lt;p&gt;この &lt;code&gt;xsbug&lt;/code&gt; は JavaScript コードにブレークポイントの設定や、ステップ実行、変数の内容などを表示することが
でき、結構本格的なデバッグツールです。&lt;/p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/237/3.png&#34; alt=&#34;3&#34;&gt;
&lt;/center&gt;
&lt;p&gt;今は独自の GUI ツールとして提供されているようですが、そのうち&lt;strong&gt;VSCode から拡張機能として利用できるようになると嬉しいですね。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;いかがだったでしょうか。
Moddable SDK を使うことで、JavaScript で書いたコードを、ESP8266/32 で動作させることができました。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Web フロントエンドや Node.js など、JavaScript を書くエンジニア人口は多いでしょうから、そういった方々も気軽にマイコン開発ができるようになりますね。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;あとは、manifest ファイルに関するドキュメントの整備がすすんだり、もう少し簡単に環境構築ができれば、格段に開発しやすくなるのではないでしょうか。&lt;/p&gt;</description></item><item><title>無料で手軽！コマンド一つで静的サイトホスティングできるSurgeを試してみた。</title><link>https://dotstud.io/blog/static-site-hosting-surge/</link><pubDate>Sun, 09 Sep 2018 04:58:49 +0900</pubDate><guid>https://dotstud.io/blog/static-site-hosting-surge/</guid><description>
&lt;p&gt;こんにちは、&lt;a href=&#34;https://dotstud.io/members/n0bisuke&#34;&gt;n0bisuke&lt;/a&gt;です。&lt;/p&gt;
&lt;p&gt;最近VuePressを触っていて、簡単に静的サイトホスティングできるサービスを探していました。&lt;/p&gt;
&lt;p&gt;そこで発見した&lt;strong&gt;Surge（サージ）というサービスがすごく簡単だった&lt;/strong&gt;ので紹介します。&lt;/p&gt;
&lt;p&gt;（日本語記事なさそうだったので勢いで書いておこう）&lt;/p&gt;
&lt;h2 id=&#34;surgeとは&#34;&gt;Surgeとは&lt;/h2&gt;
&lt;p&gt;静的サイトホスティングが無料で行えるサービスです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;コマンド一発でデプロイが出来る&lt;/strong&gt;のが特徴で、&lt;strong&gt;使い方がすごくシンプルで感動&lt;/strong&gt;しました。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://surge.sh/&#34;&gt;&lt;img src=&#34;https://i.gyazo.com/f25b1dfae03feef05a74739a4385a8eb.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://surge.sh/&#34;&gt;surge公式サイト&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;ちなみにサージって読むっぽいです。有料プランもありますがその辺は割愛して無料でできるところを紹介します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/surge&#34;&gt;surge - npm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;無料でどこまで使えるの？って気になる人は&lt;a href=&#34;https://surge.sh/help/why-is-surge-free&#34;&gt;Why is Surge free?&lt;/a&gt;という記事もあるので読んでみましょう。&lt;/p&gt;
&lt;h2 id=&#34;surgeのインストールと使い方&#34;&gt;Surgeのインストールと使い方&lt;/h2&gt;
&lt;h3 id=&#34;インストール&#34;&gt;インストール&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;npm i -g surge
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;デプロイ&#34;&gt;デプロイ&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;surge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;font size=&#34;4&#34;&gt;以上!!! &lt;/font&gt;めちゃ簡単ですね。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;でも本当にこれだけなので驚きです。&lt;code&gt;now.sh&lt;/code&gt;に似た使い勝手。&lt;/p&gt;
&lt;p&gt;初めて使うときはメールアドレスとパスワードの入力をターミナル上で求められるのでそこでユーザー登録出来るのも個人的には好きです。&lt;strong&gt;ターミナルだけで完結します&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;デプロイすると&lt;strong&gt;&lt;code&gt;xxxxxxx.surge.sh&lt;/code&gt;&lt;/strong&gt;という形式のURLが発行されるので、アクセスすればOKです。&lt;/p&gt;
&lt;h2 id=&#34;もう少し詳しく&#34;&gt;もう少し詳しく&lt;/h2&gt;
&lt;p&gt;surgeコマンドは、今いる場所を起点にそのままホスティングします。&lt;/p&gt;
&lt;p&gt;例えばmysiteフォルダ内部に&lt;code&gt;index.html&lt;/code&gt;を置いてたとします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd mysite
$ ls
index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mysiteフォルダ内にいる状態で&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;surge ./
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;とすればmysiteフォルダをまるっとホスティングできます。&lt;/p&gt;
&lt;h3 id=&#34;場所を指定してデプロイ&#34;&gt;場所を指定してデプロイ&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;surge &amp;lt;フォルダの場所&amp;gt;&lt;/code&gt;という形でデプロイできます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;surge ~/myblog/.vuepress/dist
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vuepressを使ったデプロイだとこんな感じでした&lt;/p&gt;
&lt;h3 id=&#34;場所とドメインを指定してデプロイ&#34;&gt;場所とドメインを指定してデプロイ&lt;/h3&gt;
&lt;p&gt;さらにドメインを指定してデプロイができます。&lt;/p&gt;
&lt;p&gt;通常のデプロイだと、surgeコマンドでデプロイするたびに新しいドメインが生成されるので、更新性のあるサイトだと使い勝手が良くないです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;surge &amp;lt;フォルダの場所&amp;gt; &amp;lt;ドメイン&amp;gt;&lt;/code&gt;という形でデプロイすれば&lt;strong&gt;毎回同じドメインにデプロイできます。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;surge ~/myblog/.vuepress/dist hogehoge.surge.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコマンドを何回実行しても&lt;code&gt;hogehoge.surge.sh&lt;/code&gt;にデプロイされるので更新しても安心です。&lt;/p&gt;
&lt;p&gt;確か&lt;code&gt;now.sh&lt;/code&gt;だと毎回ドメインが発行されてaliasを貼り直さないといけない感じだったのでそこが少し手間だなぁと感じてました。この辺は後述します。&lt;/p&gt;
&lt;h2 id=&#34;カスタムドメインも無料で使える&#34;&gt;カスタムドメインも無料で使える&lt;/h2&gt;
&lt;p&gt;無料でカスタムドメインを利用できます。&lt;/p&gt;
&lt;p&gt;「&lt;a href=&#34;https://surge.sh/help/adding-a-custom-domain&#34;&gt;Adding a custom domain - surge&lt;/a&gt;」を見るとやり方が書いてるのですが、利用しているドメイン事業者の管理画面で&lt;code&gt;cname&lt;/code&gt;の値に&lt;code&gt;na-west1.surge.sh&lt;/code&gt;を指定しましょう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grasping.studio&lt;/code&gt;というドメインをお名前.comで管理しているので、&lt;code&gt;hogehoge.graspin.studio&lt;/code&gt;を利用したい場合は以下のように設定します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/9e316c5d1c6eeeebab84fb08819bdd37.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;更新してしばらく経つ（体感5~10分程度）と&lt;code&gt;hogehoge.graspin.studio&lt;/code&gt;に対してデプロイできるようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ surge ~/myblog/.vuepress/dist hogehoge.graspin.studio
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;その他使い方&#34;&gt;その他使い方&lt;/h2&gt;
&lt;p&gt;surgeコマンドのサブコマンドもいくつかあるので紹介します。&lt;/p&gt;
&lt;h3 id=&#34;surge-list-アプリケーション一覧&#34;&gt;&lt;code&gt;surge list&lt;/code&gt; - アプリケーション一覧&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ surge list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/904da5a62e40457539116e012d101418.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;surge-teardown-アプリケーション削除&#34;&gt;&lt;code&gt;surge teardown&lt;/code&gt; - アプリケーション削除&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;teardown&lt;/code&gt;ってあんまり聞かないですけど他のサービスで言うところのrmとかremoveとかと同じような意味合いです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ surge teardown &amp;lt;アプリケーションのドメイン&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;surge-whoami-アカウント情報の確認&#34;&gt;&lt;code&gt;surge whoami&lt;/code&gt; - アカウント情報の確認&lt;/h3&gt;
&lt;p&gt;ログインしているアカウントのメールアドレスが表示されます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ surge whoami
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;surge-logout-アカウントからログアウトする&#34;&gt;&lt;code&gt;surge logout&lt;/code&gt; - アカウントからログアウトする&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ surge logout
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;surge-login-ログインしなおす&#34;&gt;&lt;code&gt;surge login&lt;/code&gt; - ログインしなおす&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ surge login
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;他のメンバーと共同でデプロイする&#34;&gt;他のメンバーと共同でデプロイする&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;--add&lt;/code&gt;というオプションをつけてデプロイするとアプリケーションに指定したメールアドレスのユーザーもデプロイ出来るようになります。&lt;/p&gt;
&lt;p&gt;ユーザー&lt;code&gt;hogehoge@gmail.com&lt;/code&gt;さんをアプリケーション&lt;code&gt;hogehoge.graspin.studio&lt;/code&gt;へのデプロイ権限を渡しつつ、&lt;code&gt;public&lt;/code&gt;フォルダをデプロイする。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;surge --add hogehoge@gmail.com public hogehoge.graspin.studio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この辺りもコマンドラインからやれて便利ですね。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;surge --remove&lt;/code&gt;でユーザーの権限を削除することもできます。&lt;/p&gt;
&lt;h2 id=&#34;他のサービスと比較してどうか&#34;&gt;他のサービスと比較してどうか?&lt;/h2&gt;
&lt;p&gt;無料で使えるその他のホスティングサービスとの比較です。主観です。&lt;/p&gt;
&lt;p&gt;この辺、実は違う！みたいな話あれば@n0bisukeまでコメントください〜。&lt;/p&gt;
&lt;h3 id=&#34;netlfy&#34;&gt;Netlfy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netlify.com/&#34;&gt;https://www.netlify.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;フォルダをドラッグ&amp;amp;ドロップでデプロイ出来るのは個人的に結構好きですが、毎回URLが再発行されてしまうのが少し手間がある印象です。&lt;/p&gt;
&lt;p&gt;netlfyのcliツールもあるみたいですが手順がsurgeよりはある模様&lt;/p&gt;
&lt;h3 id=&#34;heroku&#34;&gt;heroku&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://heroku.com/&#34;&gt;http://heroku.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;サーバーサイドのプログラムを含めてデプロイするときには良さそうです。
僕もよく使います。&lt;/p&gt;
&lt;p&gt;デバッグなどでけっこう詰まるのと、surgeほどの手軽さではないです。&lt;/p&gt;
&lt;p&gt;とはいえサーバーサイドプログラムまで利用したかったら選択肢になります。&lt;/p&gt;
&lt;h3 id=&#34;github-pages-bitbucket-pages&#34;&gt;GitHub Pages &amp;amp; Bitbucket Pages&lt;/h3&gt;
&lt;p&gt;GitHub PagesとBitbucket Pagesは使い勝手はほぼ同じ印象で、git pushするだけで公開できます。&lt;/p&gt;
&lt;p&gt;Webエンジニアなら当たり前のように使いますが、SSHやGitコマンドは最初少しハードルがあるかも。&lt;/p&gt;
&lt;p&gt;更新されるまでに少し時間がかかること、GitHubだとソースコードが（無料だと）公開されてしまうのでそこに抵抗感がある人がいるかも。&lt;/p&gt;
&lt;p&gt;静的サイトなのでどっちにしても公開されているようなものだけどなんとなく。&lt;/p&gt;
&lt;h3 id=&#34;gitlab-pages&#34;&gt;GitLab Pages&lt;/h3&gt;
&lt;p&gt;CIを動かして作るのでCIの記述になれてないと最初少しハマるかもしれません。&lt;/p&gt;
&lt;p&gt;その分やれることも多いので個人的には注目してます。&lt;/p&gt;
&lt;h3 id=&#34;now&#34;&gt;now&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.now.sh/&#34;&gt;https://www.now.sh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;これはめちゃ便利で&lt;code&gt;now&lt;/code&gt;コマンドだけでデプロイできて&lt;code&gt;surge&lt;/code&gt;とほぼ同じ使い勝手です。更新のたびに毎回URLが変わってしまうのでそこを解消できたら良いなぁと思うのと、同時に無料プランだと作れるアプリケーションの制限があって現状だと毎回削除していくのも結構手間があるなぁという印象です。&lt;/p&gt;
&lt;p&gt;（&lt;code&gt;now&lt;/code&gt;はもしかしたら設定でなんとかなるのかも??）&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Surge&lt;/code&gt;どうでしょう？&lt;/p&gt;
&lt;p&gt;コマンド一発で出来るので、サクッと作成したWebサイトを誰かにシェアしたり、
ハンズオンや授業などでも使いやすいと思います。&lt;/p&gt;
&lt;p&gt;僕も昨日知ったばかりですが今の所すごく良い印象です。&lt;/p&gt;
&lt;p&gt;ぜひ使ってみてください。&lt;/p&gt;</description></item><item><title>NodeSchoolでNode.jsの学習を始めよう！#2 - 問題1〜3の解答と解説</title><link>https://dotstud.io/blog/node-school-1-3/</link><pubDate>Fri, 18 May 2018 10:00:00 +0900</pubDate><guid>https://dotstud.io/blog/node-school-1-3/</guid><description>
&lt;p&gt;こんにちは、ちゃんとくです！&lt;/p&gt;
&lt;p&gt;前回の記事で、&lt;strong&gt;NodeSchoolの概要と基本の解き方&lt;/strong&gt;を紹介しました。
&lt;section class=&#34;link&#34; id=&#34;156&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/node-school-before-learn/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/156/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
NodeSchoolでNode.jsの学習を始めよう！インストール手順から基本操作までステップ別解説
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2018-04-20
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
NodeSchoolでNode.jsの学習を進めていきましょう！意外とつまづきやすい操作方法や問題の解き方をステップ別に解説します。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/p&gt;
&lt;p&gt;今回はカリキュラム「&lt;strong&gt;learnyounode&lt;/strong&gt;」の問題1〜3の解答を解説付きで紹介したいと思います！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=2&gt;※筆者はMacユーザのため、基本的にMacに沿った説明になっています。Windows向けの説明も書いていますが、わからないときは適宜調べてみてください。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;さっそく問題を解いていきましょう。インストール方法や基本の解き方は前回記事をチェック！
&lt;section class=&#34;link&#34; id=&#34;156&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/node-school-before-learn/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/156/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
NodeSchoolでNode.jsの学習を始めよう！インストール手順から基本操作までステップ別解説
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2018-04-20
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
NodeSchoolでNode.jsの学習を進めていきましょう！意外とつまづきやすい操作方法や問題の解き方をステップ別に解説します。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /your/working/directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;まずは解答用のファイルを作成するディレクトリに移動します。パスはご自身のものに置き換えてください。&lt;/p&gt;
&lt;p&gt;おさらいですが、&lt;strong&gt;&lt;code&gt;$&lt;/code&gt;マークはコマンドラインであることを表しているので不要&lt;/strong&gt;ですよ！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ learnyounode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「&lt;strong&gt;learnyounode&lt;/strong&gt;」コマンドでNodeSchoolのカリキュラムを起動します。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/1.png&#34; alt=&#34;1&#34;&gt;
&lt;/center&gt;
こんな画面が立ち上がりましたか？カーソルキーで問題を選択します。1問目の「&lt;strong&gt;こんにちは世界&lt;/strong&gt;」からやっていきましょう！&lt;/p&gt;
&lt;h2 id=&#34;問題1-こんにちは世界&#34;&gt;問題1「こんにちは世界」&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;div class=&#34;question&#34;&gt;
&lt;div style=&#34;background: #696969; padding: 4px; text-align: center;color: #fff; font-weight: bold;border-radius: 5px 5px 0 0;&#34;&gt;問題1「こんにちは世界」&lt;/div&gt;
&lt;p style=&#34;padding: 0 15px 20px 15px;&#34;&gt;コンソール (stdout) に &amp;ldquo;こんにちは世界&amp;rdquo;と出力するアプリを書いてください。&lt;/p&gt;
&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;問題の「コンソール」とは&lt;strong&gt;今表示しているコマンドラインツール&lt;/strong&gt;、「アプリ」とはここでは「&lt;strong&gt;Node.jsのプログラム&lt;/strong&gt;」を意味しています。&lt;/p&gt;
&lt;p&gt;この問題は「&lt;u&gt;実行するとコマンドラインに&amp;rdquo;こんにちは世界&amp;rdquo;と表示させるプログラムを書いてみましょう&lt;/u&gt;」ということです。&lt;/p&gt;
&lt;p&gt;ヒントを読んでみると、&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Node.jsのアプリを作るためには .jsという拡張子を持つファイルを新規に作ってJavaScriptを書くだけです。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;とあるので、&lt;code&gt;.js&lt;/code&gt;という拡張子のファイルを作りましょう。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/2.png&#34; alt=&#34;2&#34;&gt;
&lt;/center&gt;
今回は1.jsというファイルを作ったので、エディタでファイルを開き、編集していきます。（操作がよくわからないという方は&lt;a href=&#34;https://dotstud.io/blog/node-school-before-learn/&#34;&gt;前回記事&lt;/a&gt;を確認！）&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/3.png&#34; alt=&#34;3&#34;&gt;
&lt;/center&gt;
さらにヒントを読んでいくと、&lt;code&gt;console.log(&amp;quot;text&amp;quot;)&lt;/code&gt;と書くとコンソールに出力できます、とありますね。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;console.log()&lt;/code&gt;は「&lt;strong&gt;渡したものをコンソールに表示してね&lt;/strong&gt;」という命令です。関数の&lt;code&gt;()&lt;/code&gt;に入れたものは「&lt;strong&gt;引数&lt;/strong&gt;」と呼ばれ、関数に渡されます。&lt;/p&gt;
&lt;p&gt;上記は&lt;code&gt;console.log()&lt;/code&gt;というメソッドに、&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;という引数を渡している状態です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;（または&lt;code&gt;&#39;&#39;&lt;/code&gt;）は、型が「&lt;strong&gt;文字列&lt;/strong&gt;」であることを表しています（その他の型は今後登場します）。&lt;/p&gt;
&lt;p&gt;つまり「こんにちは世界」という文字列を表示させたい場合は、&lt;code&gt;console.log()&lt;/code&gt;の引数に&lt;code&gt;&amp;quot;こんにちは世界&amp;quot;&lt;/code&gt;を渡してあげればよいですね！&lt;/p&gt;
&lt;h3 id=&#34;解答&#34;&gt;解答&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;こんにちは世界&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解答用のファイルに、上記のプログラムを書き込みましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node 1.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Node.jsでファイルを実行して試してみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/4.png&#34; alt=&#34;4&#34;&gt;
&lt;/center&gt;
こんにちは世界、と表示されました。これで良さそうですね！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ learnyounode verify 1.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記コマンドを実行して答え合わせをします。正解したら次の問題へ進みましょう！&lt;/p&gt;
&lt;h2 id=&#34;問題2-ベイビーステップ&#34;&gt;問題2「ベイビーステップ」&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;div class=&#34;question&#34;&gt;
&lt;div style=&#34;background: #696969; padding: 4px; text-align: center;color: #fff; font-weight: bold;border-radius: 5px 5px 0 0;&#34;&gt;問題2「ベイビーステップ」&lt;/div&gt;
&lt;p style=&#34;padding: 0 15px 20px 15px;&#34;&gt;1つ以上の整数をコマンドライン引数として受け取り、それらを足し合わせた値をコンソール(stdout)に出力するコマンドラインアプリを書いてください。&lt;/p&gt;
&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;ちょっとレベルが上がりました。先ほどは関数に直接引数を渡しましたが、「&lt;strong&gt;コマンドライン引数&lt;/strong&gt;」は、コマンドラインからプログラムに渡すものを指します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;コマンドライン引数を読むためにはグローバル変数の process というオブジェクトが使えます。process には argv という配列のプロパティがあります。その配列の中には全てのコマンドライン引数が入っています。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;とヒントに書いてあります。&lt;/p&gt;
&lt;p&gt;まず&lt;code&gt;process.argv&lt;/code&gt;の挙動を探るため、&lt;code&gt;console.log()&lt;/code&gt;を使って表示させてみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(process.argv);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のようなプログラムを書いた&lt;code&gt;.js&lt;/code&gt;ファイルを作成します（&lt;code&gt;2.js&lt;/code&gt;というファイルにしました）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node 2.js &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;プログラムに&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;という文字列を渡してみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/5.png&#34; alt=&#34;5&#34;&gt;
&lt;/center&gt;
こんな感じの答えが返ってきました。&lt;code&gt;[]&lt;/code&gt;は「&lt;strong&gt;配列&lt;/strong&gt;」を表していて、&lt;code&gt;,&lt;/code&gt;で区切られた3つの要素が入っています。&lt;/p&gt;
&lt;p&gt;1つ目の要素の&lt;code&gt;/Users/yuka/.nodebrew/node/v9.3.0/bin/node&lt;/code&gt;は皆さんのNode.jsがインストールされているパス、2つ目の要素の&lt;code&gt;/Users/yuka/workspace/nodeschool/learnyounode/2.js&lt;/code&gt;は今実行したファイルのパス、3つ目の要素には&lt;strong&gt;渡したコマンドライン引数&lt;/strong&gt;が入っています。&lt;/p&gt;
&lt;p&gt;コマンドライン引数を表示させるには、&lt;strong&gt;&lt;code&gt;process.argv&lt;/code&gt;の3つ目の要素&lt;/strong&gt;を取り出してあげると良さそうです！&lt;/p&gt;
&lt;p&gt;試しにこんなプログラムを書いてみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(process.argv[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配列の中身の位置を指定して取り出すには、&lt;code&gt;[]&lt;/code&gt;を使います。配列の序列は0から始まるので、3つ目の要素は「0,1,2」で「2」となります。&lt;/p&gt;
&lt;p&gt;このファイルに、先ほどと同様&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;を渡してみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/6.png&#34; alt=&#34;6&#34;&gt;
&lt;/center&gt;
コマンドライン引数だけを表示することができました！&lt;/p&gt;
&lt;p&gt;では&lt;strong&gt;いくつかの引数を渡して足し算するプログラム&lt;/strong&gt;を書いてみます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(process.argv[2]+process.argv[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;こんなプログラムを書いてみます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node 2.js 1 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行して試してみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/7.png&#34; alt=&#34;7&#34;&gt;
&lt;/center&gt;
「2」となって欲しいところ、「11」となってしまいました。&lt;/p&gt;
&lt;p&gt;これは、「1」という文字列と「1」という文字列をくっつけた結果になってしまっています（ちょっとわからない、という人は&lt;code&gt;$ node 2.js &amp;quot;hel&amp;quot; &amp;quot;lo&amp;quot;&lt;/code&gt;など実行してみてください）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;process.argv&lt;/code&gt;の要素は全て文字列になるので、プログラムには「&lt;strong&gt;これは数字だよ！&lt;/strong&gt;」と教えてあげないと、わかってくれないんですね。&lt;/p&gt;
&lt;p&gt;ヒントを読んでみると、数字に変換する方法が書いてあります。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;変換するには、数字の前に + を書きます。Number()を使う方法もあります。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数字の前に&lt;code&gt;+&lt;/code&gt;をつけるか、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(+process.argv[2] + +process.argv[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Number()&lt;/code&gt;という関数を使って文字列を数字に変換してあげます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(Number(process.argv[2]) + Number(process.argv[3]));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;エラーが出てしまった人は、&lt;code&gt;Number()&lt;/code&gt;の頭文字が大文字になっているか、()の数が合っているかなど確認してみてくださいね。&lt;/p&gt;
&lt;h2 id=&#34;問題3-初めてのi-o&#34;&gt;問題3「初めてのI/O！」&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;div class=&#34;question&#34;&gt;
&lt;div style=&#34;background: #696969; padding: 4px; text-align: center;color: #fff; font-weight: bold;border-radius: 5px 5px 0 0;&#34;&gt;問題3「初めてのI/O！」&lt;/div&gt;
&lt;p style=&#34;padding: 0 15px 20px 15px;&#34;&gt;同期処理をするファイルシステムの関数を使ってファイルの改行文字(\n)の数を出力するアプリを書いてください。&lt;/p&gt;
&lt;/div&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;style&gt;
.question {
margin: 2em 0;
background: #f1f1f1;
border-radius: 5px;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.22);
max-width: 450px;
color: #696969;
}
&lt;/style&gt;
&lt;p&gt;3問目です。この問題は少し難しいので、「ファイルの中身を取り出す」ステップと、「改行を数える」ステップに分けてみます。&lt;/p&gt;
&lt;h3 id=&#34;ファイルの中身を取り出す&#34;&gt;ファイルの中身を取り出す&lt;/h3&gt;
&lt;p&gt;「&lt;strong&gt;同期処理？ファイルシステムの関数？？？&lt;/strong&gt;」となりますね。&lt;/p&gt;
&lt;p&gt;Node.jsには、あらかじめ色々な関数を用意してくれているモジュール（パッケージのようなもの）があります。その一つが&lt;code&gt;fs&lt;/code&gt;（file system）というモジュールです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fs&lt;/code&gt;には、ファイルを扱うためのいろいろな関数が用意されています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;モジュールを呼び出すためには、上記のように記述します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt;は、「&lt;strong&gt;変数の宣言&lt;/strong&gt;」です（最近は&lt;code&gt;var&lt;/code&gt;ではなく&lt;code&gt;const&lt;/code&gt;が推奨）。&lt;code&gt;var fs&lt;/code&gt;の&lt;code&gt;fs&lt;/code&gt;は「&lt;strong&gt;変数名&lt;/strong&gt;」で、任意の名前を付けられます。「fs」という名前の箱に、&lt;code&gt;require(&#39;fs&#39;)&lt;/code&gt;の結果を収納しているイメージです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;require()&lt;/code&gt;は&lt;strong&gt;モジュールを呼び出す関数&lt;/strong&gt;、引数には文字列で&lt;strong&gt;モジュールの名前&lt;/strong&gt;を渡します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;);
console.log(fs.readFileSync(process.argv[2]));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;3.js&lt;/code&gt;というファイルを作って、上記のようなプログラムで&lt;code&gt;fs&lt;/code&gt;の機能を試してみましょう。ヒントによると&lt;code&gt;fs.readFileSync()&lt;/code&gt;の引数には読み込むファイルのパスを指定するので、コマンドライン引数で渡すようにしてみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/8.png&#34; alt=&#34;8&#34;&gt;
&lt;/center&gt;
読み込みを試す用に、&lt;code&gt;sample.txt&lt;/code&gt;というテキストファイルを作ってみました。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node 3.js ./sample.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行して試してみます（&lt;code&gt;./&lt;/code&gt;は現在の位置です）。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/9.png&#34; alt=&#34;9&#34;&gt;
&lt;/center&gt;
こんな結果が出ました。「なんじゃこりゃ！」ですね&lt;/p&gt;
&lt;p&gt;&lt;code&gt;readFileSync()&lt;/code&gt;は「Bufferオブジェクト」という形式でファイルの中身を返します。これを文字列に変換するには、&lt;code&gt;toString()&lt;/code&gt;という関数を使います。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;);
var buf = fs.readFileSync(process.argv[2]);
var text = buf.toString();
console.log(text);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取り出したものを変換してから&lt;code&gt;console.log()&lt;/code&gt;してみましょう。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/10.png&#34; alt=&#34;10&#34;&gt;
&lt;/center&gt;
文字列として取り出すことができました！&lt;/p&gt;
&lt;h3 id=&#34;改行を数える&#34;&gt;改行を数える&lt;/h3&gt;
&lt;p&gt;改行を数えるには、ヒントのように&lt;code&gt;split()&lt;/code&gt;を使ってみます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScriptの String は .split() 関数を使って分割出来ます。\n を区切り文字として使えば String を1行ずつに分割した Array を受け取ることが出来ます。ただし、ファイルの最後の改行には気をつけてください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下記のようなプログラムで、文字列を&lt;code&gt;\n&lt;/code&gt;で分割してみます（&lt;code&gt;\n&lt;/code&gt;は改行を表しています）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;);
var buf = fs.readFileSync(process.argv[2]);
var text = buf.toString();
var array = text.split(&#39;\n&#39;);
console.log(array);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実行してみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/11.png&#34; alt=&#34;11&#34;&gt;
&lt;/center&gt;
ファイルの中身を&lt;code&gt;\n&lt;/code&gt;で区切ることができました！&lt;/p&gt;
&lt;p&gt;ただし、ヒントにあるように、最後に意図しない&lt;code&gt;&#39;&#39;&lt;/code&gt;が入っていますね。これはファイルの最後には改行が入るようになっているためです。&lt;/p&gt;
&lt;p&gt;なので、改行の数を数えるには「要素の数 - 1」をしてあげればよさそうです。&lt;/p&gt;
&lt;p&gt;「こんな関数使いたい！」というときは「JavaScript 配列 要素 数える」などと検索してみましょう。配列の要素を数えるためには、&lt;code&gt;Array.length&lt;/code&gt;というプロパティを使います。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;);
var buf = fs.readFileSync(process.argv[2]);
var text = buf.toString();
var array = text.split(&#39;\n&#39;);
var n_num = array.length - 1;
console.log(n_num);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記のように、&lt;code&gt;配列.length&lt;/code&gt;で要素数を数え、最後の改行分の1を引いてみます。&lt;/p&gt;
&lt;p&gt;
&lt;center style=&#34;color: #585858; font-size: 95%; padding-bottom: 10px;&#34;&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/157/12.png&#34; alt=&#34;12&#34;&gt;
&lt;/center&gt;
意図した数字になりました！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ learnyounode verify 3.js&lt;/code&gt;で答え合わせです。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;これで「learnyounode」の1〜3問目は終了です。&lt;strong&gt;お疲れ様でした！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;プログラミングを初めて学ぶ方は、新しい情報が多く難しく感じたかもしれません。でも問題を解きながら変数や関数に慣れていけば、&lt;strong&gt;「おっ、こういうことか」とわかる瞬間&lt;/strong&gt;がくるはずです！&lt;/p&gt;
&lt;p&gt;めげずにNode.js勉強頑張っていきましょう！&lt;/p&gt;</description></item><item><title>NodeSchoolでNode.jsの学習を始めよう！インストール手順から基本操作までステップ別解説</title><link>https://dotstud.io/blog/node-school-before-learn/</link><pubDate>Fri, 20 Apr 2018 14:00:26 +0900</pubDate><guid>https://dotstud.io/blog/node-school-before-learn/</guid><description>
&lt;p&gt;こんにちは、ちゃんとくです。&lt;strong&gt;みなさんNode.jsしてますかー！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dotstudioでは何度も紹介していますが、Node.jsは&lt;u&gt;超超ざっくり言うとサーバサイドで動くJavaScript&lt;/u&gt;ですね。&lt;/p&gt;
&lt;p&gt;これからNode.jsを学びたい！という人も多いと思うのですが、初めてNode.jsを学びたいときにピッタリな「&lt;strong&gt;NodeSchool&lt;/strong&gt;」をご存知でしょうか。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nodeschool.io/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/nodeschool.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
NodeSchoolは&lt;strong&gt;JavaScriptに関するいろいろな授業を集めた学校のようなもの&lt;/strong&gt;で、コードを書いて問題を解いていくことで学習を進められます。&lt;/p&gt;
&lt;p&gt;世界各国のさまざまな言語に対応していて、日本語に対応した「&lt;a href=&#34;https://nodeschool.io/tokyo/&#34;&gt;NodeSchool Tokyo&lt;/a&gt;」のページもあります。&lt;/p&gt;
&lt;p&gt;みんなで集まって授業を進めるハンズオンイベントも盛んで、ちょうど&lt;u&gt;5月21日にNodeSchool Tokyoが開催&lt;/u&gt;されるようです！
&lt;a href=&#34;https://nodejs.connpass.com/event/82742/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今回は、そもそも「コードを書くのもコマンドラインも初めて」という人向けに、&lt;strong&gt;NodeSchoolを始めるまで&lt;/strong&gt;を紹介してみたいと思います。&lt;/p&gt;
&lt;p&gt;CLIの操作方法、Node.jsの環境構築から解説していきますが、「コマンドライン使えるよ、もうNode.js入ってるよ」という人は「&lt;a href=&#34;https://dotstud.io/blog/node-school-before-learn/#nodeschool%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB&#34;&gt;NodeSchoolのインストール&lt;/a&gt;」の章から進めましょう！&lt;/p&gt;
&lt;p&gt;それではやって行こう！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=2&gt;※筆者はMacユーザのため、基本的にMacに沿った説明になっています。Windows向けの説明も書いていますが、わからないときは適宜調べてみてください。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;nodeschoolを始める前に&#34;&gt;NodeSchoolを始める前に&lt;/h2&gt;
&lt;h3 id=&#34;コマンドラインインタフェース-cli-の操作&#34;&gt;コマンドラインインタフェース（CLI）の操作&lt;/h3&gt;
&lt;p&gt;NodeSchoolは、自身のPCのコマンドライン上（コマンドラインインタフェース、CLI）で進めるツールです。学習を始めるにあたって、基本の操作を覚えておきましょう！&lt;/p&gt;
&lt;p&gt;（↓長くなっちゃったので別記事にしました）
&lt;section class=&#34;link&#34; id=&#34;158&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/how-to-use-cli/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/158/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
【Mac向け】「黒い画面」の苦手意識を克服しよう！コマンドラインインタフェースの基本操作
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2018-04-09
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Macユーザ向けコマンドラインインタフェースの使い方！実は難しくない「黒い画面」の操作方法を覚えていきましょう。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/p&gt;
&lt;!-- [![](/img/blog/156/link4.png)](/blog/how-to-use-cliwindows) --&gt;
&lt;h3 id=&#34;node-jsのインストール&#34;&gt;Node.jsのインストール&lt;/h3&gt;
&lt;p&gt;NodeSchoolはNode.jsで動きます。NodeSchoolを動かすために、自身のPCにNode.js環境を準備をします。&lt;/p&gt;
&lt;p&gt;まずNode.jsがインストールされているかは、下記コマンドで確認してみてください。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;インストールされている場合はインストールされているバージョン、されていない場合は &lt;code&gt;command not found&lt;/code&gt; といったエラーが出ます。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=2&gt;※2018年4月20日時点の最新版はv9.11.1、安定板はv8.11.1です。新しめのバージョンを使うのがオススメです（v6、v7辺りで大きめの変更がありました）。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js公式サイト&lt;/a&gt;からインストーラを使ってインストールしてもよいのですが、Node.jsはバージョンアップが多いので、&lt;u&gt;Node.jsのバージョンを管理できるツールと一緒にインストールするのがオススメ&lt;/u&gt;です。&lt;/p&gt;
&lt;p&gt;バージョン管理ツールには「nodebrew」や「nvm」、Windowsの方は「nodist」などがあります。&lt;/p&gt;
&lt;p&gt;「nodebrew」を使ったインストール方法をまとめたので、こちらを参考にインストールしてみてください！
&lt;section class=&#34;link&#34; id=&#34;136&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/nodejs-install-use-nodebrew/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/136/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.jsを始めよう！nodebrewを使って5分で環境構築
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-12-15
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
nodebrewを使ったNode.jsのインストール方法をまとめました。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/p&gt;
&lt;h2 id=&#34;nodeschoolのインストール&#34;&gt;NodeSchoolのインストール&lt;/h2&gt;
&lt;p&gt;さて、Node.js環境の準備ができたら、&lt;strong&gt;いよいよNodeSchoolをインストール&lt;/strong&gt;しましょう。&lt;/p&gt;
&lt;p&gt;NodeSchoolは「npm」というパッケージ管理ツールで配布されているので、npmコマンドでインストールします（Node.jsと一緒にインストールされるのでとりあえず深く考えなくてOK）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nodeschool.io/ja/index.html&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/class.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
NodeSchoolには上記のようにいくつかの授業があるので、今回は「&lt;strong&gt;learnyounode&lt;/strong&gt;」という授業を入れてみます。下記コマンドを実行しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install -g learnyounode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;問題なくインストールされたか確認してみます。下記コマンドを実行しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ learnyounode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/learnyounode.png&#34; alt=&#34;&#34; /&gt;
こんな画面が開いたでしょうか？&lt;/p&gt;
&lt;p&gt;これがNodeSchoolの実行画面で、ここから学習を進めていきます。&lt;strong&gt;インストールお疲れ様でした！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;nodeschoolの基本操作&#34;&gt;NodeSchoolの基本操作&lt;/h2&gt;
&lt;p&gt;まず、「&lt;strong&gt;とりあえずこの画面閉じたい！&lt;/strong&gt;」というときは&lt;code&gt;control+c&lt;/code&gt;で終了できます。&lt;/p&gt;
&lt;p&gt;基本は十字キーの↑↓で移動し、エンターで選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/language.png&#34; alt=&#34;&#34; /&gt;
「英語表示になっちゃってるよ！」という人は、まずは言語設定を日本語にしましょう。矢印キーで「CHOOSE LANGUAGE」に移動し、エンターで選択します。&lt;/p&gt;
&lt;h2 id=&#34;問題を解く方法&#34;&gt;問題を解く方法&lt;/h2&gt;
&lt;h3 id=&#34;問題画面の見方&#34;&gt;問題画面の見方&lt;/h3&gt;
&lt;p&gt;さてNodeSchoolを始める準備ができましたが、問題を解く方法も少し癖があります。試しに1問解いてみましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/helloworld.png&#34; alt=&#34;&#34; /&gt;
十字キーで移動し、「こんにちは世界」を選んでエンターします（いわゆる&amp;rdquo;Hello, world&amp;rdquo;ですが、日本語訳するとやや不自然ですね）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/question.png&#34; alt=&#34;&#34; /&gt;
するとこんな文章が表示されます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/detail.png&#34; alt=&#34;&#34; /&gt;
大きくわけると、3つの要素で構成されています。&lt;/p&gt;
&lt;p&gt;日本語なので、落ち着いて問題とヒントを読み進めましょう。&lt;/p&gt;
&lt;h3 id=&#34;ヒントを読んで進める&#34;&gt;ヒントを読んで進める&lt;/h3&gt;
&lt;p&gt;NodeSchoolでは、自分でNode.js実行ファイルを作り、実際に実行させて答え合わせをして進めていきます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/question_detail.png&#34; alt=&#34;&#34; /&gt;
この問題は、&lt;u&gt;コンソール（ここではターミナル上）に「こんにちは世界」と表示するNode.jsスクリプトを書いてください&lt;/u&gt;という意味です。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/hint1.png&#34; alt=&#34;&#34; /&gt;
ヒントをみると、「&lt;code&gt;.js&lt;/code&gt;拡張子のファイルを作って、&lt;code&gt;$ node xxx.js&lt;/code&gt; を実行すればOKです」と書いてありますね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/hint2.png&#34; alt=&#34;&#34; /&gt;
そして 「&lt;code&gt;console.log(&amp;quot;text&amp;quot;)&lt;/code&gt; と記述するとコンソールに出力できます」とあります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/hint3.png&#34; alt=&#34;&#34; /&gt;
答え合わせ方法は「&lt;code&gt;$ learnyounode verify xxx.js&lt;/code&gt;でテストする」とあります。&lt;/p&gt;
&lt;p&gt;その通りにやってみましょう！&lt;/p&gt;
&lt;h3 id=&#34;node-js実行ファイルを作る&#34;&gt;Node.js実行ファイルを作る&lt;/h3&gt;
&lt;p&gt;問題を解くとき、この問題文＆ヒントを見ながら進めたいですよね。&lt;/p&gt;
&lt;p&gt;そこで操作画面をもう一つ開きます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/terminal.png&#34; alt=&#34;&#34; /&gt;
Macの場合はツールバーの「シェル」から「新規ウィンドウ」または「新規タブ」で開くことができます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/iterm.png&#34; alt=&#34;&#34; /&gt;
前述の記事でオススメしたiTermを使っている場合は、画面分割機能がオススメです。ツールバーの「Shell」から「Split&amp;hellip;」を選ぶか、「⌘+D」で横に分割、「⌘+Shift+D」で縦に分割できます（使用頻度が高いので覚えておくのがオススメです）。&lt;/p&gt;
&lt;p&gt;問題を解くファイルは、あとで見つけやすいようにひとところにまとめておきましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/work_dir.png&#34; alt=&#34;&#34; /&gt;
ちゃんとくはこんな感じで、ホームディレクトリ（開いた場所/cdを実行した移動先）の下に &lt;code&gt;/workspace/nodeschool/learnyounode/&lt;/code&gt;というディレクトリを作り、その下に実行ファイルを作っています。&lt;/p&gt;
&lt;p&gt;好みはそれぞれなので、自分がわかりやすい場所であればなんでもOKです。&lt;/p&gt;
&lt;p&gt;それではファイルを作成して、実行スクリプトを書きましょう！Macの場合は&lt;code&gt;touch&lt;/code&gt;コマンドで新規ファイルを作成できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ touch 1.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ファイル名も、自分がわかればOKです。どの問題かわかるように番号や問題タイトルなどをつけておくのがオススメです。&lt;/p&gt;
&lt;h3 id=&#34;エディタでスクリプトを書く&#34;&gt;エディタでスクリプトを書く&lt;/h3&gt;
&lt;p&gt;それでは「こんにちは世界」用のファイルにスクリプトを書いていきます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vi&lt;/code&gt;コマンドなどでターミナル上で開いてもよいのですが、プログラミング向けエディタ（IDE）を使うのがオススメです。無料エディタでは&lt;a href=&#34;https://www.microsoft.com/ja-jp/dev/products/code-vs.aspx&#34;&gt;Visual Studio Code&lt;/a&gt;や、軽量な&lt;a href=&#34;https://atom.io/&#34;&gt;Atomエディタ&lt;/a&gt;などが流行りです（ちゃんとくはAtom）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ open ./&lt;/code&gt;というコマンド（Windowsの人は&lt;code&gt;explore&lt;/code&gt;）でファイルの場所を開いてみましょう。（&lt;code&gt;./&lt;/code&gt;は今いるディレクトリを表しています。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/open.png&#34; alt=&#34;&#34; /&gt;
ファイルの場所がファインダーで表示されました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/select_editor.png&#34; alt=&#34;&#34; /&gt;
編集したいファイルを右クリックすると開くアプリを選択できるので、エディタで開きましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=&#34;&#34;&gt;※この「CLIからエディタでファイルを開く操作」は、エディタをカスタマイズしてコマンドで実行することもできます。Atomの場合は&lt;code&gt;$ atom ./&lt;/code&gt;など（後日記事にしてみたいと思います）。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/example.png&#34; alt=&#34;&#34; /&gt;
ヒントを参考に、&lt;code&gt;console.log(&amp;quot;text&amp;quot;)&lt;/code&gt;コマンドを書いてみます。エディタで「⌘+s」などで保存して、試しに実行してみましょう。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ node xxx.js&lt;/code&gt;でファイルを実行します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/script.png&#34; alt=&#34;&#34; /&gt;
上記のような実行結果になったでしょうか？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;console.log()&lt;/code&gt;というコマンドに&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;を渡したら、「text」と表示されました。&lt;/p&gt;
&lt;p&gt;「こんにちは世界」と表示するには……もう分かったでしょうか？（ちょっと意地悪ですが、頑張って解いてみてください！）&lt;/p&gt;
&lt;h3 id=&#34;答え合わせ&#34;&gt;答え合わせ&lt;/h3&gt;
&lt;p&gt;さて、これだ！というスクリプトが書けたら答え合わせをします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/verify.png&#34; alt=&#34;&#34; /&gt;
ヒントのとおり、&lt;code&gt;$ learnyounode verify xxx.js&lt;/code&gt;を実行します（learnyounodeとかファイル名とか記述するの長いなあってときは、途中まで書いてTabを押すといいことがあります）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font size=2&gt;※CLIに慣れてくると雰囲気がわかりますが、&lt;code&gt;$ モジュール名 命令 引数&lt;/code&gt;という風にコマンドを実行しています。引数とはプログラムに渡すモノです。&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/verify_detail.png&#34; alt=&#34;&#34; /&gt;
答え合わせの結果画面です。自分の書いたスクリプトの実行結果と、想定回答（求められている答え）が表示されます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;無事に正解していると褒められます。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回答例も表示されるので、確認してみましょう。&lt;/p&gt;
&lt;p&gt;無事に解けたら、また「&lt;a href=&#34;https://dotstud.io/blog/node-school-before-learn/#%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E3%81%8F%E6%96%B9%E6%B3%95&#34;&gt;問題を解く方法&lt;/a&gt;」のように&lt;code&gt;$ learnyounode&lt;/code&gt; を実行して問題ファイルを開き、進めていきましょう。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NodeSchoolデビューお疲れ様でした！&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>【Mac向け】「黒い画面」の苦手意識を克服しよう！コマンドラインインタフェースの基本操作</title><link>https://dotstud.io/blog/how-to-use-cli/</link><pubDate>Mon, 09 Apr 2018 14:00:26 +0900</pubDate><guid>https://dotstud.io/blog/how-to-use-cli/</guid><description>
&lt;p&gt;こんにちは、ちゃんとくです。&lt;/p&gt;
&lt;p&gt;これからプログラミングの学習を始めたいと思っているみなさん、「&lt;strong&gt;コマンドラインインタフェース&lt;/strong&gt;」はご存知ですか？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/illust.png&#34; alt=&#34;&#34; /&gt;
いわゆるプログラマーなイメージの、「&lt;strong&gt;黒い画面&lt;/strong&gt;」ってやつですね。&lt;/p&gt;
&lt;p&gt;苦手意識を持つ方も多いと思いますが、プログラミングの学習を進めるにあたっては必須となっていきます。&lt;/p&gt;
&lt;p&gt;基本を覚えれば簡単なので、今回はコマンドラインインタフェースの基本操作を覚えていきましょう！&lt;/p&gt;
&lt;!-- ※Windowsの方はこちらの記事を参照してください。
[![](/img/blog/156/link4.png)](/blog/how-to-use-cliwindows) --&gt;
&lt;h2 id=&#34;コマンドラインインタフェース-cli-とは&#34;&gt;コマンドラインインタフェース（CLI）とは&lt;/h2&gt;
&lt;p&gt;コマンドラインインタフェースとは、簡単に言うとPC上で行う操作を&lt;u&gt;キーボード入力（コマンド）だけで操作する画面&lt;/u&gt;のことです。&lt;strong&gt;CLI&lt;/strong&gt;（Comand Line Interface）と呼ばれ、逆に通常マウスなどでPCを扱う画面を&lt;strong&gt;GUI&lt;/strong&gt;（Grafical User Interface）と呼びます。&lt;/p&gt;
&lt;p&gt;Macの人は「ターミナル」を開いてみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/156/cli.png&#34; alt=&#34;&#34; /&gt;
こういう画面です。いわゆる「黒い画面」（画像は白いけど）ってやつです。この画面は「&lt;strong&gt;自分のPC&lt;/strong&gt;」を表示しています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/cli_pwd.png&#34; alt=&#34;&#34; /&gt;
上記のように、「&lt;strong&gt;pwd&lt;/strong&gt;」と打ってエンターしてみてください。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Users/xxx&lt;/code&gt; のように表示されたと思います。これは&lt;code&gt;pwd&lt;/code&gt;という「&lt;strong&gt;現在のディレクトリを教えて&lt;/strong&gt;」というコマンドを打ったので、現在いる場所が表示された状態です。（※ディレクトリ…PC上の住所。フォルダ的なもの。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/gui.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;/Users/xxx&lt;/code&gt; はちょっと聞きなれないディレクトリですが、ファインダーなどで「ユーザ/xxx」を開いていることと同じことを表しています。このファインダーで表示している画面が「GUI」です。&lt;/p&gt;
&lt;p&gt;ちなみに「pwd」は「&lt;u&gt;present working directory&lt;/u&gt;」の略で、それぞれのコマンドは英語に基づいているので合わせて覚えると簡単ですね。&lt;/p&gt;
&lt;h2 id=&#34;基本のコマンドいくつか&#34;&gt;基本のコマンドいくつか&lt;/h2&gt;
&lt;p&gt;ターミナルを開いたときにいる&lt;u&gt;デフォルトの場所を「ホームディレクトリ」&lt;/u&gt;と言います。「cd」というコマンドを打つことでここに戻れます。&lt;/p&gt;
&lt;p&gt;続いて「ls」と打ってみてください。
&lt;img src=&#34;https://dotstud.io/img/blog/156/cli_ls.png&#34; alt=&#34;&#34; /&gt;
「ls」は「list」という意味で、現在のディレクトリ直下にあるディレクトリとファイルが表示されました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/gui_ls.png&#34; alt=&#34;&#34; /&gt;
この場所を見ている状態と同じです。英語と日本語ですが、同じものが表示されていますね！&lt;/p&gt;
&lt;p&gt;ではコマンドライン上で新しいディレクトリを作り、その中へ移動してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/156/cli_mkdir.png&#34; alt=&#34;&#34; /&gt;
「mkdir 任意のディレクトリ名」と打ち、そのあと「cd ディレクトリ名/」と打ちます。（nodeschool説明記事と一緒に書いているので、nodeschool用フォルダを作っています笑）&lt;/p&gt;
&lt;p&gt;※mkdir…make directory / cd…change directory&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/156/gui_mkdir.png&#34; alt=&#34;&#34; /&gt;
これは「ファインダー上で右クリックでファイルを新規作成、ダブルクリックして開く」と同じことです。&lt;/p&gt;
&lt;p&gt;コマンドのあとにディレクトリ名などを指定した部分は、「&lt;strong&gt;引数&lt;/strong&gt;」と言います。コマンドに「こういう名前で作ってね」「ここに移動してね」と渡す部分です。&lt;/p&gt;
&lt;h2 id=&#34;コマンドライン操作の表し方&#34;&gt;コマンドライン操作の表し方&lt;/h2&gt;
&lt;p&gt;「このようにコマンドを打ってみてください」というのを、大抵下記のように表します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir nodeschool
$ cd nodeschool/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;「$」マークはコマンドラインの操作だよーということを表しているので、打つときは不要です。&lt;/p&gt;
&lt;h2 id=&#34;便利なターミナルアプリ&#34;&gt;便利なターミナルアプリ&lt;/h2&gt;
&lt;p&gt;Macにデフォルトで入っている「ターミナル」で進めてもよいのですが、いろいろと便利なターミナルアプリを入れておくのがオススメです。&lt;/p&gt;
&lt;p&gt;よく使われているのは「&lt;a href=&#34;https://www.iterm2.com/&#34;&gt;iTerm&lt;/a&gt;」です。（ちゃんとくの画面もこれ。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/158/separate.png&#34; alt=&#34;&#34; /&gt;
いくつかの操作を並行したいときにこんな感じで画面を分割できたり、進めていく上でなにかと便利なカスタマイズができたりします。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;このような感じで、コマンドでPCを操作する雰囲気が掴めたでしょうか。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;なんでわざわざ難しいコマンドで操作するの？&lt;/strong&gt;」という感じもしますが、&lt;u&gt;ゆくゆくプログラムを管理したり書いたりしていく上で便利になっていく&lt;/u&gt;ので覚えておきましょう！&lt;/p&gt;
&lt;p&gt;もっとコマンドを知りたい！という人は「&lt;strong&gt;UNIXコマンド&lt;/strong&gt;」を調べてみてください！&lt;/p&gt;</description></item><item><title>Google公式ライブラリを利用してNode.jsからGmailの送受信をしてみよう</title><link>https://dotstud.io/blog/gmail-api-from-nodejs/</link><pubDate>Wed, 21 Feb 2018 17:43:26 +0900</pubDate><guid>https://dotstud.io/blog/gmail-api-from-nodejs/</guid><description>
&lt;p&gt;こんにちは、のびすけです。&lt;/p&gt;
&lt;p&gt;Node.jsでGmailを制御する方法は、過去に色々な記事が出ているのですが、全体的に記事が古く、&lt;a href=&#34;https://developers.google.com/gmail/api/quickstart/nodejs?hl=ja&#34;&gt;Gmail API Node.js Quickstart&lt;/a&gt;のチュートリアルも割とわかりにくいなぁという印象です。英語しかないし。&lt;/p&gt;
&lt;p&gt;また、勝手ライブラリも多いのですがメンテナンスされてなく利用していく際の不安も多いです。&lt;/p&gt;
&lt;p&gt;ということで、今日はNode.jsでGmailを使う方法の紹介です。&lt;/p&gt;
&lt;p&gt;以前書いたSpreadSheets記事も同様のGoogle APIライブラリを利用しているので基本的な手順は同じです。&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;135&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/google-spreadsheets-from-nodejs/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/135/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.jsでGoogle SpreadSheetsを操作してみよう。【GAS不使用】
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-12-04
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Node.jsでGoogle SpreadSheetsにアクセスする方法をチュートリアル的に紹介します。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;h2 id=&#34;gmail-apiの有効化とクライアントシークレットの取得&#34;&gt;Gmail APIの有効化とクライアントシークレットの取得&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://console.developers.google.com/start/api?id=gmail&amp;amp;hl=ja&#34;&gt;こちらのリンク&lt;/a&gt;からウィザード開始します。ログインしているGoogleアカウントが利用するGmailのアカウントになるので複数のGoogleやG Suiteのアカウントを持っている人は注意しましょう。&lt;/p&gt;
&lt;p&gt;チェックをして進みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/7aa9886c3113712265ee866ed58f6658.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;少し待つとAPIが有効になるので進みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/2babe62f7ce826080545439c3c2675d9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;認証情報に進みますが&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例によってこの画面は何もせずに&lt;code&gt;キャンセル&lt;/code&gt;ボタンを押しましょう。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/1934915770a80c6fab94ee9818f9cf65.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;このダッシュボード画面になりますが、&lt;code&gt;OAuth同意画面&lt;/code&gt;のタブを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/7f28a9c626ea9f2ecd0b4691ef337859.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ユーザーに表示するサービス名&lt;/code&gt;の箇所に任意の名前を入力して、保存を押して進みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/b93e391525943007cddd5de87a22acbf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;認証情報タブに戻り、&lt;code&gt;認証情報を作成&lt;/code&gt; -&amp;gt; &lt;code&gt;OAuthクライアントID&lt;/code&gt;を選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/57b7c424a42dd9fedaed483ebbf5d84b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;クライアントID作成画面では&lt;code&gt;その他&lt;/code&gt;を選択し、任意の名前を入力します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/124eeda9adf92739b1eff9b1e3afcb42.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;作成すると最初のダッシュボード画面に戻りますが、作成したクライアントIDが表示されています。ここの右下のダウンロードボタンを押すとクライアントシークレットが保存されたJSONファイルがダウンロードされます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/64db51910795b26e05aef6cb9918c33f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;任意の場所に&lt;code&gt;client_secret.json&lt;/code&gt;という名前にリネームして保存しましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/8a4b65dfb3319eee11ddea1d0e7d407d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;これで、 &lt;strong&gt;クライアントシークレットの保存が出来ました。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;node-jsプロジェクトの準備&#34;&gt;Node.jsプロジェクトの準備&lt;/h2&gt;
&lt;p&gt;Node.jsはv9.5.0です。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir gmail
cd gmail
npm init -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先ほどの&lt;code&gt;client_secret.json&lt;/code&gt;をこのディレクトリに移動します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls
package.json client_secret.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ライブラリのインストールをすれば準備完了です。google-auth-libraryのバージョンは1.3.1になります。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm i googleapis google-auth-library --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで準備完了です。&lt;/p&gt;
&lt;h2 id=&#34;アクセストークンの保存&#34;&gt;アクセストークンの保存&lt;/h2&gt;
&lt;p&gt;本家とは少し違うやり方です。&lt;/p&gt;
&lt;p&gt;本家のコードだとアクセストークンの作成&amp;amp;保存作業と実際のAPI呼び出しが一緒になったコードですがトークンの作成&amp;amp;保存は最初のみ行えば良いので手順を分けて紹介します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getAndStoreToken.js&lt;/code&gt;を作成します。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/google-spreadsheets-from-nodejs/&#34;&gt;前回の記事のコード&lt;/a&gt;とほぼ同様ですが、APIライブラリのバージョンの違いにより、呼び出し方が少し異なります。注意しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//getAndStoreToken.js
&#39;use strict&#39;;
const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});
const {promisify} = require(&#39;util&#39;);
const {google} = require(&#39;googleapis&#39;);
const {OAuth2Client} = require(&#39;google-auth-library&#39;);
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);
const SCOPES = [&#39;https://www.googleapis.com/auth/gmail.send&#39;,&#39;https://www.googleapis.com/auth/gmail.readonly&#39;];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+&#39;/gmail-nodejs-quickstart.json&#39;;
const main = async () =&amp;gt; {
const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
//get new token
const authUrl = oauth2Client.generateAuthUrl({
access_type: &#39;offline&#39;,
scope: SCOPES
});
console.log(&#39;Authorize this app by visiting this url: &#39;, authUrl);
rl.question(&#39;Enter the code from that page here: &#39;, (code) =&amp;gt; {
rl.close();
oauth2Client.getToken(code, async (err, token) =&amp;gt; {
if (err) {
console.log(&#39;Error while trying to retrieve access token&#39;, err);
return;
}
oauth2Client.credentials = token;
try {
fs.mkdirSync(TOKEN_DIR);
} catch (err) {
if (err.code != &#39;EEXIST&#39;) throw err;
}
await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
console.log(&#39;Token stored to &#39; + TOKEN_PATH);
});
});
};
main();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここで&lt;code&gt;&#39;https://www.googleapis.com/auth/gmail.readonly&#39;,&#39;https://www.googleapis.com/auth/gmail.send&#39;&lt;/code&gt;の二つのスコープを指定していますが、表示用のgmail.readonlyとメール送信用のgmail.sendとなっています。表示だけしたい場合や送信だけしたい場合などで使い分けましょう。スコープについては&lt;a href=&#34;https://developers.google.com/gmail/api/auth/scopes&#34;&gt;
Choose Auth Scopes&lt;/a&gt;で細かく確認できます。&lt;/p&gt;
&lt;p&gt;では、このプログラムを実行しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node getAndStoreToken.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://accounts.google.com/~&lt;/code&gt;で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;アカウント選択画面になります。 複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/c5f18901079fc0f4c0362cb0213e89c6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;許可で進みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;認証用のコードが発行されるので、ターミナルの&lt;code&gt;Enter the code from that page here:&lt;/code&gt;と書いてある箇所にコピぺしてEnterで進みます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Token stored to /Users/path/to/myapp/gmail-nodejs-quickstart.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;などの表示が出て、&lt;code&gt;gmail-nodejs-quickstart.json&lt;/code&gt;が保存されます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/4fc90f71b3520a01ce2c568eb28e005f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;これでアクセストークンの保存が完了しました。&lt;/p&gt;
&lt;h2 id=&#34;4-いよいよgmailにアクセス&#34;&gt;4. いよいよGmailにアクセス&lt;/h2&gt;
&lt;p&gt;いよいよGmailにアクセスします。&lt;/p&gt;
&lt;h3 id=&#34;ラベル一覧の取得&#34;&gt;ラベル一覧の取得&lt;/h3&gt;
&lt;p&gt;本家チュートリアルを参考に、ラベルの一覧を取得します。
&lt;code&gt;getLabels.js&lt;/code&gt;を作成します。&lt;/p&gt;
&lt;p&gt;ここから先に出てくる&lt;code&gt;userId: &#39;me&#39;&lt;/code&gt;の&lt;code&gt;me&lt;/code&gt;は指定されている文字列らしく、自分のメアドやアカウント名をあえて指定する必要はなくそのまま&lt;code&gt;me&lt;/code&gt;と書いておけば問題なさそうです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//getLabels.js
&#39;use strict&#39;;
const fs = require(&#39;fs&#39;);
const {promisify} = require(&#39;util&#39;);
const {google} = require(&#39;googleapis&#39;);
const {OAuth2Client} = require(&#39;google-auth-library&#39;);
const gmail = google.gmail(&#39;v1&#39;);
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const gmailListLabesAsync = promisify(gmail.users.labels.list); //Gmailのラベル一覧
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + &#39;/gmail-nodejs-quickstart.json&#39;; //アクセストークンのファイルを指定
const main = async () =&amp;gt; {
//クレデンシャル情報の取得
const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;); //クライアントシークレットのファイルを指定
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
const token = await readFileAsync(TOKEN_PATH);
oauth2Client.credentials = JSON.parse(token);
//API経由でシートにアクセス
const response = await gmailListLabesAsync({
auth: oauth2Client,
userId: &#39;me&#39;,
});
//結果を表示
console.log(response.data);
};
main();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Async/Awaitで利用できるように&lt;code&gt;const gmailListLabesAsync = promisify(gmail.users.labels.list);&lt;/code&gt;の箇所でPromisifyを利用してプロミス化しています。&lt;/p&gt;
&lt;p&gt;実行するとラベル一覧が取得できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node getLabels.js
{ labels:
[ { id: &#39;Label_125&#39;,
name: &#39;研修/青山学院大学&#39;,
messageListVisibility: &#39;show&#39;,
labelListVisibility: &#39;labelShow&#39;,
type: &#39;user&#39;,
color: [Object] },
{ id: &#39;Label_40&#39;,
name: &#39;取引/養老乃瀧&#39;,
messageListVisibility: &#39;show&#39;,
labelListVisibility: &#39;labelShow&#39;,
type: &#39;user&#39;,
color: [Object] },
・
・
・
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会社のメールの内容なので出せるところだけ笑&lt;/p&gt;
&lt;h3 id=&#34;メールの内容を取得&#34;&gt;メールの内容を取得&lt;/h3&gt;
&lt;p&gt;メールの内容は&lt;code&gt;Users.messages: list&lt;/code&gt;と&lt;code&gt;Users.messages: get&lt;/code&gt;を利用します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/get&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/get&lt;/a&gt;
&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/list&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;必要な箇所だけ抜粋しますが、&lt;code&gt;gmail.users.messages.list()&lt;/code&gt;と&lt;code&gt;gmail.users.messages.get()&lt;/code&gt;というメソッドがあるので利用します。
Async/Awaitで利用できるように、先ほど同様Promisifyします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const gmailGetMessagesAsync = promisify(gmail.users.messages.get);
const gmailListMessagesAsync = promisify(gmail.users.messages.list);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;メッセージリストを取得し、メッセージごとのIDを取得します。メッセージIDをもとにメッセージ本文を取得。
最後に本文はBase64変換されてるのでデコードして表示します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;省略
//メッセージリストの取得
let res = await gmailListMessagesAsync({
auth: oauth2Client,
userId: &#39;me&#39;
});
const newestMessageId = res.messages[0].id; //最新のメッセージID
//メッセージの取得
res = await gmailGetMessagesAsync({
auth: oauth2Client,
userId: &#39;me&#39;,
id: newestMessageId
});
//結果を表示
const base64mailBody = res.payload.parts[0].body.data; //parts[0]がテキスト、parts[1]がHTMLメールっぽい(?)
const mailBody = new Buffer(base64mailBody, &#39;base64&#39;).toString(); //メール本文はBase64になってるので変換
console.log(mailBody);//やっとメール本文が表示される
省略
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;メールの送信&#34;&gt;メールの送信&lt;/h3&gt;
&lt;p&gt;送信が割と大変でした。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Users.messages: send&lt;/code&gt;を利用します。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/send&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/send&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;gmail.users.messages.send()&lt;/code&gt;のメソッドを利用します。
先ほどと同様にPromisifyします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const gmailSendMessagesAsync = promisify(gmail.users.messages.send);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;次にメール送信時の処理です。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;省略
const makeBody = (params) =&amp;gt; {
params.subject = new Buffer(params.subject).toString(&amp;quot;base64&amp;quot;); //日本語対応
const str = [
`Content-Type: text/plain; charset=\&amp;quot;UTF-8\&amp;quot;\n`,
`MIME-Version: 1.0\n`,
`Content-Transfer-Encoding: 7bit\n`,
`to: ${params.to} \n`,
`from: ${params.from} \n`,
`subject: =?UTF-8?B?${params.subject}?= \n\n`,
params.message
].join(&#39;&#39;);
return new Buffer(str).toString(&amp;quot;base64&amp;quot;).replace(/\+/g, &#39;-&#39;).replace(/\//g, &#39;_&#39;);
}
const messageBody = `
XXXX 様
商品のご購入、誠にありがとうございます。
・Nefry BT x 1
の商品を本日発送しましたのでご連絡差し上げます。
こちらから配送状況をご確認頂けます。
(このメール送信の時点では反映されていない可能性もあります)
https://trackings.post.japanpost.jp/xxxxxxxxxx`;
const raw = makeBody({
to: &#39;相手のメールアドレス&#39;,
from: &#39;送信者のメールアドレス&#39;,
subject: &#39;件名(日本語可)&#39;,
message: messageBody
});
const res = await gmailSendMessagesAsync({
auth: oauth2Client,
userId: &#39;me&#39;,
resource: {
raw: raw
}
});
console.log(res.data);
省略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sendMail.js&lt;/code&gt;などを作成し、この内容で実行するとメールが送信できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node sendMail.js
{ id: &#39;xxxxxxxxxxxxxxxxx&#39;,
threadId: &#39;xxxxxxxxxxxxxxxx&#39;,
labelIds: [ &#39;SENT&#39; ] }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Gmail側で受信確認をすると、しっかりと送られてきています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3ad5f4729e90c9523e2e6e5cb972349b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;また、暗号化もされているようで、&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/mail/answer/6330403?authuser=2&amp;amp;visit_id=1-636548034928176578-836942562&amp;amp;p=tls&amp;amp;hl=ja&amp;amp;rd=1&#34;&gt;送受信時のメールの暗号化 - Gmailヘルプ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/247eb44de5f0b635d52fd2b0c06a4de3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Node.jsのメール送信ライブラリはいくつかあって、いくつか試したときに暗号化されてない場合も多かった印象です。暗号化無しだと、この赤いアラートっぽいメール表示になります。&lt;/p&gt;
&lt;p&gt;今回のやり方はGoogle公式のライブラリで、特に意識せずに暗号化も行われているので暗号化に対するアラートなども受け取り手には表示されないので迷惑メールなどに振り分けられてしまう心配もたぶん少ないのでは。
（Gmailの迷惑メールアルゴリズムは色々な要素がありそうなので断言は出来ないですが）&lt;/p&gt;
&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;
&lt;p&gt;実装途中の感想ですが、メール送信が割と苦労した印象です。&lt;/p&gt;
&lt;p&gt;メール送信のNode.jsサンプルが無かったので、&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/send#examples&#34;&gt;JavaScript Sample&lt;/a&gt;を見ると、送信パラメータに&lt;code&gt;email RFC 5322 formatted String.&lt;/code&gt;という記述があってRFCのフォーマットを確認する必要がありました。&lt;/p&gt;
&lt;p&gt;この手のライブラリだと&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const params = {
to: &#39;&#39;,
from: &#39;&#39;,
subject: &#39;&#39;,
body: &#39;&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;みたいな形式のObjectを突っ込めばいい感じにやってくれる印象があったので&amp;hellip;&amp;hellip;苦笑&lt;/p&gt;
&lt;p&gt;Stack Over Flowの&lt;a href=&#34;https://stackoverflow.com/questions/34546142/gmail-api-for-sending-mails-in-node-js&#34;&gt;Gmail API for sending mails in Node.js&lt;/a&gt;がかなり参考になりました。&lt;/p&gt;
&lt;p&gt;また、日本語でのSubject送信に&lt;code&gt;=?文字コード?メソッド?Base64変換した文字列?=&lt;/code&gt;という形式で渡すなどは&lt;a href=&#34;http://hogem.hatenablog.com/entry/20100122/1264169093&#34;&gt;メールのSubjectヘッダのエンコード&lt;/a&gt;の記事が参考になりました。&lt;/p&gt;
&lt;p&gt;とはいえ、問題なくメール送信出来たので、この記事を参考に使ってみてください。&lt;/p&gt;
&lt;p&gt;それでは！&lt;/p&gt;
&lt;h2 id=&#34;補足-本家のチュートリアルのエラー&#34;&gt;補足: 本家のチュートリアルのエラー&lt;/h2&gt;
&lt;p&gt;今回紹介した手順では問題ないですが、もともとのチュートリアルのコードだと以下の二つのエラーが出ました。(2018年2月時点)&lt;/p&gt;
&lt;h3 id=&#34;google-gmail-is-not-a-function&#34;&gt;google.gmail is not a function&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;google.gmail() is giving an error TypeError: google.gmail is not a function?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ってエラーが出ました。&lt;/p&gt;
&lt;p&gt;Stack Over Flowの&lt;a href=&#34;https://stackoverflow.com/questions/48762090/google-gmail-is-giving-an-error-typeerror-google-gmail-is-not-a-function&#34;&gt;google.gmail() is giving an error TypeError: google.gmail is not a function?&lt;/a&gt;を参考に&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var google = require(&#39;googleapis&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを↓に変更するとエラー解消されます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {google} = require(&#39;googleapis&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;googleauth-is-not-a-constructor&#34;&gt;GoogleAuth is not a constructor&lt;/h3&gt;
&lt;p&gt;こちらはIssueがあがっていて&lt;a href=&#34;https://github.com/google/google-auth-library-nodejs/issues/251&#34;&gt;GoogleAuth is not a constructor #251&lt;/a&gt;を見ると、&lt;/p&gt;
&lt;p&gt;呼び出し方が変更されてて、以下の修正が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const { GoogleAuth } = require(&#39;google-auth-library&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;↓&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const { OAuth2Client } = require(&#39;google-auth-library&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、今の変更に伴いOAuthの処理も変更が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;↓&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//const auth = new googleAuth();
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで問題なく利用できるようになりました。&lt;/p&gt;</description></item><item><title>Node.jsを始めよう！nodebrewを使って5分で環境構築</title><link>https://dotstud.io/blog/nodejs-install-use-nodebrew/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://dotstud.io/blog/nodejs-install-use-nodebrew/</guid><description>
&lt;p&gt;この記事は&lt;a href=&#34;https://qiita.com/advent-calendar/2017/nodejs2&#34;&gt;Node.js Advent Calendar 2017&lt;/a&gt;に参加しています！&lt;/p&gt;
&lt;p&gt;こんにちは、エンジニアのちゃんとくです。「これからNode.jsを始めたい！」という人向けに導入記事をまとめていきたいと思います。まずは環境構築からはじめましょう！&lt;/p&gt;
&lt;p&gt;今回はNode.jsのバージョンを管理できる「&lt;strong&gt;nodebrew&lt;/strong&gt;」を使ったインストール手順を紹介します。&lt;/p&gt;
&lt;h2 id=&#34;普通のダウンロードじゃダメなの&#34;&gt;普通のダウンロードじゃダメなの？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/1.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js公式ページ&lt;/a&gt;にアクセスすると、どーんとダウンロードボタンがありますね。これをクリックすると、表記のバージョンのNode.jsパッケージが降ってきます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;しかし！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Node.jsはバージョンアップの頻度が高く、その都度ダウンロードし直すのは大変ですよね。&lt;/p&gt;
&lt;p&gt;プロジェクトによっては古いバージョンを使いたかったり、プロジェクトごとにバージョンを変えたかったりしたいときもあります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;そこで役に立つのがNode.jsのバージョン管理ツールです&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;今回紹介する&lt;strong&gt;nodebrew&lt;/strong&gt;以外にも、世界的に利用者の多い&lt;strong&gt;NVM&lt;/strong&gt;（Node Version Manager）やWindows向けの&lt;strong&gt;nodist&lt;/strong&gt;などがあります。&lt;/p&gt;
&lt;p&gt;今回は日本人コミッタが多く困ったときにも質問しやすいnodebrewでやってみます！&lt;/p&gt;
&lt;h2 id=&#34;nodebrewをインストール&#34;&gt;nodebrewをインストール&lt;/h2&gt;
&lt;p&gt;さっそくnodebrewをインストールしましょう！以下のコマンドを実行します。（&lt;code&gt;$&lt;/code&gt;マークはCLIであることを表しているのでコピペの際は不要です！）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -L git.io/nodebrew | perl - setup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完了するとこんなことを言われます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;「&lt;code&gt;~/.nodebrew&lt;/code&gt;にインストールしたからPATH通してね！」というようなことを言っています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt;などの設定ファイルに&lt;code&gt;export PATH=$HOME/.nodebrew/current/bin:$PATH&lt;/code&gt;を追加しましょう。&lt;/p&gt;
&lt;p&gt;追記したらターミナルを開き直すか&lt;code&gt;source&lt;/code&gt;コマンドで更新します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nodebrewコマンドが使えるか確認してみます。&lt;code&gt;command not found&lt;/code&gt;が出なければOKです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew help
nodebrew 0.9.8
Usage:
…
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nodebrewでnode-jsをインストール&#34;&gt;nodebrewでNode.jsをインストール&lt;/h2&gt;
&lt;p&gt;まずは&lt;code&gt;nodebrew ls-remote&lt;/code&gt;コマンドでダウンロード可能なNode.jsのバージョンを確認してみます。&lt;/p&gt;
&lt;p&gt;Node.jsは偶数のバージョンがLTS（安定板）、奇数のバージョンが最新版となっています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew ls-remote
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/3.png&#34; alt=&#34;&#34; /&gt;
実行するとべろーっとバージョンが出てきますね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/4.png&#34; alt=&#34;&#34; /&gt;
下の方まで見ると2017年12月15日現在はLTSがv8.9.3、最新がv9.3.0であることがわかりました。（io.jsはNode.jsのForkですが、一旦気にしなくてOK）&lt;/p&gt;
&lt;p&gt;今回は最新版のv9.3.0をインストールしてみます。&lt;code&gt;nodebrew install-binary&lt;/code&gt;コマンドを利用します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew install-binary v9.3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1分くらいでインストールは完了します。（ダメ回線なので、もっと速いかもしれません）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nodebrew ls&lt;/code&gt;コマンドで状態を確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew ls
v9.3.0
current: none
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用するバージョンの&lt;code&gt;current&lt;/code&gt;がnoneになっているので指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew use v9.3.0
$ node -v
v9.3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでNode.jsのインストールは完了です！&lt;/p&gt;
&lt;h2 id=&#34;バージョン切り替え&#34;&gt;バージョン切り替え&lt;/h2&gt;
&lt;p&gt;別のバージョンを使いたくなったら、nodebrewでバージョンを切り替えてみましょう。&lt;/p&gt;
&lt;p&gt;試しにLTSのv8.9.3を使えるようにしてみます。まずはインストール。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew install-binary v8.9.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;v8.9.3とv9.3.0が使えるようになりましたが、まだ&lt;code&gt;current&lt;/code&gt;はv9.3.0のままです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew list
v8.9.3
v9.3.0
current: v9.3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;nodebrew use&lt;/code&gt;でv8.9.3を指定します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nodebrew use v8.9.3
$ nodebrew list
v8.9.3
v9.3.0
current: v8.9.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでバージョンが切り替えられました！listにあるバージョンは再インストールすることなく切り替えられます。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;ここまで特にむずかしいところなく環境構築できたのではないかと思います！はじめるまでの手軽さもNode.jsの魅力のひとつですよね。&lt;/p&gt;
&lt;p&gt;次回はNode.jsをはじめたばかりの人向けチュートリアルをやってみたいと思います。&lt;/p&gt;
&lt;p&gt;それではまた！&lt;/p&gt;</description></item><item><title>Node.jsでGoogle SpreadSheetsを操作してみよう。【GAS不使用】</title><link>https://dotstud.io/blog/google-spreadsheets-from-nodejs/</link><pubDate>Mon, 04 Dec 2017 13:14:41 +0900</pubDate><guid>https://dotstud.io/blog/google-spreadsheets-from-nodejs/</guid><description>
&lt;p&gt;こんにちは、代表ののびすけです。&lt;/p&gt;
&lt;p&gt;この記事は&lt;a href=&#34;https://qiita.com/advent-calendar/2017/nodejs&#34;&gt;Node.jsアドベントカレンダー2017&lt;/a&gt;の記事になります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://developers.google.com/apps-script/&#34;&gt;GAS&lt;/a&gt;じゃなくてNode.jsから直接スプレッドシートにアクセスしたい！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;そう思って調べると&lt;a href=&#34;https://developers.google.com/sheets/api/quickstart/nodejs&#34;&gt;Node.js Quickstart | Sheets API | Google Developers&lt;/a&gt;が出て来ますが、JS記述も古いし英語なので少しとっつきにくいです。&lt;/p&gt;
&lt;p&gt;ということでちょっと試して記録残そうと思います。&lt;/p&gt;
&lt;h2 id=&#34;google-sheets-api&#34;&gt;Google Sheets API&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/sheets/guides/concepts?hl=ja&#34;&gt;Google Sheets API&lt;/a&gt;はスプレッドシートにアクセスできるようになるAPIです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/81dd3461cd263ea7e4d63f06fef54747.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Sheets API を使用すると、スプレッドシートの要素を読み取って変更できます。 スプレッドシートは多くの設定を備えており、美しく機能的なシートを作成することができます。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;普段慣れている言語でスプレッドシートにアクセス出来まるので、簡単な操作であれば、GASを使う必要もないです。&lt;/p&gt;
&lt;p&gt;今回のサンプルは&lt;a href=&#34;https://github.com/n0bisuke/google-spread-sheet-node.js-sample&#34;&gt;こちら&lt;/a&gt;に置いておきます。&lt;/p&gt;
&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考までに今回の僕の環境です。&lt;/p&gt;
&lt;p&gt;では実際に作っていきます。&lt;/p&gt;
&lt;h2 id=&#34;1-google-sheets-apiを使えるようにする&#34;&gt;1. Google Sheets APIを使えるようにする&lt;/h2&gt;
&lt;p&gt;ちなみに2017年12月時点でのウィザードです。こういうのはアップデートによって画面遷移変わるので適宜読み替えてください。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use this wizard to create or select a project in the Google Developers Console and automatically turn on the API. Click Continue, then Go to credentials.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://console.developers.google.com/start/api?id=sheets.googleapis.com&#34;&gt;こちらのリンク&lt;/a&gt;からディベロッパーコンソールにいき、&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/31e8011951d1552b8f7126eb459da474.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;新機能のお知らせ、パフォーマンスに関するアドバイス、フィードバック調査、特典に関する最新情報をメールで受け取ります。&lt;/code&gt;の質問はいいえでもたぶん大丈夫です。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/60c5bf6a1e772473dc9fc6d4d7526077.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;認証情報に進む&lt;/code&gt;を選択&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/848f8f79460aac991b46956111f0da07.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;この画面が出ますが、&lt;code&gt;キャンセル&lt;/code&gt;を選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/e827d6ab-d728-1016-d22a-76cef4e4972e.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.00.17.png&#34; title=&#34;スクリーンショット 2017-12-03 21.00.17.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OAuth同意画面&lt;/code&gt;のタブを選択し、メールアドレスを確認し、&lt;code&gt;ユーザーに表示するサービス名&lt;/code&gt;を入力します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;保存&lt;/code&gt;を選択しましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/1ca3a2d5-b639-bb6c-9508-225d162c96ff.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.01.07.png&#34; title=&#34;スクリーンショット 2017-12-03 21.01.07.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;次に、&lt;code&gt;認証情報&lt;/code&gt;のタブを選択し、 &lt;code&gt;認証情報を作成&lt;/code&gt; -&amp;gt; &lt;code&gt;OAuthクライアントID&lt;/code&gt;を選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3d5b6da9cf3086b11c728cdc31307268.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;その他&lt;/code&gt;を選択し、任意の名前をつけて&lt;code&gt;作成&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/a8a25dd3-a194-d4a3-ac57-909f8d7712e0.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.06.47.png&#34; title=&#34;スクリーンショット 2017-12-03 21.06.47.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OK&lt;/code&gt;で進みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/93c1e777-682e-434e-444d-a3aa8659bd54.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.07.25.png&#34; title=&#34;スクリーンショット 2017-12-03 21.07.25.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;client_secret_xxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com.json&lt;/code&gt;のようなファイルがダウンロードされます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;これを&lt;code&gt;client_secret.json&lt;/code&gt;にリネームしましょう。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-node-jsプロジェクトの準備&#34;&gt;2. Node.jsプロジェクトの準備&lt;/h2&gt;
&lt;p&gt;任意のディレクトリを作成して移動します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sheetstest&lt;/code&gt;としました。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir sheetstest
cd sheetstest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;npm init -y&lt;/code&gt;で&lt;code&gt;package.json&lt;/code&gt;を作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このディレクトリに先ほどの&lt;code&gt;client_secret.json&lt;/code&gt;を移動させます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls
package.json client_secret.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3d796ef0005ef28b914a83517772c65e.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;こんな感じです。&lt;/p&gt;
&lt;p&gt;利用するモジュールを追加します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i googleapis google-auth-library --save
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-トークンの作成-保存-最初だけ&#34;&gt;3. トークンの作成&amp;amp;保存 (最初だけ)&lt;/h2&gt;
&lt;p&gt;本家とは少し違うやり方です。&lt;/p&gt;
&lt;p&gt;本家のコードだと&lt;code&gt;トークンの作成&amp;amp;保存&lt;/code&gt;作業と実際のAPI呼び出しが一緒になったコードですが&lt;code&gt;トークンの作成&amp;amp;保存&lt;/code&gt;は最初のみ行えば良いので手順を分けて紹介します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getAndStoreToken.js&lt;/code&gt;を作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//getAndStoreToken.js
&#39;use strict&#39;;
const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});
const {promisify} = require(&#39;util&#39;);
const google = require(&#39;googleapis&#39;);
const googleAuth = require(&#39;google-auth-library&#39;);
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);
const SCOPES = [&#39;https://www.googleapis.com/auth/spreadsheets.readonly&#39;];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+&#39;/sheets.googleapis.com-nodejs-quickstart.json&#39;;
const main = async () =&amp;gt; {
const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
//get new token
const authUrl = oauth2Client.generateAuthUrl({
access_type: &#39;offline&#39;,
scope: SCOPES
});
console.log(&#39;Authorize this app by visiting this url: &#39;, authUrl);
rl.question(&#39;Enter the code from that page here: &#39;, (code) =&amp;gt; {
rl.close();
oauth2Client.getToken(code, async (err, token) =&amp;gt; {
if (err) {
console.log(&#39;Error while trying to retrieve access token&#39;, err);
return;
}
oauth2Client.credentials = token;
try {
fs.mkdirSync(TOKEN_DIR);
} catch (err) {
if (err.code != &#39;EEXIST&#39;) throw err;
}
await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
console.log(&#39;Token stored to &#39; + TOKEN_PATH);
});
});
};
main();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このプログラムを実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node getAndStoreToken.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://accounts.google.com/~&lt;/code&gt;で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.52.54.png&#34; title=&#34;スクリーンショット 2017-12-04 11.52.54.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;アカウント選択画面になります。
複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/18729d60-e4a6-8996-9519-f9f4750ae1f4.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.53.02.png&#34; title=&#34;スクリーンショット 2017-12-04 11.53.02.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;許可&lt;/code&gt;で進みます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.53.09.png&#34; title=&#34;スクリーンショット 2017-12-04 11.53.09.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;認証用のコードが発行されます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/fd612d7c-0b45-3d09-64ab-c1e02315fe81.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.53.27.png&#34; title=&#34;スクリーンショット 2017-12-04 11.53.27.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;これをコピーしてターミナルに貼り付けてエンターキーで進みます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Token stored to /Users/n0bisuke/dotstudio/playground/sheetstest/sheets.googleapis.com-nodejs-quickstart.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;などと表示されてjsonファイルが保存されます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/830452dc-ad36-83ef-8cf8-8c80bc9637dd.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.57.50.png&#34; title=&#34;スクリーンショット 2017-12-04 11.57.50.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sheets.googleapis.com-nodejs-quickstart.json&lt;/code&gt;がフォルダ内に確認できればOKです。&lt;/p&gt;
&lt;h2 id=&#34;4-いよいよシートにアクセス&#34;&gt;4. いよいよシートにアクセス&lt;/h2&gt;
&lt;p&gt;さて最後の手順です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getSheetsData.js&lt;/code&gt;を作成しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//getSheetsData.js
&#39;use strict&#39;;
const fs = require(&#39;fs&#39;);
const {promisify} = require(&#39;util&#39;);
const google = require(&#39;googleapis&#39;);
const googleAuth = require(&#39;google-auth-library&#39;);
const sheets = google.sheets(&#39;v4&#39;);
//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const ssValuesGetAsync = promisify(sheets.spreadsheets.values.get);
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + &#39;/sheets.googleapis.com-nodejs-quickstart.json&#39;;
const main = async () =&amp;gt; {
//クレデンシャル情報の取得
const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
const credentials = JSON.parse(content); //クレデンシャル
//認証
const clientSecret = credentials.installed.client_secret;
const clientId = credentials.installed.client_id;
const redirectUrl = credentials.installed.redirect_uris[0];
const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
const token = await readFileAsync(TOKEN_PATH);
oauth2Client.credentials = JSON.parse(token);
//API経由でシートにアクセス
const apiOptions = {
auth: oauth2Client,
spreadsheetId: &#39;1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms&#39;,
range: &#39;Class Data!A2:E&#39;,
};
const response = await ssValuesGetAsync(apiOptions);
//結果を表示
console.log(response);
};
main();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これを実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node getSheetsData.js
{ range: &#39;\&#39;Class Data\&#39;!A2:E101&#39;,
majorDimension: &#39;ROWS&#39;,
values:
[ [ &#39;Alexandra&#39;, &#39;Female&#39;, &#39;4. Senior&#39;, &#39;CA&#39;, &#39;English&#39; ],
[ &#39;Andrew&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;SD&#39;, &#39;Math&#39; ],
[ &#39;Anna&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;NC&#39;, &#39;English&#39; ],
[ &#39;Becky&#39;, &#39;Female&#39;, &#39;2. Sophomore&#39;, &#39;SD&#39;, &#39;Art&#39; ],
[ &#39;Benjamin&#39;, &#39;Male&#39;, &#39;4. Senior&#39;, &#39;WI&#39;, &#39;English&#39; ],
[ &#39;Carl&#39;, &#39;Male&#39;, &#39;3. Junior&#39;, &#39;MD&#39;, &#39;Art&#39; ],
[ &#39;Carrie&#39;, &#39;Female&#39;, &#39;3. Junior&#39;, &#39;NE&#39;, &#39;English&#39; ],
[ &#39;Dorothy&#39;, &#39;Female&#39;, &#39;4. Senior&#39;, &#39;MD&#39;, &#39;Math&#39; ],
[ &#39;Dylan&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;MA&#39;, &#39;Math&#39; ],
[ &#39;Edward&#39;, &#39;Male&#39;, &#39;3. Junior&#39;, &#39;FL&#39;, &#39;English&#39; ],
[ &#39;Ellen&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;WI&#39;, &#39;Physics&#39; ],
[ &#39;Fiona&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;MA&#39;, &#39;Art&#39; ],
[ &#39;John&#39;, &#39;Male&#39;, &#39;3. Junior&#39;, &#39;CA&#39;, &#39;Physics&#39; ],
[ &#39;Jonathan&#39;, &#39;Male&#39;, &#39;2. Sophomore&#39;, &#39;SC&#39;, &#39;Math&#39; ],
[ &#39;Joseph&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;AK&#39;, &#39;English&#39; ],
[ &#39;Josephine&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;NY&#39;, &#39;Math&#39; ],
[ &#39;Karen&#39;, &#39;Female&#39;, &#39;2. Sophomore&#39;, &#39;NH&#39;, &#39;English&#39; ],
[ &#39;Kevin&#39;, &#39;Male&#39;, &#39;2. Sophomore&#39;, &#39;NE&#39;, &#39;Physics&#39; ],
[ &#39;Lisa&#39;, &#39;Female&#39;, &#39;3. Junior&#39;, &#39;SC&#39;, &#39;Art&#39; ],
[ &#39;Mary&#39;, &#39;Female&#39;, &#39;2. Sophomore&#39;, &#39;AK&#39;, &#39;Physics&#39; ],
[ &#39;Maureen&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;CA&#39;, &#39;Physics&#39; ],
[ &#39;Nick&#39;, &#39;Male&#39;, &#39;4. Senior&#39;, &#39;NY&#39;, &#39;Art&#39; ],
[ &#39;Olivia&#39;, &#39;Female&#39;, &#39;4. Senior&#39;, &#39;NC&#39;, &#39;Physics&#39; ],
[ &#39;Pamela&#39;, &#39;Female&#39;, &#39;3. Junior&#39;, &#39;RI&#39;, &#39;Math&#39; ],
[ &#39;Patrick&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;NY&#39;, &#39;Art&#39; ],
[ &#39;Robert&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;CA&#39;, &#39;English&#39; ],
[ &#39;Sean&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;NH&#39;, &#39;Physics&#39; ],
[ &#39;Stacy&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;NY&#39;, &#39;Math&#39; ],
[ &#39;Thomas&#39;, &#39;Male&#39;, &#39;2. Sophomore&#39;, &#39;RI&#39;, &#39;Art&#39; ],
[ &#39;Will&#39;, &#39;Male&#39;, &#39;4. Senior&#39;, &#39;FL&#39;, &#39;Math&#39; ] ] }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このサンプルでは&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit#gid=0&#34;&gt;こちらのワークブック&lt;/a&gt;へアクセスして情報を取得しています。&lt;/p&gt;
&lt;p&gt;ちなみに用語的には&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ワークブック＝Googleスプレッドシートの１ファイル&lt;/li&gt;
&lt;li&gt;シート＝ワークブック内のタブ、シート&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というニュアンスです。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//省略
const apiOptions = {
auth: oauth2Client,
spreadsheetId: &#39;1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms&#39;,
range: &#39;Class Data!A2:E&#39;,
};
//省略
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ほかのワークブックにアクセスする場合は&lt;code&gt;https://docs.google.com/spreadsheets/d/&lt;/code&gt;の後に続くIDを&lt;code&gt;spreadsheetId&lt;/code&gt;に指定して実行しましょう。&lt;code&gt;range&lt;/code&gt;は&lt;code&gt;シート名:取得する範囲&lt;/code&gt;という形式で指定して、指定したシートの指定した範囲からセルの情報を取得します。&lt;/p&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;これで次回以降は4番目の手順だけでスプレッドシートにアクセスできます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;client_secret.json&lt;/code&gt;や&lt;code&gt;sheets.googleapis.com-nodejs-quickstart.json&lt;/code&gt;をコピーしてサーバー設置しておけば自動更新する仕組みなども作れます。&lt;/p&gt;
&lt;p&gt;スプレッドシートは色々な場面で利用されているツールなので是非システム連携などに活用してみて下さい。&lt;/p&gt;
&lt;p&gt;応用としてはこちらの内容で使っています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://qiita.com/n0bisuke/items/3313a64c56317932919e&#34;&gt;勉強会( #IoTLT )の登壇者管理でHeadless Chromeを利用している話&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;それでは！&lt;/p&gt;</description></item><item><title>Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.3</title><link>https://dotstud.io/blog/hexo-static-site-vol3/</link><pubDate>Tue, 31 Oct 2017 17:53:15 +0900</pubDate><guid>https://dotstud.io/blog/hexo-static-site-vol3/</guid><description>
&lt;p&gt;こんにちは、エンジニアのちゃんとくです。ひょんなことから&lt;a href=&#34;https://nodejs.connpass.com/&#34;&gt;&lt;strong&gt;Node女学園&lt;/strong&gt;&lt;/a&gt;というNode.jsを学ぶ女性のためのコミュニティを立ち上げました。&lt;/p&gt;
&lt;p&gt;このシリーズではNode女学園のブログを作りながら、&lt;strong&gt;Node.js製の静的サイトジェネレータ「Hexo」&lt;/strong&gt;の使い方を紹介していきます！&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/hexo-static-site-vol2&#34;&gt;&lt;strong&gt;前回&lt;/strong&gt;&lt;/a&gt;はデザインを当ててブログのカスタマイズをしてみました。&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;107&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/hexo-static-site-vol2/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/107/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.2
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-07-25
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Node.jsによるNode.jsのためのサイトづくり！テーマを当てておしゃれ感を出す回です。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;p&gt;今回はルートを追加してブログ記事以外のページを作ってみます。&lt;/p&gt;
&lt;h2 id=&#34;今回やること&#34;&gt;今回やること&lt;/h2&gt;
&lt;p&gt;現在はコマンドで記事を追加すると&lt;code&gt;サイトURL/:YYYY/:MM/:DD&lt;/code&gt;という記事が作成されるようになっています。&lt;/p&gt;
&lt;p&gt;これを変更して、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;サイトURL/about/&lt;/code&gt;という情報ページを追加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;サイトURL/blog/:title&lt;/code&gt;に記事を生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というのをやってみます。&lt;/p&gt;
&lt;h2 id=&#34;新しいルートを追加&#34;&gt;新しいルートを追加&lt;/h2&gt;
&lt;p&gt;ルートの追加は、&lt;code&gt;hexo new page &amp;quot;[新しいルート]&amp;quot;&lt;/code&gt;というコマンドで簡単にできます。
&lt;img src=&#34;https://dotstud.io/img/blog/108/new_route.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;コマンドを実行すると&lt;code&gt;/source&lt;/code&gt;の下に新しいディレクトリが作成されます。
&lt;img src=&#34;https://dotstud.io/img/blog/108/about_dir.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;作成された&lt;code&gt;about/index.md&lt;/code&gt;にページ内容を記載します。&lt;/p&gt;
&lt;p&gt;ローカルサーバを起動して&lt;a href=&#34;http://localhost:4000/about/&#34;&gt;http://localhost:4000/about/&lt;/a&gt; を見てみます。
&lt;img src=&#34;https://dotstud.io/img/blog/108/about.png&#34; alt=&#34;&#34; /&gt;
新しいページができました！&lt;/p&gt;
&lt;h2 id=&#34;メニューに追加&#34;&gt;メニューに追加&lt;/h2&gt;
&lt;p&gt;今のままではどこからもリンクがないのでメニューのHomeの横に追加してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/108/menu_before.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/themes/pacman/_config.yml&lt;/code&gt;の&lt;code&gt;menu:&lt;/code&gt;に表示名とPATHを記載します。
&lt;img src=&#34;https://dotstud.io/img/blog/108/menu.png&#34; alt=&#34;&#34; /&gt;
Archivesはしばらく不要なので消しました。ついでにEventsとStaffページも追加してみます。&lt;/p&gt;
&lt;p&gt;表示を確認します。
&lt;img src=&#34;https://dotstud.io/img/blog/108/menu_after.png&#34; alt=&#34;&#34; /&gt;
メニューができました！各リンクが正しいかも確認しておきましょう。&lt;/p&gt;
&lt;h2 id=&#34;blog記事のurlを変更する&#34;&gt;blog記事のURLを変更する&lt;/h2&gt;
&lt;p&gt;続いてブログ記事が&lt;code&gt;サイトURL/blog/:title&lt;/code&gt;となるように変更していきます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;プロジェクト/_config.yml&lt;/code&gt;を変更しましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/108/title.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;permalink:&lt;/code&gt;を&lt;code&gt;/:title/&lt;/code&gt;に変更します。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new_post_name:&lt;/code&gt;の項目を&lt;code&gt;blog/:title.md&lt;/code&gt;に変更します。
&lt;img src=&#34;https://dotstud.io/img/blog/108/blog_title.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;新しい記事を作成してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/108/new_post.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;/source/blog&lt;/code&gt;の下に記事が追加されるようになりました。&lt;/p&gt;
&lt;p&gt;トップページを確認してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/108/top.png&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;http://localhost:4000&#34;&gt;http://localhost:4000&lt;/a&gt; にはブログ一覧が表示されます。&lt;/p&gt;
&lt;p&gt;記事をクリックして飛んでみます。
&lt;img src=&#34;https://dotstud.io/img/blog/108/art.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;サイトURL/blog/:title&lt;/code&gt;の形で記事が発行されました！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo deploy -g&lt;/code&gt;でデプロイです。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/108/done.png&#34; alt=&#34;&#34; /&gt;
今回もコマンドと設定ファイルの編集で簡単にルーティングをすることができました。&lt;/p&gt;
&lt;p&gt;かなりサイトらしくなってきましたね！&lt;/p&gt;
&lt;p&gt;次回はサイドバーをカスタマイズしてみたいと思います。&lt;/p&gt;</description></item><item><title>#linedevday 2017レポート！ Clova連携で期待のGateboxの技術話を聞いてみたよ</title><link>https://dotstud.io/blog/linedevday-report-2017-gatebox/</link><pubDate>Thu, 28 Sep 2017 14:45:35 +0900</pubDate><guid>https://dotstud.io/blog/linedevday-report-2017-gatebox/</guid><description>
&lt;p&gt;こんにちは、のびすけです。&lt;/p&gt;
&lt;p&gt;今日は&lt;a href=&#34;http://linedevday.linecorp.com/jp/2017/&#34;&gt;LINE DEVELOPER DAY 2017&lt;/a&gt;にお邪魔しています。&lt;/p&gt;
&lt;p&gt;Gateboxの話を聞いていましたが、&lt;strong&gt;Gateboxの技術にNode.jsが採用されていたことが驚きです。&lt;/strong&gt;って感じの話を書きます。&lt;/p&gt;
&lt;p&gt;(速報のりなので、誤字脱字あったらごめんなさい）&lt;/p&gt;
&lt;h2 id=&#34;line-developer-day-2017&#34;&gt;LINE DEVELOPER DAY 2017&lt;/h2&gt;
&lt;p&gt;LINEが開催している開発者向けのカンファレンスイベントです。&lt;/p&gt;
&lt;p&gt;LINEや周辺サービスの裏側の技術や今後の展開についての発表があるイベントです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;3つの会場でパラレルでトークが展開されていきます。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;個人的には、今回は&lt;a href=&#34;https://clova.ai&#34;&gt;Clova&lt;/a&gt;やBotの話などを期待しています。（会場で、執筆してるので現在進行形）&lt;/p&gt;
&lt;h2 id=&#34;セッション-gateboxのこれまでとこれから&#34;&gt;セッション「Gateboxのこれまでとこれから」&lt;/h2&gt;
&lt;p&gt;ランチ後の最初のセッションです。&lt;/p&gt;
&lt;p&gt;Gateboxの紹介と今後についてを紹介するセッションでした。ちなみに、当日の発表資料は&lt;a href=&#34;https://www.slideshare.net/linecorp/gatebox-how-we-got-here-and-where-were-going&#34;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gatebox.ai/&#34;&gt;Gatebox&lt;/a&gt;は好きなキャラクターと一緒に暮らせる世界初のバーチャルホームロボットです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;写真の通り、2次元のキャラクターがパーソナルアシスタントをしてくれるロボットです。
ロックマンエグゼのPETのイメージですね（分かる人いるかな&amp;hellip;）&lt;/p&gt;
&lt;p&gt;iOSのSiriにビジュアルが付いたものをイメージすると良いかもしれません。&lt;/p&gt;
&lt;p&gt;CF映画を彷彿させますね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Gateboxは2017年3月に&lt;a href=&#34;http://japanese.engadget.com/2017/03/02/line-gatebox-ai/&#34;&gt;LINEと資本提携&lt;/a&gt;をしてClovaとの連携が期待されています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;発表はGatebox代表の武地さん。&lt;/p&gt;
&lt;p&gt;「AIやスマートスピーカーが話題になってきているけど人間が話しかけたくなるインターフェイスになっていない」、「実際に話しかけたくなるものを作りたい」という想いで
&lt;strong&gt;人間と同じようにキャラクターと生活できる世界&lt;/strong&gt;を目指してGateboxを開発しているそうです。&lt;/p&gt;
&lt;h2 id=&#34;gateboxとclova&#34;&gt;GateboxとClova&lt;/h2&gt;
&lt;p&gt;世の中のスマートスピーカーはクラウド上のAIなどが処理を行って言葉を返すけれど、Gateboxは性質上、ハードウェア側がリッチである必要があります。&lt;/p&gt;
&lt;p&gt;Gatebox側では見た目のリッチさ、キャラクターの動きなどユーザーと触れる部分の見た目、振る舞いに注力しているのが他のスピーカーデバイスなどとの大きな違いです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;逆にLINEのClovaはクラウド側やAIの仕組みに注力しているので、お互いの得意分野を生かしてより人間味のある仕組みを検討していくとのことです。&lt;/p&gt;
&lt;p&gt;確かに現状のそういったデバイスはどうにも機械的なものが多いので、インターフェイスが自分好みのキャラクターになれば、&lt;strong&gt;話しかけたくなるAI&lt;/strong&gt;ができますね。&lt;/p&gt;
&lt;h2 id=&#34;gateboxの技術話が初公開&#34;&gt;Gateboxの技術話が初公開&lt;/h2&gt;
&lt;p&gt;今回、話を聞けてよかったなぁと特に思ったのがここです。&lt;/p&gt;
&lt;p&gt;ここからは久森さんに交代です。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gateboxの技術的な話を対外的にするのは今回が初めて&lt;/strong&gt;だそうです。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/5-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;大きく分けるとこれが構成要素になるようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;プロジェクション&lt;/li&gt;
&lt;li&gt;音声発話&lt;/li&gt;
&lt;li&gt;センシング（人感センサやカメラ、マイクなど）&lt;/li&gt;
&lt;li&gt;ネットワーク（Wi-Fi、Bluetooth）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ハードウェア的な部分では中身の基盤部分も紹介してくれました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/5-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;また、内部ではLinuxが動いていて、そこに色々なソフトウェアが動いています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/5-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unity: キャラクターのアクションなど&lt;/li&gt;
&lt;li&gt;Node.js: 音声認識、センサーとのやりとり、司令塔的なポジション&lt;/li&gt;
&lt;li&gt;C++: 顔認識のライブラリなどとの通信&lt;/li&gt;
&lt;li&gt;SQLite: 顔を覚えたり、発話を記憶させたり&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また、クラウド側で連動しているサービスの紹介です。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/5-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;クラウド側でもNode.jsを中心にAPIを呼び出しています。
フルスクラッチで作るよりも、PaaSやBaaS系のサービスに乗せることでサービスの本質的な機能に集中して開発を進めているらしく、スタートアップのお手本のような開発だなぁと思いました。&lt;/p&gt;
&lt;p&gt;例えば、メールを送る部分はSendGridで、それをAzureなどのPaaSから呼び出したりしているそうです。&lt;/p&gt;
&lt;h3 id=&#34;node-jsをメインで採用している理由&#34;&gt;Node.jsをメインで採用している理由&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;個人的にはC++などではなく中心にNode.jsが利用されていることが驚きでした。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;僕はNode.js大好きなんですけど、実際のハードウェアプロダクトの中でNode.jsが動いているという例をあまり聞いたことがなかったので、パフォーマンス面や安定稼働とかの側面に不安は無いのかなど気になりすぎました。。。笑&lt;/p&gt;
&lt;p&gt;気になったのでセッション後のAsk the Speakerのコーナーで聞きましたが、開発スタート時にNode.jsを使えるエンジニアが多く、開発スピードを優先して選んだそうです。&lt;/p&gt;
&lt;p&gt;確かに内部のソフトウェアではNode.jsからシリアルの値を呼び出して、サーバー側でもNode.jsを動かしてと開発効率はバツグンにいいですし、チームの規模感や文化を優先する選択はさすがだと思いました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/5-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;現状は339台作っているそうですが、今後量産体制に入っていくときのアーキテクチャ検討が課題だそうです。&lt;/p&gt;
&lt;p&gt;サーバー側のアクセス数も増えていき、ユーザーの予期せぬ使い方なども増えていくため、安定稼働やスケールの仕組みを考える必要がありそうですね。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/128/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;けっこう込み入った話も気軽に答えてくれてGateboxの皆さんの暖かさを感じました。&lt;/p&gt;
&lt;p&gt;ありがとうございました！&lt;/p&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;ClovaもGateboxはすごく未来を感じさせてくれるプロダクトなので、それらの組み合わせは本当に期待ですね。&lt;/p&gt;
&lt;p&gt;APIやSDKが提供され始めたらぜひ使ってみたいです。&lt;/p&gt;
&lt;p&gt;まだLINE DEVELOPER DAYは続いてますが面白いセッションが多いので、ツイートを　#linedevdayのハッシュタグで振り返ると面白いですよ。&lt;/p&gt;
&lt;p&gt;それでは、現場からは以上です :)&lt;/p&gt;</description></item><item><title>Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.2</title><link>https://dotstud.io/blog/hexo-static-site-vol2/</link><pubDate>Tue, 25 Jul 2017 13:19:25 +0900</pubDate><guid>https://dotstud.io/blog/hexo-static-site-vol2/</guid><description>
&lt;p&gt;こんにちは、エンジニアのちゃんとくです。ひょんなことから&lt;a href=&#34;https://nodejs.connpass.com/&#34;&gt;&lt;strong&gt;Node女学園&lt;/strong&gt;&lt;/a&gt;というNode.jsを学ぶ女性のためのコミュニティを立ち上げました。&lt;/p&gt;
&lt;p&gt;このシリーズではNode女学園のブログを作りながら、&lt;strong&gt;Node.js製の静的サイトジェネレータ「Hexo」&lt;/strong&gt;の使い方を紹介していきます！&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/hexo-static-site-vol1&#34;&gt;&lt;strong&gt;前回&lt;/strong&gt;&lt;/a&gt;は環境構築とデプロイまでやってみました。&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;105&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/hexo-static-site-vol1/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/105/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.1
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-06-07
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Node.jsによるNode.jsのためのサイトづくり！Node.jsが書けなくても制作できます。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;p&gt;今回はテーマを当ててブログデザインをカスタマイズしてみます。&lt;/p&gt;
&lt;h2 id=&#34;テーマの探し方&#34;&gt;テーマの探し方&lt;/h2&gt;
&lt;p&gt;Hexoでは既存のテーマを使うことで簡単にデザインを適用できます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hexo.io/themes/&#34;&gt;Hexoの公式サイト&lt;/a&gt;では130以上のテーマが紹介されています。
&lt;img src=&#34;https://dotstud.io/img/blog/107/themes.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;また&lt;a href=&#34;https://github.com&#34;&gt;github&lt;/a&gt;で&lt;code&gt;hexo-theme&lt;/code&gt;を検索するとユーザが制作したテーマを探すことができます。
&lt;img src=&#34;https://dotstud.io/img/blog/107/search.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;LICENSEに注意しつつ、好きなテーマを探しましょう。&lt;/p&gt;
&lt;p&gt;今回Node女学園のブログは「ロゴに合わせてオレンジ系統」「ポップな感じ」にしたかったので、こちらの&lt;strong&gt;pacman&lt;/strong&gt;のテーマを使うことにしました。
&lt;img src=&#34;https://dotstud.io/img/blog/107/demo.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/A-limon/pacman&#34;&gt;github - A-limon/pacman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://a-limon.github.io/pacman/&#34;&gt;demoページ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;テーマをダウンロード&#34;&gt;テーマをダウンロード&lt;/h2&gt;
&lt;p&gt;まずはテーマをダウンロードします。cloneして取ってきましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/A-limon/pacman.git themes/pacman
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git URLとディレクトリ名は適宜自分のダウンロードしたいテーマのものに置き換えてください。（大体のテーマはREADMEに記載があるはずです。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/107/clone_theme.png&#34; alt=&#34;&#34; /&gt;
cloneして&lt;code&gt;/themes&lt;/code&gt;の下に&lt;code&gt;/pacman&lt;/code&gt;ディレクトリができました。デフォルトの&lt;code&gt;/landscape&lt;/code&gt;は使わないので消してしまいます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_config.yml&lt;/code&gt;ファイルの&lt;code&gt;theme:&lt;/code&gt;をダウンロードしたテーマ名に書き換えます。
&lt;img src=&#34;https://dotstud.io/img/blog/107/chose_theme.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;この状態でローカルサーバを起動してみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/107/pacman.png&#34; alt=&#34;&#34; /&gt;
pacmanのテーマが適用されました！&lt;/p&gt;
&lt;h2 id=&#34;カスタマイズ&#34;&gt;カスタマイズ&lt;/h2&gt;
&lt;p&gt;デフォルトでは言語が違っていたり不要なリンクがあったりするので、自分の好みに編集していきます。&lt;/p&gt;
&lt;p&gt;今回はカスタマイズの一例としてpacmanに沿って紹介します。テーマによって方法が異なる場合があるので、各READMEを見つつこの以下は参考程度に見てください。&lt;/p&gt;
&lt;h3 id=&#34;author情報を設定&#34;&gt;Author情報を設定&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;themes/pacman/_config.yml&lt;/code&gt;を編集していきます。先ほどまでの&lt;code&gt;_config.yml&lt;/code&gt;とは違うファイルなので混同しないようにしてください。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;author:&lt;/code&gt;の部分を変更します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/author_before.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;intro_line&lt;/code&gt;はフッタに表示されるメッセージです。適宜SNSのアカウントを記載して不要な項目は消去します。&lt;/p&gt;
&lt;p&gt;以下のように設定しました。
&lt;img src=&#34;https://dotstud.io/img/blog/107/author_after.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;続いて&lt;code&gt;author_img&lt;/code&gt;を編集します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/author_img.png&#34; alt=&#34;&#34; /&gt;
画像データをURLで指定する場合は&lt;code&gt;dataURI: true&lt;/code&gt;にして&lt;code&gt;author_img_data:&lt;/code&gt;のあとにURLを記述します。&lt;/p&gt;
&lt;p&gt;ローカルに画像を置く場合は&lt;code&gt;dataURI: false&lt;/code&gt;のまま&lt;code&gt;author_img:&lt;/code&gt;のあとにコメントに習ってPATHを記載しましょう。&lt;/p&gt;
&lt;p&gt;変更を確認してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/107/footer.png&#34; alt=&#34;&#34; /&gt;
フッターに画像、メッセージ、SNSが表示されました！&lt;/p&gt;
&lt;h3 id=&#34;言語を設定&#34;&gt;言語を設定&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;/themes/pacman/languages&lt;/code&gt;以下で、&lt;code&gt;default.yml&lt;/code&gt;を残して他の言語ファイルを消去します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/lang.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;確認してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/107/en.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;default.yml&lt;/code&gt;の内容が適用されました。日本語などにしたい場合は&lt;code&gt;default.yml&lt;/code&gt;の中を編集しましょう。&lt;/p&gt;
&lt;h3 id=&#34;サイドバーを編集&#34;&gt;サイドバーを編集&lt;/h3&gt;
&lt;p&gt;続いてサイドバーを変更します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_rss_be.png&#34; alt=&#34;&#34; /&gt;
今回RSSは不要なので消してみます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/themes/pacman/layout/_widget&lt;/code&gt;の下の&lt;code&gt;rss.ejs&lt;/code&gt;を消去します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_rss1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;themes/pacman/_config.yml&lt;/code&gt;の&lt;code&gt;widget:&lt;/code&gt;からrssを消去します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_rss2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;RSSの表示が消えました。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_rss_af.png&#34; alt=&#34;&#34; /&gt;
続いてタグの記事数を表す数字も消してみます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/themes/pacman/layout/_widget/tag.ejs&lt;/code&gt;で数字を記述している部分を消去します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_tag.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;記事数を表す数字が消えました。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_tag_af.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h3 id=&#34;記事の表示を編集&#34;&gt;記事の表示を編集&lt;/h3&gt;
&lt;p&gt;記事をクリックして各記事ページもカスタマイズしましょう。&lt;/p&gt;
&lt;p&gt;まず記事内に表示されている目次（Contents）を消してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_content_be.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/themes/pacman/layout/_partial/post/article.ejs&lt;/code&gt;を編集します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_content.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;contents&lt;/code&gt;を表示させている部分を消去します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/107/del_contents.png&#34; alt=&#34;&#34; /&gt;
目次が消えました。&lt;/p&gt;
&lt;h3 id=&#34;記事のフッタを編集&#34;&gt;記事のフッタを編集&lt;/h3&gt;
&lt;p&gt;記事のフッタにはあまり馴染みのないSNSのシェアリンクがあるので変更します。
&lt;img src=&#34;https://dotstud.io/img/blog/107/art_footer_before.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/themes/pacman/layout/_partial/after_footer.ejs&lt;/code&gt;の90行目あたりを見てみます。
&lt;img src=&#34;https://dotstud.io/img/blog/107/del_share.png&#34; alt=&#34;&#34; /&gt;
リンクを追加している部分があるので不要なものを消します。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/107/del_share_af.png&#34; alt=&#34;&#34; /&gt;
FacebookとTwitterのみ残しました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/107/art_footer_after.png&#34; alt=&#34;&#34; /&gt;
ブログ側もFacebookとTwitterのみになっています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo deploy -g&lt;/code&gt;でデプロイしましょう！&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;カスタマイズを加えて自分のブログらしさを出すことができました！
&lt;img src=&#34;https://dotstud.io/img/blog/107/done.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;テーマによって編集箇所が変わりますが、&lt;strong&gt;基本はHTMLとJavaScriptで構成されている&lt;/strong&gt;のでREADMEを読みつつ焦らず直していきましょう。&lt;/p&gt;
&lt;p&gt;次回はルーティングをやってみたいと思います。&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;108&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/hexo-static-site-vol3/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/108/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.3
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-10-31
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Node.jsによるNode.jsのためのサイトづくり！簡易ルーティグで情報ページを作る回。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;</description></item><item><title>Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.1</title><link>https://dotstud.io/blog/hexo-static-site-vol1/</link><pubDate>Wed, 07 Jun 2017 17:15:30 +0900</pubDate><guid>https://dotstud.io/blog/hexo-static-site-vol1/</guid><description>
&lt;p&gt;こんにちは、エンジニアのちゃんとくです。ひょんなことから&lt;a href=&#34;https://nodejs.connpass.com/&#34;&gt;&lt;strong&gt;Node女学園&lt;/strong&gt;&lt;/a&gt;というNode.jsを学ぶ女性のためのコミュニティを立ち上げました。&lt;/p&gt;
&lt;p&gt;イベントを数回開催しましたが、毎回のナレッジが流れていくのがもったいない……。ということでNode女学園のブログを開設しました！
&lt;img src=&#34;https://dotstud.io/img/blog/105/blog.png&#34; alt=&#34;&#34; /&gt;
現在公開しているページは&lt;a href=&#34;https://nodegirls-jp.github.io/&#34;&gt;&lt;strong&gt;こちら&lt;/strong&gt;&lt;/a&gt;、ブログのレポジトリは&lt;a href=&#34;https://github.com/nodegirls-jp/nodegirls-jp.github.io&#34;&gt;&lt;strong&gt;こちら&lt;/strong&gt;&lt;/a&gt;。（鋭意開発中です）&lt;/p&gt;
&lt;p&gt;こちらのページはNode.js製の静的サイトジェネレータ「&lt;strong&gt;Hexo&lt;/strong&gt;」で開発して「&lt;strong&gt;Github Pages&lt;/strong&gt;」で公開しています。手軽に無料で公開できますので、制作過程を紹介していきたいと思います！&lt;/p&gt;
&lt;p&gt;今回は環境構築からGithub Pagesで公開するところまでやってみます。&lt;/p&gt;
&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;
&lt;h3 id=&#34;静的サイトジェネレータって&#34;&gt;静的サイトジェネレータって？&lt;/h3&gt;
&lt;p&gt;静的サイトジェネレータは、HTML/CSS/JavaScriptで構築される静的サイトをコマンドラインで簡単に生成することができるツールです。ヘッダやフッタの共通化、簡易ルーティング、MarkdownファイルのHTML変換など&lt;strong&gt;面倒な部分をよしなにやってくれます&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Ruby製のJekyllやGo製のHUGO、React.js製のGatsby……と様々な言語で組まれたジェネレータがありますが、試してみる分にはあまり大きな違いはないので好みに合わせて選びましょう！&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://staticsitegenerators.net/&#34;&gt;Static Site Generators&lt;/a&gt;というサイトで静的サイトジェネレータの一覧が見れます。
&lt;img src=&#34;https://dotstud.io/img/blog/105/ranking.png&#34; alt=&#34;&#34; /&gt;
スター順に並べてみると、Jekyll、HUGOに続いてかなり人気ですね！&lt;/p&gt;
&lt;p&gt;ちなみに&lt;strong&gt;dotstudioのサイトはHUGO&lt;/strong&gt;で生成されています。こちらの入門についてはデザイナーのちゃちゃまるくんが頑張っているのでご参照ください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/hugo-for-designers-vol1/&#34;&gt;デザイナーの僕がHugoを使ってポートフォリオサイトを作ってみる #1【準備編】&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;github-pagesって&#34;&gt;Github Pagesって？&lt;/h3&gt;
&lt;p&gt;Githubが提供する、&lt;strong&gt;無料で静的サイトを公開できるホスティングサービス&lt;/strong&gt;です。&lt;/p&gt;
&lt;p&gt;Githubのアカウントやorgnization、プロジェクトごとにサイトを制作することができ、&lt;strong&gt;pushしていくだけ&lt;/strong&gt;で公開できるのでgit管理に慣れている人にとってはかなり手軽ですね！&lt;/p&gt;
&lt;p&gt;今回はGithub Pagesを作成するアカウント（またはorgnization）が作成されている前提で進めますので、お持ちでない方は登録から始めてください。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/&#34;&gt;https://github.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;またプロジェクトに紐付けて公開する場合は手順が異なりますが本記事では割愛します。&lt;/p&gt;
&lt;h2 id=&#34;githubにレポジトリを作成しよう&#34;&gt;Githubにレポジトリを作成しよう&lt;/h2&gt;
&lt;p&gt;まずはGithubにGithub Pages用のレポジトリを作成しましょう。&lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt;にアクセスし、[New Repository]を選択します。
&lt;img src=&#34;https://dotstud.io/img/blog/105/new.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;「Create a new repository」のページに移動します。
&lt;img src=&#34;https://dotstud.io/img/blog/105/create.png&#34; alt=&#34;&#34; /&gt;
「&lt;strong&gt;Owner&lt;/strong&gt;」にはGithub Pagesを作成したいアカウントやorgnizationを指定します。今回はnodegirls-jpというorgnizationを指定します。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;Repository name&lt;/strong&gt;」には&lt;code&gt;owner名.github.io&lt;/code&gt;と入力します。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;このフォーマットに従わないとGithub Pagesが作成されない&lt;/strong&gt;ので注意してください。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/105/repos.png&#34; alt=&#34;&#34; /&gt;
レポジトリができました！公開URLは&lt;code&gt;https://owner名.github.io&lt;/code&gt;になります。&lt;/p&gt;
&lt;p&gt;SSHのアドレスは後ほど使うのでメモしておきます。&lt;/p&gt;
&lt;h2 id=&#34;雛形を作ってみよう&#34;&gt;雛形を作ってみよう&lt;/h2&gt;
&lt;p&gt;続いてGithub Pagesで公開するブログをHexoで作っていきます。&lt;/p&gt;
&lt;h3 id=&#34;開発環境構築&#34;&gt;開発環境構築&lt;/h3&gt;
&lt;p&gt;Hexoの開発は&lt;strong&gt;Node.jsが動く環境&lt;/strong&gt;で行います。まずはNode.jsをインストールしましょう。&lt;/p&gt;
&lt;p&gt;Node.jsのインストールには「nvm」や「nodebrew」を使うと便利です。下記ではnodebrewを使ったインストール方法を紹介しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/blog/setup-new-mac-app/#node-js環境整備&#34;&gt;僕がMacを買い換えてすぐにいれるツール&amp;amp;すぐにする初期設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;続いてHexoのインストールです。下記のコマンドを実行しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-g&lt;/code&gt;オプションをつけることでグローバルにインストールすることができます。&lt;/p&gt;
&lt;h3 id=&#34;コマンドで雛形生成&#34;&gt;コマンドで雛形生成&lt;/h3&gt;
&lt;p&gt;Hexoのコマンドでブログの雛形を生成します。&lt;/p&gt;
&lt;p&gt;プロジェクトを作りたい場所へ移動し、&lt;code&gt;hexo init [ブログ名]&lt;/code&gt;で作成です。今回は「nodegirls-jp」というブログ名にします。
&lt;img src=&#34;https://dotstud.io/img/blog/105/init.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;実行すると自動で&lt;code&gt;nodegirls-jp&lt;/code&gt;ディレクトリが作成されます。
&lt;img src=&#34;https://dotstud.io/img/blog/105/ls.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ディレクトリの下へ移動して見てみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/105/files.png&#34; alt=&#34;&#34; /&gt;
ファイルとフォルダが作成されています。&lt;/p&gt;
&lt;p&gt;ここで&lt;code&gt;npm install&lt;/code&gt;を実行してモジュールをインストールします。
&lt;img src=&#34;https://dotstud.io/img/blog/105/npm.png&#34; alt=&#34;&#34; /&gt;
これだけで雛形が完成です！&lt;/p&gt;
&lt;h3 id=&#34;ローカルで確認する&#34;&gt;ローカルで確認する&lt;/h3&gt;
&lt;p&gt;ローカルサーバを立ち上げてブログを確認してみます。（この状態ではまだ公開されません。）
&lt;img src=&#34;https://dotstud.io/img/blog/105/server.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;起動したまま&lt;a href=&#34;http://localhost:4000/&#34;&gt;http://localhost:4000/&lt;/a&gt; へアクセスしましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/105/sample.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ブログの雛形が作成されました！簡単…簡単……ッ！&lt;/p&gt;
&lt;h3 id=&#34;ブログの設定を追加&#34;&gt;ブログの設定を追加&lt;/h3&gt;
&lt;p&gt;主な設定は&lt;code&gt;_config.yml&lt;/code&gt;というファイルに記述します。エディタで&lt;code&gt;_config.yml&lt;/code&gt;を開きましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/105/config.png&#34; alt=&#34;&#34; /&gt;
こんな感じでブログに関する説明がずらっと記載されているので編集します。&lt;/p&gt;
&lt;p&gt;urlは先ほど作った&lt;code&gt;https://owner名.github.io&lt;/code&gt;を設定します。title, subtitle, authorなどはお好みで設定しましょう。日本語ブログの場合&lt;code&gt;language&lt;/code&gt;は&lt;code&gt;ja&lt;/code&gt;、&lt;code&gt;timezone&lt;/code&gt;は&lt;code&gt;Asia/Tokyo&lt;/code&gt;がおすすめです。&lt;/p&gt;
&lt;p&gt;今回の設定はこのようにしました。参考までに。
&lt;img src=&#34;https://dotstud.io/img/blog/105/config_sample.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;一番下まで行くと&lt;code&gt;#Deployment&lt;/code&gt;の項目があります。デプロイのためにここを修正します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
type: git
repo: git@github.com:nodegirls-jp/nodegirls-jp.github.io.git
branch: master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;repoには&lt;strong&gt;先ほど作成したレポジトリのSSHアドレスを記述&lt;/strong&gt;します。&lt;/p&gt;
&lt;p&gt;設定をローカルで確認するとこんな感じになっています。
&lt;img src=&#34;https://dotstud.io/img/blog/105/sample_local.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;反映されていない場合は一度&lt;code&gt;control&lt;/code&gt;+&lt;code&gt;c&lt;/code&gt;でサーバを止め、&lt;code&gt;hexo server&lt;/code&gt;で起動しなおしてみてください。&lt;/p&gt;
&lt;h2 id=&#34;公開してみよう&#34;&gt;公開してみよう&lt;/h2&gt;
&lt;p&gt;いよいよ公開してみましょう。下記コマンドでビルド、公開を一度に行ってくれます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo deploy -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでエラーが出る場合は、以下のコマンドでデプロイツールをインストールしましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;公開されたページを確認してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/105/deploy.png&#34; alt=&#34;&#34; /&gt;
公開できました！&lt;/p&gt;
&lt;h2 id=&#34;記事を追加しよう&#34;&gt;記事を追加しよう&lt;/h2&gt;
&lt;p&gt;記事を追加してみましょう。&lt;code&gt;hexo new 記事名&lt;/code&gt;というコマンドで生成できます。
&lt;img src=&#34;https://dotstud.io/img/blog/105/about.png&#34; alt=&#34;&#34; /&gt;
最初の記事なので&lt;code&gt;about&lt;/code&gt;という記事を作ってみました。デフォルトの設定では&lt;code&gt;サイトURL/YYYY/MM/DD/タイトル&lt;/code&gt;というURLになります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/105/new_post.png&#34; alt=&#34;&#34; /&gt;
&lt;code&gt;_posts&lt;/code&gt;の下に&lt;code&gt;about.md&lt;/code&gt;が作成されました。このファイルを編集します。&lt;/p&gt;
&lt;p&gt;title, dataには自動で値が付与されており、tagsには任意のタグを追加できます。
&lt;img src=&#34;https://dotstud.io/img/blog/105/header.png&#34; alt=&#34;&#34; /&gt;
titleを修正して、「info」というタグを設定してみました。&lt;code&gt;---&lt;/code&gt;の下から記事本文をマークダウンで記述します。（HTMLも可）&lt;/p&gt;
&lt;p&gt;記事を&lt;code&gt;hexo d -g&lt;/code&gt;でデプロイします。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/105/post_sample.png&#34; alt=&#34;&#34; /&gt;
記事が公開できました！&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;サーバの整備やデプロイなどをほとんど意識せずに公開することができました！コマンドを使い慣れている人は本当に&lt;strong&gt;爆速開発&lt;/strong&gt;だったと思います。&lt;/p&gt;
&lt;p&gt;テーマやプラグインの追加で簡単に拡張できるので、どんどんカスタマイズしてみましょう。&lt;/p&gt;
&lt;p&gt;次回はテーマを当ててブログのデザインを変更してみます。&lt;/p&gt;
&lt;section class=&#34;link&#34; id=&#34;107&#34;&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;a href=&#34;https://dotstud.io/blog/hexo-static-site-vol2/&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/107/00_thumbnail.png&#34; alt=&#34;サムネイル&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;link_content&#34;&gt;
&lt;div class=&#34;link_detail&#34;&gt;
&lt;div class=&#34;link_title&#34;&gt;
Node.js製の静的サイトジェネレータ「Hexo」で無料ブログ開発 vol.2
&lt;/div&gt;
&lt;div class=&#34;link_date&#34;&gt;
2017-07-25
&lt;/div&gt;
&lt;div class=&#34;link_desc&#34;&gt;
Node.jsによるNode.jsのためのサイトづくり！テーマを当てておしゃれ感を出す回です。
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;</description></item><item><title>Node.jsアプリケーションからMySQLにアクセスする</title><link>https://dotstud.io/blog/operate-mysql-from-nodejs/</link><pubDate>Tue, 03 Jan 2017 10:05:15 +0900</pubDate><guid>https://dotstud.io/blog/operate-mysql-from-nodejs/</guid><description>
&lt;p&gt;こんにちは、dotstudioの代表の&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;のびすけ&lt;/a&gt;です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/howto-setup-azure-mysql/&#34;&gt;前回の記事(AzureでMySQLのセットアップと接続方法)&lt;/a&gt;に続きMySQLの話です。&lt;/p&gt;
&lt;p&gt;今日は初心者向けに、Node.jsからMySQLにアクセスする方法をチュートリアル的に紹介します。&lt;/p&gt;
&lt;h2 id=&#34;mysqlモジュール-ドライバー&#34;&gt;MySQLモジュール（ドライバー）&lt;/h2&gt;
&lt;p&gt;こちらのモジュールを利用します。
おそらく一番利用されているMySQLのNode.jsモジュール（ドライバー）になります。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/mysql&#34;&gt;https://www.npmjs.com/package/mysql&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init --yes
npm i mysql --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これでインストールはできました。&lt;/p&gt;
&lt;h2 id=&#34;mysqlデータベースを用意&#34;&gt;MySQLデータベースを用意&lt;/h2&gt;
&lt;p&gt;接続を試す前にデータベースが用意できているか確認しましょう。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/howto-setup-azure-mysql/&#34;&gt;前回の記事(AzureでMySQLのセットアップと接続方法)&lt;/a&gt;などを参照してみましょう。&lt;/p&gt;
&lt;p&gt;仮データをいれておきましょう。&lt;/p&gt;
&lt;p&gt;今回は&amp;rsquo;test_user&amp;rsquo;テーブルを作って一件データを入れておきました。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/068/01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;crud-クラッド-とsql&#34;&gt;CRUD（クラッド）とSQL&lt;/h2&gt;
&lt;p&gt;データアクセスの前に&lt;a href=&#34;http://e-words.jp/w/CRUD.html&#34;&gt;CRUD&lt;/a&gt;について少し触れます。
CRUDはデータベースシステムなどの基本概念であるデータの作成（Create）、読み出し（Read）、更新（Update）、削除（Delete）を表す言葉です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://se-java-school.com/itstudy/database/intro_db_jdbc/sqltext_01.php&#34;&gt;SQL&lt;/a&gt;はデータベースを操作するための言語です。
MySQLの操作の最初のステップとして、SQLを使用してCRUDを実現してみましょう。&lt;/p&gt;
&lt;p&gt;CRUDはSQL構文では、以下のような形で対応しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create -&amp;gt; INSERT文&lt;/li&gt;
&lt;li&gt;Read -&amp;gt; SELECT文&lt;/li&gt;
&lt;li&gt;Update -&amp;gt; UPDATE文&lt;/li&gt;
&lt;li&gt;Delete -&amp;gt; DELETE文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この4つの構文に対応してコードを書いていきましょう。&lt;/p&gt;
&lt;h2 id=&#34;接続テストとread-select文&#34;&gt;接続テストとRead（SELECT文）&lt;/h2&gt;
&lt;p&gt;まずはNode.jsからMySQLへの接続テストをしつつ、データ表示のReadにあたるSELECT文を使います。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://www.dbonline.jp/mysql/select/index1.html&#34;&gt;http://www.dbonline.jp/mysql/select/index1.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;app.jsを作成しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//app.js
&#39;use strict&#39;
const mysql = require(&#39;mysql&#39;);
const connection = mysql.createConnection({
host : &#39;hoge.hoge.com&#39;,
user : &#39;n0bisuke&#39;,
password : &#39;n0bipass&#39;,
database : &#39;nobidb&#39;
});
//ここからMySQLアクセス
connection.connect();
let sql = &#39;select * from nobidb.test_user&#39;;
connection.query(sql, (err, rows, fields) =&amp;gt; {
if (err) throw err;
console.log(&#39;test_userテーブル: &#39;, rows);
});
connection.end();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7〜10行目について&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;host: MySQLのホスト名です。仮にhoge.hoge.comを指定しています。&lt;/li&gt;
&lt;li&gt;user: MySQLに登録してあるユーザー名です。仮にn0bisukeを指定しています。&lt;/li&gt;
&lt;li&gt;password: MySQLに登録してあるパスワードです。仮にn0bipassを指定しています。&lt;/li&gt;
&lt;li&gt;database: MySQLで利用するDB名です。仮にnobidbを指定しています。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16行目がSQLです。&lt;/p&gt;
&lt;p&gt;SELECT文は「&lt;code&gt;select カラム名 from DB名.テーブル名&lt;/code&gt;」が基本になります。
全てのカラムを取得する場合は&lt;code&gt;*&lt;/code&gt;を指定します。&lt;/p&gt;
&lt;p&gt;16行目のSQL文は「&lt;code&gt;nobidb&lt;/code&gt;データベースの&lt;code&gt;test_user&lt;/code&gt;テーブルの全てのカラムの情報を取得する」という内容になります。&lt;/p&gt;
&lt;p&gt;それでは実行してみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node app.js
test_userテーブル: [ RowDataPacket { id: 11, name: &#39;n0bisuke&#39;, created: 2017-01-01T21:35:26.000Z } ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで無事にNode.jsとMySQLの接続が確立され、予め登録していたtest_userテーブルの中身が表示（Read）されました。&lt;/p&gt;
&lt;h2 id=&#34;create-insert文&#34;&gt;Create（INSERT文）&lt;/h2&gt;
&lt;p&gt;次にデータ作成のCreateにあたるINSERT文を使ってみましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://www.dbonline.jp/mysql/insert/index1.html&#34;&gt;http://www.dbonline.jp/mysql/insert/index1.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;app.jsの16行目を以下に書き換えましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let sql = `insert into nobidb.test_user (name) values (&amp;quot;sugawara&amp;quot;)`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;INSERT文の基本は「&lt;code&gt;insert into DB名.テーブル名 (カラム名1, カラム名2) values (値, 値)&lt;/code&gt;」という形になります。
今回の文では「&lt;code&gt;nobidb&lt;/code&gt;データベースの&lt;code&gt;test_user&lt;/code&gt;テーブルの&lt;code&gt;name&lt;/code&gt;カラムに&lt;code&gt;sugawara&lt;/code&gt;という文字列を入れてデータを作成する」という意味になります。&lt;/p&gt;
&lt;p&gt;それでは実行してみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node app.js
test_userテーブル: OkPacket {
fieldCount: 0,
affectedRows: 1,
insertId: 31,
serverStatus: 2,
warningCount: 0,
message: &#39;&#39;,
protocol41: true,
changedRows: 0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;クライアントなどで確認してもしっかり行が追加されていることが分かります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/068/02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;update-update文&#34;&gt;Update（UPDATE文）&lt;/h2&gt;
&lt;p&gt;次にデータ更新のUpdateにあたるUPDATE文を使ってみましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://www.dbonline.jp/mysql/insert/index7.html&#34;&gt;http://www.dbonline.jp/mysql/insert/index7.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;app.jsの16行目を以下に書き換えましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let sql = `update dsdb.test_user set name=&amp;quot;すがわら&amp;quot; where id = 31`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UPDATE文の基本は「&lt;code&gt;update DB名.テーブル名 set カラム名1=更新内容1 カラム名2=更新内容2 where 条件&lt;/code&gt;」という形になります。
今回の文では「&lt;code&gt;nobidb&lt;/code&gt;データベースの&lt;code&gt;test_user&lt;/code&gt;テーブルの、idが31の&lt;code&gt;name&lt;/code&gt;カラムを&lt;code&gt;すがわら&lt;/code&gt;という文字列にデータ更新する」という意味になります。&lt;/p&gt;
&lt;p&gt;それでは実行してみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node app.js
test_userテーブル: OkPacket {
fieldCount: 0,
affectedRows: 1,
insertId: 0,
serverStatus: 2,
warningCount: 0,
message: &#39;(Rows matched: 1 Changed: 1 Warnings: 0&#39;,
protocol41: true,
changedRows: 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;クライアントなどで確認してもid31の行のnameがすがわらに更新されているのが分かります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/068/03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;delete-delete文&#34;&gt;Delete（DELETE文）&lt;/h2&gt;
&lt;p&gt;最後にデータ削除のDeleteにあたるDELETE文を使ってみましょう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://www.dbonline.jp/mysql/insert/index10.html&#34;&gt;http://www.dbonline.jp/mysql/insert/index10.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;app.jsの16行目を以下に書き換えましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let sql = `delete from dsdb.test_user where id = 31`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DELETE文の基本は「&lt;code&gt;delete from DB名.テーブル名 where 条件&lt;/code&gt;」という形になります。
今回の文では「&lt;code&gt;nobidb&lt;/code&gt;データベースの&lt;code&gt;test_user&lt;/code&gt;テーブルの、idが31の行を削除する」という意味になります。&lt;/p&gt;
&lt;p&gt;それでは実行してみましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node app.js
test_userテーブル: OkPacket {
fieldCount: 0,
affectedRows: 1,
insertId: 0,
serverStatus: 2,
warningCount: 0,
message: &#39;&#39;,
protocol41: true,
changedRows: 0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;クライアントなどで確認してもid31の行が削除されているのが分かります。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/068/04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;ここまでで、Node.jsからMySQLにアクセスしてCRUDをする操作の紹介をしました。&lt;/p&gt;
&lt;h2 id=&#34;tips-node-mysql2&#34;&gt;Tips: node-mysql2&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://qiita.com/n0bisuke/items/4e59d02f90bb66451011&#34;&gt;Node.jsからMySQL接続のメモ(とnode-mysql2)&lt;/a&gt;にもあるように&lt;a href=&#34;https://github.com/sidorares/node-mysql2&#34;&gt;node-mysql2&lt;/a&gt;というモジュールもありますので、ベンチマークが気になり始めたら利用を試みるのも良いかもしれません。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm i mysql2 --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;でインストールして&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const mysql = require(&#39;mysql&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;の読み込み箇所を&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const mysql = require(&#39;mysql2&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;に修正するだけで使えるので移行も楽そうです。&lt;/p&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;Node.jsからMySQLにアクセスする方法を紹介しました。
基礎的な内容になるので、初めてチャレンジする方は参考にして下さい。&lt;/p&gt;
&lt;p&gt;SQL直書きだと脆弱性が&amp;hellip;&amp;hellip;とかの話はありそうですがそれはまた別の機会で書けたらと思います。&lt;/p&gt;
&lt;p&gt;それでは。&lt;/p&gt;</description></item><item><title>Node.jsでファイル監視を行うchokidarを使ってみよう</title><link>https://dotstud.io/blog/nodejs-npm-chokidar-fswatch/</link><pubDate>Mon, 26 Dec 2016 14:00:27 +0900</pubDate><guid>https://dotstud.io/blog/nodejs-npm-chokidar-fswatch/</guid><description>
&lt;p&gt;こんにちは、dotstudio代表の&lt;a href=&#34;http://twitter.com/n0bisuke&#34;&gt;のびすけ&lt;/a&gt;です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/nodejs-npm-readline-sync/&#34;&gt;Node.jsでコマンドラインツール作るときに使いやすいreadline-sync&lt;/a&gt;に続いて、Node.jsのモジュール紹介です。&lt;/p&gt;
&lt;p&gt;Gitなどを用いて開発を行っていると「ファイルの変更を検知して何かを実行したい」という場面があります。
今日はそんな場面で活用できるファイル監視を行うモジュールを紹介します。&lt;/p&gt;
&lt;h2 id=&#34;執筆時点のマシンスペック&#34;&gt;執筆時点のマシンスペック&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;macOS Sierra (v10.12)&lt;/li&gt;
&lt;li&gt;Node.js v6.6.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;何か不具合があったときに参照してください。&lt;/p&gt;
&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;
&lt;p&gt;URL: &lt;a href=&#34;https://github.com/paulmillr/chokidar&#34;&gt;chokidar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm init&lt;/code&gt;で&lt;code&gt;package.json&lt;/code&gt;を作成してから進めます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init --yes
npm i --save chokidar
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;サンプルを動かしてみる&#34;&gt;サンプルを動かしてみる&lt;/h2&gt;
&lt;h3 id=&#34;ファイル監視&#34;&gt;ファイル監視&lt;/h3&gt;
&lt;p&gt;app.jsを作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const chokidar = require(&#39;chokidar&#39;);
// One-liner for current directory, ignores .dotfiles
chokidar.watch(&#39;.&#39;, {ignored: /[\/\\]\./}).on(&#39;all&#39;, (event, path) =&amp;gt; {
console.log(event, path);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;app.jsを保存したらアプリケーションを起動しましょう。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これで、nodeコマンドを実行したディレクトリ以下のファイルを監視しはじめます。&lt;/p&gt;
&lt;p&gt;先ほど実行した&lt;code&gt;npm init --yes&lt;/code&gt;で&lt;code&gt;package.json&lt;/code&gt;が作成されます。&lt;code&gt;app.js&lt;/code&gt;を実行したまま&lt;code&gt;package.json&lt;/code&gt;を編集してみましょう。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/1e9ddbebcda4037874c803f91d6a8b66.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;このように、変更があったファイルを検知してくれます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;・
・
・
change package.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;
&lt;p&gt;chokidarを使ってファイル監視して「特定のファイルが更新されたら〇〇する」というトリガーを簡単に作れます。&lt;/p&gt;
&lt;p&gt;プロジェクト管理などで活用してみてください。&lt;/p&gt;
&lt;p&gt;それでは。&lt;/p&gt;</description></item></channel></rss>