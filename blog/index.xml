<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on dotstudio（ドットスタジオ）</title>
    <link>https://dotstud.io/blog/</link>
    <description>Recent content in Blogs on dotstudio（ドットスタジオ）</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© 2016 dotstudio inc.</copyright>
    <lastBuildDate>Wed, 28 Feb 2018 10:00:00 +0900</lastBuildDate>
    <atom:link href="/blog/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>クラブでモテる！つまみ付きユニコーンポーチ　後編</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/</link>
      <pubDate>Wed, 28 Feb 2018 10:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/</guid>
      
      <description>

&lt;p&gt;みなさん、ちょりおつ！ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案するユニット、ギャル電で活動しています。今回は&lt;strong&gt;クラブ行くときにぎゃんかわに盛れる光るポーチ&lt;/strong&gt;の作り方後編でっす！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 前編をチェック！
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;arduino-nano互換機の導入方法&#34;&gt;Arduino Nano互換機の導入方法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回使用したボードはArduino Nano互換機。AmazonやAliExpressとかで一枚300円くらいから買える感じの小さいボードっす。&lt;strong&gt;いいところは、安くて小さいところ&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;導入にクセがあるのと、ケーブルがUSB MiniBタイプなところがちょっとめんどいけど、Digisparkだとちょっと容量足りなくてプログラムが書き込めないときとかにこのボードよく使ってます。&lt;/p&gt;

&lt;h2 id=&#34;ドライバのインストール&#34;&gt;ドライバのインストール&lt;/h2&gt;

&lt;p&gt;Arduino Nano互換機を使用するためには、&lt;strong&gt;ドライバのインストールが必要&lt;/strong&gt;っす。「Arduino Nano 互換 OSの名前 ドライバ」、または「CH340 ドライバ OSの名前」とかで検索すると親切なインターネット上の先輩方の情報がみつかるとおもいまっす！&lt;/p&gt;

&lt;p&gt;Macの新しめの機種使っててうまく認識しない場合には、接続するUSBの口を変えてみるか、USB2.0対応のUSBハブを接続してハブにつなげると認識しやすくなるかも。&lt;/p&gt;

&lt;p&gt;あとどうにも認識しないときは、&lt;strong&gt;一回忘れて寝る。そんで再トライ。うちらはだいたいコレでいつも乗りきってる&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ボードのセッティング&#34;&gt;ボードのセッティング&lt;/h2&gt;

&lt;p&gt;ドライバのインストールが完了して、デバイスを認識するようになったら、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「Arduino IDE」→「ツール」→「ボード」→「Arduino Nano」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;をえらんで書き込み準備オッケー。Aruduino IDEの設定等はインターネットで調べるか、&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;ドキュメント&lt;/a&gt;や&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-led-cassette/#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E6%BA%96%E5%82%99&#34;&gt;過去記事&lt;/a&gt;等も参考にしてね☆&lt;/p&gt;

&lt;h2 id=&#34;fastledライブラリの導入方法&#34;&gt;FASTLEDライブラリの導入方法&lt;/h2&gt;

&lt;p&gt;今回はいつも超お世話になっているNeoPixcelライブラリではなくて、&lt;strong&gt;FastLEDライブラリ&lt;/strong&gt;を使用してLEDを光らせたいと思いまっす。&lt;/p&gt;

&lt;p&gt;まずは、ここからライブラリファイル(SourceCode.zip)をダウンロードします。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://github.com/FastLED/FastLED/releases&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/link2.png&#34; alt=&#34;&#34; /&gt;
https://github.com/FastLED/FastLED/releases&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ダウンロードしたファイルを、Arduino IDEを起動して&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「スケッチ」→「ライブラリのインクルード」→「.Zip形式のライブラリをインストール」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;で指定してインストールします。&lt;/p&gt;

&lt;h2 id=&#34;プログラム&#34;&gt;プログラム&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/hsiboy/11545fd0241ab60b567d&#34;&gt;こちら&lt;/a&gt;のページのプログラムを参考にしました。というかLEDの数とLEDのPIN、可変抵抗のPINを書き換えただけでコピペさせていただきました。&lt;/p&gt;

&lt;p&gt;「led potentiometer」でググるといい感じの参考作例やプログラムがいっぱいみつかるよ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//FastLED_AnalogueInput.ino

/*
   Using a potentiometer to control colour, brightness and speed.
 Wire up as per http://arduino.cc/en/Tutorial/AnalogInput
 You can connect the wiper, to any analogue input pin, and
 adjust the settings below.
 You will need three 10k potentiometers.
 */

#include &amp;lt;FastLED.h&amp;gt;

#define LED_PIN 6              // which pin are LEDS connected to?
#define NUM_LEDS 24
#define COLOR_ORDER RGB
#define LED_TYPE WS2811        // i&#39;m using WS2811s, FastLED supports lots of different types.

/*
 set your desired minimum and maxium brigtness settings here.
 Valid values are 0 - 255
 With 0 being fully dim, or not lit, and 255 being fully on.
 Therefore half power, or 50%, would be 128
 */

#define MAX_BRIGHTNESS 164      // Thats full on, watch the power!
#define MIN_BRIGHTNESS 32       // set to a minimum of 25%

const int brightnessInPin = A0;  // The Analog input pin that the brightness control potentiometer is attached to.
const int speedInPin = A1;       // Analog input pin that the speed control potentiometer is attached to.
const int colourInPin = A2;      // The Analog input pin that the colour control potentiometer is attached to.

struct CRGB leds[NUM_LEDS];

void setup() {
  delay(3000); // in case we do something stupid. We dont want to get locked out.

  LEDS.addLeds&amp;lt;LED_TYPE, LED_PIN, COLOR_ORDER&amp;gt;(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
  FastLED.setBrightness(MAX_BRIGHTNESS);
}

void loop() {
  // read the analog brightness value:
  //int brightValue = analogRead(brightnessInPin);            
  // map it to the range of the FastLED brightness:
  int mappedValue = map(analogRead(brightnessInPin), 0, 1023, 0, 255);

  /*
   At this point, brightness could be full off (mappedValue == 0)
   or it could be fully on (mappedValue == 255).
   if you are ruuning from a battery pack, or in a dark room, you
   may not want full brightness.
   Or if you are in daylight, you may not want the pixels to go out.
   the following code, checks if mappedValue is above or below our defined
   brightness settings above.
   It works like this.

   we get mappedValue: if mappedValue is between MIN_BRIGHTNESS and MAX_BRIGHTNESS.
   we get MIN_BRIGHTNESS: if mappedValue is less than our defined MIN_BRIGHTNESS.
   we get MAX_BRIGHTNESS: if mappedValue is greater than our defined MAX_BRIGHTNESS

   so, it limits range of brightness values.

   */

  //int outputValue = constrain(mappedValue, MIN_BRIGHTNESS, MAX_BRIGHTNESS);

  // now we set the brightness of the strip
  FastLED.setBrightness(constrain(mappedValue, MIN_BRIGHTNESS, MAX_BRIGHTNESS));

  // read the analog speed value:          
  // map it to a value used in delay();
  int delayValue = map(analogRead(speedInPin), 0, 1023, 0, 50);  

  int mappedHue;
  // read the analog brightness value:
  //int hueValue = analogRead(colourInPin);            
  // map it to the range of the FastLED brightness:

  // First slide the led in one direction
  for(int i = 0; i &amp;lt; NUM_LEDS; i++) {
    mappedHue = map(analogRead(colourInPin), 0, 1023, 0, 255);
    // Set the i&#39;th led to the chosen colour
    leds[i] = CHSV(mappedHue, 255, 255);
    // Show the leds
    FastLED.show();
    // now that we&#39;ve shown the leds, reset the i&#39;th led to black
    leds[i] = CRGB::Black;
    // Wait a little bit before we loop around and do it again
    delay(delayValue);  
  }

  // Now go in the other direction.  
  for(int i = NUM_LEDS-1; i &amp;gt;= 0; i--) {
    mappedHue = map(analogRead(colourInPin), 0, 1023, 0, 255);
    // Set the i&#39;th led to the chosen colour
    leds[i] = CHSV(mappedHue, 255, 255);
    // Show the leds
    FastLED.show();
    // now that we&#39;ve shown the leds, reset the i&#39;th led to black
    leds[i] = CRGB::Black;
    // Wait a little bit before we loop around and do it again
    delay(delayValue);  
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;プログラムを書き込んでテストしてみよう&#34;&gt;プログラムを書き込んでテストしてみよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/2.png&#34; alt=&#34;&#34; /&gt;
プログラムが書き込めたら、ちゃんと可変抵抗器で光り方が変わるかを確認します。&lt;/p&gt;

&lt;p&gt;このプログラムでは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A0に接続したつまみが、明るさ&lt;/li&gt;
&lt;li&gt;A1に接続したつまみが、点滅速度&lt;/li&gt;
&lt;li&gt;A2に接続したつまみが、色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を調整できるようになっています。&lt;/p&gt;

&lt;h2 id=&#34;いい感じにポーチと部品を合体しよう&#34;&gt;いい感じにポーチと部品を合体しよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;光る部分が完成したので、ユニコーンファーポーチと合体します。&lt;/p&gt;

&lt;p&gt;ファーの表面に可変抵抗器用の小さな穴をあけます。可変抵抗器をポーチの表面に出し、キャップをかぶせます。この時、ファーの毛を巻き込んで動きにくい場合は毛を少し刈ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/4.png&#34; alt=&#34;&#34; /&gt;
ポーチの裏側にLEDを貼ったプラ板を固定し、配線をいい感じに収納します。今回はポーチに裏布がついていたので、上部を切り開いてポケット状にして超いい感じに格納したっす。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/5.png&#34; alt=&#34;&#34; /&gt;
とりあえず、ポーチにLEDとボードとモバイルバッテリーがおさまれば完成でっす！&lt;/p&gt;

&lt;h2 id=&#34;光らすと超ユニコーン&#34;&gt;光らすと超ユニコーン！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/6.png&#34; alt=&#34;&#34; /&gt;
うひょー！超かわいくない？！シーンに合わせてかわいめからハードめまで光りかたが調整できちゃうから、現場（クラブ）でモテる未来しか見えない！！！！&lt;/p&gt;

&lt;p&gt;みんなも作ってひからせてみよ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>パソコンやモバイルバッテリーに繋いで動かせるデバイスを作ろう！USB電子工作のすすめ#1 - 基礎知識編</title>
      <link>https://dotstud.io/blog/usb-power-supply-making/</link>
      <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/usb-power-supply-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、ものづくり担当のうこ(&lt;a href=&#34;https://twitter.com/harmoniko&#34;&gt;@harmoniko&lt;/a&gt;)です。&lt;/p&gt;

&lt;p&gt;みなさんは、&lt;strong&gt;電子工作をするときの電源はどこから取っていますか？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Arduinoをよく使われる方だと5V端子や3.3V端子から取っている場合が非常に多いですが、ではArduinoを使わない、ピュアな電子工作の場合だとどうしたらいいでしょうか？&lt;/p&gt;

&lt;p&gt;今回は、電子工作用電源としても非常に有用な&lt;strong&gt;USBの基本と扱い方&lt;/strong&gt;についてお伝えします。&lt;/p&gt;

&lt;h2 id=&#34;usbのしくみ&#34;&gt;USBのしくみ&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;USB&lt;/strong&gt;」は「&lt;strong&gt;Universal Serial Bus&lt;/strong&gt;」の略で、PCとその周辺機器の間の汎用的な通信規格として1996年に登場しました。USBは1対2本の信号線（※）で順番にデータを送る「&lt;strong&gt;シリアル接続&lt;/strong&gt;」という方式で、複数のデバイスを吊り下げられる「&lt;strong&gt;バス規格&lt;/strong&gt;」の1つです。&lt;/p&gt;

&lt;p&gt;※…USB 2.0まで&lt;/p&gt;

&lt;p&gt;端子は従来のものと比べてシンプルになり、ホストとデバイスをすぐに区別できるようなものになりました。&lt;/p&gt;

&lt;p&gt;USBを使って通信をするには、USBを制御する専用のコントローラハードウェアが必要となるため、電子工作では少し難易度があがります。ただし、&lt;strong&gt;電源を使うだけならケーブルを切って電源のVcc線（+）とGnd線（-）を引き出すだけでよい&lt;/strong&gt;ので、スマホが普及しはじめるよりも早くから電源用ケーブルとしても使われるようになりました。&lt;/p&gt;

&lt;p&gt;USBの簡単な特徴をまとめると、以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通信は、 1つの「ホスト」（PC側）と1〜複数の「デバイス」（周辺機器側）との間で行われる。&lt;/li&gt;
&lt;li&gt;ホスト側とデバイス側で端子形状が区別されている（タイプC端子を除く）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;電源供給用のケーブルおよび端子として使うなら扱いは簡単！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ここ数年普及してきている「USB PD」は、大電力の供給が可能でMacBookの給電などにも利用されている。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて当記事は、 &lt;strong&gt;「電子工作において電源として気軽に使えるUSB」&lt;/strong&gt; を知っていただくためのものですので、扱いの簡単な「USB2.0規格（タイプC端子を除く）」までを使う前提の説明にとどめます。&lt;/p&gt;

&lt;p&gt;USB3.0規格以降は端子が増えたり電源規格が多様になったりしているため、電子工作での利用であれば、USB2.0規格までの理解で問題ありません。&lt;/p&gt;

&lt;p&gt;さらに詳しくUSBについて知りたい方は、以下のリンクを参考にしてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://thinkit.co.jp/article/11142&#34;&gt;現代PCの基礎知識(7):仕様書を紐解くとわかる―本当はややこしいUSB（Think IT）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;電源に使うことのメリット&#34;&gt;電源に使うことのメリット&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モバイルバッテリー、PC、コンセントアダプタなど、多彩なソースが選べる。&lt;/li&gt;
&lt;li&gt;給電方法に汎用性があるため、必要なパーツが安くて手に入りやすい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;電源に使うことのデメリット&#34;&gt;電源に使うことのデメリット&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;「外部電源」となるため、電池として本体に含めることができない。&lt;/li&gt;
&lt;li&gt;規格上、5V電圧以外を扱うときや大電流が必要なものには適さない（USB PDを除く）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;仕様の一覧&#34;&gt;仕様の一覧&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 1.0&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 1.1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 2.0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端子タイプ（ホスト側）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A, タイプC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端子タイプ（デバイス側）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ミニA, マイクロA, ミニB, マイクロB, タイプC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;通信速度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12Mビット/秒&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12Mビット/秒&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;480Mビット/秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;定格電圧&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;同右&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;同右&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;約5V（ホスト側4.4~5.25V）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;最大電流&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA（USB BC拡張:1.5A）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上は通信に関する基本的なバージョン仕様ですが、さらにUSB2.0を拡張したUSB電源専用規格である「USB BC（Battery Charging）」というものがあり、1.5Aまでの電流を流すことが可能となっています。&lt;/p&gt;

&lt;p&gt;また、電子工作で利用するためのUSBパーツは100円ショップなどで購入できます。&lt;strong&gt;100円ショップなどで安価に入手可能なUSBパーツはほぼ100%がUSB2.0規格またはUSB BC規格のもの&lt;/strong&gt;となります。&lt;/p&gt;

&lt;p&gt;よって、電子工作の&lt;strong&gt;電源として&lt;/strong&gt;USBを使ってみたいときは&lt;strong&gt;USB2.0規格またはUSB BC規格&lt;/strong&gt;に準じたUSB部品の仕様を知っておけばOKです。&lt;/p&gt;

&lt;h2 id=&#34;usbケーブルの配線図&#34;&gt;USBケーブルの配線図&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;USB2.0には、電源線の5V（VccやVBUSとも）とGND、信号線のD-とD+の合計4種類の線があります。ケーブルのほとんどは2層構造になっていて、内側に収められている4本の線の色分けも上図のように決まっています。&lt;/p&gt;

&lt;p&gt;電子工作でUSBを使うときは、「標準Aメス端子を基板に実装する」か、上図のような「標準Aオス端子がついたケーブルの電源線を接続する」ことになるので、端子の順番や色分けは覚えておくと楽です。&lt;/p&gt;

&lt;h2 id=&#34;電圧と電流&#34;&gt;電圧と電流&lt;/h2&gt;

&lt;p&gt;USB電源の基本は「&lt;strong&gt;電圧5V/電流500mAまで&lt;/strong&gt;」です。&lt;/p&gt;

&lt;p&gt;といっても、これはパソコンのような「電源供給」を主目的としないホストから給電する場合の「USB2.0規格」による制限値です。&lt;/p&gt;

&lt;p&gt;電子工作でUSB電源を扱う場合は、モバイルバッテリーやUSBコンセントなどからの給電がほとんどになると思われます。その場合は、USB BC規格の上限値である1.5Aとなりますが、普通はバッテリーやコンセントに最大出力が書いてあります（例：5V/800mA）ので、電流値の最大はそれに従いましょう。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;usbケーブルの注意点&#34;&gt;USBケーブルの注意点&lt;/h4&gt;

&lt;p style=&#34;font-size: 80%&#34;&gt;細かい話をすると、市場で出回る多くの充電器は「最大2.4A出力」などを謳っていて、この場合だとUSB BC規格にもあてはまりません。このような製品は、USBを通信を行わない完全な電源ケーブルとみなし、独自の規格を採用している場合が多いです。よって、電子工作でUSB電源を使うときは、「USB2.0規格の配線」と「使いたい電源供給源（バッテリーやコンセント等）の出力電流」を考慮して回路設計をするのがベストだといえます。難しく考えたくない人は、 **とにかく省エネになるように意識して作る**ようにするのがよいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 80%&#34;&gt;⇒ 参考: &lt;a href=&#34;https://hanpenblog.com/1472/&#34;&gt;乱立するスマホ向け急速充電の規格について調べた（HANPEN-BLOG）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;電子工作での利用を考えると電流消費を見ることが大事で、個人で製作する小規模な回路であればほとんどが500mA以内に収まることが多いです。&lt;/p&gt;

&lt;p&gt;ヒーターやモーターを使った回路は例外的で、接続された個数や負荷で変動しますが、最大電流が容易に1Aを超えてしまうことがあります。しかし、どのような場合であっても、個人製作された電子回路は漏電流やショートへの配慮、適切な電流制限などが行われていないことが大半です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本的には、USB電源を利用する自作の電子回路は、安全上の理由からパソコンに接続して給電してはいけません。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⇒ 参考：&lt;a href=&#34;http://www.wheel.gr.jp/~dai/hardware/usb-port.html&#34;&gt;USBポートは電源ではありません&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現実には今のパソコンは全て保護回路が入っているため、ブレッドボードを繋げたArduinoにパソコンから給電するといったようなことを行なっていてもまず問題はありません。しかし&lt;strong&gt;危険性は少なからずあるもの&lt;/strong&gt;だとして意識してもらえれば幸いです。&lt;/p&gt;

&lt;p&gt;（15年ほど前のパソコンでは、USB端子に500mA以上の過電流を流すといきなりパソコンの電源ごと落ちるものもありました。）&lt;/p&gt;

&lt;h2 id=&#34;入手方法&#34;&gt;入手方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;おすすめは100円ショップ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;100円ショップの電気系コーナーに行くと、どこに行っても大抵はUSBケーブルが置いてあります。USBケーブルの中でも取り扱いが多いのは、おそらく次の3つでしょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Aオス端子-microBオス端子（スマホ充電用）&lt;/li&gt;
&lt;li&gt;Aオス端子-Bオス端子（プリンタなどの接続用）&lt;/li&gt;
&lt;li&gt;Aオス端子-Aメス端子（ケーブル延長用）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このうち、最後の &lt;strong&gt;Aオス端子-Aメス端子（ケーブル延長用）&lt;/strong&gt; は、置いていない店舗もありますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ケーブル部分が比較的長い。&lt;/li&gt;
&lt;li&gt;基本的にはAオス端子側を使うが、工作の内容によってはAメス端子があると便利なことがある。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった点から、電子工作で利用するには最もおすすめなケーブルとなっています。売られているのを発見したら、ぜひ買っておきましょう。&lt;/p&gt;

&lt;h2 id=&#34;実際に電子工作で使うには&#34;&gt;実際に電子工作で使うには&lt;/h2&gt;

&lt;p&gt;USBについて、どんなものなのかなんとなくおわかりいただけましたでしょうか？&lt;/p&gt;

&lt;p&gt;とりあえず要約すると、 &lt;strong&gt;「100円で手に入って電子工作で簡単に利用できる汎用電源インターフェース」&lt;/strong&gt; といったところでしょうか。では、実際に使うにはどうすればいいかを見ていきましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;USBケーブルを電源として利用する上で最も重要なパーツが「Aオス端子」部分となります。&lt;/p&gt;

&lt;p&gt;100円ショップで購入できるUSBケーブルは少なくとも一方がこの端子ですので、この端子から伸びるケーブルを十分長く残したうえでニッパで切断します。長さは、製作するモノによって適切に決めてください。あとから調整できるという意味では長めに切り取るのがよいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/5.png&#34; alt=&#34;&#34; /&gt;
切り取った部分の一番外側の皮膜をニッパまたは皮膜剥き用のニッパで1cm程度除去します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/6.png&#34; alt=&#34;&#34; /&gt;
すると細い4本のケーブルが中から出てきますが、このうち赤色と黒色がそれぞれ電源となります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/7.png&#34; alt=&#34;&#34; /&gt;
残りの2本は信号線で、&lt;del&gt;USB BC規格として大きめの電流を流したい場合は、この信号線を200Ωの抵抗でショートします。が、実際には何もしなくても給電はなされます。&lt;/del&gt;ここでは簡単にするため切り落としました。&lt;/p&gt;

&lt;p style=&#34;font-size: 80%; color: red;&#34;&gt;
（3/4 修正）200Ωの抵抗を接続するのは充電器側であるとのご指摘をいただき、上記訂正します。
&lt;/p&gt;
&lt;p style=&#34;font-size: 80%;&#34;&gt;
⇒ 出展: USB.orgの&lt;a href =&#34;http://www.usb.org/developers/docs/devclass_docs/&#34;&gt;開発者向けドキュメント&lt;/a&gt;にある「Battery Charging v1.2 Spec and Adopters Agreement.zip」内のBC1.2_FINAL.pdf「Battery Charging Specification, Revision 1.2」3.2.4項「Primary Detection」のFigure 3-6 など）
&lt;/p&gt;

&lt;p&gt;これで、Aオス端子が電源側、切断したほうが電子回路側となります。&lt;/p&gt;

&lt;p&gt;さて、次回はこの1対の電源線を使って、電池で動作するおもちゃをUSB電源駆動に改造してみます。&lt;/p&gt;

&lt;p&gt;お楽しみに。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>放置されていた3Dプリンタ「Trinus」で初めての3Dプリントに挑戦</title>
      <link>https://dotstud.io/blog/3d-printer-trinus-usage/</link>
      <pubDate>Thu, 22 Feb 2018 03:00:43 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/3d-printer-trinus-usage/</guid>
      
      <description>

&lt;p&gt;こんにちは、たくろーどんです。大学で&lt;a href=&#34;https://dotstud.io/docs/nefrybt&#34;&gt;NefryBT&lt;/a&gt;を使った工作をしていたら、いつのまにかdotstudioでアルバイトすることになっていました。宇宙工学を勉強しています。以後よろしくお願いします。&lt;/p&gt;

&lt;p&gt;=&amp;gt; 参考: &lt;a href=&#34;https://qiita.com/minwinmin/items/d1f296b8a9cd1a2c22f6&#34;&gt;研究室のみんなとNefry BTを使ってはじめてIoTデバイスをつくってみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今回は、dotstudioに放置されていた3Dプリンタ「Trinus（トライナス）」を使って初めての3Dプリントに挑戦してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/149/lead.png&#34; alt=&#34;&#34; /&gt;
これで哲学的なものを錬成していきましょう。&lt;/p&gt;

&lt;h2 id=&#34;3dプリントを始める前に&#34;&gt;3Dプリントを始める前に&lt;/h2&gt;

&lt;h3 id=&#34;3dプリンタとは&#34;&gt;3Dプリンタとは？&lt;/h3&gt;

&lt;p&gt;3Dプリンタとは、その名の通り&lt;strong&gt;3Dのデータを出力できる&lt;/strong&gt;プリンタです。
&lt;img src=&#34;https://dotstud.io/img/blog/149/3dprint.png&#34; alt=&#34;&#34; /&gt;
プリンタによりますが、金属、アルミ、ゴムなどさまざまな素材で出力できるため広い分野で活躍しています。&lt;/p&gt;

&lt;p&gt;現在は業務用から一般向けまでさまざまな種類の3Dプリンタが販売されていますが、今回はdotstudioに放置されていた「Trinus（トライナス）」を使ってみます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://www.trinus3d.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/trinus.png&#34; alt=&#34;&#34; /&gt;
Trinus - Kodama, Inc.&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;3万円代とお手頃価格で、樹脂に加えて木材やアルミも利用でき、別売りのヘッドをつけることでレーザ彫刻機にもなる優れものです。&lt;/p&gt;

&lt;h3 id=&#34;3dプリントには3dデータが必要&#34;&gt;3Dプリントには3Dデータが必要&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;3Dプリントをするためには3Dデータが必要です&lt;/strong&gt;。3Dデータをモデリング（作成すること）方法はいくつかありますが、今回は3D CADソフトを使っています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/inventor.png&#34; alt=&#34;&#34; /&gt;
僕はAutodeskの「&lt;a href=&#34;https://www.autodesk.co.jp/products/inventor/overview&#34;&gt;&lt;strong&gt;Inventor&lt;/strong&gt;&lt;/a&gt;」を使ってデータを作成しました。有料ソフトですが、なんと&lt;strong&gt;学生だと3年間無料で&lt;/strong&gt;つかえます！&lt;/p&gt;

&lt;p&gt;Inventorは本格的な機械設計向きなので、簡単に試したい人は同じくAutodeskの「&lt;a href=&#34;https://www.autodesk.co.jp/products/fusion-360/overview&#34;&gt;&lt;strong&gt;fusion360&lt;/strong&gt;&lt;/a&gt;」の方がとっつきやすいかと思います。こちらも個人利用の場合は無料です。&lt;/p&gt;

&lt;p&gt;3D CADソフトは他にも&lt;a href=&#34;https://www.rs-online.com/designspark/mechanical-software-jp&#34;&gt;DesignSpark Mechanical&lt;/a&gt;や&lt;a href=&#34;https://www.freecadweb.org/?lang=ja&#34;&gt;FreeCAD&lt;/a&gt;などいくつかあるので、自分が使いやすいと思ったものを使うと良いでしょう。&lt;/p&gt;

&lt;p&gt;さらにもう一つ。
プログラマーのためにGithubがあるなら、&lt;strong&gt;メカ系エンジニアのために&lt;a href=&#34;https://grabcad.com/&#34;&gt;GrabcCAD&lt;/a&gt;というものがあります&lt;/strong&gt;。
&lt;img src=&#34;https://dotstud.io/img/blog/149/grabccad.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで、世界中のエンジニアが製作した様々なモデリングを閲覧したり使用したりできます。もし複雑なパーツをモデリングすることが難しければ、GrabCADを参考にしてみるのも手だと思います。&lt;/p&gt;

&lt;h3 id=&#34;trinusの組み立て&#34;&gt;Trinusの組み立て&lt;/h3&gt;

&lt;p&gt;Trinusの組み立てに関しては説明書をご覧ください。
また、日本語の公式サイトもあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://www.trinusjapan.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/community.png&#34; alt=&#34;&#34; /&gt;
http://trinusjapan.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;trinus用ソフト-pango-をインストール&#34;&gt;Trinus用ソフト「Pango」をインストール&lt;/h3&gt;

&lt;p&gt;Trinusで3Dプリントするには、モデリングしたものを扱う専用ソフト「Pango」が必要です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://trinusjapan.com/softwaredownload/&#34;&gt;こちらのリンク&lt;/a&gt;からインストールしてください。&lt;/p&gt;

&lt;h2 id=&#34;3dプリントに挑戦&#34;&gt;3Dプリントに挑戦！&lt;/h2&gt;

&lt;h3 id=&#34;プリンタ側の準備&#34;&gt;プリンタ側の準備&lt;/h3&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://trinusjapan.com/firstprint/&#34;&gt;公式サイト&lt;/a&gt;にのっているので、要点だけ説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/printer.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まず、Trinusの電源をいれるため、コンセントにつなげましょう。電源がつくと「ビッ」という音がします。&lt;/p&gt;

&lt;h3 id=&#34;pangoにデータを取り込む&#34;&gt;Pangoにデータを取り込む&lt;/h3&gt;

&lt;p&gt;パソコンからデータ（stlファイル）をPangoで開きましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/1.png&#34; alt=&#34;&#34; /&gt;
①のように「書き出し」から「CAD形式」を選択し、stl形式で保存します。&lt;strong&gt;サイズがモデリングと一致&lt;/strong&gt;しているかしっかりと確認してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/2.png&#34; alt=&#34;&#34; /&gt;
Pangoでstlファイルを開くと&lt;strong&gt;何故かサイズが10分の1&lt;/strong&gt;になってしまうので（dotstudioだけで起こる現象なのか不明）、元のサイズに戻します。③と④のように比率（Ratio）を10に変えます。Amountは寸法を意味していて、単位はmmです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/3.png&#34; alt=&#34;&#34; /&gt;
必要があれば3Dプリントしやすいようにモデルの向きを変えましょう。&lt;strong&gt;どのような向きで出力するか&lt;/strong&gt;、これがとても大事です！印刷中に思いがけない失敗を引き起こすことになります。&lt;/p&gt;

&lt;p&gt;⑤のように赤丸部をクリックすると回転軸の表示が出ます。そして、回転したい軸にマウスポインタを持っていきます。⑥のように回転する軸が強調されます。マウスで操作する場合はホイールを動かすことで回転させることができます。パソコンにあるタッチパッドの場合は2本の指で、上下になぞるように動かすと回転します（Windowsの場合）。&lt;/p&gt;

&lt;h3 id=&#34;印刷のシミュレーション&#34;&gt;印刷のシミュレーション&lt;/h3&gt;

&lt;p&gt;実際にどのように印刷が進められるかPango上で確認することもできます。Pangoの上部にある「View」から「Layer」をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/149/4.png&#34; alt=&#34;&#34; /&gt;
すると自分がモデリングしたもの以外に格子状のモデリング（濃いピンクの部分）が追加されています。これは「&lt;strong&gt;ラフト&lt;/strong&gt;」と呼ばれ、3Dプリンタの印刷面と出力するものの間に積層される荒い土台のことです。&lt;/p&gt;

&lt;p&gt;これがあると出力した後に製作物を外しやすく、最終的には除去してゴミとして捨てることができます。&lt;/p&gt;

&lt;h3 id=&#34;データをtrinusに移す&#34;&gt;データをTrinusに移す&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/5.png&#34; alt=&#34;&#34; /&gt;
データをSDカードに「pcode」形式で保存します。図の赤丸部をクリックし、SDカードにデータをpcode形式で保存します。この形式は、Torinusで出力するために必要な形式です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/6.png&#34; alt=&#34;&#34; /&gt;
SDカードをTorinusに接続し、TorinusとパソコンをUSB接続します。&lt;/p&gt;

&lt;h3 id=&#34;出力設定を調整&#34;&gt;出力設定を調整&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/7.png&#34; alt=&#34;&#34; /&gt;
Pango上部の「Preference」から「Setting」を選択します。ここでは、出力するスピードや厚みなどを設定することができます。&lt;strong&gt;設定はあまりいじる必要はない&lt;/strong&gt;ので、眺めおきましょう！（ただし今回は試行錯誤の結果、Thickness: 0.2mm、Print Speed: 40mm/sとしています）&lt;/p&gt;

&lt;h3 id=&#34;重要-出力位置の初期位置を調整&#34;&gt;【重要】出力位置の初期位置を調整&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/8.png&#34; alt=&#34;&#34; /&gt;
TorinusとパソコンをUSB接続した状態でPango上部の「View」から「Console」をクリックします。上のような画像が出たら、さらに「Console」をクリックします。　&lt;/p&gt;

&lt;p&gt;そうすると下記のような設定画面があらわれます。&lt;strong&gt;この画面で行う設定が非常に重要です&lt;/strong&gt;。
&lt;img src=&#34;https://dotstud.io/img/blog/149/9.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;まず「Home」をクリック&lt;/strong&gt;します。これで、3Dプリンタのノズル（フィラメントが出る部分）が初期位置に戻ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/10.png&#34; alt=&#34;&#34; /&gt;
ここで&lt;strong&gt;z軸の距離（ノズルから出力される面の高さ、画像でいう赤い矢印部分）を確認&lt;/strong&gt;してください。その距離が初期位置で広すぎると上手く出力されません。なので、目視でその距離を縮めましょう。「Offset」をクリックすると&lt;strong&gt;z軸方向の距離を上下&lt;/strong&gt;することができます。&lt;/p&gt;

&lt;h3 id=&#34;出力を開始&#34;&gt;出力を開始！&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/9.png&#34; alt=&#34;&#34; /&gt;
位置設定が終わったら、「&lt;strong&gt;Heat E」をクリック&lt;/strong&gt;し3Dプリンタのノズルを温めます。どれくらい温まっているかは、Console画面の左下に示す数字（分数部分）で表されます。最後に右のSDカードのイラスト部分をクリックし、保存したpcodeファイルを指定します。3Dプリンタのノズルが十分に温まれば自動で出力が始まります！&lt;/p&gt;

&lt;h3 id=&#34;出力直後にやるべきこと&#34;&gt;出力直後にやるべきこと&lt;/h3&gt;

&lt;p&gt;出力が始まるとその直後に、&lt;strong&gt;ノズルから溶け出たフィラメント&lt;/strong&gt;が垂れてきます。&lt;strong&gt;垂れて固まったフィラメントは出力の邪魔になることもあるので、ピンセットで取り除きましょう&lt;/strong&gt;。下記の図の赤丸で囲った部分がその例です。
&lt;img src=&#34;https://dotstud.io/img/blog/149/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;あとは見守りながら完成するまで放置しましょう。&lt;/p&gt;

&lt;h2 id=&#34;はじめての出力&#34;&gt;はじめての出力&lt;/h2&gt;

&lt;p&gt;プリンタとデータをセットして出力されるのを待ちます……。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/c7659ea8-e54a-f50a-400a-183218006215.gif&#34; alt=&#34;出力.gif&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成しました。
&lt;img src=&#34;https://dotstud.io/img/blog/149/完成1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;哲学的なゴミです。特に用途はありません。
&lt;img src=&#34;https://dotstud.io/img/blog/149/完成2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3dプリンタを使うときに注意すること&#34;&gt;3Dプリンタを使うときに注意すること&lt;/h2&gt;

&lt;p&gt;セットアップの説明でも述べましたが、3Dプリンターを使ってみて注意した方が良い点をもう一度まとめます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pango上でモデリングのサイズを要チェック&lt;/li&gt;
&lt;li&gt;モデリングしたものをどの向きで出力するか&lt;/li&gt;
&lt;li&gt;初期位置の設定を正確に！（特にz軸方向）&lt;/li&gt;
&lt;li&gt;出力直後に溶け出したフィラメントを必ず除去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3Dプリンタは複雑なものを簡単に出力できるイメージですが、実際に使ってみると経験やコツがいります。やはり、どんな道具も使いこなせるようになるには時間が必要なようです。&lt;/p&gt;

&lt;p&gt;まだまだ3Dプリンターを使う上で学ぶことが多いと感じたので、継続して使っていきたいと思います。&lt;/p&gt;

&lt;p&gt;それではまた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google公式ライブラリを利用してNode.jsからGmailの送受信をしてみよう</title>
      <link>https://dotstud.io/blog/gmail-api-from-nodejs/</link>
      <pubDate>Wed, 21 Feb 2018 17:43:26 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gmail-api-from-nodejs/</guid>
      
      <description>

&lt;p&gt;こんにちは、のびすけです。&lt;/p&gt;

&lt;p&gt;Node.jsでGmailを制御する方法は、過去に色々な記事が出ているのですが、全体的に記事が古く、&lt;a href=&#34;https://developers.google.com/gmail/api/quickstart/nodejs?hl=ja&#34;&gt;Gmail API Node.js Quickstart&lt;/a&gt;のチュートリアルも割とわかりにくいなぁという印象です。英語しかないし。&lt;/p&gt;

&lt;p&gt;また、勝手ライブラリも多いのですがメンテナンスされてなく利用していく際の不安も多いです。&lt;/p&gt;

&lt;p&gt;ということで、今日はNode.jsでGmailを使う方法の紹介です。&lt;/p&gt;

&lt;p&gt;以前書いたSpreadSheets記事も同様のGoogle APIライブラリを利用しているので基本的な手順は同じです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/google-spreadsheets-from-nodejs/&#34;&gt;Node.jsでGoogle SpreadSheetsを操作してみよう。【GAS不使用】&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/135/00_eyecatch.png&#34; width=&#34;400px&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;gmail-apiの有効化とクライアントシークレットの取得&#34;&gt;Gmail APIの有効化とクライアントシークレットの取得&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://console.developers.google.com/start/api?id=gmail&amp;amp;hl=ja&#34;&gt;こちらのリンク&lt;/a&gt;からウィザード開始します。ログインしているGoogleアカウントが利用するGmailのアカウントになるので複数のGoogleやG Suiteのアカウントを持っている人は注意しましょう。&lt;/p&gt;

&lt;p&gt;チェックをして進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/7aa9886c3113712265ee866ed58f6658.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;少し待つとAPIが有効になるので進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/2babe62f7ce826080545439c3c2675d9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証情報に進みますが&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例によってこの画面は何もせずに&lt;code&gt;キャンセル&lt;/code&gt;ボタンを押しましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/1934915770a80c6fab94ee9818f9cf65.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このダッシュボード画面になりますが、&lt;code&gt;OAuth同意画面&lt;/code&gt;のタブを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/7f28a9c626ea9f2ecd0b4691ef337859.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ユーザーに表示するサービス名&lt;/code&gt;の箇所に任意の名前を入力して、保存を押して進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/b93e391525943007cddd5de87a22acbf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証情報タブに戻り、&lt;code&gt;認証情報を作成&lt;/code&gt; -&amp;gt; &lt;code&gt;OAuthクライアントID&lt;/code&gt;を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/57b7c424a42dd9fedaed483ebbf5d84b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;クライアントID作成画面では&lt;code&gt;その他&lt;/code&gt;を選択し、任意の名前を入力します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/124eeda9adf92739b1eff9b1e3afcb42.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;作成すると最初のダッシュボード画面に戻りますが、作成したクライアントIDが表示されています。ここの右下のダウンロードボタンを押すとクライアントシークレットが保存されたJSONファイルがダウンロードされます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/64db51910795b26e05aef6cb9918c33f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;任意の場所に&lt;code&gt;client_secret.json&lt;/code&gt;という名前にリネームして保存しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/8a4b65dfb3319eee11ddea1d0e7d407d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これで、 &lt;strong&gt;クライアントシークレットの保存が出来ました。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;node-jsプロジェクトの準備&#34;&gt;Node.jsプロジェクトの準備&lt;/h2&gt;

&lt;p&gt;Node.jsはv9.5.0です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir gmail
cd gmail
npm init -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほどの&lt;code&gt;client_secret.json&lt;/code&gt;をこのディレクトリに移動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls

package.json client_secret.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライブラリのインストールをすれば準備完了です。google-auth-libraryのバージョンは1.3.1になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm i googleapis google-auth-library --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで準備完了です。&lt;/p&gt;

&lt;h2 id=&#34;アクセストークンの保存&#34;&gt;アクセストークンの保存&lt;/h2&gt;

&lt;p&gt;本家とは少し違うやり方です。&lt;/p&gt;

&lt;p&gt;本家のコードだとアクセストークンの作成&amp;amp;保存作業と実際のAPI呼び出しが一緒になったコードですがトークンの作成&amp;amp;保存は最初のみ行えば良いので手順を分けて紹介します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getAndStoreToken.js&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/google-spreadsheets-from-nodejs/&#34;&gt;前回の記事のコード&lt;/a&gt;とほぼ同様ですが、APIライブラリのバージョンの違いにより、呼び出し方が少し異なります。注意しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//getAndStoreToken.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
const {promisify} = require(&#39;util&#39;);

const {google} = require(&#39;googleapis&#39;);
const {OAuth2Client} = require(&#39;google-auth-library&#39;);

//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);

const SCOPES = [&#39;https://www.googleapis.com/auth/gmail.send&#39;,&#39;https://www.googleapis.com/auth/gmail.readonly&#39;];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+&#39;/gmail-nodejs-quickstart.json&#39;;

const main = async () =&amp;gt; {
    const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
    const credentials = JSON.parse(content); //クレデンシャル
    //認証
    const clientSecret = credentials.installed.client_secret;
    const clientId = credentials.installed.client_id;
    const redirectUrl = credentials.installed.redirect_uris[0];
    const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);

    //get new token
    const authUrl = oauth2Client.generateAuthUrl({
        access_type: &#39;offline&#39;,
        scope: SCOPES
    });

    console.log(&#39;Authorize this app by visiting this url: &#39;, authUrl);

    rl.question(&#39;Enter the code from that page here: &#39;, (code) =&amp;gt; {
        rl.close();

        oauth2Client.getToken(code, async (err, token) =&amp;gt; {
            if (err) {
                console.log(&#39;Error while trying to retrieve access token&#39;, err);
                return;
            }

            oauth2Client.credentials = token;

            try {
                fs.mkdirSync(TOKEN_DIR);
            } catch (err) {
                if (err.code != &#39;EEXIST&#39;) throw err;
            }

            await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
            console.log(&#39;Token stored to &#39; + TOKEN_PATH);
        });
    });
};

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで&lt;code&gt;&#39;https://www.googleapis.com/auth/gmail.readonly&#39;,&#39;https://www.googleapis.com/auth/gmail.send&#39;&lt;/code&gt;の二つのスコープを指定していますが、表示用のgmail.readonlyとメール送信用のgmail.sendとなっています。表示だけしたい場合や送信だけしたい場合などで使い分けましょう。スコープについては&lt;a href=&#34;https://developers.google.com/gmail/api/auth/scopes&#34;&gt;
Choose Auth Scopes&lt;/a&gt;で細かく確認できます。&lt;/p&gt;

&lt;p&gt;では、このプログラムを実行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node getAndStoreToken.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://accounts.google.com/~&lt;/code&gt;で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アカウント選択画面になります。 複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/c5f18901079fc0f4c0362cb0213e89c6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;許可で進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証用のコードが発行されるので、ターミナルの&lt;code&gt;Enter the code from that page here:&lt;/code&gt;と書いてある箇所にコピぺしてEnterで進みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Token stored to /Users/path/to/myapp/gmail-nodejs-quickstart.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などの表示が出て、&lt;code&gt;gmail-nodejs-quickstart.json&lt;/code&gt;が保存されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/4fc90f71b3520a01ce2c568eb28e005f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これでアクセストークンの保存が完了しました。&lt;/p&gt;

&lt;h2 id=&#34;4-いよいよgmailにアクセス&#34;&gt;4. いよいよGmailにアクセス&lt;/h2&gt;

&lt;p&gt;いよいよGmailにアクセスします。&lt;/p&gt;

&lt;h3 id=&#34;ラベル一覧の取得&#34;&gt;ラベル一覧の取得&lt;/h3&gt;

&lt;p&gt;本家チュートリアルを参考に、ラベルの一覧を取得します。
&lt;code&gt;getLabels.js&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;p&gt;ここから先に出てくる&lt;code&gt;userId: &#39;me&#39;&lt;/code&gt;の&lt;code&gt;me&lt;/code&gt;は指定されている文字列らしく、自分のメアドやアカウント名をあえて指定する必要はなくそのまま&lt;code&gt;me&lt;/code&gt;と書いておけば問題なさそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//getLabels.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const {promisify} = require(&#39;util&#39;);
const {google} = require(&#39;googleapis&#39;);
const {OAuth2Client} = require(&#39;google-auth-library&#39;);
const gmail = google.gmail(&#39;v1&#39;);

//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const gmailListLabesAsync = promisify(gmail.users.labels.list); //Gmailのラベル一覧

const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + &#39;/gmail-nodejs-quickstart.json&#39;; //アクセストークンのファイルを指定

const main = async () =&amp;gt; {
    //クレデンシャル情報の取得
    const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;); //クライアントシークレットのファイルを指定
    const credentials = JSON.parse(content); //クレデンシャル

    //認証
    const clientSecret = credentials.installed.client_secret;
    const clientId = credentials.installed.client_id;
    const redirectUrl = credentials.installed.redirect_uris[0];
    const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
    const token = await readFileAsync(TOKEN_PATH);
    oauth2Client.credentials = JSON.parse(token);

    //API経由でシートにアクセス
    const response = await gmailListLabesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;,
    });
    //結果を表示
    console.log(response.data);
};

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Async/Awaitで利用できるように&lt;code&gt;const gmailListLabesAsync = promisify(gmail.users.labels.list);&lt;/code&gt;の箇所でPromisifyを利用してプロミス化しています。&lt;/p&gt;

&lt;p&gt;実行するとラベル一覧が取得できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node getLabels.js

{ labels:
   [ { id: &#39;Label_125&#39;,
       name: &#39;研修/青山学院大学&#39;,
       messageListVisibility: &#39;show&#39;,
       labelListVisibility: &#39;labelShow&#39;,
       type: &#39;user&#39;,
       color: [Object] },
     { id: &#39;Label_40&#39;,
       name: &#39;取引/養老乃瀧&#39;,
       messageListVisibility: &#39;show&#39;,
       labelListVisibility: &#39;labelShow&#39;,
       type: &#39;user&#39;,
       color: [Object] },
       
       ・
       ・
       ・
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会社のメールの内容なので出せるところだけ笑&lt;/p&gt;

&lt;h3 id=&#34;メールの内容を取得&#34;&gt;メールの内容を取得&lt;/h3&gt;

&lt;p&gt;メールの内容は&lt;code&gt;Users.messages: list&lt;/code&gt;と&lt;code&gt;Users.messages: get&lt;/code&gt;を利用します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/get&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/get&lt;/a&gt;
&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/list&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;必要な箇所だけ抜粋しますが、&lt;code&gt;gmail.users.messages.list()&lt;/code&gt;と&lt;code&gt;gmail.users.messages.get()&lt;/code&gt;というメソッドがあるので利用します。
Async/Awaitで利用できるように、先ほど同様Promisifyします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const gmailGetMessagesAsync = promisify(gmail.users.messages.get); 
const gmailListMessagesAsync = promisify(gmail.users.messages.list);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メッセージリストを取得し、メッセージごとのIDを取得します。メッセージIDをもとにメッセージ本文を取得。
最後に本文はBase64変換されてるのでデコードして表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;省略

    //メッセージリストの取得
    let res = await gmailListMessagesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;
    });
    const newestMessageId = res.messages[0].id; //最新のメッセージID

    //メッセージの取得
    res = await gmailGetMessagesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;,
        id: newestMessageId
    });
    //結果を表示
    const base64mailBody = res.payload.parts[0].body.data; //parts[0]がテキスト、parts[1]がHTMLメールっぽい(?)
    const mailBody = new Buffer(base64mailBody, &#39;base64&#39;).toString(); //メール本文はBase64になってるので変換
    console.log(mailBody);//やっとメール本文が表示される

省略
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;メールの送信&#34;&gt;メールの送信&lt;/h3&gt;

&lt;p&gt;送信が割と大変でした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Users.messages: send&lt;/code&gt;を利用します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/send&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/send&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;gmail.users.messages.send()&lt;/code&gt;のメソッドを利用します。
先ほどと同様にPromisifyします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const gmailSendMessagesAsync = promisify(gmail.users.messages.send);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にメール送信時の処理です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;省略

    const makeBody = (params) =&amp;gt; {
        params.subject = new Buffer(params.subject).toString(&amp;quot;base64&amp;quot;); //日本語対応

        const str = [
            `Content-Type: text/plain; charset=\&amp;quot;UTF-8\&amp;quot;\n`,
            `MIME-Version: 1.0\n`,
            `Content-Transfer-Encoding: 7bit\n`,
            `to: ${params.to} \n`,
            `from: ${params.from} \n`,
            `subject: =?UTF-8?B?${params.subject}?= \n\n`,
            params.message
        ].join(&#39;&#39;);
        return new Buffer(str).toString(&amp;quot;base64&amp;quot;).replace(/\+/g, &#39;-&#39;).replace(/\//g, &#39;_&#39;);
    }
    
    const messageBody = `
        XXXX 様

        商品のご購入、誠にありがとうございます。
        ・Nefry BT x 1
        の商品を本日発送しましたのでご連絡差し上げます。
        
        こちらから配送状況をご確認頂けます。
        (このメール送信の時点では反映されていない可能性もあります)

        https://trackings.post.japanpost.jp/xxxxxxxxxx`;

    const raw = makeBody({
        to: &#39;相手のメールアドレス&#39;,
        from: &#39;送信者のメールアドレス&#39;,
        subject: &#39;件名(日本語可)&#39;,
        message: messageBody
    });

    const res = await gmailSendMessagesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;,
        resource: {
          raw: raw
        }
    });
    console.log(res.data);

省略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sendMail.js&lt;/code&gt;などを作成し、この内容で実行するとメールが送信できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node sendMail.js

{ id: &#39;xxxxxxxxxxxxxxxxx&#39;,
  threadId: &#39;xxxxxxxxxxxxxxxx&#39;,
  labelIds: [ &#39;SENT&#39; ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gmail側で受信確認をすると、しっかりと送られてきています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3ad5f4729e90c9523e2e6e5cb972349b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;また、暗号化もされているようで、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/mail/answer/6330403?authuser=2&amp;amp;visit_id=1-636548034928176578-836942562&amp;amp;p=tls&amp;amp;hl=ja&amp;amp;rd=1&#34;&gt;送受信時のメールの暗号化 - Gmailヘルプ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/247eb44de5f0b635d52fd2b0c06a4de3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Node.jsのメール送信ライブラリはいくつかあって、いくつか試したときに暗号化されてない場合も多かった印象です。暗号化無しだと、この赤いアラートっぽいメール表示になります。&lt;/p&gt;

&lt;p&gt;今回のやり方はGoogle公式のライブラリで、特に意識せずに暗号化も行われているので暗号化に対するアラートなども受け取り手には表示されないので迷惑メールなどに振り分けられてしまう心配もたぶん少ないのでは。
（Gmailの迷惑メールアルゴリズムは色々な要素がありそうなので断言は出来ないですが）&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;実装途中の感想ですが、メール送信が割と苦労した印象です。&lt;/p&gt;

&lt;p&gt;メール送信のNode.jsサンプルが無かったので、&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/send#examples&#34;&gt;JavaScript Sample&lt;/a&gt;を見ると、送信パラメータに&lt;code&gt;email RFC 5322 formatted String.&lt;/code&gt;という記述があってRFCのフォーマットを確認する必要がありました。&lt;/p&gt;

&lt;p&gt;この手のライブラリだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const params = {
    to: &#39;&#39;,
    from: &#39;&#39;,
    subject: &#39;&#39;,
    body: &#39;&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいな形式のObjectを突っ込めばいい感じにやってくれる印象があったので&amp;hellip;&amp;hellip;苦笑&lt;/p&gt;

&lt;p&gt;Stack Over Flowの&lt;a href=&#34;https://stackoverflow.com/questions/34546142/gmail-api-for-sending-mails-in-node-js&#34;&gt;Gmail API for sending mails in Node.js&lt;/a&gt;がかなり参考になりました。&lt;/p&gt;

&lt;p&gt;また、日本語でのSubject送信に&lt;code&gt;=?文字コード?メソッド?Base64変換した文字列?=&lt;/code&gt;という形式で渡すなどは&lt;a href=&#34;http://hogem.hatenablog.com/entry/20100122/1264169093&#34;&gt;メールのSubjectヘッダのエンコード&lt;/a&gt;の記事が参考になりました。&lt;/p&gt;

&lt;p&gt;とはいえ、問題なくメール送信出来たので、この記事を参考に使ってみてください。&lt;/p&gt;

&lt;p&gt;それでは！&lt;/p&gt;

&lt;h2 id=&#34;補足-本家のチュートリアルのエラー&#34;&gt;補足: 本家のチュートリアルのエラー&lt;/h2&gt;

&lt;p&gt;今回紹介した手順では問題ないですが、もともとのチュートリアルのコードだと以下の二つのエラーが出ました。(2018年2月時点)&lt;/p&gt;

&lt;h3 id=&#34;google-gmail-is-not-a-function&#34;&gt;google.gmail is not a function&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;google.gmail() is giving an error TypeError: google.gmail is not a function?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ってエラーが出ました。&lt;/p&gt;

&lt;p&gt;Stack Over Flowの&lt;a href=&#34;https://stackoverflow.com/questions/48762090/google-gmail-is-giving-an-error-typeerror-google-gmail-is-not-a-function&#34;&gt;google.gmail() is giving an error TypeError: google.gmail is not a function?&lt;/a&gt;を参考に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var google = require(&#39;googleapis&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを↓に変更するとエラー解消されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var {google} = require(&#39;googleapis&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;googleauth-is-not-a-constructor&#34;&gt;GoogleAuth is not a constructor&lt;/h3&gt;

&lt;p&gt;こちらはIssueがあがっていて&lt;a href=&#34;https://github.com/google/google-auth-library-nodejs/issues/251&#34;&gt;GoogleAuth is not a constructor #251&lt;/a&gt;を見ると、&lt;/p&gt;

&lt;p&gt;呼び出し方が変更されてて、以下の修正が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { GoogleAuth } = require(&#39;google-auth-library&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;↓&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { OAuth2Client } = require(&#39;google-auth-library&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、今の変更に伴いOAuthの処理も変更が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;↓&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//const auth = new googleAuth();
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで問題なく利用できるようになりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラブでモテる！つまみ付きユニコーンポーチ　前編</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette/</guid>
      
      <description>

&lt;p&gt;みなさん、ちょりおつ！ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案するユニット、ギャル電で活動しています。今回は、&lt;strong&gt;クラブ行くときにぎゃんかわに盛れる光るポーチの作り方&lt;/strong&gt;を2回にわけて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;ユニコーンきゃわたん&#34;&gt;ユニコーンきゃわたん&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ちょっと前から、イケてるヤングの間ではユニコーンがはやってるっぽい。角生えてる馬、かっこいいしかわいいからはやるのも超わかりみある。&lt;/p&gt;

&lt;p&gt;つーことで、イケてるユニコーンっぽいバッグが街には今いっぱい売ってる。今回は、&lt;strong&gt;WEGOで500円のサイズ感もぴったりな超イケてるポーチ&lt;/strong&gt;をゲット。めっちゃリーズナブル！！！！&lt;/p&gt;

&lt;p&gt;コレ光らせたらやばくねってことで、さっそく作ってこう。&lt;/p&gt;

&lt;h2 id=&#34;材料&#34;&gt;材料&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;①Arduino Nano 互換機&lt;/li&gt;
&lt;li&gt;②可変抵抗 10KΩ 3個&lt;/li&gt;
&lt;li&gt;③つまみのキャップ&lt;/li&gt;
&lt;li&gt;④LEDテープ（WS2812B 60LED/M）LED24個分&lt;/li&gt;
&lt;li&gt;線材（コネクタは気分で）&lt;/li&gt;
&lt;li&gt;USB miniB ケーブル&lt;/li&gt;
&lt;li&gt;プラ板&lt;/li&gt;
&lt;li&gt;ユニコーンぽいファーのいい感じのポーチ（白系）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;材料はこんな感じ。つまみのキャップはギター用のカッコいいやつを使ったよ。ポーチはだいたいモバイルバッテリーと小銭と携帯が入るくらいのサイズ感のものがおすすめっす。&lt;/p&gt;

&lt;h2 id=&#34;可変抵抗器をアクセントにしてみよう&#34;&gt;可変抵抗器をアクセントにしてみよう&lt;/h2&gt;

&lt;p&gt;可変抵抗器はイケてるキャップをつけるとめっちゃかわいい！&lt;/p&gt;

&lt;p&gt;今回は三つの可変抵抗器の値を変更することで、LEDの&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;明るさ&lt;/li&gt;
&lt;li&gt;色&lt;/li&gt;
&lt;li&gt;点灯速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を変更できる仕組みをつくります。&lt;/p&gt;

&lt;h2 id=&#34;配線をはんだ付けしよう&#34;&gt;配線をはんだ付けしよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずは写真と図のように三つの可変抵抗器のプラスとプラス、マイナスとマイナスを配線でつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/5.png&#34; alt=&#34;&#34; /&gt;
三つのうちの可変抵抗器の一つに、プラスとマイナスの配線をさらに1セット追加してArduino Nanoの5VとGNDにつなぎます。可変抵抗器の真ん中の線とAruduino NanoのA0〜A1ポートを配線でそれぞれつなぎます。&lt;/p&gt;

&lt;p&gt;LEDテープはDINとD6、5V、GNDをそれぞれAruduino Nanoと配線でつなぎます。
&lt;img src=&#34;https://dotstud.io/img/blog/146/6.png&#34; alt=&#34;&#34; /&gt;
Aruduino Nanoの5VとGNDのところは、可変抵抗器とLEDテープからそれぞれ配線がつながります。一つのPINにはんだ付けが難しい場合は、ボードの裏と表にそれぞれ1本ずつ配線をつなげるとはんだ付けがやりやすいです。&lt;/p&gt;

&lt;h2 id=&#34;前編はここまで&#34;&gt;前編はここまで&lt;/h2&gt;

&lt;p&gt;今回は可変抵抗器を三つつなげたので、ちょっと配線とはんだ付けが複雑で疲れちゃったのでここまで！&lt;/p&gt;

&lt;p&gt;後編はArduino Nanoへのプログラム書き込みと、ポーチとLEDを組み立てまっす！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 後編をチェック！
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScriptで開発できる！Mongoose OSでNefry BTをLチカしよう</title>
      <link>https://dotstud.io/blog/mongoose-os-nefry-blink/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/mongoose-os-nefry-blink/</guid>
      
      <description>

&lt;p&gt;唐突ですが、森田(&lt;a href=&#34;https://twitter.com/morita_pac&#34;&gt;@morita_pac&lt;/a&gt;)と申します。&lt;/p&gt;

&lt;p&gt;ヘビーNefryBTユーザです。持ち歩いていろんな場所でNefry BTを利用したり、ケースを作ったりもしています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常Nefry BTはArduino言語でプログラムするのですが、今回はJavaScriptで書き込めるようにしたいと思います。&lt;/p&gt;

&lt;p&gt;※この記事内のプログラムはNefy BT（無印）向けです。Nefry BT R2向けのプログラムは別途準備中です。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで開発できるmongoose-osとは&#34;&gt;JavaScriptで開発できるMongoose OSとは&lt;/h2&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://mongoose-os.com/&#34;&gt;Mongoose OS&lt;/a&gt;というIoTのプロト開発を簡単にできるサービスを利用します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://mongoose-os.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/2.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ Mongoose OS公式サイト
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Mongoose OSでは、ESP32やESP8266へJavaScript（&lt;a href=&#34;https://github.com/cesanta/mjs&#34;&gt;mJS&lt;/a&gt;）でコードを書き込めます。
さらには、セキュアで、AWS IoTやGoogleのCloud IoT Coreなどとも連携設定がシンプルにできます。&lt;/p&gt;

&lt;p&gt;Mongoose OSをインストールしている間は元のNefry BTのプログラムは利用できなくなります。（Arduino IDEで書き込むことですぐに戻せます。）&lt;/p&gt;

&lt;h2 id=&#34;mongoose-osの開発環境をセットアップ&#34;&gt;Mongoose OSの開発環境をセットアップ&lt;/h2&gt;

&lt;h3 id=&#34;windowsの場合&#34;&gt;Windowsの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://mongoose-os.com/software.html&#34;&gt;Download Page&lt;/a&gt;から、exeをダウンロードするだけで使えます。（アンチウイルス系のソフトが反応するかもしれません。）なお、以降MacOSでの説明になります。
&lt;img src=&#34;https://dotstud.io/img/blog/145/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mac-osの場合&#34;&gt;Mac OSの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://mongoose-os.com/software.html&#34;&gt;Download Page&lt;/a&gt;の、MacOS/Linuxのcurlコマンドをターミナルで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://mongoose-os.com/downloads/mos/install.sh | /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ターミナルで以下のようになれば無事完了です。開く場合は、Runの&lt;code&gt;/xxx/.mos/bin/mos&lt;/code&gt;を実行するとWeb UIが開きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://mongoose-os.com/downloads/mos/install.sh | /bin/bash
Downloading https://mongoose-os.com/downloads/mos-release/mac/mos ...
########################################################################
 100.0%
Installing into /xxx/.mos/bin/mos ...
Adding /xxx/.mos/bin to your PATH in /xxx/.profile
SUCCESS: /xxx/.mos/bin/mos is installed.
Run &#39;/xxx/.mos/bin/mos --help&#39; to see all available commands.
Run &#39;/xxx/.mos/bin/mos&#39; without arguments to start a simplified Web UI installer.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;いざ-mongoose-osをnefry-btに入れてみよう&#34;&gt;いざ、Mongoose  OSをNefry BTに入れてみよう&lt;/h2&gt;

&lt;p&gt;Nefry BTをUSBポートに差し込み、Mongose OSとサンプルコードをFlashします。（次回起動時は、ポート選択のみで利用可能です。）&lt;/p&gt;

&lt;p&gt;Mongoose OSのWeb UIは、ブラウザで開きます。①②③の設定が完了すれば無事、JavaScriptで書き込む準備完了です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;①は、Nefry BTのポートを選択します。ポートが見つからない場合はUSBを認識させるための&lt;a href=&#34;https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers&#34;&gt;ドライバ&lt;/a&gt;をインストールする必要があります。
②では、Platformで「esp32」とapp「demo-js」を選択し「Flash」ボタンをクリックし、処理が終わるまで待ちます。
③では、Wi-fi設定を行います。（今回は必須ではないです。）
全ての設定が完了したら、「Done」ボタンをおしてdevice setupを閉じます。&lt;/p&gt;

&lt;h1 id=&#34;4-基本的なweb-uiとサンプルプログラム&#34;&gt;4. 基本的なWeb UIとサンプルプログラム&lt;/h1&gt;

&lt;h3 id=&#34;web-uiについて&#34;&gt;Web UIについて&lt;/h3&gt;

&lt;p&gt;まず、画面左側Device Filesを選択します。すると、init.jsが選択され、メインプログラムが表示されます。init.jsファイルをメインで編集します。&lt;/p&gt;

&lt;p&gt;編集後、書き込みたい場合は、Save + Rebootボタンで行えます。このコードやファイルの情報は、端末から読んでいますので、コードを書き換えたら、書き込む前にバックアップを取っておくことをお勧めします。
&lt;img src=&#34;https://dotstud.io/img/blog/145/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;サンプルプログラムについて&#34;&gt;サンプルプログラムについて&lt;/h3&gt;

&lt;p&gt;デフォルトプログラムを僕の感性でコメントしましたので、ご確認ください。なお、色々と制限付きのJSなので、仕様は&lt;a href=&#34;https://github.com/cesanta/mjs&#34;&gt;こちら&lt;/a&gt;で確認ください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;// 利用するAPIを読み出します。Flashした時点のサンプルAPIが呼ばれています。
// 各APIの仕様やサンプルは画面左のファイル一覧で参照可能です。
load(&#39;api_config.js&#39;);
load(&#39;api_events.js&#39;);
load(&#39;api_gpio.js&#39;);
load(&#39;api_mqtt.js&#39;);
load(&#39;api_net.js&#39;);
load(&#39;api_sys.js&#39;);
load(&#39;api_timer.js&#39;);

// 変数宣言はletのみです。const, varは使えません。
let led = Cfg.get(&#39;pins.led&#39;);
let button = Cfg.get(&#39;pins.button&#39;);
let topic = &#39;/devices/&#39; + Cfg.get(&#39;device.id&#39;) + &#39;/events&#39;;

print(&#39;LED GPIO:&#39;, led, &#39;button GPIO:&#39;, button);

let getInfo = function() {
  return JSON.stringify({
    total_ram: Sys.total_ram(),
    free_ram: Sys.free_ram()
  });
};

// 1秒おきにLEDをチカチカさせてます。ついでにチクタク時を刻んでいます。
GPIO.set_mode(led, GPIO.MODE_OUTPUT);
Timer.set(1000 /* 1 sec */, Timer.REPEAT, function() {
  let value = GPIO.toggle(led);
  print(value ? &#39;Tick&#39; : &#39;Tock&#39;, &#39;uptime:&#39;, Sys.uptime(), getInfo());
}, null);

// リセットボタンではない方のボタンを押すとMQTTでpublishします。
GPIO.set_button_handler(button, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 200, function() {
  let message = getInfo();
  let ok = MQTT.pub(topic, message, 1);
  print(&#39;Published:&#39;, ok, topic, &#39;-&amp;gt;&#39;, message);
}, null);

// ネットワークモニタです。
Event.addGroupHandler(Net.EVENT_GRP, function(ev, evdata, arg) {
  let evs = &#39;???&#39;;
  if (ev === Net.STATUS_DISCONNECTED) {
    evs = &#39;DISCONNECTED&#39;;
  } else if (ev === Net.STATUS_CONNECTING) {
    evs = &#39;CONNECTING&#39;;
  } else if (ev === Net.STATUS_CONNECTED) {
    evs = &#39;CONNECTED&#39;;
  } else if (ev === Net.STATUS_GOT_IP) {
    evs = &#39;GOT_IP&#39;;
  }
  print(&#39;== Net event:&#39;, ev, evs);
}, null);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nefry-btのフルカラーledを点灯しよう&#34;&gt;Nefry BTのフルカラーLEDを点灯しよう&lt;/h2&gt;

&lt;p&gt;やっと本題に入ります。&lt;/p&gt;

&lt;p&gt;Mongoose OSでは、様々なオープンソースコードがあり、それをインポートすることができます。今回は、NefryBTのフルカラーLEDを点灯させるためにNeoPixelのサンプルコードを入手します。&lt;/p&gt;

&lt;p&gt;画面左のProjectsを選択し、Importをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/145/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;App Managerのサーチ部分に「neopixel」と入力し、HARDWAREから「example-neopixel-js」をimportします。完了したらApp Managerの画面を閉じます。
&lt;img src=&#34;https://dotstud.io/img/blog/145/8.png&#34; alt=&#34;&#34; /&gt;
次に、サンプルプログラムをNefryBTに書き込みます。&lt;/p&gt;

&lt;p&gt;今ImportしたAppが選択されていることを確認し、①Rebuildアイコンと②Flashアイコンを処理が完了次第、順番にクリックすることで書き込み完了です。（それぞれ少々時間がかかります。）
&lt;img src=&#34;https://dotstud.io/img/blog/145/9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Device Filesのinit.jsの内容を以下の内容に書き換えます。Nefry BTのボタンを押したらフルカラーLEDが点灯するという内容のプログラムです。&lt;/p&gt;

&lt;p&gt;※なお、R2に関しては動作確認中ですので、確認次第内容を変更いたします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;load(&#39;api_config.js&#39;);
load(&#39;api_events.js&#39;);
load(&#39;api_gpio.js&#39;);
load(&#39;api_sys.js&#39;);
load(&#39;api_timer.js&#39;);
load(&#39;api_neopixel.js&#39;);

// 今回は一部しか利用していませんが、NefryのピンNoです。
let pin = {
    &amp;quot;nefrybt&amp;quot;:{
      &amp;quot;sw&amp;quot;: 4,
      &amp;quot;d0&amp;quot;:22,
      &amp;quot;d1&amp;quot;:21,
      &amp;quot;d2&amp;quot;:23,
      &amp;quot;d3&amp;quot;:19,
      &amp;quot;d4&amp;quot;:18,
      &amp;quot;a0&amp;quot;:25,
      &amp;quot;a1&amp;quot;:26,
      &amp;quot;a2&amp;quot;:32,
      &amp;quot;a3&amp;quot;:33,
      &amp;quot;a4&amp;quot;:27,
      &amp;quot;a5&amp;quot;:14,
      &amp;quot;a6&amp;quot;:13,
      &amp;quot;a7&amp;quot;:35,
      &amp;quot;LED&amp;quot;:16
    },
    &amp;quot;nefrybtR2&amp;quot;:{
      &amp;quot;sw&amp;quot;: 4,
      &amp;quot;d0&amp;quot;:22,
      &amp;quot;d1&amp;quot;:21,
      &amp;quot;d2&amp;quot;:23,
      &amp;quot;d3&amp;quot;:19,
      &amp;quot;d4&amp;quot;:18,
      &amp;quot;d5&amp;quot;:25,
      &amp;quot;d6&amp;quot;:26,
      &amp;quot;d7&amp;quot;:13,
      &amp;quot;d8&amp;quot;:14,
      &amp;quot;a0&amp;quot;:33,
      &amp;quot;a1&amp;quot;:32,
      &amp;quot;a2&amp;quot;:39,
      &amp;quot;a3&amp;quot;:36,
      &amp;quot;LED&amp;quot;:16
    }
  };


// フルカラーLEDのピンと個数、オーダーを指定しています。
let Lpin = pin.nefrybt.LED, numPixels = 1, colorOrder = NeoPixel.GRB;

// api_neopixel.jsに基づき初期化を行います。
let strip = NeoPixel.create(Lpin, numPixels, colorOrder);
strip.clear();
strip.setPixel(0,0,0,0);
strip.show();

// ボタンを押したら赤色をつけます。setpixel(0,0,0,0)は、ピクセルナンバーとRGBになっています。Redの数字は20としていますが、数字をあげるとかなり明るくなります。
// GPIO.set_button_handlerの仕様は、
GPIO.set_button_handler(4, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 200, function() {
    strip.clear();
    strip.setPixel(0,20,0,0);
    strip.show();
}, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;困った時は&#34;&gt;困った時は&lt;/h2&gt;

&lt;p&gt;Q. DeviceLogsにエラーがでている。&lt;/p&gt;

&lt;p&gt;A. Mongoose OS画面右上のdevice setupより、ポートを選択し直してください。それでも治らない場合は、ターミナルにて、&lt;code&gt;control+c&lt;/code&gt;でMongoose OSを一度終わらせて、再起動をしてみてください。&lt;/p&gt;

&lt;p&gt;それでもエラーが発生する場合は、一度Arduino IDEからNefry BTをボードに選択し、何も書いていないコードで書き込み直してください。なお、Nefry BTの状態に戻したい場合もArduino IDEから書き込むことで初期状態にもどせます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTをJavaScriptでプログラムして、LEDを点灯させるところまでできました。&lt;/p&gt;

&lt;p&gt;ディスプレイも表示させることができるので、次回は、Mongoose OSを使ったディスプレイの表示方法をご紹介しようと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IoTも私らしく！楽しく学べる「IoT女子会」のクリスマスイベント潜入レポ</title>
      <link>https://dotstud.io/blog/iot-girls2-xmas-handson/</link>
      <pubDate>Fri, 19 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/iot-girls2-xmas-handson/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃんとくです。12月22日にDMM.make AKIBAで開催された「&lt;strong&gt;&lt;a href=&#34;https://peatix.com/event/328302&#34;&gt;IoT女子会 女性限定・お土産付き♡ ディップアートで光る クリスマスオーナメントワークショップ&lt;/a&gt;&lt;/strong&gt;」に参加してきました！&lt;/p&gt;

&lt;p&gt;楽しく学べて内容もりだくさんだったイベントの様子をレポートします！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/10.png&#34; alt=&#34;&#34; /&gt;
３回目の今回も、たくさんの女性で大盛況でした！
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;iot女子会とは&#34;&gt;IoT女子会とは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/140/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DMM.make AKIBA主催の「IoT女子会」は今回で第3回目。2017年6月の立ち上げを皮切りに、女性ならではのモノづくりやIoT分野で活躍する女性にフォーカスしたイベントを開催されています。&lt;/p&gt;

&lt;p&gt;「IoT」という言葉が流行って久しいですが「便利なモノ・欲しいモノ」は年齢・性別・職業など立場によって違うはず。画一的・汎用的なIoTデバイスだけでなく、「&lt;strong&gt;自分らしいIoTなモノ作りを実現したい&lt;/strong&gt;」と考える女性にぴったりのイベントです。&lt;/p&gt;

&lt;p&gt;第1回・第2回のIoT女子会ではモデレータとして参加させていただきました！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/iot-girls-chantoku-report/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/140/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 第1回IoT女子会イベントレポート
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://inside.dmm.com/entry/2017/10/10/iot-girl&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/140/link2.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 第2回IoT女子会イベントレポート by あくやん氏
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;そのデバイス-本当に私らしい&#34;&gt;そのデバイス、本当に私らしい？&lt;/h2&gt;

&lt;p&gt;まず「私らしいIoTの実現ってなんだろう」を考えるところから会はスタート。TVのリモコンを例に、誰もが使えるように作られた、&lt;strong&gt;機能重視、わかりやすさ重視のデバイスって本当に私らしいだろうか？&lt;/strong&gt; という部分に立ち返って考えてみます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/2.png&#34; alt=&#34;&#34; /&gt;
▲ 講師を務めるのは合同会社techika代表・乙女電芸部部長 矢島佳澄氏
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;例えば朝にはTVでニュースが、夜にはリラックスできる音楽が流れる「私らしい暮らし」、自分の好きなテイストに揃えたインテリアに溶け込む「私らしい見た目」。人それぞれ違う、&lt;strong&gt;好きな見た目と必要な機能だけを備えたデバイスで「私らしい暮らし」を実現&lt;/strong&gt;できればステキですよね。&lt;/p&gt;

&lt;p&gt;テクノロジーで実現する私らしい暮らしの第一歩、ということで、今回は電子工作の基礎を学びつつオーナメント作りに挑戦してみます！&lt;/p&gt;

&lt;h2 id=&#34;ディップアートで光るオーナメントづくり&#34;&gt;ディップアートで光るオーナメントづくり！&lt;/h2&gt;

&lt;p&gt;今回作る「ディップアートで光るオーナメント」は、「ものづくりをエンターテイメントにする」をテーマに活動する&lt;a href=&#34;http://makership.co.jp/&#34;&gt;Makershp Inc.&lt;/a&gt; 発案の子供向けワークショップで作っていたものをアレンジしたもの。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/15.png&#34; alt=&#34;&#34; /&gt;
▲ Makership Inc. CEO 高野 慎太郎氏
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ワイヤーとディップ液（マニキュアのような液）で作る「ディップアート」に、スイッチのON/OFFでライトアップできる機構を加えたオーナメントを作っていきます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/13.png&#34; alt=&#34;&#34; /&gt;
サンプルの作品。実際に作ってみるとわかるが、かなりレベルが高い。
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;まずは回路を作成&#34;&gt;まずは回路を作成&lt;/h3&gt;

&lt;p&gt;入門といえど、しっかり回路設計からお勉強。今回は電池駆動でLEDモジュールを動かすシンプルな機構です。
&lt;img src=&#34;https://dotstud.io/img/blog/140/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「ジャンパワイヤってどれでしょう？」や「ブレッドボードの電流の向き」など、電子工作の基礎の基礎から学んでいきました！
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/4.png&#34; alt=&#34;&#34; /&gt;
▲ 電池はスポンサーのRSコンポーネンツさんのご提供
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ブレッドボードを使って、はんだづけなしで機構は完成。スイッチでLEDがON/OFFできます。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/5.png&#34; alt=&#34;&#34; /&gt;
▲ 飾るときに外れないよう、ブレッドボード側は全てグルーガンで固定！
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;ディップオーナメントで自由にデコ&#34;&gt;ディップオーナメントで自由にデコ！&lt;/h3&gt;

&lt;p&gt;LED部分ができたら、お楽しみの（？）ディップアート！針金で好きな形を作り、赤・緑・白など好きな色のディップ液に浸していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/140/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サンプルにあった風船や葉っぱに加えて、立体的なお花やハートなど個性的な作品が次々に生まれていきます！
&lt;img src=&#34;https://dotstud.io/img/blog/140/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/8.png&#34; alt=&#34;&#34; /&gt;
▲ ある一角には草が量産されていた
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/17.png&#34; alt=&#34;&#34; /&gt;
▲ ファンシーな蝶と風船を作りたかったちゃんとく氏
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;個性的なオーナメントが完成&#34;&gt;個性的なオーナメントが完成！&lt;/h3&gt;

&lt;p&gt;メイソン・ジャーに、ディップアートとLEDを飾ったらオーナメントは完成！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/18.png&#34; alt=&#34;&#34; /&gt;
▲ ちゃんとく作・ディップアートで光るオーナメント
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ちょっとばかり雑で瓶の向きも間違ってるけど、自分で作ったものは愛着が湧いてかわいい……！&lt;/p&gt;

&lt;p&gt;参加者のみなさんの作品それぞれ個性的でとってもステキでした！
&lt;img src=&#34;https://dotstud.io/img/blog/140/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;恒例の豪華な懇親会-お土産で交流&#34;&gt;恒例の豪華な懇親会＆お土産で交流！&lt;/h2&gt;

&lt;p&gt;モノづくりのあとは、美味しいご飯で懇親会！いろいろな形でIoTへの思いを持つ女性たちで、モノづくりの聖地・秋葉原の夜が盛り上がりました。
&lt;img src=&#34;https://dotstud.io/img/blog/140/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/20.png&#34; alt=&#34;&#34; /&gt;
▲ お酒はリカーイノベーション株式会社さんからのご提供
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;性別、立場などマイノリティに関係なく、テクノロジーでみんながステキな暮らしを実現できる世界もそう遠くないのでは、と思わされるイベントでした。IoT女子会の最新情報は&lt;a href=&#34;https://www.facebook.com/groups/184023265513094/&#34;&gt;Facebookグループ&lt;/a&gt;をウォッチ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）からBLEでNode.jsにデータを送ってみよう</title>
      <link>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</link>
      <pubDate>Fri, 12 Jan 2018 23:58:16 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</guid>
      
      <description>

&lt;p&gt;こんにちは、代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。Nefry BTを使ってBluetooth / BLEを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、検証してませんが他のESP32系のボードでも動作すると思います。&lt;/p&gt;

&lt;h2 id=&#34;bleについて&#34;&gt;BLEについて&lt;/h2&gt;

&lt;p&gt;BLEには大きく分け&lt;strong&gt;Peripheral （ペリフェラル）&lt;/strong&gt;と&lt;strong&gt;Central（セントラル）&lt;/strong&gt;という二つの役割があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Peripheral: 発信側端末、ビーコンやBLEタグなど受信端末に対して情報を送る側&lt;/li&gt;
&lt;li&gt;Central: 受信側端末、iPhoneやMacなどBLEデバイスの情報を探して受け取る側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTは書き込むコードによって、PeripheralにもCentralにもなることができます。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;peripheralの作成&#34;&gt;Peripheralの作成&lt;/h2&gt;

&lt;p&gt;情報発信側のPeripheralをNefry BTで作成します。&lt;/p&gt;

&lt;h3 id=&#34;uuidの作成&#34;&gt;UUIDの作成&lt;/h3&gt;

&lt;p&gt;BLEを利用するためには&lt;strong&gt;SERVICE（サービス）&lt;/strong&gt;と&lt;strong&gt;CHARACTERISTIC（キャラクタリスティック）&lt;/strong&gt;という各機能を司るUUIDを設定する必要があります。プログラミングでいうクラスとメソッドの関係だと思うと良いかもしれません。&lt;/p&gt;

&lt;p&gt;BLEデバイスは部屋の中やカフェ、駅などいたるところに存在するのでそれらのデバイスと自分が所持しているデバイスのIDが競合しないようにユニークな値にする必要があります。そこでUUIDを作成し、設定する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.uuidgenerator.net/&#34;&gt;https://www.uuidgenerator.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このサイトでUUIDが作成出きるので各自作成しましょう。&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;大元のコードはnkolban氏の&lt;a href=&#34;https://github.com/nkolban/ESP32_BLE_Arduino/blob/f8fe9d7cdfb20caa54b70849826d1ac6e375ff78/examples/BLE_notify/BLE_notify.ino&#34;&gt;こちらのコード&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#define SERVICE_UUID&lt;/code&gt;の箇所と&lt;code&gt;#define CHARACTERISTIC_UUID&lt;/code&gt;の箇所に先ほど作成したUUIDを指定します。&lt;/p&gt;

&lt;p&gt;また&lt;code&gt;BLEDevice::init(&amp;quot;&amp;quot;);&lt;/code&gt;の箇所にBLEデバイスの名前を設定できます。
以下のコードではNefryBT-n0bisukeという名前を指定しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;BLEDevice.h&amp;gt;
#include &amp;lt;BLEServer.h&amp;gt;
#include &amp;lt;BLEUtils.h&amp;gt;
#include &amp;lt;BLE2902.h&amp;gt;

BLECharacteristic *pCharacteristic;
bool deviceConnected = false;
uint8_t value = 0;

// See the following for generating UUIDs:
// https://www.uuidgenerator.net/

#define SERVICE_UUID        &amp;quot;D5875408-FA51-4763-A75D-7D33CECEBC31&amp;quot;
#define CHARACTERISTIC_UUID &amp;quot;A4F01D8C-A037-43B6-9050-1876A8C23584&amp;quot;

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
    }
};

void setup() {
  Serial.begin(115200);

  // Create the BLE Device
  BLEDevice::init(&amp;quot;NefryBT-n0bisuke&amp;quot;);

  // Create the BLE Server
  BLEServer *pServer = BLEDevice::createServer();
  pServer-&amp;gt;setCallbacks(new MyServerCallbacks());

  // Create the BLE Service
  BLEService *pService = pServer-&amp;gt;createService(SERVICE_UUID);

  // Create a BLE Characteristic
  pCharacteristic = pService-&amp;gt;createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ   |
                      BLECharacteristic::PROPERTY_WRITE  |
                      BLECharacteristic::PROPERTY_NOTIFY |
                      BLECharacteristic::PROPERTY_INDICATE
                    );

  // https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml
  // Create a BLE Descriptor
  pCharacteristic-&amp;gt;addDescriptor(new BLE2902());

  // Start the service
  pService-&amp;gt;start();

  // Start advertising
  pServer-&amp;gt;getAdvertising()-&amp;gt;start();
  Serial.println(&amp;quot;Waiting a client connection to notify...&amp;quot;);
}

void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイルエラーが出ないで書き込みが出来ればOKです。&lt;/p&gt;

&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;

&lt;p&gt;デバッグには&lt;a href=&#34;https://itunes.apple.com/jp/app/lightblue/id639944780?mt=12&#34;&gt;LightBlue&lt;/a&gt;などのBLEデバッグ用のアプリケーションを利用することをお勧めします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTが起動すると先ほど指定した&lt;strong&gt;NefryBT-n0bisuke&lt;/strong&gt;という名前でBLEデバイスが検出されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SERVICEのUUIDやCHARACTERISTICのUUIDも先ほど指定したものが表示されていると思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これで問題なく、Nefry BTから情報が発信されていることが確認出来ました。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;centralの作成&#34;&gt;Centralの作成&lt;/h2&gt;

&lt;p&gt;次は受信側のCentralを作成していきます。
データの確認だけであれば先ほどのLightBlueなどのアプリで確認でも良いのですが、自分のサービスに組み込む際には何かしらのプログラミング言語でアクセスできた方が都合が良いです。&lt;/p&gt;

&lt;h3 id=&#34;nobleの利用&#34;&gt;nobleの利用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sandeepmistry/noble&#34;&gt;noble&lt;/a&gt;はNode.js向けのBLEライブラリです。MacやWindows、Raspberry PiなどのデバイスをBLEのCentralにすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ble_central
cd ble_central
touch app.js
npm init -y
npm i --save noble
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで準備とnobleのインストールが完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;に以下を記述します。SERVICE_UUIDやCHARACTERISTIC_UUIDは自分で作成したNefry BT側に書き込んだUUIDと同様のものを指定しましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[WIP] Async/Awaitに書き換えたい。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const noble = require(&#39;noble&#39;);
const serviceuuid = `d5875408fa514763a75d7d33cecebc31`;
const charauuid = `a4f01d8ca03743b690501876a8c23584`;

//キャラクタリスティックにアクセスしてデータやりとり
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}


//discovered BLE device
const discovered = (peripheral) =&amp;gt; {
    console.log(`BLE Device Found: ${peripheral.advertisement.localName}(${peripheral.uuid}) RSSI${peripheral.rssi}`);

    if(peripheral.advertisement.localName === &#39;NefryBT-n0bisuke&#39;){
        noble.stopScanning();
        console.log(&#39;device found&#39;);
        console.log(`service discover...`);

        peripheral.connect(error =&amp;gt; {
            if (error) {
                console.log(&amp;quot;connection error:&amp;quot;, error)
            } else {
                console.log(&amp;quot;device connected&amp;quot;);
            }

            peripheral.discoverServices([],(err, services) =&amp;gt; {
                if (error) {
                    console.log(&amp;quot;discover service error&amp;quot;, error)
                }
                console.log(&#39;discover service&#39;);               
                services.forEach(service =&amp;gt; {
                    if(service.uuid === serviceuuid){
                        service.discoverCharacteristics([], (error, charas) =&amp;gt; {
                            console.log(&#39;discover chara&#39;);
                            charas.forEach(chara =&amp;gt; {
                                if(chara.uuid === charauuid){
                                    console.log(&amp;quot;found chara: &amp;quot;, chara.uuid)
                                    accessChara(chara);
                                }
                            });
                        });
                    }
                });
            });
        });
    }
}

//BLE scan start
const scanStart = () =&amp;gt; {
    noble.startScanning();
    noble.on(&#39;discover&#39;, discovered);
}

if(noble.state === &#39;poweredOn&#39;){
    scanStart();
}else{
    noble.on(&#39;stateChange&#39;, scanStart);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実行&#34;&gt;実行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で実行します。この時、先ほどのLightBlueなどのアプリでNefryBTにBLEアクセスしていると上手くいかないのでアプリ側の接続は解除しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/5.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mac側のNode.jsのログはこんな感じで表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BLE Device Found: LED(59aa15c3a3274ed7b11d334b5c0d0900) RSSI-68
BLE Device Found: NefryBT-n0bisuke(d0b77d4611f54380b8b63e6d05765ad6) RSSI-49
device found
service discover...
device connected
discover service
discover chara
found chara:  a4f01d8ca03743b690501876a8c23584
-----Start GATT Access-----
listen notif
{ val: 147 }
{ val: 148 }
・
・
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解説&#34;&gt;解説&lt;/h3&gt;

&lt;p&gt;NefryBT側ではデバイスにアクセスがありCentralとのコネクションが確立すると、&lt;code&gt;変数value&lt;/code&gt;の値をセット(pCharacteristic-&amp;gt;setValue)して送信（pCharacteristic-&amp;gt;notify）し、valueの値をインクリメントします。&lt;/p&gt;

&lt;p&gt;これを2秒ごとに行うので2秒間隔でNefryBTからMacのNode.jsに情報が送信されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
(省略)
・
・
void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js（noble）側では、PERIPHERAL -&amp;gt; SERVICE -&amp;gt; CHARACTERISTICと階層的にアクセスしていき、CHARACTERISTICまでアクセスが出きると、accessChara関数が呼ばれます。&lt;/p&gt;

&lt;p&gt;この中の&lt;code&gt;chara.on(&#39;data&#39;)&lt;/code&gt;の箇所でデータが送られてくるたびにイベントが発火して、データの中身を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
・
(省略)
・
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}
・
・
(省略)
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTでBLEを利用する方法を紹介しました。
Nefry BTでセンサーのデータを取得し、Centralに送信する方法なども応用して作れそうですね。&lt;/p&gt;

&lt;p&gt;これを参考にNefry BTとBLEデバイスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;今回はNefry BTをPeripheralにする実装でしたが、別の機会でCentralにする方法も紹介できればと思っています。&lt;/p&gt;

&lt;p&gt;それでは！&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;今回の実装ですが色々と途中でのハマりが多いかつ、調べてもまだまだESP32のBLE利用をArduinoでやってる事例は少なくけっこう大変でした。この辺の大変だった知見はQiitaなどでまとめらたらと思っています。お疲れ様です笑&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title>
      <link>https://dotstud.io/blog/raspberry-pi-case-making/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong&gt;ラズパイにはまってしまったラズパイ女子です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p&gt;

&lt;p&gt;しかしなかなか可愛いいケースがない……。&lt;strong&gt;ないなら、作ってしまえばいい！！！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p&gt;

&lt;h2 id=&#34;レーザーカッターを使える場所を探そう&#34;&gt;レーザーカッターを使える場所を探そう&lt;/h2&gt;

&lt;p&gt;今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong&gt;工作機械を気軽に利用できるFabスペース&lt;/strong&gt;を利用してみましょう！&lt;/p&gt;

&lt;p&gt;レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p&gt;

&lt;p&gt;何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p&gt;

&lt;h3 id=&#34;レーザーカッターが使える初心者向けオススメfabスペース&#34;&gt;レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3&gt;

&lt;p&gt;初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p&gt;

&lt;h4 id=&#34;fabcafe-https-fabcafe-com-tokyo&#34;&gt;&lt;a href=&#34;https://fabcafe.com/tokyo/&#34;&gt;◆FabCafe&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p&gt;

&lt;h4 id=&#34;iotlab-https-cami-jp-iotlab&#34;&gt;&lt;a href=&#34;https://cami.jp/iotlab/&#34;&gt;◆IoTLab&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p&gt;

&lt;h4 id=&#34;techshop-http-www-techshop-jp&#34;&gt;&lt;a href=&#34;http://www.techshop.jp/&#34;&gt;◆TechShop&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p&gt;

&lt;h2 id=&#34;ケースの形について調べてみよう&#34;&gt;ケースの形について調べてみよう&lt;/h2&gt;

&lt;p&gt;一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/1.png&#34; alt=&#34;&#34; /&gt;
「Raspberry Pi  ケース」を検索
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ケースの形によってはかなり難易度が高そうです……。&lt;/p&gt;

&lt;h3 id=&#34;初心者にも作りやすいケースの形&#34;&gt;初心者にも作りやすいケースの形&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li&gt;
&lt;li&gt;ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/2.png&#34; alt=&#34;&#34; /&gt;
上蓋と下蓋を支柱で支えるタイプのケース　　
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;部材を集めよう&#34;&gt;部材を集めよう&lt;/h2&gt;

&lt;h3 id=&#34;かわいいアクリルで作れば-かわいいケースになる-はず&#34;&gt;かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;かわいいアクリルで作ればかわいいケースになる&lt;/strong&gt;と信じて、素敵なアクリルを用意しましょう。&lt;/p&gt;

&lt;p&gt;アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong&gt;実際に店舗に行ってみるのがオススメ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href=&#34;https://www.miyukiacryl.tokyo/tokyo-acryl&#34;&gt;デザインアクリル専門店 ミユキアクリル&lt;/a&gt;」さんのような&lt;strong&gt;デザインアクリル専門店&lt;/strong&gt;もあるので、興味のある方は覗いてみましょう！&lt;/p&gt;

&lt;p&gt;※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/3.png&#34; alt=&#34;&#34; /&gt;
自分好みのアクリルを選ぼう
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p&gt;

&lt;p&gt;厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p&gt;

&lt;p&gt;好みのアクリルがない場合は、&lt;strong&gt;UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong&gt;という手もあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/4.png&#34; alt=&#34;&#34; /&gt;
UVプリンターでイラストや写真を転写
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p&gt;

&lt;h3 id=&#34;ネジやスペーサーなどのパーツ&#34;&gt;ネジやスペーサーなどのパーツ&lt;/h3&gt;

&lt;p&gt;支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/5.png&#34; alt=&#34;&#34; /&gt;
上：真鍮黒ネジ、シルバーの六角スペーサー の組み合わせ&lt;br /&gt;
下：プラネジ、白のプラスチックのスペーサー&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;必要なパーツ一覧&#34;&gt;必要なパーツ一覧&lt;/h3&gt;

&lt;p&gt;好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li&gt;
&lt;li&gt;ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li&gt;
&lt;li&gt;アクリル板固定・ネジ M3（8mm）8本&lt;/li&gt;
&lt;li&gt;アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li&gt;
&lt;li&gt;アクリル（今回は厚さ3mmのもの）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/parts.png&#34; alt=&#34;&#34; /&gt;
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;h3 id=&#34;step1-型の準備&#34;&gt;step1. 型の準備&lt;/h3&gt;

&lt;p&gt;Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p&gt;

&lt;p&gt;ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href=&#34;https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y&#34;&gt;&lt;strong&gt;こちらのaiデータ&lt;/strong&gt;&lt;/a&gt;をそのまま使うこともできます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/6.png&#34; alt=&#34;&#34; /&gt;
左：下蓋 / 右：上蓋
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラ：幅0.9mm × 高さ28mm&lt;/li&gt;
&lt;li&gt;GPIO：幅55mm × 高さ12mm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/7.png&#34; alt=&#34;&#34; /&gt;
上蓋にカメラとGPIOの部分を追加
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;レーザーカッターには切る順番があり、「&lt;strong&gt;彫刻 → 穴 → 切り落とし&lt;/strong&gt;」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p&gt;

&lt;p&gt;これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p&gt;

&lt;h3 id=&#34;step2-アクリルを裁断&#34;&gt;step2. アクリルを裁断&lt;/h3&gt;

&lt;p&gt;今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step3-組み立てる&#34;&gt;step3. 組み立てる&lt;/h3&gt;

&lt;p&gt;まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/9.png&#34; alt=&#34;&#34; /&gt;
短いスペーサーでラズパイを下蓋に固定
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p&gt;

&lt;h3 id=&#34;完成&#34;&gt;完成&lt;/h3&gt;

&lt;p&gt;自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src=&#34;https://dotstud.io/img/blog/142/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/12.png&#34; alt=&#34;&#34; /&gt;
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p&gt;

&lt;p&gt;日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong&gt;どこに連れて行ってもかわいいと言ってもらえる&lt;/strong&gt;ので作りがいがありました。何より愛着がわきますね〜！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）でMQTTを使ってみよう Subscribe編</title>
      <link>https://dotstud.io/blog/nefry-bt-connect-mqtt/</link>
      <pubDate>Sat, 06 Jan 2018 14:28:04 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-bt-connect-mqtt/</guid>
      
      <description>

&lt;p&gt;あけましておめでとうございます。 代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;Nefry BTを使ってMQTTを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;今回はMQTTでNefry BTに情報を送信してみます。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、ESP32系の他のボードを利用している人の参考にもなると思います。&lt;/p&gt;

&lt;h2 id=&#34;mqttの登場人物&#34;&gt;MQTTの登場人物&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Broker - 通信のサーバー&lt;/li&gt;
&lt;li&gt;Publisher - 情報の送信側&lt;/li&gt;
&lt;li&gt;Subscriber - 情報の受信側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebSocketではサーバーとクライアントだけで双方向通信をしますが、MQTTではサーバーはBrocker、クライアント側が送信者のPublisherと受信者のSubscriberに分かれます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回はNefry BTをSubscriber（受信者）にして、外部からNefry BTに情報を送ってみたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subscriberの作成&#34;&gt;Subscriberの作成&lt;/h2&gt;

&lt;h3 id=&#34;arduino向けのmqttライブラリをインストール&#34;&gt;Arduino向けのMQTTライブラリをインストール&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knolleary/pubsubclient&#34;&gt;knolleary/pubsubclient&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;zipファイルをダウンロードしたら、 &lt;code&gt;スケッチ &amp;gt; ライブラリのインポート &amp;gt; .ZIP形式のライブラリをインストール&lt;/code&gt;からArduino IDEにライブラリをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;ブローカーは&lt;a href=&#34;https://mosquitto.org/&#34;&gt;Mosquitto&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;mosquitto.org&amp;rdquo;の&amp;rdquo;n0bisuke&amp;rdquo;という名前のトピックに情報が送信されたら受信します。&lt;/p&gt;

&lt;p&gt;MQTTはデフォルト1883ポートを利用するので、1883ポートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;

WiFiClient httpsClient;
PubSubClient mqttClient(httpsClient);

#define TOPIC &amp;quot;n0bisuke&amp;quot;
#define QOS 0
#define URL &amp;quot;mosquitto.org&amp;quot;
#define PORT 1883

void setup() {
  mqttClient.setServer(URL, PORT);
  mqttClient.setCallback(callback);
}

void loop() {
  if(!mqttClient.connected()) {
    if (mqttClient.connect(TOPIC)) {
      Serial.println(&amp;quot;Connected.&amp;quot;);    
      mqttClient.subscribe(TOPIC, QOS);
      Serial.println(&amp;quot;Subscribed.&amp;quot;);
    }
    else {
      errorReport();
    }
  }

  mqttClient.loop();
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print(&amp;quot;Message arrived [&amp;quot;);
  Serial.print(topic);
  Serial.print(&amp;quot;] &amp;quot;);
  for (int i = 0; i &amp;lt; length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();
}

void errorReport(){
  Serial.print(&amp;quot;Failed. Error state = &amp;quot;);

  switch (mqttClient.state()) {
    case MQTT_CONNECT_UNAUTHORIZED:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAUTHORIZED&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CREDENTIALS:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CREDENTIALS&amp;quot;);
      break;
    case MQTT_CONNECT_UNAVAILABLE:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAVAILABLE&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CLIENT_ID:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CLIENT_ID&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_PROTOCOL:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_PROTOCOL&amp;quot;);
      break;
    case MQTT_CONNECTED:
      Serial.println(&amp;quot;MQTT_CONNECTED&amp;quot;);
      break;
    case MQTT_DISCONNECTED:
      Serial.println(&amp;quot;MQTT_DISCONNECTED&amp;quot;);
      break;
    case MQTT_CONNECT_FAILED:
      Serial.println(&amp;quot;MQTT_CONNECT_FAILED&amp;quot;);
      break;
    case MQTT_CONNECTION_LOST:
      Serial.println(&amp;quot;MQTT_CONNECTION_LOST&amp;quot;);
      break;
    case MQTT_CONNECTION_TIMEOUT:
      Serial.println(&amp;quot;MQTT_CONNECTION_TIMEOUT&amp;quot;);
      break;
  }

  delay(5000); // Wait 5 seconds before retrying
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publisherの作成&#34;&gt;Publisherの作成&lt;/h2&gt;

&lt;p&gt;情報の送信側であるPublisherは手元のMac Book上のNode.jsで作成しました。&lt;/p&gt;

&lt;p&gt;Node.jsでMQTTを利用する場合は&lt;a href=&#34;https://www.npmjs.com/package/mqtt&#34;&gt;mqtt.js&lt;/a&gt;を利用するのが手頃です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir mqtt-test
cd mqtt-test
npm init -y
npm i --save mqtt
touch publisher.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//publisher.js
&#39;use strict&#39;;

const mqtt = require(&#39;mqtt&#39;);
const client = mqtt.connect(&#39;mqtt://mosquitto.org&#39;);

client.on(&#39;connect&#39;, () =&amp;gt; console.log(&#39;publisher.connected.&#39;));

setInterval(() =&amp;gt; {
    const message = Date.now().toString();
    client.publish(&#39;n0bisuke&#39;, message);
    console.log(&#39;publisher.publish:&#39;, message);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行すると、以下のように時間の情報をパブリッシュ（送信）し始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node publisher.js

publisher.publish: 1515219086876
publisher.publish: 1515219087879
publisher.publish: 1515219088880
publisher.publish: 1515219089882
・
・
・
(省略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;思ってたより簡単に実装出来ました。
これを参考にNefry BTとWebサービスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mosca.io/&#34;&gt;Mosca&lt;/a&gt;などを使うとBrokerも自分で作成することが出来るので試してみると良いかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.jsを始めよう！nodebrewを使って5分で環境構築</title>
      <link>https://dotstud.io/blog/nodejs-install-use-nodebrew/</link>
      <pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/nodejs-install-use-nodebrew/</guid>
      
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;https://qiita.com/advent-calendar/2017/nodejs2&#34;&gt;Node.js Advent Calendar 2017&lt;/a&gt;に参加しています！&lt;/p&gt;

&lt;p&gt;こんにちは、エンジニアのちゃんとくです。「これからNode.jsを始めたい！」という人向けに導入記事をまとめていきたいと思います。まずは環境構築からはじめましょう！&lt;/p&gt;

&lt;p&gt;今回はNode.jsのバージョンを管理できる「&lt;strong&gt;nodebrew&lt;/strong&gt;」を使ったインストール手順を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;普通のダウンロードじゃダメなの&#34;&gt;普通のダウンロードじゃダメなの？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/1.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js公式ページ&lt;/a&gt;にアクセスすると、どーんとダウンロードボタンがありますね。これをクリックすると、表記のバージョンのNode.jsパッケージが降ってきます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;しかし！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node.jsはバージョンアップの頻度が高く、その都度ダウンロードし直すのは大変ですよね。&lt;/p&gt;

&lt;p&gt;プロジェクトによっては古いバージョンを使いたかったり、プロジェクトごとにバージョンを変えたかったりしたいときもあります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;そこで役に立つのがNode.jsのバージョン管理ツールです&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;今回紹介する&lt;strong&gt;nodebrew&lt;/strong&gt;以外にも、世界的に利用者の多い&lt;strong&gt;NVM&lt;/strong&gt;（Node Version Manager）やWindows向けの&lt;strong&gt;nodist&lt;/strong&gt;などがあります。&lt;/p&gt;

&lt;p&gt;今回は日本人コミッタが多く困ったときにも質問しやすいnodebrewでやってみます！&lt;/p&gt;

&lt;h2 id=&#34;nodebrewをインストール&#34;&gt;nodebrewをインストール&lt;/h2&gt;

&lt;p&gt;さっそくnodebrewをインストールしましょう！以下のコマンドを実行します。（&lt;code&gt;$&lt;/code&gt;マークはCLIであることを表しているのでコピペの際は不要です！）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L git.io/nodebrew | perl - setup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完了するとこんなことを言われます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「&lt;code&gt;~/.nodebrew&lt;/code&gt;にインストールしたからPATH通してね！」というようなことを言っています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt;などの設定ファイルに&lt;code&gt;export PATH=$HOME/.nodebrew/current/bin:$PATH&lt;/code&gt;を追加しましょう。&lt;/p&gt;

&lt;p&gt;追記したらターミナルを開き直すか&lt;code&gt;source&lt;/code&gt;コマンドで更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nodebrewコマンドが使えるか確認してみます。&lt;code&gt;command not found&lt;/code&gt;が出なければOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew help
nodebrew 0.9.8

Usage:
…
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nodebrewでnode-jsをインストール&#34;&gt;nodebrewでNode.jsをインストール&lt;/h2&gt;

&lt;p&gt;まずは&lt;code&gt;nodebrew ls-remote&lt;/code&gt;コマンドでダウンロード可能なNode.jsのバージョンを確認してみます。&lt;/p&gt;

&lt;p&gt;Node.jsは偶数のバージョンがLTS（安定板）、奇数のバージョンが最新版となっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew ls-remote
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/3.png&#34; alt=&#34;&#34; /&gt;
実行するとべろーっとバージョンが出てきますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/4.png&#34; alt=&#34;&#34; /&gt;
下の方まで見ると2017年12月15日現在はLTSがv8.9.3、最新がv9.3.0であることがわかりました。（io.jsはNode.jsのForkですが、一旦気にしなくてOK）&lt;/p&gt;

&lt;p&gt;今回は最新版のv9.3.0をインストールしてみます。&lt;code&gt;nodebrew install-binary&lt;/code&gt;コマンドを利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew install-binary v9.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1分くらいでインストールは完了します。（ダメ回線なので、もっと速いかもしれません）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodebrew ls&lt;/code&gt;コマンドで状態を確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew ls
v9.3.0

current: none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用するバージョンの&lt;code&gt;current&lt;/code&gt;がnoneになっているので指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew use v9.3.0
$ node -v
v9.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでNode.jsのインストールは完了です！&lt;/p&gt;

&lt;h2 id=&#34;バージョン切り替え&#34;&gt;バージョン切り替え&lt;/h2&gt;

&lt;p&gt;別のバージョンを使いたくなったら、nodebrewでバージョンを切り替えてみましょう。&lt;/p&gt;

&lt;p&gt;試しにLTSのv8.9.3を使えるようにしてみます。まずはインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew install-binary v8.9.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v8.9.3とv9.3.0が使えるようになりましたが、まだ&lt;code&gt;current&lt;/code&gt;はv9.3.0のままです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew list
v8.9.3
v9.3.0

current: v9.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nodebrew use&lt;/code&gt;でv8.9.3を指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew use v8.9.3
$ nodebrew list
v8.9.3
v9.3.0

current: v8.9.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでバージョンが切り替えられました！listにあるバージョンは再インストールすることなく切り替えられます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ここまで特にむずかしいところなく環境構築できたのではないかと思います！はじめるまでの手軽さもNode.jsの魅力のひとつですよね。&lt;/p&gt;

&lt;p&gt;次回はNode.jsをはじめたばかりの人向けチュートリアルをやってみたいと思います。&lt;/p&gt;

&lt;p&gt;それではまた！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【予測変換】Macで日本語の変換ウィンドウが消えなくなったときの対処法【邪魔】</title>
      <link>https://dotstud.io/blog/mac-nihongo-window-error/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/mac-nihongo-window-error/</guid>
      
      <description>

&lt;p&gt;こんにちは、エンジニア兼ライターのちゃんとくです。日々たくさんのコードや文字を書き続けているわけですが、&lt;strong&gt;突然消えなくなるアレ&lt;/strong&gt;に悩まされています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/137/1.png&#34; alt=&#34;&#34; /&gt;
これ。&lt;/p&gt;

&lt;p&gt;クリックしてもEscapeしてもQuitしても消えなくて本当に邪魔ですよね。&lt;/p&gt;

&lt;p&gt;わりと起こる頻度が高いのでそのたびに再起動するのも面倒です。&lt;/p&gt;

&lt;h2 id=&#34;日本語入力のプロセスをキルする&#34;&gt;日本語入力のプロセスをキルする&lt;/h2&gt;

&lt;p&gt;タイトルが全てですが、日本語入力のプロセスを終了すると消すことができます。&lt;/p&gt;

&lt;p&gt;［アクテビティモニタ］を開いて［日本語入力］を探します。
&lt;img src=&#34;https://dotstud.io/img/blog/137/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ダブルクリックするとウィンドウが開くので［終了］をクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/137/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;平和がおとずれましたね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Adventやら原稿やらガリガリ書いているときに邪魔でしょうがないので紹介してみました。&lt;/p&gt;

&lt;p&gt;El Capitanからアップデートしたらなおるのかなぁ。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.jsでGoogle SpreadSheetsを操作してみよう。【GAS不使用】</title>
      <link>https://dotstud.io/blog/google-spreadsheets-from-nodejs/</link>
      <pubDate>Mon, 04 Dec 2017 13:14:41 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/google-spreadsheets-from-nodejs/</guid>
      
      <description>

&lt;p&gt;こんにちは、代表ののびすけです。&lt;/p&gt;

&lt;p&gt;この記事は&lt;a href=&#34;https://qiita.com/advent-calendar/2017/nodejs&#34;&gt;Node.jsアドベントカレンダー2017&lt;/a&gt;の記事になります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://developers.google.com/apps-script/&#34;&gt;GAS&lt;/a&gt;じゃなくてNode.jsから直接スプレッドシートにアクセスしたい！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;そう思って調べると&lt;a href=&#34;https://developers.google.com/sheets/api/quickstart/nodejs&#34;&gt;Node.js Quickstart | Sheets API | Google Developers&lt;/a&gt;が出て来ますが、JS記述も古いし英語なので少しとっつきにくいです。&lt;/p&gt;

&lt;p&gt;ということでちょっと試して記録残そうと思います。&lt;/p&gt;

&lt;h2 id=&#34;google-sheets-api&#34;&gt;Google Sheets API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/sheets/guides/concepts?hl=ja&#34;&gt;Google Sheets API&lt;/a&gt;はスプレッドシートにアクセスできるようになるAPIです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/81dd3461cd263ea7e4d63f06fef54747.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Google Sheets API を使用すると、スプレッドシートの要素を読み取って変更できます。 スプレッドシートは多くの設定を備えており、美しく機能的なシートを作成することができます。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;普段慣れている言語でスプレッドシートにアクセス出来まるので、簡単な操作であれば、GASを使う必要もないです。&lt;/p&gt;

&lt;p&gt;今回のサンプルは&lt;a href=&#34;https://github.com/n0bisuke/google-spread-sheet-node.js-sample&#34;&gt;こちら&lt;/a&gt;に置いておきます。&lt;/p&gt;

&lt;h3 id=&#34;環境&#34;&gt;環境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考までに今回の僕の環境です。&lt;/p&gt;

&lt;p&gt;では実際に作っていきます。&lt;/p&gt;

&lt;h2 id=&#34;1-google-sheets-apiを使えるようにする&#34;&gt;1. Google Sheets APIを使えるようにする&lt;/h2&gt;

&lt;p&gt;ちなみに2017年12月時点でのウィザードです。こういうのはアップデートによって画面遷移変わるので適宜読み替えてください。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Use this wizard to create or select a project in the Google Developers Console and automatically turn on the API. Click Continue, then Go to credentials.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://console.developers.google.com/start/api?id=sheets.googleapis.com&#34;&gt;こちらのリンク&lt;/a&gt;からディベロッパーコンソールにいき、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/31e8011951d1552b8f7126eb459da474.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;新機能のお知らせ、パフォーマンスに関するアドバイス、フィードバック調査、特典に関する最新情報をメールで受け取ります。&lt;/code&gt;の質問はいいえでもたぶん大丈夫です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/60c5bf6a1e772473dc9fc6d4d7526077.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;認証情報に進む&lt;/code&gt;を選択&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/848f8f79460aac991b46956111f0da07.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この画面が出ますが、&lt;code&gt;キャンセル&lt;/code&gt;を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/e827d6ab-d728-1016-d22a-76cef4e4972e.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.00.17.png&#34; title=&#34;スクリーンショット 2017-12-03 21.00.17.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;OAuth同意画面&lt;/code&gt;のタブを選択し、メールアドレスを確認し、&lt;code&gt;ユーザーに表示するサービス名&lt;/code&gt;を入力します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;保存&lt;/code&gt;を選択しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/1ca3a2d5-b639-bb6c-9508-225d162c96ff.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.01.07.png&#34; title=&#34;スクリーンショット 2017-12-03 21.01.07.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;次に、&lt;code&gt;認証情報&lt;/code&gt;のタブを選択し、 &lt;code&gt;認証情報を作成&lt;/code&gt; -&amp;gt; &lt;code&gt;OAuthクライアントID&lt;/code&gt;を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3d5b6da9cf3086b11c728cdc31307268.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;その他&lt;/code&gt;を選択し、任意の名前をつけて&lt;code&gt;作成&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/a8a25dd3-a194-d4a3-ac57-909f8d7712e0.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.06.47.png&#34; title=&#34;スクリーンショット 2017-12-03 21.06.47.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;OK&lt;/code&gt;で進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/93c1e777-682e-434e-444d-a3aa8659bd54.png&#34; alt=&#34;スクリーンショット 2017-12-03 21.07.25.png&#34; title=&#34;スクリーンショット 2017-12-03 21.07.25.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;client_secret_xxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com.json&lt;/code&gt;のようなファイルがダウンロードされます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これを&lt;code&gt;client_secret.json&lt;/code&gt;にリネームしましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-node-jsプロジェクトの準備&#34;&gt;2. Node.jsプロジェクトの準備&lt;/h2&gt;

&lt;p&gt;任意のディレクトリを作成して移動します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sheetstest&lt;/code&gt;としました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir sheetstest
cd sheetstest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;npm init -y&lt;/code&gt;で&lt;code&gt;package.json&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm init -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このディレクトリに先ほどの&lt;code&gt;client_secret.json&lt;/code&gt;を移動させます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls

package.json client_secret.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3d796ef0005ef28b914a83517772c65e.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;こんな感じです。&lt;/p&gt;

&lt;p&gt;利用するモジュールを追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i googleapis google-auth-library --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-トークンの作成-保存-最初だけ&#34;&gt;3. トークンの作成&amp;amp;保存 (最初だけ)&lt;/h2&gt;

&lt;p&gt;本家とは少し違うやり方です。&lt;/p&gt;

&lt;p&gt;本家のコードだと&lt;code&gt;トークンの作成&amp;amp;保存&lt;/code&gt;作業と実際のAPI呼び出しが一緒になったコードですが&lt;code&gt;トークンの作成&amp;amp;保存&lt;/code&gt;は最初のみ行えば良いので手順を分けて紹介します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getAndStoreToken.js&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//getAndStoreToken.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
const {promisify} = require(&#39;util&#39;);

const google = require(&#39;googleapis&#39;);
const googleAuth = require(&#39;google-auth-library&#39;);

//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);

const SCOPES = [&#39;https://www.googleapis.com/auth/spreadsheets.readonly&#39;];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+&#39;/sheets.googleapis.com-nodejs-quickstart.json&#39;;

const main = async () =&amp;gt; {
    const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
    const credentials = JSON.parse(content); //クレデンシャル
    //認証
    const clientSecret = credentials.installed.client_secret;
    const clientId = credentials.installed.client_id;
    const redirectUrl = credentials.installed.redirect_uris[0];
    const auth = new googleAuth();
    const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);

    //get new token
    const authUrl = oauth2Client.generateAuthUrl({
        access_type: &#39;offline&#39;,
        scope: SCOPES
    });

    console.log(&#39;Authorize this app by visiting this url: &#39;, authUrl);

    rl.question(&#39;Enter the code from that page here: &#39;, (code) =&amp;gt; {
        rl.close();

        oauth2Client.getToken(code, async (err, token) =&amp;gt; {
            if (err) {
                console.log(&#39;Error while trying to retrieve access token&#39;, err);
                return;
            }

            oauth2Client.credentials = token;

            try {
                fs.mkdirSync(TOKEN_DIR);
            } catch (err) {
                if (err.code != &#39;EEXIST&#39;) throw err;
            }

            await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
            console.log(&#39;Token stored to &#39; + TOKEN_PATH);
        });
    });
};

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このプログラムを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node getAndStoreToken.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://accounts.google.com/~&lt;/code&gt;で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.52.54.png&#34; title=&#34;スクリーンショット 2017-12-04 11.52.54.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アカウント選択画面になります。
複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/18729d60-e4a6-8996-9519-f9f4750ae1f4.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.53.02.png&#34; title=&#34;スクリーンショット 2017-12-04 11.53.02.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;許可&lt;/code&gt;で進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.53.09.png&#34; title=&#34;スクリーンショット 2017-12-04 11.53.09.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証用のコードが発行されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/fd612d7c-0b45-3d09-64ab-c1e02315fe81.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.53.27.png&#34; title=&#34;スクリーンショット 2017-12-04 11.53.27.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これをコピーしてターミナルに貼り付けてエンターキーで進みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Token stored to /Users/n0bisuke/dotstudio/playground/sheetstest/sheets.googleapis.com-nodejs-quickstart.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などと表示されてjsonファイルが保存されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/830452dc-ad36-83ef-8cf8-8c80bc9637dd.png&#34; alt=&#34;スクリーンショット 2017-12-04 11.57.50.png&#34; title=&#34;スクリーンショット 2017-12-04 11.57.50.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sheets.googleapis.com-nodejs-quickstart.json&lt;/code&gt;がフォルダ内に確認できればOKです。&lt;/p&gt;

&lt;h2 id=&#34;4-いよいよシートにアクセス&#34;&gt;4. いよいよシートにアクセス&lt;/h2&gt;

&lt;p&gt;さて最後の手順です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getSheetsData.js&lt;/code&gt;を作成しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//getSheetsData.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const {promisify} = require(&#39;util&#39;);
const google = require(&#39;googleapis&#39;);
const googleAuth = require(&#39;google-auth-library&#39;);
const sheets = google.sheets(&#39;v4&#39;);

//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const ssValuesGetAsync = promisify(sheets.spreadsheets.values.get);

const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + &#39;/sheets.googleapis.com-nodejs-quickstart.json&#39;;

const main = async () =&amp;gt; {
    //クレデンシャル情報の取得
    const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
    const credentials = JSON.parse(content); //クレデンシャル

    //認証
    const clientSecret = credentials.installed.client_secret;
    const clientId = credentials.installed.client_id;
    const redirectUrl = credentials.installed.redirect_uris[0];
    const auth = new googleAuth();
    const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
    const token = await readFileAsync(TOKEN_PATH);
    oauth2Client.credentials = JSON.parse(token);

    //API経由でシートにアクセス
    const apiOptions = {
        auth: oauth2Client,
        spreadsheetId: &#39;1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms&#39;,
        range: &#39;Class Data!A2:E&#39;,
    };
    const response = await ssValuesGetAsync(apiOptions);

    //結果を表示
    console.log(response);
};

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node getSheetsData.js

{ range: &#39;\&#39;Class Data\&#39;!A2:E101&#39;,
  majorDimension: &#39;ROWS&#39;,
  values:
   [ [ &#39;Alexandra&#39;, &#39;Female&#39;, &#39;4. Senior&#39;, &#39;CA&#39;, &#39;English&#39; ],
     [ &#39;Andrew&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;SD&#39;, &#39;Math&#39; ],
     [ &#39;Anna&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;NC&#39;, &#39;English&#39; ],
     [ &#39;Becky&#39;, &#39;Female&#39;, &#39;2. Sophomore&#39;, &#39;SD&#39;, &#39;Art&#39; ],
     [ &#39;Benjamin&#39;, &#39;Male&#39;, &#39;4. Senior&#39;, &#39;WI&#39;, &#39;English&#39; ],
     [ &#39;Carl&#39;, &#39;Male&#39;, &#39;3. Junior&#39;, &#39;MD&#39;, &#39;Art&#39; ],
     [ &#39;Carrie&#39;, &#39;Female&#39;, &#39;3. Junior&#39;, &#39;NE&#39;, &#39;English&#39; ],
     [ &#39;Dorothy&#39;, &#39;Female&#39;, &#39;4. Senior&#39;, &#39;MD&#39;, &#39;Math&#39; ],
     [ &#39;Dylan&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;MA&#39;, &#39;Math&#39; ],
     [ &#39;Edward&#39;, &#39;Male&#39;, &#39;3. Junior&#39;, &#39;FL&#39;, &#39;English&#39; ],
     [ &#39;Ellen&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;WI&#39;, &#39;Physics&#39; ],
     [ &#39;Fiona&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;MA&#39;, &#39;Art&#39; ],
     [ &#39;John&#39;, &#39;Male&#39;, &#39;3. Junior&#39;, &#39;CA&#39;, &#39;Physics&#39; ],
     [ &#39;Jonathan&#39;, &#39;Male&#39;, &#39;2. Sophomore&#39;, &#39;SC&#39;, &#39;Math&#39; ],
     [ &#39;Joseph&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;AK&#39;, &#39;English&#39; ],
     [ &#39;Josephine&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;NY&#39;, &#39;Math&#39; ],
     [ &#39;Karen&#39;, &#39;Female&#39;, &#39;2. Sophomore&#39;, &#39;NH&#39;, &#39;English&#39; ],
     [ &#39;Kevin&#39;, &#39;Male&#39;, &#39;2. Sophomore&#39;, &#39;NE&#39;, &#39;Physics&#39; ],
     [ &#39;Lisa&#39;, &#39;Female&#39;, &#39;3. Junior&#39;, &#39;SC&#39;, &#39;Art&#39; ],
     [ &#39;Mary&#39;, &#39;Female&#39;, &#39;2. Sophomore&#39;, &#39;AK&#39;, &#39;Physics&#39; ],
     [ &#39;Maureen&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;CA&#39;, &#39;Physics&#39; ],
     [ &#39;Nick&#39;, &#39;Male&#39;, &#39;4. Senior&#39;, &#39;NY&#39;, &#39;Art&#39; ],
     [ &#39;Olivia&#39;, &#39;Female&#39;, &#39;4. Senior&#39;, &#39;NC&#39;, &#39;Physics&#39; ],
     [ &#39;Pamela&#39;, &#39;Female&#39;, &#39;3. Junior&#39;, &#39;RI&#39;, &#39;Math&#39; ],
     [ &#39;Patrick&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;NY&#39;, &#39;Art&#39; ],
     [ &#39;Robert&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;CA&#39;, &#39;English&#39; ],
     [ &#39;Sean&#39;, &#39;Male&#39;, &#39;1. Freshman&#39;, &#39;NH&#39;, &#39;Physics&#39; ],
     [ &#39;Stacy&#39;, &#39;Female&#39;, &#39;1. Freshman&#39;, &#39;NY&#39;, &#39;Math&#39; ],
     [ &#39;Thomas&#39;, &#39;Male&#39;, &#39;2. Sophomore&#39;, &#39;RI&#39;, &#39;Art&#39; ],
     [ &#39;Will&#39;, &#39;Male&#39;, &#39;4. Senior&#39;, &#39;FL&#39;, &#39;Math&#39; ] ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このサンプルでは&lt;a href=&#34;https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit#gid=0&#34;&gt;こちらのワークブック&lt;/a&gt;へアクセスして情報を取得しています。&lt;/p&gt;

&lt;p&gt;ちなみに用語的には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ワークブック＝Googleスプレッドシートの１ファイル&lt;/li&gt;
&lt;li&gt;シート＝ワークブック内のタブ、シート&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というニュアンスです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//省略

    const apiOptions = {
        auth: oauth2Client,
        spreadsheetId: &#39;1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms&#39;,
        range: &#39;Class Data!A2:E&#39;,
    };

//省略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほかのワークブックにアクセスする場合は&lt;code&gt;https://docs.google.com/spreadsheets/d/&lt;/code&gt;の後に続くIDを&lt;code&gt;spreadsheetId&lt;/code&gt;に指定して実行しましょう。&lt;code&gt;range&lt;/code&gt;は&lt;code&gt;シート名:取得する範囲&lt;/code&gt;という形式で指定して、指定したシートの指定した範囲からセルの情報を取得します。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;これで次回以降は4番目の手順だけでスプレッドシートにアクセスできます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;client_secret.json&lt;/code&gt;や&lt;code&gt;sheets.googleapis.com-nodejs-quickstart.json&lt;/code&gt;をコピーしてサーバー設置しておけば自動更新する仕組みなども作れます。&lt;/p&gt;

&lt;p&gt;スプレッドシートは色々な場面で利用されているツールなので是非システム連携などに活用してみて下さい。&lt;/p&gt;

&lt;p&gt;応用としてはこちらの内容で使っています。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://qiita.com/n0bisuke/items/3313a64c56317932919e&#34;&gt;勉強会( #IoTLT )の登壇者管理でHeadless Chromeを利用している話&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;それでは！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Maker Faire ShenZhen2017】アキバ電気街の30倍！？世界最大の電脳都市”深セン＠中国”に行ってきた！</title>
      <link>https://dotstud.io/blog/maker-faire-shenzhen-report2/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/maker-faire-shenzhen-report2/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioモノづくり担当・うこです。&lt;/p&gt;

&lt;p&gt;日本は秋も終わりだんだんと寒くなってきつつありますが、中国南部・広東省深セン市はまだまだ暑いです。そんな深セン市で11月10日〜12日の3日間、モノづくりの祭典「&lt;strong&gt;Maker Faire Shenzhen&lt;/strong&gt;」が開催され、dotstudioのメンバーで偵察に行ってきましたのでその模様をお伝えします。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/134/33.png&#34; alt=&#34;&#34; /&gt;
至るところにこのパンダが居た
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;maker-faire-shenzhen-mfsz-について&#34;&gt;Maker Faire Shenzhen(MFSZ) について&lt;/h2&gt;

&lt;p&gt;世界一の電気街を擁するとされる街・中国広東省深セン市で行われる、非常に規模の大きいモノづくりの祭典です。
dotstudioでは過去にも出展したことがあり過去にも記事をいくつか書いておりますので、詳しくはそちらも参照してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/maker-faire-shenzhen-2016/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/link1.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://dotstud.io/blog/maker-faire-shenzhen-report/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/link2.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;深センまでの道のり&#34;&gt;深センまでの道のり&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/1.png&#34; alt=&#34;&#34; /&gt;
今回はジェットスター航空で成田空港〜香港国際空港を移動し、さらに機場快線（エアポートエクスプレス）と香港MRTで羅湖駅を経由して深セン市までアクセスしました。香港に入国するとすぐにエアポートエクスプレスのカウンターがあり、クレジットカードで往復に使えるパスを購入できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/2.png&#34; alt=&#34;&#34; /&gt;
香港区域内で観光をしない場合は、空港からバスで直接上水駅まで行き1駅だけMTRに乗り国境を目指すか、香港に入境せずフェリーで深セン側の港に移動する方法もあります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/4.png&#34; alt=&#34;&#34; /&gt;
せっかくなので香港の中心部を経由してきました。ここはまだ、日本と同じで車道が左側通行なので違和感がありませんね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/5.png&#34; alt=&#34;&#34; /&gt;
羅湖駅まで移動します。ここは禁区と呼ばれる緩衝地帯の中のため駅の外には出ることができません。「↑深セン」と書かれた看板があり、人の流れに乗って進んでゆくと香港を出境することになります。さらにそのまま100mほどある河の上にかかる通路を通り、中国本土に入国します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/6.png&#34; alt=&#34;&#34; /&gt;
中国側のイミグレーションは、中国国内で最大のものとあって建物はとても立派でした。旅行客のほとんどは中国人のようです。ホテルやタクシーの客引きのしつこさが尋常ではないです。今回は、ここから徒歩5分ほどの好立地のホテルに宿泊しました。&lt;/p&gt;

&lt;h2 id=&#34;会場は大学のキャンパス&#34;&gt;会場は大学のキャンパス&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/7.png&#34; alt=&#34;&#34; /&gt;
今年のMFSZ会場となったのは「深セン職業技術学院」。香港国境の羅湖駅からは地下鉄で1時間ほどかかります。とても大きくて綺麗なキャンパスでした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/8.png&#34; alt=&#34;&#34; /&gt;
日本のMaker Faireと違い、屋外に1つ1つが巨大なオブジェをかなりダイナミックに配置しているのがとても印象的でした。&lt;/p&gt;

&lt;h2 id=&#34;展示物紹介&#34;&gt;展示物紹介&lt;/h2&gt;

&lt;h3 id=&#34;さすが中国-編&#34;&gt;さすが中国！編&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/9.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/134/10.png&#34; alt=&#34;&#34; /&gt;
くまモン（のパチモン）です。やたら腕が細長かったです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/11.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/134/12.png&#34; alt=&#34;&#34; /&gt;
筋電でドローンなどを制御できる腕輪です。かなり面白かったので購入しようとしたのですが、現金が足りず……。しかしここは中国、&lt;strong&gt;田舎の屋台ですらも電子マネーが使える国&lt;/strong&gt;です。WechatPayでなんとか購入することができました。&lt;/p&gt;

&lt;p&gt;ちなみに日本人がWechatPayを使うためには、「知人から送金してもらいPayアカウントを開設」し、「チャージ」する必要があります。「チャージ」は、本来は中国国内の銀行口座が必要ですが、国内の空港ででも日本円で可能なようです。&lt;/p&gt;

&lt;p&gt;参考 : &lt;a href=&#34;http://japanese.engadget.com/2017/07/27/wechat-pay/&#34;&gt;中国旅行の新定番！ ポケットチェンジでWeChat Payにチャージする：旅人目線のデジタルレポ 中山智 - Engadget 日本版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ゲーム編&#34;&gt;ゲーム編&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/13.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/134/14.png&#34; alt=&#34;&#34; /&gt;
RaspberryPiを使った超小型のスーファミのようなもの。レスポンスもよく、普通に遊べました。名作はひととおり揃っているようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/15.png&#34; alt=&#34;&#34; /&gt;
縁日で子供達が遊んでそうなおもちゃを作ったのは韓国のメイカーさん。スイッチ類が付いていてゴールしたら光ったりするそうですが、ちょうど修理中とのことでした。メイカーあるあるです。&lt;/p&gt;

&lt;h3 id=&#34;教育ツール編&#34;&gt;教育ツール編&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/16.png&#34; alt=&#34;&#34; /&gt;
PCメーカー・acer製の教育用ツールです。PCやタブレットから、Arduinoとそれに接続されたセンサ群をスクラッチでプログラミングできるようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/17.png&#34; alt=&#34;&#34; /&gt;
IoT Brickという、ブロックパーツをつなげて回路を作り、コントローラで制御ができるプロダクトです。すこし昔の日本にもあった、電子ブロックのようなものでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/18.png&#34; alt=&#34;&#34; /&gt;
天津市の企業であるYwRobot社のArduino互換シールドです。ケーブルが一般的によく使用されているもので代替ができて便利で、機能性の高いユニークな基板がたくさん用意されていました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/19.png&#34; alt=&#34;&#34; /&gt;
弊社でも取り扱いをしている、上海SeeedStudio社のプロダクトです。Grove Zeroなどの新製品が展示・販売されていました。&lt;/p&gt;

&lt;h3 id=&#34;デザイン編&#34;&gt;デザイン編&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/20.png&#34; alt=&#34;&#34; /&gt;
眼球盦子という、こちらを見てくる目玉です。スマホと接続するとカメラが顔を認識し、顔のある方向に目玉がクリクリと動きます。買い換えたあとで余ってしまっているスマホを、インタラクティブな置物に変身させてくれそうです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/21.png&#34; alt=&#34;&#34; /&gt;
ボルトやらチェーンやらの無骨なパーツで構成されたオブジェが展示されていました。どちらかというと、美大生の作品のような印象です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/22.png&#34; alt=&#34;&#34; /&gt;
レーザーでカットされた木材でできた箱ですが、模様をずらして絵柄を合わせないと開くことができないようになっています。日本にも寄木細工の秘密箱がありますが、それの現代メイカー版といったところでしょうか。&lt;/p&gt;

&lt;h3 id=&#34;パワーを感じる編&#34;&gt;パワーを感じる編&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/23.png&#34; alt=&#34;&#34; /&gt;
水上歩行を可能にする靴、いわゆる「忍者の水蜘蛛」です。後ろにはディスプレイがあって実際に水上を歩いている動画が流れていましたが、音と水しぶきだけやたらすごかったです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/24.png&#34; alt=&#34;&#34; /&gt;
Groveのタッチセンサがついていて、うっかり触れると赤い星がキラリと光ります。&lt;/p&gt;

&lt;h3 id=&#34;その他編&#34;&gt;その他編&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/25.png&#34; alt=&#34;&#34; /&gt;
女の子が10人ほど、ライブコーディングならぬライブソーイング？で、目の前でミシンを使って作品を作り出していました。意外にも、出展者も来場者も女の子の割合が比較的高めな印象でした。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/26.png&#34; alt=&#34;&#34; /&gt;
一般の出展者とは別に、各地の大学からきた学生サークルのブースばかりのエリアがありました。日本の理系大学の学園祭のような雰囲気ですが、ほとんど出払っていて人気があまりありません。どこかのブースではさりげなくただのガンプラとかも置いてあった気がします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/27.png&#34; alt=&#34;&#34; /&gt;
なんと食べ物の屋台もたくさん出ていました！無難に美味しかったです。日本人からすると物価が安いのでほぼ食べ放題ですね。&lt;/p&gt;

&lt;h2 id=&#34;電気街にも行ってきました&#34;&gt;電気街にも行ってきました&lt;/h2&gt;

&lt;p&gt;電子機器産業は深セン市全体で盛んではありますが、小売も卸売もどちらも行う業者が多数入り混じって一大繁華街を形成しているのが、深セン市中心部の華強路です。せっかくなので店舗を巡ってみました！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/28.png&#34; alt=&#34;&#34; /&gt;
去年まで行われていた大規模な工事が完了していて、とても綺麗な街並みでした。路上に落ちているゴミはほとんどなく、治安もとても良いです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/29.png&#34; alt=&#34;&#34; /&gt;
すぐ近くのお店に入ってみると、ケーブルやらコンセントやらがずらり。こんな調子のお店が百店舗近く詰まったビルがいくつも並んでいます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/30.png&#34; alt=&#34;&#34; /&gt;
路上の仮設テントで、VRを利用したアトラクションゲームが楽しめます。このテントの前では人の胴体ぐらいの大きさの飛行機のラジコンが通りの上空を猛スピードで飛び回っていました。日本では絶対にできませんね……。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/31.png&#34; alt=&#34;&#34; /&gt;
DHLの集荷所のようです。秋葉原の路上で売られている製品も、ここから旅立っていくものはおそらく少なくないはずです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/134/32.png&#34; alt=&#34;&#34; /&gt;
最近話題の犬型ロボットだって、安く、早く、手に入ります。そう、深センならね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;深センのMakerFaireは去年に引き続き2回目の来場でしたが、今年は少し規模が小さめになっており、ビジネス向け製品よりもデザイン寄りの作品がかなり多く出展されている印象でした。深センでは土地柄、新たなプロダクトを求めて来場するバイヤーも多く来場するそうですが、今回は会場が学校だったことが関係しているのかもしれません。&lt;/p&gt;

&lt;p&gt;また、日本人をはじめとする海外メイカー勢も多く見受けられました。中国って少し行きづらそうなイメージがありますが、実際に行ってみると&lt;strong&gt;想像以上に治安がよく、渡航費・滞在費もあまりかからず、どの国からでも意外と参加しやすい&lt;/strong&gt;のかもしれません。特に深センは世界的な国際港である香港に隣接していることもあり、電子工業が加速的に発展していった街でもあります。
ものづくりが好きだけど、まだ中国深センに行ったことがないという方も、この記事でご興味を持たれたらぜひ渡航してみてはいかがでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/134/34.png&#34; alt=&#34;&#34; /&gt;
現地に残ってお見送りする僕と知らないおじさん&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>オフィス移転したらインターホンがなかったのでRaspbeerry Piでカメラ付きインターホン作ってみた</title>
      <link>https://dotstud.io/blog/office-new-door-notification/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/office-new-door-notification/</guid>
      
      <description>

&lt;p&gt;こんにちは、dotstudioモノづくり担当・うこです。&lt;/p&gt;

&lt;p&gt;dotstudioは&lt;a href=&#34;https://dotstud.io/blog/office-relocation-for-akihabara/&#34;&gt;&lt;strong&gt;めでたく新オフィスに移転したのですが&lt;/strong&gt;&lt;/a&gt;、インターホンがついておらず不便なんですよね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/10.png&#34; alt=&#34;&#34; /&gt;
代表・のびすけ「&lt;strong&gt;うこ先生、これRaspberry Piでインターホン作れない？&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/1.png&#34; alt=&#34;&#34; /&gt;
僕「&lt;strong&gt;秒でいけます&lt;/strong&gt;」&lt;/p&gt;

&lt;p&gt;ということで作ってみました！&lt;/p&gt;

&lt;h2 id=&#34;全体の構成&#34;&gt;全体の構成&lt;/h2&gt;

&lt;p&gt;今回は&lt;strong&gt;ボタンを押したら室内のスピーカに音がなる機能&lt;/strong&gt;に加えて、&lt;strong&gt;押した人の姿が見えるカメラ機能&lt;/strong&gt;も搭載してみました。&lt;/p&gt;

&lt;p&gt;全体の構成はこんな感じです。
&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/116011/a7707b67-176f-8dc6-cf32-8323a56e860c.png&#34; alt=&#34;いんたーほん.png&#34; title=&#34;いんたーほん.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Raspberry Pi 3（以下ラズパイ）をベースにして、Grove接続されたタッチセンサに触れると室内のBluetoothスピーカー（今回はBASE EGG）から音が流れる仕組みを作ります。&lt;/p&gt;

&lt;p&gt;さらに、ラズパイカメラをドアの外に出して、外の様子がオフィス内のモニタから見られるようにします。&lt;/p&gt;

&lt;h3 id=&#34;使ったもの&#34;&gt;使ったもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3&lt;/li&gt;
&lt;li&gt;Raspberry Pi カメラモジュール&lt;/li&gt;
&lt;li&gt;Grove タッチセンサ&lt;/li&gt;
&lt;li&gt;Bluetoothオーディオトランスミッタ&lt;/li&gt;
&lt;li&gt;Bluetoothスピーカー（今回はBASS EGG）&lt;/li&gt;
&lt;li&gt;スピーカー（100円）&lt;/li&gt;
&lt;li&gt;オーディオ分岐プラグ（100円）&lt;/li&gt;
&lt;li&gt;マグネット付きプラスチックケース（100円）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;呼び鈴の製作&#34;&gt;呼び鈴の製作&lt;/h2&gt;

&lt;h3 id=&#34;ハードウェア部分&#34;&gt;ハードウェア部分&lt;/h3&gt;

&lt;p&gt;まずはじめに、&lt;strong&gt;来客者がボタンを押すと室内で音が鳴って訪問を知らせるようにする機能&lt;/strong&gt;を作ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/12.png&#34; alt=&#34;&#34; /&gt;
ラズパイはマグネット付きのプラスチックケースに入れて、金属製のドアの内側に貼り付けます。ケースはケーブルが引き出せるように適宜加工します。&lt;/p&gt;

&lt;p&gt;次にGroveタッチセンサですが、そのままだとラズパイに接続できないためジャンパワイヤを3本用意します。接続するピンは以下のとおりです。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;タッチセンサのピン&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ラズパイGPIO&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;VCC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3.3V&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;GND&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ground&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;NC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SIG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ラズパイGPIOのピン番号と位置については、以下の公式ページにある2番目の図を参照してください。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.raspberrypi.org/documentation/usage/gpio-plus-and-raspi2/&#34;&gt;GPIO: MODELS A+, B+, RASPBERRY PI 2 B AND RASPBERRY PI 3 B&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;次に、100円程度で売られているオーディオ出力分岐器をラズパイのオーディオ出力に接続し、さらにBluetoothのオーディオトランスミッタと小型のスピーカーに接続します。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/133/11.png&#34; alt=&#34;&#34; /&gt;
実証の結果、「押した人にも音が鳴ったことがわかる」ことが必要とわかった
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;オーディオトランスミッタは室内に来客を知らせるスピーカーを鳴らす用、小型スピーカーはドアの外に出して来客者に「呼び鈴が鳴った」ことを知らせる用です。USB接続のアンプ付きスピーカーなどで大きな音が出せるのならそれで代用することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/5.png&#34; alt=&#34;&#34; /&gt;
最後に電源を近くのコンセントからUSBアダプタ経由で接続してハードウェア部分は完了です！&lt;/p&gt;

&lt;h3 id=&#34;ソフトウェア部分&#34;&gt;ソフトウェア部分&lt;/h3&gt;

&lt;p&gt;まず、適当なインターフォンの音となるmp3を用意しましょう。簡単なピンポン音でも、ネタのような効果音でもいいです。dotstudioでは、「ファミマ入店音」が好評だったため採用しました。&lt;/p&gt;

&lt;p&gt;mp3が用意できたら、&lt;code&gt;/home/pi&lt;/code&gt;などのディレクトリに&lt;code&gt;sounds&lt;/code&gt;というフォルダを作ってその中にmp3を入れましょう。&lt;/p&gt;

&lt;p&gt;次に、&lt;code&gt;sudo apt-get install mpg321&lt;/code&gt;を実行し、サウンド再生用のソフトウェア「mpg321」をインストールします。&lt;code&gt;mpg321 sounds/サウンド.mp3&lt;/code&gt;などと実行して、スピーカーから音が出ていればOKです。もしここで音が小さい場合は、&lt;code&gt;alsamixer&lt;/code&gt;コマンドを実行すると音量調整ができますので、矢印キーで大きくしておきます。&lt;/p&gt;

&lt;p&gt;音の再生が確認できたら、以下のPythonプログラムを&lt;code&gt;sounds&lt;/code&gt;ディレクトリと同じ場所に保存して実行します。タッチセンサを触ると同時に、音が鳴ってターミナル上に&amp;rsquo;Ping-pon!&amp;lsquo;と表示されれば成功です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-/home/pi/interphone.py&#34;&gt;#!/usr/bin/python

import RPi.GPIO as GPIO
import glob
import subprocess
from time import sleep
from random import shuffle

GPIO.setmode(GPIO.BCM)
GPIO.setup(24, GPIO.IN)

# mp3が保存されているディレクトリは適宜変更してください
soundlist = glob.glob(&amp;quot;./sounds/*.mp3&amp;quot;)

while True:
    if GPIO.input(24) == GPIO.HIGH:
        shuffle(soundlist)
        print(&#39;Ping-pon!&#39;)
        subprocess.call(&amp;quot;mpg321 -q &amp;quot;+soundlist[0], shell=True)
    else:
        sleep(0.01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、再起動しても動くように、&lt;code&gt;/etc/rc.local&lt;/code&gt;ファイルの末尾に&lt;code&gt;/usr/bin/python /home/pi/interphone.py &amp;amp;&lt;/code&gt;と追記しておきましょう。
ちなみにですが、上記のコードでは&lt;code&gt;sounds&lt;/code&gt;ディレクトリ内に複数のmp3が入っているとランダムで再生されるような仕組みにしています。&lt;/p&gt;

&lt;h2 id=&#34;監視カメラ部分の製作&#34;&gt;監視カメラ部分の製作&lt;/h2&gt;

&lt;p&gt;監視カメラはラズパイ専用カメラを使用します。接続はとても簡単で、HDMI端子とオーディオ端子の間にある細長い端子にケーブルを差し込むだけです。&lt;code&gt;sudo raspi-config&lt;/code&gt;コマンドで、カメラを使うことができるように設定を変更しておきましょう。&lt;code&gt;raspistill -p&lt;/code&gt;コマンドを実行し、特にエラーが出なければ正常に接続されています。&lt;/p&gt;

&lt;p&gt;今回はカメラと呼び鈴部分は連動させず、カメラは&lt;a href=&#34;https://github.com/ccrisan/motioneye/wiki&#34;&gt;motionEye&lt;/a&gt;というオープンソースウェアを使って単独で動作させます。
motionEyeのインストールは以下を参考にしました。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://qiita.com/mt08/items/96207abfba91954b50d4&#34;&gt;らずぱい motionEye (Web UIベースのカメラサーバ) - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こちらのページにも書かれていますが、ラズパイのカメラモジュールを使用するので、以下のコマンドを実行しておくのを忘れないようにしましょう。
&lt;code&gt;grep bcm2835-v4l2 /etc/modules || echo bcm2835-v4l2 | sudo tee -a /etc/modules&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/4.png&#34; alt=&#34;&#34; /&gt;
インストールが完了して、室内に常設してあるPCのブラウザからアクセスしてみました。
ばっちりドアの外が撮影されていますね！
1秒おきに更新されていますが、python上で動作しているためか、少々重たいようです。&lt;/p&gt;

&lt;h2 id=&#34;試してみる&#34;&gt;試してみる&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/7.png&#34; alt=&#34;&#34; /&gt;
インターホンを押すと……&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/4W4pJ0bZVGY&#34; frameborder=&#34;0&#34; gesture=&#34;media&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;入店っぽい音が流れます！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/133/13.png&#34; alt=&#34;&#34; /&gt;
旧スタイルに比べるとだいぶ未来になりました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;今回は数時間ほどでこのシステムを作ることができました。カメラと呼び鈴が独立してしまっていますが、可能ならば「呼び鈴を押した瞬間の画像を保存してhipchatにアップロード」するような仕組みを作ってみたいです。
&lt;img src=&#34;https://dotstud.io/img/blog/133/3.png&#34; alt=&#34;&#34; /&gt;
次は何をつくってやろうか……。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>