<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on dotstudio（ドットスタジオ）</title>
    <link>https://dotstud.io/blog/</link>
    <description>Recent content in Blogs on dotstudio（ドットスタジオ）</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>© 2016 dotstudio inc.</copyright>
    <lastBuildDate>Mon, 19 Mar 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/blog/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Nefry BTで簡単IoT！★IoTバイブステンアゲポロシャツ★ 後編</title>
      <link>https://dotstud.io/blog/gyaruden-mao-vibes-polo2/</link>
      <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-mao-vibes-polo2/</guid>
      
      <description>

&lt;p&gt;こんにちは！ギャル電のまおです❤︎&lt;/p&gt;

&lt;p&gt;今回は「★IoTバイブステンアゲポロシャツ★」の作り方後編です。前回の記事はこちら↓
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-mao-vibes-polo/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;作り方の流れ&#34;&gt;作り方の流れ☆&lt;/h2&gt;

&lt;p&gt;作り方の流れはざっとこんな感じです。今回はArduino IDEでプログラムを書き込むところから始めていきたいと思います。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;IFTTTでレシピを作成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Arduino IDEでプログラムを書き込む&lt;/strong&gt; &lt;strong&gt;←今回はここから❤︎&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Nefry BTのWi-Fi設定とIFTTTの連携&lt;/li&gt;
&lt;li&gt;センサーとLEDをNefry BTに配線&lt;/li&gt;
&lt;li&gt;ボロシャツに取り付け&lt;/li&gt;
&lt;li&gt;☆テスト☆&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;arduino-ideでプログラムを書き込む&#34;&gt;Arduino IDEでプログラムを書き込む&lt;/h2&gt;

&lt;h3 id=&#34;arduino-ideをインストール&#34;&gt;Arduino IDEをインストール&lt;/h3&gt;

&lt;p&gt;Nefry BTはArduino IDEという無料ソフトウェアで書き込めるボードです。まだパソコンにインストールされてない方は、&lt;a href=&#34;https://www.arduino.cc/en/Main/Software&#34;&gt;公式サイト&lt;/a&gt;でダウンロードしてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;Arduino IDEをPCにインストール&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;nefry-btライブラリの追加&#34;&gt;Nefry BTライブラリの追加&lt;/h3&gt;

&lt;p&gt;Arduino IDEを立ち上げてまだすぐプログラミングはできません。 まず、&lt;u&gt;Aduino IDEにNefry BTというマイコンボードを知ってもらうためにボードのインストール&lt;/u&gt;をします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/1.png&#34; alt=&#34;&#34; /&gt;
Arduino &amp;gt; Preferences をクリックしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/2.png&#34; alt=&#34;&#34; /&gt;
下記のURLを「追加のボードマネージャのURL」という欄に追加してください。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nefry.studio/package_nefrybt_index.json&#34;&gt;http://nefry.studio/package_nefrybt_index.json&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;追加できたら「OK」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/3.png&#34; alt=&#34;&#34; /&gt;
次にツール＞ボード＞ボードマネージャをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/4.png&#34; alt=&#34;&#34; /&gt;
ボードマネージャというウィンドウが出てくるので上にある検索欄で”Nefry”と検索すると、Nefryのライブラリが出てくるので「インストール」をクリックします。&lt;/p&gt;

&lt;p&gt;インストールが完了したらプログラムを書き込む準備は終わりです。&lt;/p&gt;

&lt;h3 id=&#34;プログラムを書き込む&#34;&gt;プログラムを書き込む&lt;/h3&gt;

&lt;p&gt;まずNefry BTをパソコンのUSBポートに差し込みましょう。&lt;/p&gt;

&lt;p&gt;下記のプログラムは&lt;u&gt;デジタルチルトセンサーが傾きを検出した時に画像がツイートされる&lt;/u&gt;というプログラムです。Nefry BTのスケッチ例の「NefryIFTTT」というプログラムを少し変えたものです。&lt;/p&gt;

&lt;p&gt;以下をArduino IDEにコピペしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;NefryIFTTT.h&amp;gt;
String Event, SecretKey;
int counter =0;                       //送信データのカウンタ
int ledPin = 1;                // Connect LED to pin A1
int switcher = 0;                 // Connect Tilt sensor to D0


void setup() {
  Nefry.setStoreTitle(&amp;quot;SecretKey&amp;quot;,0); //Nefry DataStoreのタイトルを指定
  Nefry.setStoreTitle(&amp;quot;Event&amp;quot;,1);     //Nefry DataStoreのタイトルを指定
  SecretKey = Nefry.getStoreStr(0);   //Nefry DataStoreからデータを取得
  Event = Nefry.getStoreStr(1);       //Nefry DataStoreからデータを取得
  pinMode(ledPin, OUTPUT);      // Set digital pin A1 to output mode
  pinMode(switcher, INPUT);       // Set digital pin D0 to input mode

}

void loop() {
  if (digitalRead(switcher)==HIGH) {               
    digitalWrite(ledPin, HIGH);   // Turn on LED when the sensor is tilted
    counter++;                        //送信回数加算
    bool sendData = IFTTT.send(Event, SecretKey,&amp;quot;Nefry&amp;quot;,(String)(micros()/1000000)+&amp;quot;秒&amp;quot;,(String)counter);//IFTTTにデータを送信
                                      //Value1:Nefry,Value2:Nefryが起動してからの秒数,Value3:送信カウンタ
    if (!sendData) {//IFTTTにデータを送信が成功したか失敗したかの判定
      Nefry.setLed(255, 0, 0);        //Errの時、赤色点灯
    }

    Nefry.ndelay(1000);               //送信後1秒間待つ
  }
else
     {
        digitalWrite(ledPin, LOW);    // Turn off LED when the sensor is not triggered
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/5.png&#34; alt=&#34;&#34; /&gt;
ツールをクリックして、ボード・UploadSpeed・シリアルポートを以下のように設定しましょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ボード：Nefry BT&lt;/li&gt;
&lt;li&gt;UploadSpeed:115200&lt;/li&gt;
&lt;li&gt;シリアルポート:/dev/cu.usbserial-XXXXX（MacOSの場合）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/6.png&#34; alt=&#34;&#34; /&gt;
設定が完了したら左上にある「➡︎」ボタンをクリックしてボードに書き込みます。&lt;/p&gt;

&lt;h2 id=&#34;nefry-btのwi-fi設定とiftttの連携&#34;&gt;Nefry BTのWi-Fi設定とIFTTTの連携&lt;/h2&gt;

&lt;p&gt;次にNefry BTのWi-Fi設定とIFTTTの連携をします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/7.png&#34; alt=&#34;&#34; /&gt;
Nefry BTをパソコンのUSBポートなど電源が取れる状態にしてから、パソコンのWi-Fi設定のところをクリックすると、&amp;rdquo;NefryBT-xxx&amp;rdquo;のような表示があります。それをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/8.png&#34; alt=&#34;&#34; /&gt;
すると、上のようなコンソール画面が出てきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/9.png&#34; alt=&#34;&#34; /&gt;
Setup WiFiをクリックして、Nefry BTが使うWi-Fi（2.4GHz帯）を設定します。使いたいWi-FiのSSIDとパスワードを入力して「Save」します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/10.png&#34; alt=&#34;&#34; /&gt;
次に、前の画面に戻ってData Storeをクリックします。上のような画面が出てくるので、ここではIFTTTのwebhookの設定で取得した「SecretKey」とレシピを作成した時に設定した「イベント名」を記入して「Save」すれば設定完了です。&lt;/p&gt;

&lt;h2 id=&#34;センサーとledをnefry-btに配線&#34;&gt;センサーとLEDをNefry BTに配線&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/11.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;こんな感じで配線しました〜！&lt;/strong&gt;（※Nefry BT（無印）での配線です。Nefry BT R2の場合は配線表を参考に配線してください。）&lt;/p&gt;

&lt;p&gt;デジタルチルトセンサーのピン配置は以下になります。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/153/12.png&#34; alt=&#34;&#34; /&gt;
1: Input / 2: Power / 3: GND
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Nefry BT、LEDとデジタルチルトセンサーの配線表は以下になります。
&lt;img src=&#34;https://dotstud.io/img/blog/153/13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ポロシャツに取り付け&#34;&gt;ポロシャツに取り付け&lt;/h2&gt;

&lt;p&gt;ポロシャツの襟の裏側にチルトセンサーを取り付けます。
&lt;img src=&#34;https://dotstud.io/img/blog/153/14.png&#34; alt=&#34;&#34; /&gt;
配線がポロシャツの中に隠れるように、ポロシャツに穴を開けて配線を通します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/15.png&#34; alt=&#34;&#34; /&gt;
モバイルバッテリーにネフリーを接続して、巾着袋に入れます。&lt;/p&gt;

&lt;p&gt;最後に首から背中に巾着袋をかけて、チルトセンサーのピンをNefry BTに接続したら出来上がり❤︎&lt;/p&gt;

&lt;h2 id=&#34;テスト&#34;&gt;☆テスト☆&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;襟を立てると、ツイートされる！😆&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/153/demo.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;みんなも襟立てをインターネット化して、パリピになろうね卍&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;シャンパンは死にます✨ &lt;a href=&#34;https://t.co/2AbCV5ffOq&#34;&gt;pic.twitter.com/2AbCV5ffOq&lt;/a&gt;&lt;/p&gt; mao (@galmao777) &lt;a href=&#34;https://twitter.com/galmao777/status/964164179643912192?ref_src=twsrc%5Etfw&#34;&gt;2018年2月15日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BTで簡単IoT！★IoTバイブステンアゲポロシャツ★ 前編</title>
      <link>https://dotstud.io/blog/gyaruden-mao-vibes-polo/</link>
      <pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-mao-vibes-polo/</guid>
      
      <description>

&lt;p&gt;こんにちは！ギャル電のまおです★
&lt;img src=&#34;https://dotstud.io/img/blog/152/1.png&#34; alt=&#34;&#34; /&gt;
今回は去年のIoTLT第30回目にてプレゼンした&lt;u&gt;インターネット経由できるバイブスアゲ↑アゲ↑なポロシャツの作り方&lt;/u&gt;について、紹介していきたいと思います！&lt;/p&gt;

&lt;h2 id=&#34;iotバイブステンアゲポロシャツ&#34;&gt;IoTバイブステンアゲポロシャツ&lt;/h2&gt;

&lt;p&gt;うちみたいな大学生ギャルがたまに六本木のクラブにいくと世代間のギャップで疑問に思うことがよくある。&lt;/p&gt;

&lt;p&gt;毎回最もモヤモヤすることは、お兄さん達のファッション。みんなも何回かは見たことあるであろう、あのちょっと色黒のがたい良さげなお兄さん達がよく着ている&amp;hellip;&amp;hellip;&lt;strong&gt;最高に襟が立ったピッチピチなポロシャツ。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;うちみたいなヤンギャル（若いギャル）は、あの最高に襟が立ったポロシャツのよさみがわからない。&lt;/p&gt;

&lt;p&gt;よってうちらギャル電、&lt;u&gt;テクノロジーを使って襟が立ったポロシャツにナウみを足してかっこよさを引き立てられるスタイル&lt;/u&gt;を提案した。&lt;/p&gt;

&lt;p&gt;それが「 &lt;strong&gt;襟立てポロシャツのインターネット化&lt;/strong&gt;」、俺が最もイケてる瞬間をインターネットで全世界にお知らせ😄&lt;/p&gt;

&lt;p&gt;しくみは、ポロシャツの襟を立てた瞬間ツイッターに通知される感じ。これならヤンギャルでも、&lt;strong&gt;バイブステンアゲピーナッツすぎてまじやばたん&lt;/strong&gt;ってなる。&lt;/p&gt;

&lt;p&gt;IoTバイブステンアゲポロシャツについてプレゼンした資料はこちら↓&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;23b7788d53344c4ab9e6d7c5415a7802&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;さっそく作っていく&#34;&gt;さっそく作っていく！&lt;/h2&gt;

&lt;h3 id=&#34;用意するもの&#34;&gt;用意するもの♡&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dotstud.io/docs/nefrybt&#34;&gt;Nefry BT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;デジタルチルトセンサー（例: &lt;a href=&#34;http://akizukidenshi.com/catalog/g/gM-07036/&#34;&gt;DFR0028（秋月電子）&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;LED  1個&lt;/li&gt;
&lt;li&gt;モバイルバッテリー&lt;/li&gt;
&lt;li&gt;襟がめっちゃ立っているボロシャツ&lt;/li&gt;
&lt;li&gt;紐長めの巾着袋&lt;/li&gt;
&lt;li&gt;両面テープ、穴あけ道具&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;作り方の流れ&#34;&gt;作り方の流れ☆&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;IFTTTでレシピを作成&lt;/strong&gt; ←今回はここまで❤︎&lt;/li&gt;
&lt;li&gt;Arduino IDEでプログラムを書き込む&lt;/li&gt;
&lt;li&gt;Nefry BTとIFTTTの連携とwifi設定&lt;/li&gt;
&lt;li&gt;センサーとLEDをNefry BTに配線&lt;/li&gt;
&lt;li&gt;ボロシャツに取り付け&lt;/li&gt;
&lt;li&gt;☆テスト☆&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;今回IoTバイブステンアゲポロシャツを作成するのにあたり、Nefry BT開発者わみさんの「&lt;a href=&#34;https://dotstud.io/blog/nefry-ifttt-push-line/&#34;&gt;&lt;strong&gt;Nefry BTとIFTTTでスイッチを押したらLINEを送る仕組みを作ってみよう&lt;/strong&gt;&lt;/a&gt;」の記事を元に作りました。こちらを参考にしながら作成するのもいいと思います！&lt;/p&gt;

&lt;h2 id=&#34;iftttでレシピを作成&#34;&gt;IFTTTでレシピを作成&lt;/h2&gt;

&lt;p&gt;IFFT（いふと）とは&lt;u&gt;いろんなWebサービス同士を簡単に連携できるサービス&lt;/u&gt;です。&lt;/p&gt;

&lt;p&gt;IFTTTは、「&lt;strong&gt;If This Then That&lt;/strong&gt;」の略で「&lt;strong&gt;もし☆☆したら♡♡をする&lt;/strong&gt;」ことを&lt;strong&gt;レシピ&lt;/strong&gt;と呼びます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/2.png&#34; alt=&#34;&#34; /&gt;
まず、&lt;a href=&#34;https://ifttt.com/&#34;&gt;IFTTTの公式サイト&lt;/a&gt;でアカウントを作ってください。&lt;/p&gt;

&lt;p&gt;次に、さっそくレシピを作成していきます。&lt;/p&gt;

&lt;h3 id=&#34;secret-keyの取得&#34;&gt;Secret Keyの取得&lt;/h3&gt;

&lt;p&gt;まずはNefry BTとIFTTTの連携に必要な「Secret Key」を取得します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/3.png&#34; alt=&#34;&#34; /&gt;
メニューバーの「Search」を選択して検索欄で”Webhook”と記入すると、Webhookアプリが出てくるのでそれをクリックしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/4.png&#34; alt=&#34;&#34; /&gt;
右上にある「Settings」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/5.png&#34; alt=&#34;&#34; /&gt;
そうすると、Account Infoが出てきます。こちらに表示されている&lt;strong&gt;URLの最後の部分がSecret Key&lt;/strong&gt;となるのでこちらを各自ゲトりましょう。（画像の中に表示されているSecret Keyは無効なので各自取得してください。）&lt;/p&gt;

&lt;h3 id=&#34;トリガーの作成&#34;&gt;トリガーの作成&lt;/h3&gt;

&lt;p&gt;次に、「もし☆☆したら」の部分（トリガー）を作成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/6.png&#34; alt=&#34;&#34; /&gt;
メニューバーの「My Applets」をクリックして「New Applet」をクリックしてください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/7.png&#34; alt=&#34;&#34; /&gt;
このような画面が出てきたら、「this」のとこをクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/8.png&#34; alt=&#34;&#34; /&gt;
検索欄で再び&amp;rdquo;Webhook&amp;rdquo;を検索します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/9.png&#34; alt=&#34;&#34; /&gt;
「Receive a web request」をクリック！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/10.png&#34; alt=&#34;&#34; /&gt;
続いて、イベント名を記入します（Nefry　BTにプログラムを書き込む際使用する）。&lt;/p&gt;

&lt;p&gt;記入したら「Create trigger」をクリックしてトリガーの作成が完了です。&lt;/p&gt;

&lt;h3 id=&#34;アクションの作成&#34;&gt;アクションの作成&lt;/h3&gt;

&lt;p&gt;最後に「♡♡をする」の部分（アクション）を設定します！
&lt;img src=&#34;https://dotstud.io/img/blog/152/11.png&#34; alt=&#34;&#34; /&gt;
画面の「that」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/12.png&#34; alt=&#34;&#34; /&gt;
次に、使うサービスを検索欄で検索します。今回はツイッターにツイートさせたいので”twitter”と検索します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/13.png&#34; alt=&#34;&#34; /&gt;
そして、今回は画像をツイートさせたいので「Post a tweet with image」をクリックします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/14.png&#34; alt=&#34;&#34; /&gt;
この画面ではツイートさせたい文章と画像のURLを記入して、「Create action」をクリックします。&lt;/p&gt;

&lt;p&gt;すると、最後の画面に移るので「Finish」をクリックしてレシピ作成終了です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;こんな感じで今回はここまで！次回後半はで残りのステップを紹介します★ では！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;デコトラサンバイザーを更にアプリで盛る🤙✨💓 &lt;a href=&#34;https://t.co/G01xOz2L3k&#34;&gt;pic.twitter.com/G01xOz2L3k&lt;/a&gt;&lt;/p&gt; ギャル電 (@GALDEN999) &lt;a href=&#34;https://twitter.com/GALDEN999/status/956156306007601152?ref_src=twsrc%5Etfw&#34;&gt;2018年1月24日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;後編の記事はこちら↓
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-mao-vibes-polo2/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/152/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon Echoを使いこなそう！Node.jsでAlexaスキル開発 - スマートスピーカーの基本とスキル開発入門</title>
      <link>https://dotstud.io/blog/nodejs-amazon-alexa-skill/</link>
      <pubDate>Tue, 06 Mar 2018 01:00:43 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nodejs-amazon-alexa-skill/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃんとくです。突然ですが、「&lt;strong&gt;スマートスピーカー&lt;/strong&gt;」流行っていますね！&lt;/p&gt;

&lt;p&gt;dotstudioでも「LINE Wave」「Google Home mini」「Amazon Echo Dot」と取り揃えております。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;が。&lt;strong&gt;ぶっちゃけ「音楽かけて」しか活用できてない……。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで、スマートスピーカーのスキルを開発し、&lt;u&gt;活用できるよう自分向けにカスタマイズ&lt;/u&gt;してみましょう！今回は&lt;strong&gt;Amazon EchoのAlexaスキルをNode.jsで開発&lt;/strong&gt;してみます！&lt;/p&gt;

&lt;p&gt;※記事は長いですが、開発は簡単なのでぜひチャレンジしてみてください！&lt;/p&gt;

&lt;h2 id=&#34;開発を始める前に&#34;&gt;開発を始める前に&lt;/h2&gt;

&lt;h3 id=&#34;alexaって何-amazon-echoじゃないの&#34;&gt;Alexaって何？Amazon Echoじゃないの？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/device.png&#34; alt=&#34;&#34; /&gt;
Amazonのスマートスピーカーは「Echo」という&lt;strong&gt;スピーカーのシリーズ&lt;/strong&gt;に、「Alexa」という&lt;strong&gt;音声AI&lt;/strong&gt;が搭載されたものです。Alexaは音声AIの名前なので、Alexa搭載のPCやクルマもありますよね。&lt;/p&gt;

&lt;p&gt;各スピーカの違いは音質だったり、スマートホームハブ内臓だったりと色々あるので、調べてみてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;http://www.itmedia.co.jp/news/articles/1711/08/news107.html&#34;&gt;日本上陸「Amazon Echo」3機種の違いは？　他社とどう差別化する？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ちなみに「LINE WAVE」の音声AIは「Clova」、「Google Home」の音声AIは「Googleアシスタント」と言います。&lt;/p&gt;

&lt;h3 id=&#34;alexaのスキルってなに&#34;&gt;Alexaのスキルってなに？&lt;/h3&gt;

&lt;p&gt;「スキル」とは、&lt;u&gt;開発者によって追加された拡張機能&lt;/u&gt;を指します。スマートフォンでいうアプリのようなものですね。&lt;/p&gt;

&lt;p&gt;スキルにも「カスタムスキル（汎用）」「スマートホームスキル（家電制御など）」「フラッシュブリーフィングスキル（読み上げ）」などの種類があります。&lt;/p&gt;

&lt;p&gt;開発したカスタムスキルは&lt;strong&gt;自分のデバイスですぐに利用&lt;/strong&gt;できますが、&lt;strong&gt;Alexaスキルストアで公開して頒布する&lt;/strong&gt;こともできます！今回は自分のデバイスで利用できるところまでやってみますよ〜！&lt;/p&gt;

&lt;h3 id=&#34;スキルを開発する方法&#34;&gt;スキルを開発する方法&lt;/h3&gt;

&lt;p&gt;まずはスキルの全体の処理の流れを見てみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/144/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Echoデバイスは受け取った音声をAlexaサービスに渡します。&lt;/li&gt;
&lt;li&gt;Alexaサービスは音声を解析してテキストに変換し、処理ロジックに渡します。&lt;/li&gt;
&lt;li&gt;処理ロジックの結果がAlexaに渡され、音声データを生成してデバイスに渡します。&lt;/li&gt;
&lt;li&gt;Echoデバイスが音声を発します。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スキルを開発するときに必要なのは、上の図で「&lt;strong&gt;音声インタフェース&lt;/strong&gt;」と「&lt;strong&gt;処理ロジック&lt;/strong&gt;」の部分です。&lt;/p&gt;

&lt;p&gt;音声インタフェースは&lt;u&gt;どんな言葉を受け取るか、どう理解するか&lt;/u&gt;などです。この部分は&lt;strong&gt;Amazon Developer上で設計&lt;/strong&gt;することができます。&lt;/p&gt;

&lt;p&gt;処理ロジックは&lt;u&gt;返答をする部分&lt;/u&gt;です。自前でエンドポイントを作成することもできますが、&lt;strong&gt;AWS Lambdaで作成すると簡単に紐付けることができます&lt;/strong&gt;。今回はAWS Lambdaを使ってみます。&lt;/p&gt;

&lt;h3 id=&#34;開発手順の整理&#34;&gt;開発手順の整理&lt;/h3&gt;

&lt;p&gt;今回は下記の手順で開発していきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Amazon Developer上で音声インタフェースを設計&lt;/li&gt;
&lt;li&gt;AWS Lambdaで処理ロジックを開発&lt;/li&gt;
&lt;li&gt;音声インタフェースと処理ロジックの紐付け&lt;/li&gt;
&lt;li&gt;デバイスでスキルを有効にする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一つ一つの手順は難しくないので、しっかり理解しておきましょう！&lt;/p&gt;

&lt;h2 id=&#34;開発の事前準備&#34;&gt;開発の事前準備&lt;/h2&gt;

&lt;p&gt;各種アカウントやセットアップは開発の前にあらかじめ用意しておくとスムーズです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Amazon Developerアカウント&lt;/li&gt;
&lt;li&gt;Echoデバイスのセットアップ&lt;/li&gt;
&lt;li&gt;AWSアカウント&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下記でそれぞれの手順を紹介します。&lt;/p&gt;

&lt;h3 id=&#34;amazon-developerアカウントの作成&#34;&gt;Amazon Developerアカウントの作成&lt;/h3&gt;

&lt;p&gt;Alexaスキルの登録や音声インタフェースの設計に必要です。Amazon.co.jpのお買い物アカウントをそのまま紐付けることができます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※Amazon.com（米国）アカウントを紐付けると最後のデバイスとスキルの紐付けでうまくいかない場合があります。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://developer.amazon.com/ja/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_console.png&#34; alt=&#34;&#34; /&gt;
Amazon Developer（日本語版）&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;右上のDeveloper Consoleから登録します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_monetize.png&#34; alt=&#34;&#34; /&gt;
収益化の項目はひとまず「いいえ」にしておきます（後から変更できます）。&lt;/p&gt;

&lt;h3 id=&#34;echoデバイスのセットアップ&#34;&gt;Echoデバイスのセットアップ&lt;/h3&gt;

&lt;p&gt;スマートフォンアプリで、Amazon Developerアカウントの紐づけとWi-Fi設定を行います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_login.png&#34; alt=&#34;&#34; /&gt;
お手持ちのiPhone、Android端末にAlexaアプリをインストールしましょう（以下iPhoneでの説明です）。Amazon Developerアカウントでログインします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_setup.png&#34; alt=&#34;&#34; /&gt;
「設定」から「新しいデバイスをセットアップ」を選びます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_wifi.png&#34; alt=&#34;&#34; /&gt;
言語を選択し、スマートフォンを利用するWi-Fiに接続します。&lt;strong&gt;Wi-Fiは2.4GHz帯でないと利用できない&lt;/strong&gt;ので注意しましょう（最近だと5GHz帯も多いので確認してください）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_action.png&#34; alt=&#34;&#34; /&gt;
Echoデバイスと接続します。デバイスがオレンジになっていない場合はアクションボタンを長押しします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_mode.png&#34; alt=&#34;&#34; /&gt;
「・」のボタンがアクションボタンです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/app_device.png&#34; alt=&#34;&#34; /&gt;
「Amazon-XXXX」に接続します（複数のデバイスがセットアップモードになっている場合、混同しないよう注意してください）。&lt;/p&gt;

&lt;p&gt;以上でセットアップ完了です！&lt;/p&gt;

&lt;h3 id=&#34;awsアカウントの作成&#34;&gt;AWSアカウントの作成&lt;/h3&gt;

&lt;p&gt;AWSアカウントは下記の公式サイトを参考に進めてみてください（以前に登録済みだったので画面キャプチャが用意できませんでした……）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/jp/register-flow/&#34;&gt;https://aws.amazon.com/jp/register-flow/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;アカウント登録の際には&lt;strong&gt;クレジットカードの登録&lt;/strong&gt;、&lt;strong&gt;電話確認&lt;/strong&gt;（自動応答）が必要です。&lt;/p&gt;

&lt;p&gt;AWSアカウントには2018年3月現在では1年間の無料枠がついてきますが、&lt;u&gt;ご自身のアカウントの管理には注意してください。&lt;/u&gt;&lt;/p&gt;

&lt;h2 id=&#34;音声インタフェースの設計&#34;&gt;音声インタフェースの設計&lt;/h2&gt;

&lt;p&gt;まずは&lt;a href=&#34;https://developer.amazon.com/ja/&#34;&gt;Amazon Developer&lt;/a&gt;上で音声インタフェースを作成していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/144/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;alexaスキルを新規登録&#34;&gt;Alexaスキルを新規登録&lt;/h3&gt;

&lt;p&gt;Amazon Developerにログインして&lt;a href=&#34;https://developer.amazon.com/home.html&#34;&gt;Developer Console&lt;/a&gt;を開きます。
&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_alexa.png&#34; alt=&#34;&#34; /&gt;
Alexaのページへ移動します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_start.png&#34; alt=&#34;&#34; /&gt;
「Alexa Skills Kit」を始めます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/create1.png&#34; alt=&#34;&#34; /&gt;
「新しいスキルを追加」します（新メニューのβ版が出てますが、まだ日本語対応していないようです）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/create2.png&#34; alt=&#34;&#34; /&gt;
作成するスキルの情報を入力します。今回は下記のようにしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;スキルの種類 ⇒ 「カスタム対話モデル」&lt;/li&gt;
&lt;li&gt;言語 ⇒ 日本語&lt;/li&gt;
&lt;li&gt;スキル名 ⇒ ちゃんとくカフェ&lt;/li&gt;
&lt;li&gt;呼び出し名 ⇒ ちゃんとくカフェ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「保存」して「次へ」で作成します。&lt;/p&gt;

&lt;h3 id=&#34;対話モデルを作成&#34;&gt;対話モデルを作成&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/create3.png&#34; alt=&#34;&#34; /&gt;
作成したら、&lt;strong&gt;対話モデル&lt;/strong&gt;を作っていきます。「スキルビルダーを起動する」を選択します。&lt;/p&gt;

&lt;p&gt;対話モデルとは、&lt;u&gt;ユーザがどのように発話するか、どのように解釈して処理ロジックに伝えるか&lt;/u&gt;の部分です。用語がいくつか出てくるので、下の図を見てみましょう。
&lt;img src=&#34;https://dotstud.io/img/blog/144/model1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;スキル名を&lt;strong&gt;Invocation name&lt;/strong&gt;と言い、「&lt;strong&gt;Alexa、{Invocation name}を開いて&lt;/strong&gt;」と呼びかけます。&lt;/li&gt;
&lt;li&gt;起動後に返すAlexaの言葉を&lt;strong&gt;LaunchRequest&lt;/strong&gt;と言います。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;Alexaが受け付けるアクションの呼びかけ&lt;/u&gt;を、&lt;strong&gt;Intent&lt;/strong&gt;と言います。&lt;/li&gt;
&lt;li&gt;Intentに対するAlexaの返答を&lt;strong&gt;IntentRequest&lt;/strong&gt;と言います。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これが基本的なユーザとAlexaのやりとりの構図です。対話モデルでは&lt;strong&gt;Intent&lt;/strong&gt;を設定して、Alexaに受け付けてもらえるようにしていきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/model2.png&#34; alt=&#34;&#34; /&gt;
ちなみに「スキルを開く〜アクション」までは一文での呼びかけでもできます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder1.png&#34; alt=&#34;&#34; /&gt;
スキルビルダーの画面が開いたら、左のIntentsから「ADD」を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder2.png&#34; alt=&#34;&#34; /&gt;
設定するIntentの名前を付けます。今回はオススメを教えてもらうアクションを作成したいので「RecomendIntent」にしてみました。&lt;u&gt;アクションに沿った名前をつけておく&lt;/u&gt;とIntentが増えてもわかりやすいと思います。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder3.png&#34; alt=&#34;&#34; /&gt;
アクションを呼ぶときの「呼びかけ」のサンプル発話を登録していきます。公式によると、パターン数は1つのIntentに対し、&lt;u&gt;最低6つ、理想は30&lt;/u&gt;だそうです。サンプル発話が多いほど認識精度が向上します。&lt;/p&gt;

&lt;p&gt;登録したら「&lt;strong&gt;Save Model&lt;/strong&gt;」、「&lt;strong&gt;Build Model&lt;/strong&gt;」を順に選択します。（Buildには少し時間がかかります。ここで機械学習がされているそうです。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder4.png&#34; alt=&#34;&#34; /&gt;
ビルドが完了したら「Configuration」を選択し、設定画面に戻ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/builder5.png&#34; alt=&#34;&#34; /&gt;
スキルの「ID」をコピーして、Amazon Developerは一旦置いておきます（まだ設定があるので開いたまま）。&lt;/p&gt;

&lt;h2 id=&#34;処理ロジックの開発&#34;&gt;処理ロジックの開発&lt;/h2&gt;

&lt;p&gt;続いて、&lt;a href=&#34;https://aws.amazon.com/jp/&#34;&gt;AWS&lt;/a&gt;のLambda上で処理ロジックを作っていきます。
&lt;img src=&#34;https://dotstud.io/img/blog/144/4.png&#34; alt=&#34;&#34; /&gt;
AWS Lambdaは、&lt;u&gt;AWSに関するイベントにをトリガーにする処理を作成できる実行環境&lt;/u&gt;です。&lt;/p&gt;

&lt;p&gt;自分自身でエンドポイントを立てることもできますが、AWS Lambdaを使うとロジック自体の開発や他のAWSサービスとの連携も簡単です。&lt;/p&gt;

&lt;h3 id=&#34;aws-lambda関数を作成&#34;&gt;AWS Lambda関数を作成&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func1.png&#34; alt=&#34;&#34; /&gt;
AWSコンソールを開いたら、「lambda」を検索して開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func2.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;リージョンが「東京」になっていることを確認&lt;/strong&gt;し、「関数を作成」します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func3.png&#34; alt=&#34;&#34; /&gt;
「設計図」から作成し、「alexa-skill-sdk-factskill」を検索して選びます。この設計図を利用すると、&lt;strong&gt;Alexa Skills Kit for Node.jsというNode.jsのSDK&lt;/strong&gt;がデフォルトで入ってきます。&lt;u&gt;現在のところ公式に開発されているSDKはNode.jsだけ&lt;/u&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func4.png&#34; alt=&#34;&#34; /&gt;
上記のように関数の情報を設定します。&lt;/p&gt;

&lt;p&gt;「ロール」は関数のアクセス権限です。今回は「シンプルなマイクロハーネスのアクセス権限」を選択しましたが、S3など他のサービスに繋ぎたい場合は別途選択が必要です。AWSの&lt;a href=&#34;https://developer.amazon.com/ja/docs/custom-skills/host-a-custom-skill-as-an-aws-lambda-function.html&#34;&gt;ドキュメント&lt;/a&gt;を参考にしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func5.png&#34; alt=&#34;&#34; /&gt;
下にスクロールして保存します。&lt;/p&gt;

&lt;h3 id=&#34;トリガーをセット&#34;&gt;トリガーをセット&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func6.png&#34; alt=&#34;&#34; /&gt;
関数が作成できたら、トリガー部分に「Alexa Skills Kit」をドラッグ＆ドロップで設定します。&lt;/p&gt;

&lt;p&gt;ここで「Alexa Skills Kitがない！」という人は、&lt;strong&gt;リージョンが東京になっているか&lt;/strong&gt;をもう一度確認してください。（東京じゃない場合は、リージョンを選び直して関数を再度作成ですよ！）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func8.png&#34; alt=&#34;&#34; /&gt;
下にスクロールして「トリガーの設定」に、Amazon Developerで取得した「スキルのID」を貼り付けます。&lt;/p&gt;

&lt;h3 id=&#34;処理ロジックを編集&#34;&gt;処理ロジックを編集&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func9.png&#34; alt=&#34;&#34; /&gt;
関数がデフォルトの設計図のままなので編集します。上記の部分を選択すると下にエディタが開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func11.png&#34; alt=&#34;&#34; /&gt;
コードのエントリタイプ（エディタを使う・アップロードするなど）や、ランタイムを選択できます。Node.jsは6.10までの対応になっています。もう少しバージョンが上がってほしいですね……！&lt;/p&gt;

&lt;p&gt;エディタには、デフォルトのコードを参考に下記のようなコードを貼り付けます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const Alexa = require(&#39;alexa-sdk&#39;);

const handlers = {
    // アプリ起動時の返答
    &#39;LaunchRequest&#39;: function () {
        const speechOutput = &#39;こんにちは。オススメをお知らせします。&#39;
        const reprompt = &#39;オススメをお知らせします。&#39;
        this.emit(&#39;:ask&#39;, speechOutput, reprompt);
    },
    // RecomendIntentへの返答
    &#39;RecomendIntent&#39;: function () {
        const intent = this.event.request.intent;
        const speechOutput = &#39;オススメはハンバーグ定食です。&#39;
        this.emit(&#39;:tell&#39;, speechOutput);
    },
    // ヘルプ（デフォルト）への返答
    &#39;AMAZON.HelpIntent&#39;: function () {
        const speechOutput = &#39;ちゃんとくカフェのオススメメニューをお知らせします。&#39;;
        const reprompt = &#39;オススメを聞いてみてください。&#39;
        this.emit(&#39;:ask&#39;, speechOutput, reprompt);
    },
    // キャンセル（デフォルト）への返答
    &#39;AMAZON.CancelIntent&#39;: function () {
        this.emit(&#39;:tell&#39;, this.t(&#39;STOP_MESSAGE&#39;));
    },
    // 対応できないアクションへの返答
    &#39;AMAZON.StopIntent&#39;: function () {
        const speechOutput = &#39;すみません。わかりません。&#39;;
        const reprompt = &#39;もう一度お願いします。&#39;
        this.emit(&#39;:tell&#39;, this.t(&#39;STOP_MESSAGE&#39;));
    },
};

// 下記のように修正
exports.handler = function(event, context, callback) {
    const alexa = Alexa.handler(event, context, callback);
    alexa.registerHandlers(handlers);
    alexa.execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほど設定した「RecomendIntent」（ご自身が設定したIntent名。小文字大文字など注意！）に対する返答や、その他の返答を作成しました。RaunchRequest、HelpIntentなど、&lt;strong&gt;スキル開発で推奨されている設定があるので記述する&lt;/strong&gt;ようにします。&lt;/p&gt;

&lt;p&gt;&lt;u&gt;&lt;strong&gt;この辺がきちんと設定されていないとAlexaスキルストアでは公開できない&lt;/strong&gt;みたいです。&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/func7.png&#34; alt=&#34;&#34; /&gt;
コードが編集できたら右上で保存し、ARNをコピーして、AWSの設定は完了です。&lt;/p&gt;

&lt;h2 id=&#34;音声インターフェースと処理ロジックの紐付け&#34;&gt;音声インターフェースと処理ロジックの紐付け&lt;/h2&gt;

&lt;p&gt;作成したAWS Lambda関数とAmazon Developer上のスキルを紐づけます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/ad_func.png&#34; alt=&#34;&#34; /&gt;
Amazon Developer側の設定ページで、「エンドポイント」に「AWS LambdaのARN」を選択し、「デフォルト」に先ほどのARNを貼り付けます。&lt;/p&gt;

&lt;p&gt;保存して紐づけは完了です！&lt;strong&gt;これでスキルの作成が一通り完了しました！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;試してみよう&#34;&gt;試してみよう！&lt;/h2&gt;

&lt;h3 id=&#34;シミュレータでテスト&#34;&gt;シミュレータでテスト&lt;/h3&gt;

&lt;p&gt;まずはAmazon Developer上に用意されているシミュレータでテストしてみます（実はスキル開発だけならEchoデバイスが無くてもできるんですね）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/simu1.png&#34; alt=&#34;&#34; /&gt;
「テスト」のサービスシミュレータに登録したサンプル発話を入力し、スキルを呼び出します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/simu2.png&#34; alt=&#34;&#34; /&gt;
レスポンスが返ってきました！処理ロジックを作ったらここでデバッグをしていくのが良さそうです。&lt;/p&gt;

&lt;h3 id=&#34;echoデバイスでスキルを有効にする&#34;&gt;Echoデバイスでスキルを有効にする&lt;/h3&gt;

&lt;p&gt;開発したスキルは、自分のAmazon Developerアカウントに紐付いているデバイスで検証することができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo1.png&#34; alt=&#34;&#34; /&gt;
スマートフォンアプリから「スキル」を選びます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo2.png&#34; alt=&#34;&#34; /&gt;
「有効なスキル」を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo3.png&#34; alt=&#34;&#34; /&gt;
「DEVスキル」の項目から、作成したスキルを選択します。&lt;/p&gt;

&lt;p&gt;ここで作ったスキルが表示されていない場合は、Amazon Developerアカウントが&lt;strong&gt;Amazon.comアカウント（米国）に紐付いてないか確認&lt;/strong&gt;してください。Amazon.co.jpアカウントに紐づけないとダメみたい……（現象が起こせなくて解決策がイマイチわかっていません、すみません）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/144/demo4.png&#34; alt=&#34;&#34; /&gt;
選択すると連携しているEchoデバイスでスキルが使えるようになります（無効にすると使えなくなります）。&lt;/p&gt;

&lt;h3 id=&#34;いざ-スキルを呼び出し&#34;&gt;いざ、スキルを呼び出し！&lt;/h3&gt;

&lt;p&gt;デバイスで作成したスキルを試してみましょう！&lt;/p&gt;

&lt;p&gt;基本のやりとりから……
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/RyHESCiE03s&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;
バッチリです！&lt;/p&gt;

&lt;p&gt;「ヘルプ」「ストップ」などの呼びかけは、Intentを登録しなくてもデフォルトで設定されています。
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/dr-akz9qTDk&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; encrypted-media&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;手順の紹介は長くなってしまいましたが、あまり引っかかるところなくスキルの開発ができたと思います。&lt;/p&gt;

&lt;p&gt;今回の基本のスキルに加えて、&lt;u&gt;デフォルトのIntentの拡張や、任意の数字や都市を受け取ることができる「Slot」の追加&lt;/u&gt;などまだまだカスタマイズができます。&lt;/p&gt;

&lt;p&gt;次回はカスタマイズを加えたスキルを開発し、公開するところまでやってみたいと思います。それではまた！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラブでモテる！つまみ付きユニコーンポーチ　後編</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/</link>
      <pubDate>Wed, 28 Feb 2018 10:00:00 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/</guid>
      
      <description>

&lt;p&gt;みなさん、ちょりおつ！ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案するユニット、ギャル電で活動しています。今回は&lt;strong&gt;クラブ行くときにぎゃんかわに盛れる光るポーチ&lt;/strong&gt;の作り方後編でっす！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 前編をチェック！
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;arduino-nano互換機の導入方法&#34;&gt;Arduino Nano互換機の導入方法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回使用したボードはArduino Nano互換機。AmazonやAliExpressとかで一枚300円くらいから買える感じの小さいボードっす。&lt;strong&gt;いいところは、安くて小さいところ&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;導入にクセがあるのと、ケーブルがUSB MiniBタイプなところがちょっとめんどいけど、Digisparkだとちょっと容量足りなくてプログラムが書き込めないときとかにこのボードよく使ってます。&lt;/p&gt;

&lt;h2 id=&#34;ドライバのインストール&#34;&gt;ドライバのインストール&lt;/h2&gt;

&lt;p&gt;Arduino Nano互換機を使用するためには、&lt;strong&gt;ドライバのインストールが必要&lt;/strong&gt;っす。「Arduino Nano 互換 OSの名前 ドライバ」、または「CH340 ドライバ OSの名前」とかで検索すると親切なインターネット上の先輩方の情報がみつかるとおもいまっす！&lt;/p&gt;

&lt;p&gt;Macの新しめの機種使っててうまく認識しない場合には、接続するUSBの口を変えてみるか、USB2.0対応のUSBハブを接続してハブにつなげると認識しやすくなるかも。&lt;/p&gt;

&lt;p&gt;あとどうにも認識しないときは、&lt;strong&gt;一回忘れて寝る。そんで再トライ。うちらはだいたいコレでいつも乗りきってる&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ボードのセッティング&#34;&gt;ボードのセッティング&lt;/h2&gt;

&lt;p&gt;ドライバのインストールが完了して、デバイスを認識するようになったら、&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「Arduino IDE」→「ツール」→「ボード」→「Arduino Nano」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;をえらんで書き込み準備オッケー。Aruduino IDEの設定等はインターネットで調べるか、&lt;a href=&#34;https://dotstud.io/docs/arduinoide-setup/&#34;&gt;ドキュメント&lt;/a&gt;や&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-led-cassette/#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E6%BA%96%E5%82%99&#34;&gt;過去記事&lt;/a&gt;等も参考にしてね☆&lt;/p&gt;

&lt;h2 id=&#34;fastledライブラリの導入方法&#34;&gt;FASTLEDライブラリの導入方法&lt;/h2&gt;

&lt;p&gt;今回はいつも超お世話になっているNeoPixcelライブラリではなくて、&lt;strong&gt;FastLEDライブラリ&lt;/strong&gt;を使用してLEDを光らせたいと思いまっす。&lt;/p&gt;

&lt;p&gt;まずは、ここからライブラリファイル(SourceCode.zip)をダウンロードします。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://github.com/FastLED/FastLED/releases&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/link2.png&#34; alt=&#34;&#34; /&gt;
https://github.com/FastLED/FastLED/releases&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ダウンロードしたファイルを、Arduino IDEを起動して&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「スケッチ」→「ライブラリのインクルード」→「.Zip形式のライブラリをインストール」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;で指定してインストールします。&lt;/p&gt;

&lt;h2 id=&#34;プログラム&#34;&gt;プログラム&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/hsiboy/11545fd0241ab60b567d&#34;&gt;こちら&lt;/a&gt;のページのプログラムを参考にしました。というかLEDの数とLEDのPIN、可変抵抗のPINを書き換えただけでコピペさせていただきました。&lt;/p&gt;

&lt;p&gt;「led potentiometer」でググるといい感じの参考作例やプログラムがいっぱいみつかるよ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//FastLED_AnalogueInput.ino

/*
   Using a potentiometer to control colour, brightness and speed.
 Wire up as per http://arduino.cc/en/Tutorial/AnalogInput
 You can connect the wiper, to any analogue input pin, and
 adjust the settings below.
 You will need three 10k potentiometers.
 */

#include &amp;lt;FastLED.h&amp;gt;

#define LED_PIN 6              // which pin are LEDS connected to?
#define NUM_LEDS 24
#define COLOR_ORDER RGB
#define LED_TYPE WS2811        // i&#39;m using WS2811s, FastLED supports lots of different types.

/*
 set your desired minimum and maxium brigtness settings here.
 Valid values are 0 - 255
 With 0 being fully dim, or not lit, and 255 being fully on.
 Therefore half power, or 50%, would be 128
 */

#define MAX_BRIGHTNESS 164      // Thats full on, watch the power!
#define MIN_BRIGHTNESS 32       // set to a minimum of 25%

const int brightnessInPin = A0;  // The Analog input pin that the brightness control potentiometer is attached to.
const int speedInPin = A1;       // Analog input pin that the speed control potentiometer is attached to.
const int colourInPin = A2;      // The Analog input pin that the colour control potentiometer is attached to.

struct CRGB leds[NUM_LEDS];

void setup() {
  delay(3000); // in case we do something stupid. We dont want to get locked out.

  LEDS.addLeds&amp;lt;LED_TYPE, LED_PIN, COLOR_ORDER&amp;gt;(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
  FastLED.setBrightness(MAX_BRIGHTNESS);
}

void loop() {
  // read the analog brightness value:
  //int brightValue = analogRead(brightnessInPin);            
  // map it to the range of the FastLED brightness:
  int mappedValue = map(analogRead(brightnessInPin), 0, 1023, 0, 255);

  /*
   At this point, brightness could be full off (mappedValue == 0)
   or it could be fully on (mappedValue == 255).
   if you are ruuning from a battery pack, or in a dark room, you
   may not want full brightness.
   Or if you are in daylight, you may not want the pixels to go out.
   the following code, checks if mappedValue is above or below our defined
   brightness settings above.
   It works like this.

   we get mappedValue: if mappedValue is between MIN_BRIGHTNESS and MAX_BRIGHTNESS.
   we get MIN_BRIGHTNESS: if mappedValue is less than our defined MIN_BRIGHTNESS.
   we get MAX_BRIGHTNESS: if mappedValue is greater than our defined MAX_BRIGHTNESS

   so, it limits range of brightness values.

   */

  //int outputValue = constrain(mappedValue, MIN_BRIGHTNESS, MAX_BRIGHTNESS);

  // now we set the brightness of the strip
  FastLED.setBrightness(constrain(mappedValue, MIN_BRIGHTNESS, MAX_BRIGHTNESS));

  // read the analog speed value:          
  // map it to a value used in delay();
  int delayValue = map(analogRead(speedInPin), 0, 1023, 0, 50);  

  int mappedHue;
  // read the analog brightness value:
  //int hueValue = analogRead(colourInPin);            
  // map it to the range of the FastLED brightness:

  // First slide the led in one direction
  for(int i = 0; i &amp;lt; NUM_LEDS; i++) {
    mappedHue = map(analogRead(colourInPin), 0, 1023, 0, 255);
    // Set the i&#39;th led to the chosen colour
    leds[i] = CHSV(mappedHue, 255, 255);
    // Show the leds
    FastLED.show();
    // now that we&#39;ve shown the leds, reset the i&#39;th led to black
    leds[i] = CRGB::Black;
    // Wait a little bit before we loop around and do it again
    delay(delayValue);  
  }

  // Now go in the other direction.  
  for(int i = NUM_LEDS-1; i &amp;gt;= 0; i--) {
    mappedHue = map(analogRead(colourInPin), 0, 1023, 0, 255);
    // Set the i&#39;th led to the chosen colour
    leds[i] = CHSV(mappedHue, 255, 255);
    // Show the leds
    FastLED.show();
    // now that we&#39;ve shown the leds, reset the i&#39;th led to black
    leds[i] = CRGB::Black;
    // Wait a little bit before we loop around and do it again
    delay(delayValue);  
  }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;プログラムを書き込んでテストしてみよう&#34;&gt;プログラムを書き込んでテストしてみよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/2.png&#34; alt=&#34;&#34; /&gt;
プログラムが書き込めたら、ちゃんと可変抵抗器で光り方が変わるかを確認します。&lt;/p&gt;

&lt;p&gt;このプログラムでは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A0に接続したつまみが、明るさ&lt;/li&gt;
&lt;li&gt;A1に接続したつまみが、点滅速度&lt;/li&gt;
&lt;li&gt;A2に接続したつまみが、色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を調整できるようになっています。&lt;/p&gt;

&lt;h2 id=&#34;いい感じにポーチと部品を合体しよう&#34;&gt;いい感じにポーチと部品を合体しよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;光る部分が完成したので、ユニコーンファーポーチと合体します。&lt;/p&gt;

&lt;p&gt;ファーの表面に可変抵抗器用の小さな穴をあけます。可変抵抗器をポーチの表面に出し、キャップをかぶせます。この時、ファーの毛を巻き込んで動きにくい場合は毛を少し刈ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/4.png&#34; alt=&#34;&#34; /&gt;
ポーチの裏側にLEDを貼ったプラ板を固定し、配線をいい感じに収納します。今回はポーチに裏布がついていたので、上部を切り開いてポケット状にして超いい感じに格納したっす。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/5.png&#34; alt=&#34;&#34; /&gt;
とりあえず、ポーチにLEDとボードとモバイルバッテリーがおさまれば完成でっす！&lt;/p&gt;

&lt;h2 id=&#34;光らすと超ユニコーン&#34;&gt;光らすと超ユニコーン！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/147/6.png&#34; alt=&#34;&#34; /&gt;
うひょー！超かわいくない？！シーンに合わせてかわいめからハードめまで光りかたが調整できちゃうから、現場（クラブ）でモテる未来しか見えない！！！！&lt;/p&gt;

&lt;p&gt;みんなも作ってひからせてみよ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>パソコンやモバイルバッテリーに繋いで動かせるデバイスを作ろう！USB電子工作のすすめ#1 - 基礎知識編</title>
      <link>https://dotstud.io/blog/usb-power-supply-making/</link>
      <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/usb-power-supply-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、ものづくり担当のうこ(&lt;a href=&#34;https://twitter.com/harmoniko&#34;&gt;@harmoniko&lt;/a&gt;)です。&lt;/p&gt;

&lt;p&gt;みなさんは、&lt;strong&gt;電子工作をするときの電源はどこから取っていますか？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Arduinoをよく使われる方だと5V端子や3.3V端子から取っている場合が非常に多いですが、ではArduinoを使わない、ピュアな電子工作の場合だとどうしたらいいでしょうか？&lt;/p&gt;

&lt;p&gt;今回は、電子工作用電源としても非常に有用な&lt;strong&gt;USBの基本と扱い方&lt;/strong&gt;についてお伝えします。&lt;/p&gt;

&lt;h2 id=&#34;usbのしくみ&#34;&gt;USBのしくみ&lt;/h2&gt;

&lt;p&gt;「&lt;strong&gt;USB&lt;/strong&gt;」は「&lt;strong&gt;Universal Serial Bus&lt;/strong&gt;」の略で、PCとその周辺機器の間の汎用的な通信規格として1996年に登場しました。USBは1対2本の信号線（※）で順番にデータを送る「&lt;strong&gt;シリアル接続&lt;/strong&gt;」という方式で、複数のデバイスを吊り下げられる「&lt;strong&gt;バス規格&lt;/strong&gt;」の1つです。&lt;/p&gt;

&lt;p&gt;※…USB 2.0まで&lt;/p&gt;

&lt;p&gt;端子は従来のものと比べてシンプルになり、ホストとデバイスをすぐに区別できるようなものになりました。&lt;/p&gt;

&lt;p&gt;USBを使って通信をするには、USBを制御する専用のコントローラハードウェアが必要となるため、電子工作では少し難易度があがります。ただし、&lt;strong&gt;電源を使うだけならケーブルを切って電源のVcc線（+）とGnd線（-）を引き出すだけでよい&lt;/strong&gt;ので、スマホが普及しはじめるよりも早くから電源用ケーブルとしても使われるようになりました。&lt;/p&gt;

&lt;p&gt;USBの簡単な特徴をまとめると、以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通信は、 1つの「ホスト」（PC側）と1〜複数の「デバイス」（周辺機器側）との間で行われる。&lt;/li&gt;
&lt;li&gt;ホスト側とデバイス側で端子形状が区別されている（タイプC端子を除く）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;電源供給用のケーブルおよび端子として使うなら扱いは簡単！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ここ数年普及してきている「USB PD」は、大電力の供給が可能でMacBookの給電などにも利用されている。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;さて当記事は、 &lt;strong&gt;「電子工作において電源として気軽に使えるUSB」&lt;/strong&gt; を知っていただくためのものですので、扱いの簡単な「USB2.0規格（タイプC端子を除く）」までを使う前提の説明にとどめます。&lt;/p&gt;

&lt;p&gt;USB3.0規格以降は端子が増えたり電源規格が多様になったりしているため、電子工作での利用であれば、USB2.0規格までの理解で問題ありません。&lt;/p&gt;

&lt;p&gt;さらに詳しくUSBについて知りたい方は、以下のリンクを参考にしてください。&lt;/p&gt;

&lt;p&gt;⇒ 参考: &lt;a href=&#34;https://thinkit.co.jp/article/11142&#34;&gt;現代PCの基礎知識(7):仕様書を紐解くとわかる―本当はややこしいUSB（Think IT）&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;電源に使うことのメリット&#34;&gt;電源に使うことのメリット&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モバイルバッテリー、PC、コンセントアダプタなど、多彩なソースが選べる。&lt;/li&gt;
&lt;li&gt;給電方法に汎用性があるため、必要なパーツが安くて手に入りやすい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;電源に使うことのデメリット&#34;&gt;電源に使うことのデメリット&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;「外部電源」となるため、電池として本体に含めることができない。&lt;/li&gt;
&lt;li&gt;規格上、5V電圧以外を扱うときや大電流が必要なものには適さない（USB PDを除く）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;仕様の一覧&#34;&gt;仕様の一覧&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 1.0&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 1.1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;USB 2.0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端子タイプ（ホスト側）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;標準A, タイプC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端子タイプ（デバイス側）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ミニA, マイクロA, ミニB, マイクロB, タイプC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;通信速度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12Mビット/秒&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12Mビット/秒&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;480Mビット/秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;定格電圧&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;同右&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;同右&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;約5V（ホスト側4.4~5.25V）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;最大電流&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;500mA（USB BC拡張:1.5A）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上は通信に関する基本的なバージョン仕様ですが、さらにUSB2.0を拡張したUSB電源専用規格である「USB BC（Battery Charging）」というものがあり、1.5Aまでの電流を流すことが可能となっています。&lt;/p&gt;

&lt;p&gt;また、電子工作で利用するためのUSBパーツは100円ショップなどで購入できます。&lt;strong&gt;100円ショップなどで安価に入手可能なUSBパーツはほぼ100%がUSB2.0規格またはUSB BC規格のもの&lt;/strong&gt;となります。&lt;/p&gt;

&lt;p&gt;よって、電子工作の&lt;strong&gt;電源として&lt;/strong&gt;USBを使ってみたいときは&lt;strong&gt;USB2.0規格またはUSB BC規格&lt;/strong&gt;に準じたUSB部品の仕様を知っておけばOKです。&lt;/p&gt;

&lt;h2 id=&#34;usbケーブルの配線図&#34;&gt;USBケーブルの配線図&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;USB2.0には、電源線の5V（VccやVBUSとも）とGND、信号線のD-とD+の合計4種類の線があります。ケーブルのほとんどは2層構造になっていて、内側に収められている4本の線の色分けも上図のように決まっています。&lt;/p&gt;

&lt;p&gt;電子工作でUSBを使うときは、「標準Aメス端子を基板に実装する」か、上図のような「標準Aオス端子がついたケーブルの電源線を接続する」ことになるので、端子の順番や色分けは覚えておくと楽です。&lt;/p&gt;

&lt;h2 id=&#34;電圧と電流&#34;&gt;電圧と電流&lt;/h2&gt;

&lt;p&gt;USB電源の基本は「&lt;strong&gt;電圧5V/電流500mAまで&lt;/strong&gt;」です。&lt;/p&gt;

&lt;p&gt;といっても、これはパソコンのような「電源供給」を主目的としないホストから給電する場合の「USB2.0規格」による制限値です。&lt;/p&gt;

&lt;p&gt;電子工作でUSB電源を扱う場合は、モバイルバッテリーやUSBコンセントなどからの給電がほとんどになると思われます。その場合は、USB BC規格の上限値である1.5Aとなりますが、普通はバッテリーやコンセントに最大出力が書いてあります（例：5V/800mA）ので、電流値の最大はそれに従いましょう。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;usbケーブルの注意点&#34;&gt;USBケーブルの注意点&lt;/h4&gt;

&lt;p style=&#34;font-size: 80%&#34;&gt;細かい話をすると、市場で出回る多くの充電器は「最大2.4A出力」などを謳っていて、この場合だとUSB BC規格にもあてはまりません。このような製品は、USBを通信を行わない完全な電源ケーブルとみなし、独自の規格を採用している場合が多いです。よって、電子工作でUSB電源を使うときは、「USB2.0規格の配線」と「使いたい電源供給源（バッテリーやコンセント等）の出力電流」を考慮して回路設計をするのがベストだといえます。難しく考えたくない人は、 **とにかく省エネになるように意識して作る**ようにするのがよいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 80%&#34;&gt;⇒ 参考: &lt;a href=&#34;https://hanpenblog.com/1472/&#34;&gt;乱立するスマホ向け急速充電の規格について調べた（HANPEN-BLOG）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;電子工作での利用を考えると電流消費を見ることが大事で、個人で製作する小規模な回路であればほとんどが500mA以内に収まることが多いです。&lt;/p&gt;

&lt;p&gt;ヒーターやモーターを使った回路は例外的で、接続された個数や負荷で変動しますが、最大電流が容易に1Aを超えてしまうことがあります。しかし、どのような場合であっても、個人製作された電子回路は漏電流やショートへの配慮、適切な電流制限などが行われていないことが大半です。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本的には、USB電源を利用する自作の電子回路は、安全上の理由からパソコンに接続して給電してはいけません。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⇒ 参考：&lt;a href=&#34;http://www.wheel.gr.jp/~dai/hardware/usb-port.html&#34;&gt;USBポートは電源ではありません&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現実には今のパソコンは全て保護回路が入っているため、ブレッドボードを繋げたArduinoにパソコンから給電するといったようなことを行なっていてもまず問題はありません。しかし&lt;strong&gt;危険性は少なからずあるもの&lt;/strong&gt;だとして意識してもらえれば幸いです。&lt;/p&gt;

&lt;p&gt;（15年ほど前のパソコンでは、USB端子に500mA以上の過電流を流すといきなりパソコンの電源ごと落ちるものもありました。）&lt;/p&gt;

&lt;h2 id=&#34;入手方法&#34;&gt;入手方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;おすすめは100円ショップ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;100円ショップの電気系コーナーに行くと、どこに行っても大抵はUSBケーブルが置いてあります。USBケーブルの中でも取り扱いが多いのは、おそらく次の3つでしょう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Aオス端子-microBオス端子（スマホ充電用）&lt;/li&gt;
&lt;li&gt;Aオス端子-Bオス端子（プリンタなどの接続用）&lt;/li&gt;
&lt;li&gt;Aオス端子-Aメス端子（ケーブル延長用）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このうち、最後の &lt;strong&gt;Aオス端子-Aメス端子（ケーブル延長用）&lt;/strong&gt; は、置いていない店舗もありますが、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ケーブル部分が比較的長い。&lt;/li&gt;
&lt;li&gt;基本的にはAオス端子側を使うが、工作の内容によってはAメス端子があると便利なことがある。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった点から、電子工作で利用するには最もおすすめなケーブルとなっています。売られているのを発見したら、ぜひ買っておきましょう。&lt;/p&gt;

&lt;h2 id=&#34;実際に電子工作で使うには&#34;&gt;実際に電子工作で使うには&lt;/h2&gt;

&lt;p&gt;USBについて、どんなものなのかなんとなくおわかりいただけましたでしょうか？&lt;/p&gt;

&lt;p&gt;とりあえず要約すると、 &lt;strong&gt;「100円で手に入って電子工作で簡単に利用できる汎用電源インターフェース」&lt;/strong&gt; といったところでしょうか。では、実際に使うにはどうすればいいかを見ていきましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;USBケーブルを電源として利用する上で最も重要なパーツが「Aオス端子」部分となります。&lt;/p&gt;

&lt;p&gt;100円ショップで購入できるUSBケーブルは少なくとも一方がこの端子ですので、この端子から伸びるケーブルを十分長く残したうえでニッパで切断します。長さは、製作するモノによって適切に決めてください。あとから調整できるという意味では長めに切り取るのがよいでしょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/5.png&#34; alt=&#34;&#34; /&gt;
切り取った部分の一番外側の皮膜をニッパまたは皮膜剥き用のニッパで1cm程度除去します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/6.png&#34; alt=&#34;&#34; /&gt;
すると細い4本のケーブルが中から出てきますが、このうち赤色と黒色がそれぞれ電源となります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/151/7.png&#34; alt=&#34;&#34; /&gt;
残りの2本は信号線で、&lt;del&gt;USB BC規格として大きめの電流を流したい場合は、この信号線を200Ωの抵抗でショートします。が、実際には何もしなくても給電はなされます。&lt;/del&gt;ここでは簡単にするため切り落としました。&lt;/p&gt;

&lt;p style=&#34;font-size: 80%; color: red;&#34;&gt;
（3/4 修正）200Ωの抵抗を接続するのは充電器側であるとのご指摘をいただき、上記訂正します。
&lt;/p&gt;
&lt;p style=&#34;font-size: 80%;&#34;&gt;
⇒ 出展: USB.orgの&lt;a href =&#34;http://www.usb.org/developers/docs/devclass_docs/&#34;&gt;開発者向けドキュメント&lt;/a&gt;にある「Battery Charging v1.2 Spec and Adopters Agreement.zip」内のBC1.2_FINAL.pdf「Battery Charging Specification, Revision 1.2」3.2.4項「Primary Detection」のFigure 3-6 など）
&lt;/p&gt;

&lt;p&gt;これで、Aオス端子が電源側、切断したほうが電子回路側となります。&lt;/p&gt;

&lt;p&gt;さて、次回はこの1対の電源線を使って、電池で動作するおもちゃをUSB電源駆動に改造してみます。&lt;/p&gt;

&lt;p&gt;お楽しみに。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>放置されていた3Dプリンタ「Trinus」で初めての3Dプリントに挑戦</title>
      <link>https://dotstud.io/blog/3d-printer-trinus-usage/</link>
      <pubDate>Thu, 22 Feb 2018 03:00:43 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/3d-printer-trinus-usage/</guid>
      
      <description>

&lt;p&gt;こんにちは、たくろーどんです。大学で&lt;a href=&#34;https://dotstud.io/docs/nefrybt&#34;&gt;NefryBT&lt;/a&gt;を使った工作をしていたら、いつのまにかdotstudioでアルバイトすることになっていました。宇宙工学を勉強しています。以後よろしくお願いします。&lt;/p&gt;

&lt;p&gt;=&amp;gt; 参考: &lt;a href=&#34;https://qiita.com/minwinmin/items/d1f296b8a9cd1a2c22f6&#34;&gt;研究室のみんなとNefry BTを使ってはじめてIoTデバイスをつくってみた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今回は、dotstudioに放置されていた3Dプリンタ「Trinus（トライナス）」を使って初めての3Dプリントに挑戦してみます。
&lt;img src=&#34;https://dotstud.io/img/blog/149/lead.png&#34; alt=&#34;&#34; /&gt;
これで哲学的なものを錬成していきましょう。&lt;/p&gt;

&lt;h2 id=&#34;3dプリントを始める前に&#34;&gt;3Dプリントを始める前に&lt;/h2&gt;

&lt;h3 id=&#34;3dプリンタとは&#34;&gt;3Dプリンタとは？&lt;/h3&gt;

&lt;p&gt;3Dプリンタとは、その名の通り&lt;strong&gt;3Dのデータを出力できる&lt;/strong&gt;プリンタです。
&lt;img src=&#34;https://dotstud.io/img/blog/149/3dprint.png&#34; alt=&#34;&#34; /&gt;
プリンタによりますが、金属、アルミ、ゴムなどさまざまな素材で出力できるため広い分野で活躍しています。&lt;/p&gt;

&lt;p&gt;現在は業務用から一般向けまでさまざまな種類の3Dプリンタが販売されていますが、今回はdotstudioに放置されていた「Trinus（トライナス）」を使ってみます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://www.trinus3d.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/trinus.png&#34; alt=&#34;&#34; /&gt;
Trinus - Kodama, Inc.&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;3万円代とお手頃価格で、樹脂に加えて木材やアルミも利用でき、別売りのヘッドをつけることでレーザ彫刻機にもなる優れものです。&lt;/p&gt;

&lt;h3 id=&#34;3dプリントには3dデータが必要&#34;&gt;3Dプリントには3Dデータが必要&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;3Dプリントをするためには3Dデータが必要です&lt;/strong&gt;。3Dデータをモデリング（作成すること）方法はいくつかありますが、今回は3D CADソフトを使っています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/inventor.png&#34; alt=&#34;&#34; /&gt;
僕はAutodeskの「&lt;a href=&#34;https://www.autodesk.co.jp/products/inventor/overview&#34;&gt;&lt;strong&gt;Inventor&lt;/strong&gt;&lt;/a&gt;」を使ってデータを作成しました。有料ソフトですが、なんと&lt;strong&gt;学生だと3年間無料で&lt;/strong&gt;つかえます！&lt;/p&gt;

&lt;p&gt;Inventorは本格的な機械設計向きなので、簡単に試したい人は同じくAutodeskの「&lt;a href=&#34;https://www.autodesk.co.jp/products/fusion-360/overview&#34;&gt;&lt;strong&gt;fusion360&lt;/strong&gt;&lt;/a&gt;」の方がとっつきやすいかと思います。こちらも個人利用の場合は無料です。&lt;/p&gt;

&lt;p&gt;3D CADソフトは他にも&lt;a href=&#34;https://www.rs-online.com/designspark/mechanical-software-jp&#34;&gt;DesignSpark Mechanical&lt;/a&gt;や&lt;a href=&#34;https://www.freecadweb.org/?lang=ja&#34;&gt;FreeCAD&lt;/a&gt;などいくつかあるので、自分が使いやすいと思ったものを使うと良いでしょう。&lt;/p&gt;

&lt;p&gt;さらにもう一つ。
プログラマーのためにGithubがあるなら、&lt;strong&gt;メカ系エンジニアのために&lt;a href=&#34;https://grabcad.com/&#34;&gt;GrabcCAD&lt;/a&gt;というものがあります&lt;/strong&gt;。
&lt;img src=&#34;https://dotstud.io/img/blog/149/grabccad.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで、世界中のエンジニアが製作した様々なモデリングを閲覧したり使用したりできます。もし複雑なパーツをモデリングすることが難しければ、GrabCADを参考にしてみるのも手だと思います。&lt;/p&gt;

&lt;h3 id=&#34;trinusの組み立て&#34;&gt;Trinusの組み立て&lt;/h3&gt;

&lt;p&gt;Trinusの組み立てに関しては説明書をご覧ください。
また、日本語の公式サイトもあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;http://www.trinusjapan.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/community.png&#34; alt=&#34;&#34; /&gt;
http://trinusjapan.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;trinus用ソフト-pango-をインストール&#34;&gt;Trinus用ソフト「Pango」をインストール&lt;/h3&gt;

&lt;p&gt;Trinusで3Dプリントするには、モデリングしたものを扱う専用ソフト「Pango」が必要です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://trinusjapan.com/softwaredownload/&#34;&gt;こちらのリンク&lt;/a&gt;からインストールしてください。&lt;/p&gt;

&lt;h2 id=&#34;3dプリントに挑戦&#34;&gt;3Dプリントに挑戦！&lt;/h2&gt;

&lt;h3 id=&#34;プリンタ側の準備&#34;&gt;プリンタ側の準備&lt;/h3&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://trinusjapan.com/firstprint/&#34;&gt;公式サイト&lt;/a&gt;にのっているので、要点だけ説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/printer.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まず、Trinusの電源をいれるため、コンセントにつなげましょう。電源がつくと「ビッ」という音がします。&lt;/p&gt;

&lt;h3 id=&#34;pangoにデータを取り込む&#34;&gt;Pangoにデータを取り込む&lt;/h3&gt;

&lt;p&gt;パソコンからデータ（stlファイル）をPangoで開きましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/1.png&#34; alt=&#34;&#34; /&gt;
①のように「書き出し」から「CAD形式」を選択し、stl形式で保存します。&lt;strong&gt;サイズがモデリングと一致&lt;/strong&gt;しているかしっかりと確認してください。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/2.png&#34; alt=&#34;&#34; /&gt;
Pangoでstlファイルを開くと&lt;strong&gt;何故かサイズが10分の1&lt;/strong&gt;になってしまうので（dotstudioだけで起こる現象なのか不明）、元のサイズに戻します。③と④のように比率（Ratio）を10に変えます。Amountは寸法を意味していて、単位はmmです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/3.png&#34; alt=&#34;&#34; /&gt;
必要があれば3Dプリントしやすいようにモデルの向きを変えましょう。&lt;strong&gt;どのような向きで出力するか&lt;/strong&gt;、これがとても大事です！印刷中に思いがけない失敗を引き起こすことになります。&lt;/p&gt;

&lt;p&gt;⑤のように赤丸部をクリックすると回転軸の表示が出ます。そして、回転したい軸にマウスポインタを持っていきます。⑥のように回転する軸が強調されます。マウスで操作する場合はホイールを動かすことで回転させることができます。パソコンにあるタッチパッドの場合は2本の指で、上下になぞるように動かすと回転します（Windowsの場合）。&lt;/p&gt;

&lt;h3 id=&#34;印刷のシミュレーション&#34;&gt;印刷のシミュレーション&lt;/h3&gt;

&lt;p&gt;実際にどのように印刷が進められるかPango上で確認することもできます。Pangoの上部にある「View」から「Layer」をクリックしてください。
&lt;img src=&#34;https://dotstud.io/img/blog/149/4.png&#34; alt=&#34;&#34; /&gt;
すると自分がモデリングしたもの以外に格子状のモデリング（濃いピンクの部分）が追加されています。これは「&lt;strong&gt;ラフト&lt;/strong&gt;」と呼ばれ、3Dプリンタの印刷面と出力するものの間に積層される荒い土台のことです。&lt;/p&gt;

&lt;p&gt;これがあると出力した後に製作物を外しやすく、最終的には除去してゴミとして捨てることができます。&lt;/p&gt;

&lt;h3 id=&#34;データをtrinusに移す&#34;&gt;データをTrinusに移す&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/5.png&#34; alt=&#34;&#34; /&gt;
データをSDカードに「pcode」形式で保存します。図の赤丸部をクリックし、SDカードにデータをpcode形式で保存します。この形式は、Torinusで出力するために必要な形式です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/6.png&#34; alt=&#34;&#34; /&gt;
SDカードをTorinusに接続し、TorinusとパソコンをUSB接続します。&lt;/p&gt;

&lt;h3 id=&#34;出力設定を調整&#34;&gt;出力設定を調整&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/7.png&#34; alt=&#34;&#34; /&gt;
Pango上部の「Preference」から「Setting」を選択します。ここでは、出力するスピードや厚みなどを設定することができます。&lt;strong&gt;設定はあまりいじる必要はない&lt;/strong&gt;ので、眺めおきましょう！（ただし今回は試行錯誤の結果、Thickness: 0.2mm、Print Speed: 40mm/sとしています）&lt;/p&gt;

&lt;h3 id=&#34;重要-出力位置の初期位置を調整&#34;&gt;【重要】出力位置の初期位置を調整&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/8.png&#34; alt=&#34;&#34; /&gt;
TorinusとパソコンをUSB接続した状態でPango上部の「View」から「Console」をクリックします。上のような画像が出たら、さらに「Console」をクリックします。　&lt;/p&gt;

&lt;p&gt;そうすると下記のような設定画面があらわれます。&lt;strong&gt;この画面で行う設定が非常に重要です&lt;/strong&gt;。
&lt;img src=&#34;https://dotstud.io/img/blog/149/9.png&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;まず「Home」をクリック&lt;/strong&gt;します。これで、3Dプリンタのノズル（フィラメントが出る部分）が初期位置に戻ります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/10.png&#34; alt=&#34;&#34; /&gt;
ここで&lt;strong&gt;z軸の距離（ノズルから出力される面の高さ、画像でいう赤い矢印部分）を確認&lt;/strong&gt;してください。その距離が初期位置で広すぎると上手く出力されません。なので、目視でその距離を縮めましょう。「Offset」をクリックすると&lt;strong&gt;z軸方向の距離を上下&lt;/strong&gt;することができます。&lt;/p&gt;

&lt;h3 id=&#34;出力を開始&#34;&gt;出力を開始！&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/149/9.png&#34; alt=&#34;&#34; /&gt;
位置設定が終わったら、「&lt;strong&gt;Heat E」をクリック&lt;/strong&gt;し3Dプリンタのノズルを温めます。どれくらい温まっているかは、Console画面の左下に示す数字（分数部分）で表されます。最後に右のSDカードのイラスト部分をクリックし、保存したpcodeファイルを指定します。3Dプリンタのノズルが十分に温まれば自動で出力が始まります！&lt;/p&gt;

&lt;h3 id=&#34;出力直後にやるべきこと&#34;&gt;出力直後にやるべきこと&lt;/h3&gt;

&lt;p&gt;出力が始まるとその直後に、&lt;strong&gt;ノズルから溶け出たフィラメント&lt;/strong&gt;が垂れてきます。&lt;strong&gt;垂れて固まったフィラメントは出力の邪魔になることもあるので、ピンセットで取り除きましょう&lt;/strong&gt;。下記の図の赤丸で囲った部分がその例です。
&lt;img src=&#34;https://dotstud.io/img/blog/149/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;あとは見守りながら完成するまで放置しましょう。&lt;/p&gt;

&lt;h2 id=&#34;はじめての出力&#34;&gt;はじめての出力&lt;/h2&gt;

&lt;p&gt;プリンタとデータをセットして出力されるのを待ちます……。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/212276/c7659ea8-e54a-f50a-400a-183218006215.gif&#34; alt=&#34;出力.gif&#34; /&gt;&lt;/p&gt;

&lt;p&gt;完成しました。
&lt;img src=&#34;https://dotstud.io/img/blog/149/完成1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;哲学的なゴミです。特に用途はありません。
&lt;img src=&#34;https://dotstud.io/img/blog/149/完成2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3dプリンタを使うときに注意すること&#34;&gt;3Dプリンタを使うときに注意すること&lt;/h2&gt;

&lt;p&gt;セットアップの説明でも述べましたが、3Dプリンターを使ってみて注意した方が良い点をもう一度まとめます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pango上でモデリングのサイズを要チェック&lt;/li&gt;
&lt;li&gt;モデリングしたものをどの向きで出力するか&lt;/li&gt;
&lt;li&gt;初期位置の設定を正確に！（特にz軸方向）&lt;/li&gt;
&lt;li&gt;出力直後に溶け出したフィラメントを必ず除去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3Dプリンタは複雑なものを簡単に出力できるイメージですが、実際に使ってみると経験やコツがいります。やはり、どんな道具も使いこなせるようになるには時間が必要なようです。&lt;/p&gt;

&lt;p&gt;まだまだ3Dプリンターを使う上で学ぶことが多いと感じたので、継続して使っていきたいと思います。&lt;/p&gt;

&lt;p&gt;それではまた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google公式ライブラリを利用してNode.jsからGmailの送受信をしてみよう</title>
      <link>https://dotstud.io/blog/gmail-api-from-nodejs/</link>
      <pubDate>Wed, 21 Feb 2018 17:43:26 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/gmail-api-from-nodejs/</guid>
      
      <description>

&lt;p&gt;こんにちは、のびすけです。&lt;/p&gt;

&lt;p&gt;Node.jsでGmailを制御する方法は、過去に色々な記事が出ているのですが、全体的に記事が古く、&lt;a href=&#34;https://developers.google.com/gmail/api/quickstart/nodejs?hl=ja&#34;&gt;Gmail API Node.js Quickstart&lt;/a&gt;のチュートリアルも割とわかりにくいなぁという印象です。英語しかないし。&lt;/p&gt;

&lt;p&gt;また、勝手ライブラリも多いのですがメンテナンスされてなく利用していく際の不安も多いです。&lt;/p&gt;

&lt;p&gt;ということで、今日はNode.jsでGmailを使う方法の紹介です。&lt;/p&gt;

&lt;p&gt;以前書いたSpreadSheets記事も同様のGoogle APIライブラリを利用しているので基本的な手順は同じです。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/google-spreadsheets-from-nodejs/&#34;&gt;Node.jsでGoogle SpreadSheetsを操作してみよう。【GAS不使用】&lt;/a&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/135/00_eyecatch.png&#34; width=&#34;400px&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;gmail-apiの有効化とクライアントシークレットの取得&#34;&gt;Gmail APIの有効化とクライアントシークレットの取得&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://console.developers.google.com/start/api?id=gmail&amp;amp;hl=ja&#34;&gt;こちらのリンク&lt;/a&gt;からウィザード開始します。ログインしているGoogleアカウントが利用するGmailのアカウントになるので複数のGoogleやG Suiteのアカウントを持っている人は注意しましょう。&lt;/p&gt;

&lt;p&gt;チェックをして進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/7aa9886c3113712265ee866ed58f6658.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;少し待つとAPIが有効になるので進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/2babe62f7ce826080545439c3c2675d9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証情報に進みますが&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例によってこの画面は何もせずに&lt;code&gt;キャンセル&lt;/code&gt;ボタンを押しましょう。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/1934915770a80c6fab94ee9818f9cf65.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このダッシュボード画面になりますが、&lt;code&gt;OAuth同意画面&lt;/code&gt;のタブを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/7f28a9c626ea9f2ecd0b4691ef337859.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ユーザーに表示するサービス名&lt;/code&gt;の箇所に任意の名前を入力して、保存を押して進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/b93e391525943007cddd5de87a22acbf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証情報タブに戻り、&lt;code&gt;認証情報を作成&lt;/code&gt; -&amp;gt; &lt;code&gt;OAuthクライアントID&lt;/code&gt;を選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/57b7c424a42dd9fedaed483ebbf5d84b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;クライアントID作成画面では&lt;code&gt;その他&lt;/code&gt;を選択し、任意の名前を入力します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/124eeda9adf92739b1eff9b1e3afcb42.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;作成すると最初のダッシュボード画面に戻りますが、作成したクライアントIDが表示されています。ここの右下のダウンロードボタンを押すとクライアントシークレットが保存されたJSONファイルがダウンロードされます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/64db51910795b26e05aef6cb9918c33f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;任意の場所に&lt;code&gt;client_secret.json&lt;/code&gt;という名前にリネームして保存しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/8a4b65dfb3319eee11ddea1d0e7d407d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これで、 &lt;strong&gt;クライアントシークレットの保存が出来ました。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;node-jsプロジェクトの準備&#34;&gt;Node.jsプロジェクトの準備&lt;/h2&gt;

&lt;p&gt;Node.jsはv9.5.0です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir gmail
cd gmail
npm init -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先ほどの&lt;code&gt;client_secret.json&lt;/code&gt;をこのディレクトリに移動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls

package.json client_secret.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ライブラリのインストールをすれば準備完了です。google-auth-libraryのバージョンは1.3.1になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm i googleapis google-auth-library --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで準備完了です。&lt;/p&gt;

&lt;h2 id=&#34;アクセストークンの保存&#34;&gt;アクセストークンの保存&lt;/h2&gt;

&lt;p&gt;本家とは少し違うやり方です。&lt;/p&gt;

&lt;p&gt;本家のコードだとアクセストークンの作成&amp;amp;保存作業と実際のAPI呼び出しが一緒になったコードですがトークンの作成&amp;amp;保存は最初のみ行えば良いので手順を分けて紹介します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getAndStoreToken.js&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dotstud.io/blog/google-spreadsheets-from-nodejs/&#34;&gt;前回の記事のコード&lt;/a&gt;とほぼ同様ですが、APIライブラリのバージョンの違いにより、呼び出し方が少し異なります。注意しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//getAndStoreToken.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const readline = require(&#39;readline&#39;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
const {promisify} = require(&#39;util&#39;);

const {google} = require(&#39;googleapis&#39;);
const {OAuth2Client} = require(&#39;google-auth-library&#39;);

//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const rlQuestionAsync = promisify(rl.question);

const SCOPES = [&#39;https://www.googleapis.com/auth/gmail.send&#39;,&#39;https://www.googleapis.com/auth/gmail.readonly&#39;];
const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR+&#39;/gmail-nodejs-quickstart.json&#39;;

const main = async () =&amp;gt; {
    const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;);
    const credentials = JSON.parse(content); //クレデンシャル
    //認証
    const clientSecret = credentials.installed.client_secret;
    const clientId = credentials.installed.client_id;
    const redirectUrl = credentials.installed.redirect_uris[0];
    const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);

    //get new token
    const authUrl = oauth2Client.generateAuthUrl({
        access_type: &#39;offline&#39;,
        scope: SCOPES
    });

    console.log(&#39;Authorize this app by visiting this url: &#39;, authUrl);

    rl.question(&#39;Enter the code from that page here: &#39;, (code) =&amp;gt; {
        rl.close();

        oauth2Client.getToken(code, async (err, token) =&amp;gt; {
            if (err) {
                console.log(&#39;Error while trying to retrieve access token&#39;, err);
                return;
            }

            oauth2Client.credentials = token;

            try {
                fs.mkdirSync(TOKEN_DIR);
            } catch (err) {
                if (err.code != &#39;EEXIST&#39;) throw err;
            }

            await writeFileAsync(TOKEN_PATH, JSON.stringify(token));
            console.log(&#39;Token stored to &#39; + TOKEN_PATH);
        });
    });
};

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで&lt;code&gt;&#39;https://www.googleapis.com/auth/gmail.readonly&#39;,&#39;https://www.googleapis.com/auth/gmail.send&#39;&lt;/code&gt;の二つのスコープを指定していますが、表示用のgmail.readonlyとメール送信用のgmail.sendとなっています。表示だけしたい場合や送信だけしたい場合などで使い分けましょう。スコープについては&lt;a href=&#34;https://developers.google.com/gmail/api/auth/scopes&#34;&gt;
Choose Auth Scopes&lt;/a&gt;で細かく確認できます。&lt;/p&gt;

&lt;p&gt;では、このプログラムを実行しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node getAndStoreToken.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/379de8711e19b5510225e167de555ab6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://accounts.google.com/~&lt;/code&gt;で始まるURLが表示されるのでこれをコピーしてブラウザで開きます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/06afa961-4789-535b-3fee-8eaf67a997af.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;アカウント選択画面になります。 複数Googleアカウントを持っている人は、今回アクセスしようとしているアカウントを選択します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/c5f18901079fc0f4c0362cb0213e89c6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;許可で進みます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://qiita-image-store.s3.amazonaws.com/0/35387/6058bd3e-258f-1d8d-a7c6-68962617f1b2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;認証用のコードが発行されるので、ターミナルの&lt;code&gt;Enter the code from that page here:&lt;/code&gt;と書いてある箇所にコピぺしてEnterで進みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Token stored to /Users/path/to/myapp/gmail-nodejs-quickstart.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;などの表示が出て、&lt;code&gt;gmail-nodejs-quickstart.json&lt;/code&gt;が保存されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/4fc90f71b3520a01ce2c568eb28e005f.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これでアクセストークンの保存が完了しました。&lt;/p&gt;

&lt;h2 id=&#34;4-いよいよgmailにアクセス&#34;&gt;4. いよいよGmailにアクセス&lt;/h2&gt;

&lt;p&gt;いよいよGmailにアクセスします。&lt;/p&gt;

&lt;h3 id=&#34;ラベル一覧の取得&#34;&gt;ラベル一覧の取得&lt;/h3&gt;

&lt;p&gt;本家チュートリアルを参考に、ラベルの一覧を取得します。
&lt;code&gt;getLabels.js&lt;/code&gt;を作成します。&lt;/p&gt;

&lt;p&gt;ここから先に出てくる&lt;code&gt;userId: &#39;me&#39;&lt;/code&gt;の&lt;code&gt;me&lt;/code&gt;は指定されている文字列らしく、自分のメアドやアカウント名をあえて指定する必要はなくそのまま&lt;code&gt;me&lt;/code&gt;と書いておけば問題なさそうです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//getLabels.js
&#39;use strict&#39;;

const fs = require(&#39;fs&#39;);
const {promisify} = require(&#39;util&#39;);
const {google} = require(&#39;googleapis&#39;);
const {OAuth2Client} = require(&#39;google-auth-library&#39;);
const gmail = google.gmail(&#39;v1&#39;);

//promisifyでプロミス化
const readFileAsync = promisify(fs.readFile);
const gmailListLabesAsync = promisify(gmail.users.labels.list); //Gmailのラベル一覧

const TOKEN_DIR = __dirname;
const TOKEN_PATH = TOKEN_DIR + &#39;/gmail-nodejs-quickstart.json&#39;; //アクセストークンのファイルを指定

const main = async () =&amp;gt; {
    //クレデンシャル情報の取得
    const content = await readFileAsync(__dirname+&#39;/client_secret.json&#39;); //クライアントシークレットのファイルを指定
    const credentials = JSON.parse(content); //クレデンシャル

    //認証
    const clientSecret = credentials.installed.client_secret;
    const clientId = credentials.installed.client_id;
    const redirectUrl = credentials.installed.redirect_uris[0];
    const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
    const token = await readFileAsync(TOKEN_PATH);
    oauth2Client.credentials = JSON.parse(token);

    //API経由でシートにアクセス
    const response = await gmailListLabesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;,
    });
    //結果を表示
    console.log(response.data);
};

main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Async/Awaitで利用できるように&lt;code&gt;const gmailListLabesAsync = promisify(gmail.users.labels.list);&lt;/code&gt;の箇所でPromisifyを利用してプロミス化しています。&lt;/p&gt;

&lt;p&gt;実行するとラベル一覧が取得できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node getLabels.js

{ labels:
   [ { id: &#39;Label_125&#39;,
       name: &#39;研修/青山学院大学&#39;,
       messageListVisibility: &#39;show&#39;,
       labelListVisibility: &#39;labelShow&#39;,
       type: &#39;user&#39;,
       color: [Object] },
     { id: &#39;Label_40&#39;,
       name: &#39;取引/養老乃瀧&#39;,
       messageListVisibility: &#39;show&#39;,
       labelListVisibility: &#39;labelShow&#39;,
       type: &#39;user&#39;,
       color: [Object] },
       
       ・
       ・
       ・
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会社のメールの内容なので出せるところだけ笑&lt;/p&gt;

&lt;h3 id=&#34;メールの内容を取得&#34;&gt;メールの内容を取得&lt;/h3&gt;

&lt;p&gt;メールの内容は&lt;code&gt;Users.messages: list&lt;/code&gt;と&lt;code&gt;Users.messages: get&lt;/code&gt;を利用します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/get&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/get&lt;/a&gt;
&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/list&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;必要な箇所だけ抜粋しますが、&lt;code&gt;gmail.users.messages.list()&lt;/code&gt;と&lt;code&gt;gmail.users.messages.get()&lt;/code&gt;というメソッドがあるので利用します。
Async/Awaitで利用できるように、先ほど同様Promisifyします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const gmailGetMessagesAsync = promisify(gmail.users.messages.get); 
const gmailListMessagesAsync = promisify(gmail.users.messages.list);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;メッセージリストを取得し、メッセージごとのIDを取得します。メッセージIDをもとにメッセージ本文を取得。
最後に本文はBase64変換されてるのでデコードして表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;省略

    //メッセージリストの取得
    let res = await gmailListMessagesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;
    });
    const newestMessageId = res.messages[0].id; //最新のメッセージID

    //メッセージの取得
    res = await gmailGetMessagesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;,
        id: newestMessageId
    });
    //結果を表示
    const base64mailBody = res.payload.parts[0].body.data; //parts[0]がテキスト、parts[1]がHTMLメールっぽい(?)
    const mailBody = new Buffer(base64mailBody, &#39;base64&#39;).toString(); //メール本文はBase64になってるので変換
    console.log(mailBody);//やっとメール本文が表示される

省略
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;メールの送信&#34;&gt;メールの送信&lt;/h3&gt;

&lt;p&gt;送信が割と大変でした。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Users.messages: send&lt;/code&gt;を利用します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/send&#34;&gt;https://developers.google.com/gmail/api/v1/reference/users/messages/send&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;gmail.users.messages.send()&lt;/code&gt;のメソッドを利用します。
先ほどと同様にPromisifyします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const gmailSendMessagesAsync = promisify(gmail.users.messages.send);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次にメール送信時の処理です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;省略

    const makeBody = (params) =&amp;gt; {
        params.subject = new Buffer(params.subject).toString(&amp;quot;base64&amp;quot;); //日本語対応

        const str = [
            `Content-Type: text/plain; charset=\&amp;quot;UTF-8\&amp;quot;\n`,
            `MIME-Version: 1.0\n`,
            `Content-Transfer-Encoding: 7bit\n`,
            `to: ${params.to} \n`,
            `from: ${params.from} \n`,
            `subject: =?UTF-8?B?${params.subject}?= \n\n`,
            params.message
        ].join(&#39;&#39;);
        return new Buffer(str).toString(&amp;quot;base64&amp;quot;).replace(/\+/g, &#39;-&#39;).replace(/\//g, &#39;_&#39;);
    }
    
    const messageBody = `
        XXXX 様

        商品のご購入、誠にありがとうございます。
        ・Nefry BT x 1
        の商品を本日発送しましたのでご連絡差し上げます。
        
        こちらから配送状況をご確認頂けます。
        (このメール送信の時点では反映されていない可能性もあります)

        https://trackings.post.japanpost.jp/xxxxxxxxxx`;

    const raw = makeBody({
        to: &#39;相手のメールアドレス&#39;,
        from: &#39;送信者のメールアドレス&#39;,
        subject: &#39;件名(日本語可)&#39;,
        message: messageBody
    });

    const res = await gmailSendMessagesAsync({
        auth: oauth2Client,
        userId: &#39;me&#39;,
        resource: {
          raw: raw
        }
    });
    console.log(res.data);

省略
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sendMail.js&lt;/code&gt;などを作成し、この内容で実行するとメールが送信できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node sendMail.js

{ id: &#39;xxxxxxxxxxxxxxxxx&#39;,
  threadId: &#39;xxxxxxxxxxxxxxxx&#39;,
  labelIds: [ &#39;SENT&#39; ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gmail側で受信確認をすると、しっかりと送られてきています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/3ad5f4729e90c9523e2e6e5cb972349b.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;また、暗号化もされているようで、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/mail/answer/6330403?authuser=2&amp;amp;visit_id=1-636548034928176578-836942562&amp;amp;p=tls&amp;amp;hl=ja&amp;amp;rd=1&#34;&gt;送受信時のメールの暗号化 - Gmailヘルプ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.gyazo.com/247eb44de5f0b635d52fd2b0c06a4de3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Node.jsのメール送信ライブラリはいくつかあって、いくつか試したときに暗号化されてない場合も多かった印象です。暗号化無しだと、この赤いアラートっぽいメール表示になります。&lt;/p&gt;

&lt;p&gt;今回のやり方はGoogle公式のライブラリで、特に意識せずに暗号化も行われているので暗号化に対するアラートなども受け取り手には表示されないので迷惑メールなどに振り分けられてしまう心配もたぶん少ないのでは。
（Gmailの迷惑メールアルゴリズムは色々な要素がありそうなので断言は出来ないですが）&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;実装途中の感想ですが、メール送信が割と苦労した印象です。&lt;/p&gt;

&lt;p&gt;メール送信のNode.jsサンプルが無かったので、&lt;a href=&#34;https://developers.google.com/gmail/api/v1/reference/users/messages/send#examples&#34;&gt;JavaScript Sample&lt;/a&gt;を見ると、送信パラメータに&lt;code&gt;email RFC 5322 formatted String.&lt;/code&gt;という記述があってRFCのフォーマットを確認する必要がありました。&lt;/p&gt;

&lt;p&gt;この手のライブラリだと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const params = {
    to: &#39;&#39;,
    from: &#39;&#39;,
    subject: &#39;&#39;,
    body: &#39;&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいな形式のObjectを突っ込めばいい感じにやってくれる印象があったので&amp;hellip;&amp;hellip;苦笑&lt;/p&gt;

&lt;p&gt;Stack Over Flowの&lt;a href=&#34;https://stackoverflow.com/questions/34546142/gmail-api-for-sending-mails-in-node-js&#34;&gt;Gmail API for sending mails in Node.js&lt;/a&gt;がかなり参考になりました。&lt;/p&gt;

&lt;p&gt;また、日本語でのSubject送信に&lt;code&gt;=?文字コード?メソッド?Base64変換した文字列?=&lt;/code&gt;という形式で渡すなどは&lt;a href=&#34;http://hogem.hatenablog.com/entry/20100122/1264169093&#34;&gt;メールのSubjectヘッダのエンコード&lt;/a&gt;の記事が参考になりました。&lt;/p&gt;

&lt;p&gt;とはいえ、問題なくメール送信出来たので、この記事を参考に使ってみてください。&lt;/p&gt;

&lt;p&gt;それでは！&lt;/p&gt;

&lt;h2 id=&#34;補足-本家のチュートリアルのエラー&#34;&gt;補足: 本家のチュートリアルのエラー&lt;/h2&gt;

&lt;p&gt;今回紹介した手順では問題ないですが、もともとのチュートリアルのコードだと以下の二つのエラーが出ました。(2018年2月時点)&lt;/p&gt;

&lt;h3 id=&#34;google-gmail-is-not-a-function&#34;&gt;google.gmail is not a function&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;google.gmail() is giving an error TypeError: google.gmail is not a function?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ってエラーが出ました。&lt;/p&gt;

&lt;p&gt;Stack Over Flowの&lt;a href=&#34;https://stackoverflow.com/questions/48762090/google-gmail-is-giving-an-error-typeerror-google-gmail-is-not-a-function&#34;&gt;google.gmail() is giving an error TypeError: google.gmail is not a function?&lt;/a&gt;を参考に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var google = require(&#39;googleapis&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを↓に変更するとエラー解消されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var {google} = require(&#39;googleapis&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;googleauth-is-not-a-constructor&#34;&gt;GoogleAuth is not a constructor&lt;/h3&gt;

&lt;p&gt;こちらはIssueがあがっていて&lt;a href=&#34;https://github.com/google/google-auth-library-nodejs/issues/251&#34;&gt;GoogleAuth is not a constructor #251&lt;/a&gt;を見ると、&lt;/p&gt;

&lt;p&gt;呼び出し方が変更されてて、以下の修正が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { GoogleAuth } = require(&#39;google-auth-library&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;↓&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { OAuth2Client } = require(&#39;google-auth-library&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、今の変更に伴いOAuthの処理も変更が必要です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const auth = new googleAuth();
const oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;↓&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//const auth = new googleAuth();
const oauth2Client = new OAuth2Client(clientId, clientSecret, redirectUrl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで問題なく利用できるようになりました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラブでモテる！つまみ付きユニコーンポーチ　前編</title>
      <link>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette/</link>
      <pubDate>Thu, 15 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette/</guid>
      
      <description>

&lt;p&gt;みなさん、ちょりおつ！ギャル電きょうこです。ギャルによるギャルのためのテクノロジーを提案するユニット、ギャル電で活動しています。今回は、&lt;strong&gt;クラブ行くときにぎゃんかわに盛れる光るポーチの作り方&lt;/strong&gt;を2回にわけて紹介します。&lt;/p&gt;

&lt;h2 id=&#34;ユニコーンきゃわたん&#34;&gt;ユニコーンきゃわたん&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ちょっと前から、イケてるヤングの間ではユニコーンがはやってるっぽい。角生えてる馬、かっこいいしかわいいからはやるのも超わかりみある。&lt;/p&gt;

&lt;p&gt;つーことで、イケてるユニコーンっぽいバッグが街には今いっぱい売ってる。今回は、&lt;strong&gt;WEGOで500円のサイズ感もぴったりな超イケてるポーチ&lt;/strong&gt;をゲット。めっちゃリーズナブル！！！！&lt;/p&gt;

&lt;p&gt;コレ光らせたらやばくねってことで、さっそく作ってこう。&lt;/p&gt;

&lt;h2 id=&#34;材料&#34;&gt;材料&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;①Arduino Nano 互換機&lt;/li&gt;
&lt;li&gt;②可変抵抗 10KΩ 3個&lt;/li&gt;
&lt;li&gt;③つまみのキャップ&lt;/li&gt;
&lt;li&gt;④LEDテープ（WS2812B 60LED/M）LED24個分&lt;/li&gt;
&lt;li&gt;線材（コネクタは気分で）&lt;/li&gt;
&lt;li&gt;USB miniB ケーブル&lt;/li&gt;
&lt;li&gt;プラ板&lt;/li&gt;
&lt;li&gt;ユニコーンぽいファーのいい感じのポーチ（白系）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;材料はこんな感じ。つまみのキャップはギター用のカッコいいやつを使ったよ。ポーチはだいたいモバイルバッテリーと小銭と携帯が入るくらいのサイズ感のものがおすすめっす。&lt;/p&gt;

&lt;h2 id=&#34;可変抵抗器をアクセントにしてみよう&#34;&gt;可変抵抗器をアクセントにしてみよう&lt;/h2&gt;

&lt;p&gt;可変抵抗器はイケてるキャップをつけるとめっちゃかわいい！&lt;/p&gt;

&lt;p&gt;今回は三つの可変抵抗器の値を変更することで、LEDの&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;明るさ&lt;/li&gt;
&lt;li&gt;色&lt;/li&gt;
&lt;li&gt;点灯速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を変更できる仕組みをつくります。&lt;/p&gt;

&lt;h2 id=&#34;配線をはんだ付けしよう&#34;&gt;配線をはんだ付けしよう&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;まずは写真と図のように三つの可変抵抗器のプラスとプラス、マイナスとマイナスを配線でつなぎます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/5.png&#34; alt=&#34;&#34; /&gt;
三つのうちの可変抵抗器の一つに、プラスとマイナスの配線をさらに1セット追加してArduino Nanoの5VとGNDにつなぎます。可変抵抗器の真ん中の線とAruduino NanoのA0〜A1ポートを配線でそれぞれつなぎます。&lt;/p&gt;

&lt;p&gt;LEDテープはDINとD6、5V、GNDをそれぞれAruduino Nanoと配線でつなぎます。
&lt;img src=&#34;https://dotstud.io/img/blog/146/6.png&#34; alt=&#34;&#34; /&gt;
Aruduino Nanoの5VとGNDのところは、可変抵抗器とLEDテープからそれぞれ配線がつながります。一つのPINにはんだ付けが難しい場合は、ボードの裏と表にそれぞれ1本ずつ配線をつなげるとはんだ付けがやりやすいです。&lt;/p&gt;

&lt;h2 id=&#34;前編はここまで&#34;&gt;前編はここまで&lt;/h2&gt;

&lt;p&gt;今回は可変抵抗器を三つつなげたので、ちょっと配線とはんだ付けが複雑で疲れちゃったのでここまで！&lt;/p&gt;

&lt;p&gt;後編はArduino Nanoへのプログラム書き込みと、ポーチとLEDを組み立てまっす！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/gyaruden-kyoko-unicorn-pochette2/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/146/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 後編をチェック！
&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScriptで開発できる！Mongoose OSでNefry BTをLチカしよう</title>
      <link>https://dotstud.io/blog/mongoose-os-nefry-blink/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/mongoose-os-nefry-blink/</guid>
      
      <description>

&lt;p&gt;唐突ですが、森田(&lt;a href=&#34;https://twitter.com/morita_pac&#34;&gt;@morita_pac&lt;/a&gt;)と申します。&lt;/p&gt;

&lt;p&gt;ヘビーNefryBTユーザです。持ち歩いていろんな場所でNefry BTを利用したり、ケースを作ったりもしています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常Nefry BTはArduino言語でプログラムするのですが、今回はJavaScriptで書き込めるようにしたいと思います。&lt;/p&gt;

&lt;p&gt;※この記事内のプログラムはNefy BT（無印）向けです。Nefry BT R2向けのプログラムは別途準備中です。&lt;/p&gt;

&lt;h2 id=&#34;javascriptで開発できるmongoose-osとは&#34;&gt;JavaScriptで開発できるMongoose OSとは&lt;/h2&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://mongoose-os.com/&#34;&gt;Mongoose OS&lt;/a&gt;というIoTのプロト開発を簡単にできるサービスを利用します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://mongoose-os.com/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/2.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ Mongoose OS公式サイト
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Mongoose OSでは、ESP32やESP8266へJavaScript（&lt;a href=&#34;https://github.com/cesanta/mjs&#34;&gt;mJS&lt;/a&gt;）でコードを書き込めます。
さらには、セキュアで、AWS IoTやGoogleのCloud IoT Coreなどとも連携設定がシンプルにできます。&lt;/p&gt;

&lt;p&gt;Mongoose OSをインストールしている間は元のNefry BTのプログラムは利用できなくなります。（Arduino IDEで書き込むことですぐに戻せます。）&lt;/p&gt;

&lt;h2 id=&#34;mongoose-osの開発環境をセットアップ&#34;&gt;Mongoose OSの開発環境をセットアップ&lt;/h2&gt;

&lt;h3 id=&#34;windowsの場合&#34;&gt;Windowsの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://mongoose-os.com/software.html&#34;&gt;Download Page&lt;/a&gt;から、exeをダウンロードするだけで使えます。（アンチウイルス系のソフトが反応するかもしれません。）なお、以降MacOSでの説明になります。
&lt;img src=&#34;https://dotstud.io/img/blog/145/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mac-osの場合&#34;&gt;Mac OSの場合&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://mongoose-os.com/software.html&#34;&gt;Download Page&lt;/a&gt;の、MacOS/Linuxのcurlコマンドをターミナルで実行します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://mongoose-os.com/downloads/mos/install.sh | /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ターミナルで以下のようになれば無事完了です。開く場合は、Runの&lt;code&gt;/xxx/.mos/bin/mos&lt;/code&gt;を実行するとWeb UIが開きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -fsSL https://mongoose-os.com/downloads/mos/install.sh | /bin/bash
Downloading https://mongoose-os.com/downloads/mos-release/mac/mos ...
########################################################################
 100.0%
Installing into /xxx/.mos/bin/mos ...
Adding /xxx/.mos/bin to your PATH in /xxx/.profile
SUCCESS: /xxx/.mos/bin/mos is installed.
Run &#39;/xxx/.mos/bin/mos --help&#39; to see all available commands.
Run &#39;/xxx/.mos/bin/mos&#39; without arguments to start a simplified Web UI installer.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;いざ-mongoose-osをnefry-btに入れてみよう&#34;&gt;いざ、Mongoose  OSをNefry BTに入れてみよう&lt;/h2&gt;

&lt;p&gt;Nefry BTをUSBポートに差し込み、Mongose OSとサンプルコードをFlashします。（次回起動時は、ポート選択のみで利用可能です。）&lt;/p&gt;

&lt;p&gt;Mongoose OSのWeb UIは、ブラウザで開きます。①②③の設定が完了すれば無事、JavaScriptで書き込む準備完了です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/145/5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;①は、Nefry BTのポートを選択します。ポートが見つからない場合はUSBを認識させるための&lt;a href=&#34;https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers&#34;&gt;ドライバ&lt;/a&gt;をインストールする必要があります。
②では、Platformで「esp32」とapp「demo-js」を選択し「Flash」ボタンをクリックし、処理が終わるまで待ちます。
③では、Wi-fi設定を行います。（今回は必須ではないです。）
全ての設定が完了したら、「Done」ボタンをおしてdevice setupを閉じます。&lt;/p&gt;

&lt;h1 id=&#34;4-基本的なweb-uiとサンプルプログラム&#34;&gt;4. 基本的なWeb UIとサンプルプログラム&lt;/h1&gt;

&lt;h3 id=&#34;web-uiについて&#34;&gt;Web UIについて&lt;/h3&gt;

&lt;p&gt;まず、画面左側Device Filesを選択します。すると、init.jsが選択され、メインプログラムが表示されます。init.jsファイルをメインで編集します。&lt;/p&gt;

&lt;p&gt;編集後、書き込みたい場合は、Save + Rebootボタンで行えます。このコードやファイルの情報は、端末から読んでいますので、コードを書き換えたら、書き込む前にバックアップを取っておくことをお勧めします。
&lt;img src=&#34;https://dotstud.io/img/blog/145/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;サンプルプログラムについて&#34;&gt;サンプルプログラムについて&lt;/h3&gt;

&lt;p&gt;デフォルトプログラムを僕の感性でコメントしましたので、ご確認ください。なお、色々と制限付きのJSなので、仕様は&lt;a href=&#34;https://github.com/cesanta/mjs&#34;&gt;こちら&lt;/a&gt;で確認ください。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;// 利用するAPIを読み出します。Flashした時点のサンプルAPIが呼ばれています。
// 各APIの仕様やサンプルは画面左のファイル一覧で参照可能です。
load(&#39;api_config.js&#39;);
load(&#39;api_events.js&#39;);
load(&#39;api_gpio.js&#39;);
load(&#39;api_mqtt.js&#39;);
load(&#39;api_net.js&#39;);
load(&#39;api_sys.js&#39;);
load(&#39;api_timer.js&#39;);

// 変数宣言はletのみです。const, varは使えません。
let led = Cfg.get(&#39;pins.led&#39;);
let button = Cfg.get(&#39;pins.button&#39;);
let topic = &#39;/devices/&#39; + Cfg.get(&#39;device.id&#39;) + &#39;/events&#39;;

print(&#39;LED GPIO:&#39;, led, &#39;button GPIO:&#39;, button);

let getInfo = function() {
  return JSON.stringify({
    total_ram: Sys.total_ram(),
    free_ram: Sys.free_ram()
  });
};

// 1秒おきにLEDをチカチカさせてます。ついでにチクタク時を刻んでいます。
GPIO.set_mode(led, GPIO.MODE_OUTPUT);
Timer.set(1000 /* 1 sec */, Timer.REPEAT, function() {
  let value = GPIO.toggle(led);
  print(value ? &#39;Tick&#39; : &#39;Tock&#39;, &#39;uptime:&#39;, Sys.uptime(), getInfo());
}, null);

// リセットボタンではない方のボタンを押すとMQTTでpublishします。
GPIO.set_button_handler(button, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 200, function() {
  let message = getInfo();
  let ok = MQTT.pub(topic, message, 1);
  print(&#39;Published:&#39;, ok, topic, &#39;-&amp;gt;&#39;, message);
}, null);

// ネットワークモニタです。
Event.addGroupHandler(Net.EVENT_GRP, function(ev, evdata, arg) {
  let evs = &#39;???&#39;;
  if (ev === Net.STATUS_DISCONNECTED) {
    evs = &#39;DISCONNECTED&#39;;
  } else if (ev === Net.STATUS_CONNECTING) {
    evs = &#39;CONNECTING&#39;;
  } else if (ev === Net.STATUS_CONNECTED) {
    evs = &#39;CONNECTED&#39;;
  } else if (ev === Net.STATUS_GOT_IP) {
    evs = &#39;GOT_IP&#39;;
  }
  print(&#39;== Net event:&#39;, ev, evs);
}, null);

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nefry-btのフルカラーledを点灯しよう&#34;&gt;Nefry BTのフルカラーLEDを点灯しよう&lt;/h2&gt;

&lt;p&gt;やっと本題に入ります。&lt;/p&gt;

&lt;p&gt;Mongoose OSでは、様々なオープンソースコードがあり、それをインポートすることができます。今回は、NefryBTのフルカラーLEDを点灯させるためにNeoPixelのサンプルコードを入手します。&lt;/p&gt;

&lt;p&gt;画面左のProjectsを選択し、Importをクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/145/7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;App Managerのサーチ部分に「neopixel」と入力し、HARDWAREから「example-neopixel-js」をimportします。完了したらApp Managerの画面を閉じます。
&lt;img src=&#34;https://dotstud.io/img/blog/145/8.png&#34; alt=&#34;&#34; /&gt;
次に、サンプルプログラムをNefryBTに書き込みます。&lt;/p&gt;

&lt;p&gt;今ImportしたAppが選択されていることを確認し、①Rebuildアイコンと②Flashアイコンを処理が完了次第、順番にクリックすることで書き込み完了です。（それぞれ少々時間がかかります。）
&lt;img src=&#34;https://dotstud.io/img/blog/145/9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Device Filesのinit.jsの内容を以下の内容に書き換えます。Nefry BTのボタンを押したらフルカラーLEDが点灯するという内容のプログラムです。&lt;/p&gt;

&lt;p&gt;※なお、R2に関しては動作確認中ですので、確認次第内容を変更いたします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js:init.js&#34;&gt;load(&#39;api_config.js&#39;);
load(&#39;api_events.js&#39;);
load(&#39;api_gpio.js&#39;);
load(&#39;api_sys.js&#39;);
load(&#39;api_timer.js&#39;);
load(&#39;api_neopixel.js&#39;);

// 今回は一部しか利用していませんが、NefryのピンNoです。
let pin = {
    &amp;quot;nefrybt&amp;quot;:{
      &amp;quot;sw&amp;quot;: 4,
      &amp;quot;d0&amp;quot;:22,
      &amp;quot;d1&amp;quot;:21,
      &amp;quot;d2&amp;quot;:23,
      &amp;quot;d3&amp;quot;:19,
      &amp;quot;d4&amp;quot;:18,
      &amp;quot;a0&amp;quot;:25,
      &amp;quot;a1&amp;quot;:26,
      &amp;quot;a2&amp;quot;:32,
      &amp;quot;a3&amp;quot;:33,
      &amp;quot;a4&amp;quot;:27,
      &amp;quot;a5&amp;quot;:14,
      &amp;quot;a6&amp;quot;:13,
      &amp;quot;a7&amp;quot;:35,
      &amp;quot;LED&amp;quot;:16
    },
    &amp;quot;nefrybtR2&amp;quot;:{
      &amp;quot;sw&amp;quot;: 4,
      &amp;quot;d0&amp;quot;:22,
      &amp;quot;d1&amp;quot;:21,
      &amp;quot;d2&amp;quot;:23,
      &amp;quot;d3&amp;quot;:19,
      &amp;quot;d4&amp;quot;:18,
      &amp;quot;d5&amp;quot;:25,
      &amp;quot;d6&amp;quot;:26,
      &amp;quot;d7&amp;quot;:13,
      &amp;quot;d8&amp;quot;:14,
      &amp;quot;a0&amp;quot;:33,
      &amp;quot;a1&amp;quot;:32,
      &amp;quot;a2&amp;quot;:39,
      &amp;quot;a3&amp;quot;:36,
      &amp;quot;LED&amp;quot;:16
    }
  };


// フルカラーLEDのピンと個数、オーダーを指定しています。
let Lpin = pin.nefrybt.LED, numPixels = 1, colorOrder = NeoPixel.GRB;

// api_neopixel.jsに基づき初期化を行います。
let strip = NeoPixel.create(Lpin, numPixels, colorOrder);
strip.clear();
strip.setPixel(0,0,0,0);
strip.show();

// ボタンを押したら赤色をつけます。setpixel(0,0,0,0)は、ピクセルナンバーとRGBになっています。Redの数字は20としていますが、数字をあげるとかなり明るくなります。
// GPIO.set_button_handlerの仕様は、
GPIO.set_button_handler(4, GPIO.PULL_UP, GPIO.INT_EDGE_NEG, 200, function() {
    strip.clear();
    strip.setPixel(0,20,0,0);
    strip.show();
}, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;困った時は&#34;&gt;困った時は&lt;/h2&gt;

&lt;p&gt;Q. DeviceLogsにエラーがでている。&lt;/p&gt;

&lt;p&gt;A. Mongoose OS画面右上のdevice setupより、ポートを選択し直してください。それでも治らない場合は、ターミナルにて、&lt;code&gt;control+c&lt;/code&gt;でMongoose OSを一度終わらせて、再起動をしてみてください。&lt;/p&gt;

&lt;p&gt;それでもエラーが発生する場合は、一度Arduino IDEからNefry BTをボードに選択し、何も書いていないコードで書き込み直してください。なお、Nefry BTの状態に戻したい場合もArduino IDEから書き込むことで初期状態にもどせます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTをJavaScriptでプログラムして、LEDを点灯させるところまでできました。&lt;/p&gt;

&lt;p&gt;ディスプレイも表示させることができるので、次回は、Mongoose OSを使ったディスプレイの表示方法をご紹介しようと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IoTも私らしく！楽しく学べる「IoT女子会」のクリスマスイベント潜入レポ</title>
      <link>https://dotstud.io/blog/iot-girls2-xmas-handson/</link>
      <pubDate>Fri, 19 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/iot-girls2-xmas-handson/</guid>
      
      <description>

&lt;p&gt;こんにちは、ちゃんとくです。12月22日にDMM.make AKIBAで開催された「&lt;strong&gt;&lt;a href=&#34;https://peatix.com/event/328302&#34;&gt;IoT女子会 女性限定・お土産付き♡ ディップアートで光る クリスマスオーナメントワークショップ&lt;/a&gt;&lt;/strong&gt;」に参加してきました！&lt;/p&gt;

&lt;p&gt;楽しく学べて内容もりだくさんだったイベントの様子をレポートします！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/10.png&#34; alt=&#34;&#34; /&gt;
３回目の今回も、たくさんの女性で大盛況でした！
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;iot女子会とは&#34;&gt;IoT女子会とは&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/140/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DMM.make AKIBA主催の「IoT女子会」は今回で第3回目。2017年6月の立ち上げを皮切りに、女性ならではのモノづくりやIoT分野で活躍する女性にフォーカスしたイベントを開催されています。&lt;/p&gt;

&lt;p&gt;「IoT」という言葉が流行って久しいですが「便利なモノ・欲しいモノ」は年齢・性別・職業など立場によって違うはず。画一的・汎用的なIoTデバイスだけでなく、「&lt;strong&gt;自分らしいIoTなモノ作りを実現したい&lt;/strong&gt;」と考える女性にぴったりのイベントです。&lt;/p&gt;

&lt;p&gt;第1回・第2回のIoT女子会ではモデレータとして参加させていただきました！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://dotstud.io/blog/iot-girls-chantoku-report/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/140/link.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 第1回IoT女子会イベントレポート
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;a href=&#34;https://inside.dmm.com/entry/2017/10/10/iot-girl&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/140/link2.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
▲ 第2回IoT女子会イベントレポート by あくやん氏
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;そのデバイス-本当に私らしい&#34;&gt;そのデバイス、本当に私らしい？&lt;/h2&gt;

&lt;p&gt;まず「私らしいIoTの実現ってなんだろう」を考えるところから会はスタート。TVのリモコンを例に、誰もが使えるように作られた、&lt;strong&gt;機能重視、わかりやすさ重視のデバイスって本当に私らしいだろうか？&lt;/strong&gt; という部分に立ち返って考えてみます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/2.png&#34; alt=&#34;&#34; /&gt;
▲ 講師を務めるのは合同会社techika代表・乙女電芸部部長 矢島佳澄氏
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;例えば朝にはTVでニュースが、夜にはリラックスできる音楽が流れる「私らしい暮らし」、自分の好きなテイストに揃えたインテリアに溶け込む「私らしい見た目」。人それぞれ違う、&lt;strong&gt;好きな見た目と必要な機能だけを備えたデバイスで「私らしい暮らし」を実現&lt;/strong&gt;できればステキですよね。&lt;/p&gt;

&lt;p&gt;テクノロジーで実現する私らしい暮らしの第一歩、ということで、今回は電子工作の基礎を学びつつオーナメント作りに挑戦してみます！&lt;/p&gt;

&lt;h2 id=&#34;ディップアートで光るオーナメントづくり&#34;&gt;ディップアートで光るオーナメントづくり！&lt;/h2&gt;

&lt;p&gt;今回作る「ディップアートで光るオーナメント」は、「ものづくりをエンターテイメントにする」をテーマに活動する&lt;a href=&#34;http://makership.co.jp/&#34;&gt;Makershp Inc.&lt;/a&gt; 発案の子供向けワークショップで作っていたものをアレンジしたもの。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/15.png&#34; alt=&#34;&#34; /&gt;
▲ Makership Inc. CEO 高野 慎太郎氏
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ワイヤーとディップ液（マニキュアのような液）で作る「ディップアート」に、スイッチのON/OFFでライトアップできる機構を加えたオーナメントを作っていきます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/13.png&#34; alt=&#34;&#34; /&gt;
サンプルの作品。実際に作ってみるとわかるが、かなりレベルが高い。
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;まずは回路を作成&#34;&gt;まずは回路を作成&lt;/h3&gt;

&lt;p&gt;入門といえど、しっかり回路設計からお勉強。今回は電池駆動でLEDモジュールを動かすシンプルな機構です。
&lt;img src=&#34;https://dotstud.io/img/blog/140/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「ジャンパワイヤってどれでしょう？」や「ブレッドボードの電流の向き」など、電子工作の基礎の基礎から学んでいきました！
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/4.png&#34; alt=&#34;&#34; /&gt;
▲ 電池はスポンサーのRSコンポーネンツさんのご提供
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ブレッドボードを使って、はんだづけなしで機構は完成。スイッチでLEDがON/OFFできます。
&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/5.png&#34; alt=&#34;&#34; /&gt;
▲ 飾るときに外れないよう、ブレッドボード側は全てグルーガンで固定！
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;ディップオーナメントで自由にデコ&#34;&gt;ディップオーナメントで自由にデコ！&lt;/h3&gt;

&lt;p&gt;LED部分ができたら、お楽しみの（？）ディップアート！針金で好きな形を作り、赤・緑・白など好きな色のディップ液に浸していきます。
&lt;img src=&#34;https://dotstud.io/img/blog/140/6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;サンプルにあった風船や葉っぱに加えて、立体的なお花やハートなど個性的な作品が次々に生まれていきます！
&lt;img src=&#34;https://dotstud.io/img/blog/140/16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/8.png&#34; alt=&#34;&#34; /&gt;
▲ ある一角には草が量産されていた
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/17.png&#34; alt=&#34;&#34; /&gt;
▲ ファンシーな蝶と風船を作りたかったちゃんとく氏
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;個性的なオーナメントが完成&#34;&gt;個性的なオーナメントが完成！&lt;/h3&gt;

&lt;p&gt;メイソン・ジャーに、ディップアートとLEDを飾ったらオーナメントは完成！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/18.png&#34; alt=&#34;&#34; /&gt;
▲ ちゃんとく作・ディップアートで光るオーナメント
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ちょっとばかり雑で瓶の向きも間違ってるけど、自分で作ったものは愛着が湧いてかわいい……！&lt;/p&gt;

&lt;p&gt;参加者のみなさんの作品それぞれ個性的でとってもステキでした！
&lt;img src=&#34;https://dotstud.io/img/blog/140/19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;恒例の豪華な懇親会-お土産で交流&#34;&gt;恒例の豪華な懇親会＆お土産で交流！&lt;/h2&gt;

&lt;p&gt;モノづくりのあとは、美味しいご飯で懇親会！いろいろな形でIoTへの思いを持つ女性たちで、モノづくりの聖地・秋葉原の夜が盛り上がりました。
&lt;img src=&#34;https://dotstud.io/img/blog/140/12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/140/20.png&#34; alt=&#34;&#34; /&gt;
▲ お酒はリカーイノベーション株式会社さんからのご提供
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;性別、立場などマイノリティに関係なく、テクノロジーでみんながステキな暮らしを実現できる世界もそう遠くないのでは、と思わされるイベントでした。IoT女子会の最新情報は&lt;a href=&#34;https://www.facebook.com/groups/184023265513094/&#34;&gt;Facebookグループ&lt;/a&gt;をウォッチ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）からBLEでNode.jsにデータを送ってみよう</title>
      <link>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</link>
      <pubDate>Fri, 12 Jan 2018 23:58:16 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefrybt-ble-bluetooth-peripheral/</guid>
      
      <description>

&lt;p&gt;こんにちは、代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。Nefry BTを使ってBluetooth / BLEを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、検証してませんが他のESP32系のボードでも動作すると思います。&lt;/p&gt;

&lt;h2 id=&#34;bleについて&#34;&gt;BLEについて&lt;/h2&gt;

&lt;p&gt;BLEには大きく分け&lt;strong&gt;Peripheral （ペリフェラル）&lt;/strong&gt;と&lt;strong&gt;Central（セントラル）&lt;/strong&gt;という二つの役割があります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Peripheral: 発信側端末、ビーコンやBLEタグなど受信端末に対して情報を送る側&lt;/li&gt;
&lt;li&gt;Central: 受信側端末、iPhoneやMacなどBLEデバイスの情報を探して受け取る側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTは書き込むコードによって、PeripheralにもCentralにもなることができます。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;peripheralの作成&#34;&gt;Peripheralの作成&lt;/h2&gt;

&lt;p&gt;情報発信側のPeripheralをNefry BTで作成します。&lt;/p&gt;

&lt;h3 id=&#34;uuidの作成&#34;&gt;UUIDの作成&lt;/h3&gt;

&lt;p&gt;BLEを利用するためには&lt;strong&gt;SERVICE（サービス）&lt;/strong&gt;と&lt;strong&gt;CHARACTERISTIC（キャラクタリスティック）&lt;/strong&gt;という各機能を司るUUIDを設定する必要があります。プログラミングでいうクラスとメソッドの関係だと思うと良いかもしれません。&lt;/p&gt;

&lt;p&gt;BLEデバイスは部屋の中やカフェ、駅などいたるところに存在するのでそれらのデバイスと自分が所持しているデバイスのIDが競合しないようにユニークな値にする必要があります。そこでUUIDを作成し、設定する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.uuidgenerator.net/&#34;&gt;https://www.uuidgenerator.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このサイトでUUIDが作成出きるので各自作成しましょう。&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;大元のコードはnkolban氏の&lt;a href=&#34;https://github.com/nkolban/ESP32_BLE_Arduino/blob/f8fe9d7cdfb20caa54b70849826d1ac6e375ff78/examples/BLE_notify/BLE_notify.ino&#34;&gt;こちらのコード&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#define SERVICE_UUID&lt;/code&gt;の箇所と&lt;code&gt;#define CHARACTERISTIC_UUID&lt;/code&gt;の箇所に先ほど作成したUUIDを指定します。&lt;/p&gt;

&lt;p&gt;また&lt;code&gt;BLEDevice::init(&amp;quot;&amp;quot;);&lt;/code&gt;の箇所にBLEデバイスの名前を設定できます。
以下のコードではNefryBT-n0bisukeという名前を指定しています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;BLEDevice.h&amp;gt;
#include &amp;lt;BLEServer.h&amp;gt;
#include &amp;lt;BLEUtils.h&amp;gt;
#include &amp;lt;BLE2902.h&amp;gt;

BLECharacteristic *pCharacteristic;
bool deviceConnected = false;
uint8_t value = 0;

// See the following for generating UUIDs:
// https://www.uuidgenerator.net/

#define SERVICE_UUID        &amp;quot;D5875408-FA51-4763-A75D-7D33CECEBC31&amp;quot;
#define CHARACTERISTIC_UUID &amp;quot;A4F01D8C-A037-43B6-9050-1876A8C23584&amp;quot;

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
    }
};

void setup() {
  Serial.begin(115200);

  // Create the BLE Device
  BLEDevice::init(&amp;quot;NefryBT-n0bisuke&amp;quot;);

  // Create the BLE Server
  BLEServer *pServer = BLEDevice::createServer();
  pServer-&amp;gt;setCallbacks(new MyServerCallbacks());

  // Create the BLE Service
  BLEService *pService = pServer-&amp;gt;createService(SERVICE_UUID);

  // Create a BLE Characteristic
  pCharacteristic = pService-&amp;gt;createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ   |
                      BLECharacteristic::PROPERTY_WRITE  |
                      BLECharacteristic::PROPERTY_NOTIFY |
                      BLECharacteristic::PROPERTY_INDICATE
                    );

  // https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml
  // Create a BLE Descriptor
  pCharacteristic-&amp;gt;addDescriptor(new BLE2902());

  // Start the service
  pService-&amp;gt;start();

  // Start advertising
  pServer-&amp;gt;getAdvertising()-&amp;gt;start();
  Serial.println(&amp;quot;Waiting a client connection to notify...&amp;quot;);
}

void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンパイルエラーが出ないで書き込みが出来ればOKです。&lt;/p&gt;

&lt;h3 id=&#34;確認&#34;&gt;確認&lt;/h3&gt;

&lt;p&gt;デバッグには&lt;a href=&#34;https://itunes.apple.com/jp/app/lightblue/id639944780?mt=12&#34;&gt;LightBlue&lt;/a&gt;などのBLEデバッグ用のアプリケーションを利用することをお勧めします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nefry BTが起動すると先ほど指定した&lt;strong&gt;NefryBT-n0bisuke&lt;/strong&gt;という名前でBLEデバイスが検出されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SERVICEのUUIDやCHARACTERISTICのUUIDも先ほど指定したものが表示されていると思います。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;これで問題なく、Nefry BTから情報が発信されていることが確認出来ました。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;centralの作成&#34;&gt;Centralの作成&lt;/h2&gt;

&lt;p&gt;次は受信側のCentralを作成していきます。
データの確認だけであれば先ほどのLightBlueなどのアプリで確認でも良いのですが、自分のサービスに組み込む際には何かしらのプログラミング言語でアクセスできた方が都合が良いです。&lt;/p&gt;

&lt;h3 id=&#34;nobleの利用&#34;&gt;nobleの利用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sandeepmistry/noble&#34;&gt;noble&lt;/a&gt;はNode.js向けのBLEライブラリです。MacやWindows、Raspberry PiなどのデバイスをBLEのCentralにすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ble_central
cd ble_central
touch app.js
npm init -y
npm i --save noble
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで準備とnobleのインストールが完了しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;に以下を記述します。SERVICE_UUIDやCHARACTERISTIC_UUIDは自分で作成したNefry BT側に書き込んだUUIDと同様のものを指定しましょう。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[WIP] Async/Awaitに書き換えたい。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

const noble = require(&#39;noble&#39;);
const serviceuuid = `d5875408fa514763a75d7d33cecebc31`;
const charauuid = `a4f01d8ca03743b690501876a8c23584`;

//キャラクタリスティックにアクセスしてデータやりとり
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}


//discovered BLE device
const discovered = (peripheral) =&amp;gt; {
    console.log(`BLE Device Found: ${peripheral.advertisement.localName}(${peripheral.uuid}) RSSI${peripheral.rssi}`);

    if(peripheral.advertisement.localName === &#39;NefryBT-n0bisuke&#39;){
        noble.stopScanning();
        console.log(&#39;device found&#39;);
        console.log(`service discover...`);

        peripheral.connect(error =&amp;gt; {
            if (error) {
                console.log(&amp;quot;connection error:&amp;quot;, error)
            } else {
                console.log(&amp;quot;device connected&amp;quot;);
            }

            peripheral.discoverServices([],(err, services) =&amp;gt; {
                if (error) {
                    console.log(&amp;quot;discover service error&amp;quot;, error)
                }
                console.log(&#39;discover service&#39;);               
                services.forEach(service =&amp;gt; {
                    if(service.uuid === serviceuuid){
                        service.discoverCharacteristics([], (error, charas) =&amp;gt; {
                            console.log(&#39;discover chara&#39;);
                            charas.forEach(chara =&amp;gt; {
                                if(chara.uuid === charauuid){
                                    console.log(&amp;quot;found chara: &amp;quot;, chara.uuid)
                                    accessChara(chara);
                                }
                            });
                        });
                    }
                });
            });
        });
    }
}

//BLE scan start
const scanStart = () =&amp;gt; {
    noble.startScanning();
    noble.on(&#39;discover&#39;, discovered);
}

if(noble.state === &#39;poweredOn&#39;){
    scanStart();
}else{
    noble.on(&#39;stateChange&#39;, scanStart);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;実行&#34;&gt;実行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;node app.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で実行します。この時、先ほどのLightBlueなどのアプリでNefryBTにBLEアクセスしていると上手くいかないのでアプリ側の接続は解除しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/143/5.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mac側のNode.jsのログはこんな感じで表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BLE Device Found: LED(59aa15c3a3274ed7b11d334b5c0d0900) RSSI-68
BLE Device Found: NefryBT-n0bisuke(d0b77d4611f54380b8b63e6d05765ad6) RSSI-49
device found
service discover...
device connected
discover service
discover chara
found chara:  a4f01d8ca03743b690501876a8c23584
-----Start GATT Access-----
listen notif
{ val: 147 }
{ val: 148 }
・
・
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解説&#34;&gt;解説&lt;/h3&gt;

&lt;p&gt;NefryBT側ではデバイスにアクセスがありCentralとのコネクションが確立すると、&lt;code&gt;変数value&lt;/code&gt;の値をセット(pCharacteristic-&amp;gt;setValue)して送信（pCharacteristic-&amp;gt;notify）し、valueの値をインクリメントします。&lt;/p&gt;

&lt;p&gt;これを2秒ごとに行うので2秒間隔でNefryBTからMacのNode.jsに情報が送信されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
(省略)
・
・
void loop() {

  if (deviceConnected) {
    Serial.printf(&amp;quot;*** NOTIFY: %d ***\n&amp;quot;, value);
    char buffer[10];
    sprintf(buffer, &amp;quot;{\&amp;quot;val\&amp;quot;:%d}&amp;quot;, value);
    Serial.printf(buffer);
    pCharacteristic-&amp;gt;setValue(buffer);
    pCharacteristic-&amp;gt;notify();
    //pCharacteristic-&amp;gt;indicate();
    value++;
  }
  delay(2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Node.js（noble）側では、PERIPHERAL -&amp;gt; SERVICE -&amp;gt; CHARACTERISTICと階層的にアクセスしていき、CHARACTERISTICまでアクセスが出きると、accessChara関数が呼ばれます。&lt;/p&gt;

&lt;p&gt;この中の&lt;code&gt;chara.on(&#39;data&#39;)&lt;/code&gt;の箇所でデータが送られてくるたびにイベントが発火して、データの中身を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;・
・
(省略)
・
const accessChara = (chara) =&amp;gt; {
    console.log(&#39;-----Start GATT Access-----&#39;)
    chara.notify(true, (err) =&amp;gt; {
        if (err) {
          console.log(&#39;listen notif error&#39;, err)
        } else {
          console.log(&#39;listen notif&#39;)
        }
    });
    chara.on(&#39;data&#39;, (data, isNotif) =&amp;gt; {
        const jsonStr = data.toString(&#39;utf-8&#39;);
        const jsonData = JSON.parse(jsonStr);
        console.log(jsonData);
    });
}
・
・
(省略)
・
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Nefry BTでBLEを利用する方法を紹介しました。
Nefry BTでセンサーのデータを取得し、Centralに送信する方法なども応用して作れそうですね。&lt;/p&gt;

&lt;p&gt;これを参考にNefry BTとBLEデバイスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;今回はNefry BTをPeripheralにする実装でしたが、別の機会でCentralにする方法も紹介できればと思っています。&lt;/p&gt;

&lt;p&gt;それでは！&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;今回の実装ですが色々と途中でのハマりが多いかつ、調べてもまだまだESP32のBLE利用をArduinoでやってる事例は少なくけっこう大変でした。この辺の大変だった知見はQiitaなどでまとめらたらと思っています。お疲れ様です笑&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>レーザーカッターで自分だけのRaspberryPiケースを作ってみよう！</title>
      <link>https://dotstud.io/blog/raspberry-pi-case-making/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/raspberry-pi-case-making/</guid>
      
      <description>

&lt;p&gt;こんにちは、Webデザイナーの3yakaです。自宅の猫が心配すぎてラズパイ（Raspberry Pi）で監視するアプリを作ったら、&lt;strong&gt;ラズパイにはまってしまったラズパイ女子です&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;ものづくりをする方は、Raspberry PiやらArduinoやら、いろいろ使っているとケースに困ることはないでしょうか？&lt;/p&gt;

&lt;p&gt;しかしなかなか可愛いいケースがない……。&lt;strong&gt;ないなら、作ってしまえばいい！！！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ということで可愛いケースを作りましょう！今回はレーザーカッターを使ったRaspberry Pi3用ケースの作り方を紹介します。アクリルや型の扱いは他のケースにも応用できるのでぜひ見てみてください！&lt;/p&gt;

&lt;h2 id=&#34;レーザーカッターを使える場所を探そう&#34;&gt;レーザーカッターを使える場所を探そう&lt;/h2&gt;

&lt;p&gt;今回はアクリルをレーザーカッターで切り抜いてケースにします。レーザーカッターを持っている人は少ないと思うので、&lt;strong&gt;工作機械を気軽に利用できるFabスペース&lt;/strong&gt;を利用してみましょう！&lt;/p&gt;

&lt;p&gt;レーザーカッターはとても難しそうですが、実はそんなに難しくないんですよ。細かいデータの作り方のルールは機械によって異なるので、パスでできたデータ（Adobe Illustratorのai形式）さえ持っていけば大丈夫です。（Illustratorも合わせて貸してくれるスペースもあります。）&lt;/p&gt;

&lt;p&gt;何ポイントで何色で……などは、優しい店員さんが使い方をレクチャーしてくれるので心配しなくても大丈夫です。（※使用前に講習があるお店もあります。）&lt;/p&gt;

&lt;h3 id=&#34;レーザーカッターが使える初心者向けオススメfabスペース&#34;&gt;レーザーカッターが使える初心者向けオススメFabスペース&lt;/h3&gt;

&lt;p&gt;初心者の方でも気軽に入れるFabスペースをご紹介します！&lt;/p&gt;

&lt;h4 id=&#34;fabcafe-https-fabcafe-com-tokyo&#34;&gt;&lt;a href=&#34;https://fabcafe.com/tokyo/&#34;&gt;◆FabCafe&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;渋谷のおしゃれカフェといった感じなのでとっても入りやすいです。最初はお茶だけしに行きました。&lt;/p&gt;

&lt;h4 id=&#34;iotlab-https-cami-jp-iotlab&#34;&gt;&lt;a href=&#34;https://cami.jp/iotlab/&#34;&gt;◆IoTLab&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;できたばかりのFabスペース。五反田のオフィス街でふらっと立ち寄れる場所で便利。今回はこちらで作成しました！&lt;/p&gt;

&lt;h4 id=&#34;techshop-http-www-techshop-jp&#34;&gt;&lt;a href=&#34;http://www.techshop.jp/&#34;&gt;◆TechShop&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;プロ仕様です！広いです！UVプリンターもあるので好きなデザインのアクリルから作りたい人にオススメです。&lt;/p&gt;

&lt;h2 id=&#34;ケースの形について調べてみよう&#34;&gt;ケースの形について調べてみよう&lt;/h2&gt;

&lt;p&gt;一口に「ケース」といっても、素材や形などいろいろな種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/1.png&#34; alt=&#34;&#34; /&gt;
「Raspberry Pi  ケース」を検索
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;ケースの形によってはかなり難易度が高そうです……。&lt;/p&gt;

&lt;h3 id=&#34;初心者にも作りやすいケースの形&#34;&gt;初心者にも作りやすいケースの形&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;凹凸の多い形や局面のある形のケースは加工が難しそう。&lt;/li&gt;
&lt;li&gt;ラズパイは発熱するので、放熱を考えると覆わない形がよさそう。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということで、上蓋・下蓋・支柱で作るシンプルな形が初心者には優しそうです！&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/2.png&#34; alt=&#34;&#34; /&gt;
上蓋と下蓋を支柱で支えるタイプのケース　　
&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;部材を集めよう&#34;&gt;部材を集めよう&lt;/h2&gt;

&lt;h3 id=&#34;かわいいアクリルで作れば-かわいいケースになる-はず&#34;&gt;かわいいアクリルで作れば、かわいいケースになる（はず）！！&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;かわいいアクリルで作ればかわいいケースになる&lt;/strong&gt;と信じて、素敵なアクリルを用意しましょう。&lt;/p&gt;

&lt;p&gt;アクリルには、透明/色つき透明、不透明/乳白、ミラー、表面プリント、とたくさんの種類があります。ネットではあまりサイズ展開がないことも多いので、&lt;strong&gt;実際に店舗に行ってみるのがオススメ&lt;/strong&gt;です。&lt;/p&gt;

&lt;p&gt;ラメ入りやレース入り、パール入りなどのデザイン性の高いアクリルを取り扱う「&lt;a href=&#34;https://www.miyukiacryl.tokyo/tokyo-acryl&#34;&gt;デザインアクリル専門店 ミユキアクリル&lt;/a&gt;」さんのような&lt;strong&gt;デザインアクリル専門店&lt;/strong&gt;もあるので、興味のある方は覗いてみましょう！&lt;/p&gt;

&lt;p&gt;※デザインアクリルの価格は普通のクリアアクリルの２〜４倍くらい&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/3.png&#34; alt=&#34;&#34; /&gt;
自分好みのアクリルを選ぼう
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;アクリルの厚みは、今回のケースの場合3ミリが一番作りやすくバランスがいいです（アクリルの中に入るものによって厚みが異なります）。5ミリだと重厚感が出て、2ミリだとちょっと薄く感じます。&lt;/p&gt;

&lt;p&gt;厚みを変えて楽しむこともできますが、ネジの長さが変わりますので注意してください！（今回は３ミリで作りますよ！）&lt;/p&gt;

&lt;p&gt;好みのアクリルがない場合は、&lt;strong&gt;UVプリンターを使ってオリジナルのアクリルを作る&lt;/strong&gt;という手もあります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/4.png&#34; alt=&#34;&#34; /&gt;
UVプリンターでイラストや写真を転写
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;UVプリンターを使えば写真もイラストもだいたいプリントできます。&lt;/p&gt;

&lt;h3 id=&#34;ネジやスペーサーなどのパーツ&#34;&gt;ネジやスペーサーなどのパーツ&lt;/h3&gt;

&lt;p&gt;支柱となるスペーサーは、プラスチックの白や、金属のシルバー、ゴールドなどがあるので、上のアクリルの色や柄によって好みで選びましょう。ネジも色や素材、形などたくさんの種類があります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/5.png&#34; alt=&#34;&#34; /&gt;
上：真鍮黒ネジ、シルバーの六角スペーサー の組み合わせ&lt;br /&gt;
下：プラネジ、白のプラスチックのスペーサー&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;必要なパーツ一覧&#34;&gt;必要なパーツ一覧&lt;/h3&gt;

&lt;p&gt;好みのネジ、スペーサー、アクリルを選んでパーツを揃えましょう！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ラズパイ固定用・ネジ M2.6（8mm）8本&lt;/li&gt;
&lt;li&gt;ラズパイ固定用・両メススペーサー M2.6（7mm）４個&lt;/li&gt;
&lt;li&gt;アクリル板固定・ネジ M3（8mm）8本&lt;/li&gt;
&lt;li&gt;アクリル板固定・両メススペーサー M3（30mm） 4本&lt;/li&gt;
&lt;li&gt;アクリル（今回は厚さ3mmのもの）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;アクリルはケースのサイズ分あればOKですが、A4サイズが扱いやすくオススメです！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/parts.png&#34; alt=&#34;&#34; /&gt;
デザインによりけりですが、上をデザインアクリル、下をクリアアクリルで作成した場合1,600円ほどで作れることができました！&lt;/p&gt;

&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;

&lt;h3 id=&#34;step1-型の準備&#34;&gt;step1. 型の準備&lt;/h3&gt;

&lt;p&gt;Illustratorでアクリルの型データをパスで作ります。Illustratorをお持ちでない方はレーザーカッターと合わせて貸してくれるfabスペースもあるので探してみてください！&lt;/p&gt;

&lt;p&gt;ラズパイの実寸を測りながら、上蓋と下蓋、ネジ穴をそれぞれ型どります。&lt;a href=&#34;https://drive.google.com/open?id=1_jcM5kPaZ1AGNdrkMTUWEc8vrxDtU1-Y&#34;&gt;&lt;strong&gt;こちらのaiデータ&lt;/strong&gt;&lt;/a&gt;をそのまま使うこともできます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/6.png&#34; alt=&#34;&#34; /&gt;
左：下蓋 / 右：上蓋
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;カメラとGPIOがそのまま使えるようしたいので、実寸に少し余裕をもたせて追加します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラ：幅0.9mm × 高さ28mm&lt;/li&gt;
&lt;li&gt;GPIO：幅55mm × 高さ12mm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/7.png&#34; alt=&#34;&#34; /&gt;
上蓋にカメラとGPIOの部分を追加
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;レーザーカッターには切る順番があり、「&lt;strong&gt;彫刻 → 穴 → 切り落とし&lt;/strong&gt;」の順番になります。データもレーザーカッターが切る順番を認識できるように、最初に切る線を赤で、次に切る線を青という風に分けて作ります。&lt;/p&gt;

&lt;p&gt;これはレーザーカッターの機械によってルールが異なるので、お店の人に確認してみてください！&lt;/p&gt;

&lt;h3 id=&#34;step2-アクリルを裁断&#34;&gt;step2. アクリルを裁断&lt;/h3&gt;

&lt;p&gt;今回は彫刻作業はないので最初にネジ穴とカメラの穴から切り、続いて外枠を切り落とします。切った穴は熱でくっついて外れなくなってしまうので、早めに外しましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step3-組み立てる&#34;&gt;step3. 組み立てる&lt;/h3&gt;

&lt;p&gt;まず下の蓋とラズパイを固定します。短い方のスペーサーを下蓋にM2.6のネジで固定します。ラズパイを乗せ、上からもM2.6のネジで固定します。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/9.png&#34; alt=&#34;&#34; /&gt;
短いスペーサーでラズパイを下蓋に固定
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;次に長い方のスペーサーをM3のネジで下蓋に固定し、上蓋を乗せて上からも固定します。&lt;/p&gt;

&lt;h3 id=&#34;完成&#34;&gt;完成&lt;/h3&gt;

&lt;p&gt;自分だけのラズパイケースが完成しました！カメラもGPIOも問題なく使えますよ〜！
&lt;img src=&#34;https://dotstud.io/img/blog/142/10.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://dotstud.io/img/blog/142/11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/142/12.png&#34; alt=&#34;&#34; /&gt;
アクリルとパーツを選ぶだけで、ケースの雰囲気はずいぶんと変わります！枠線さえ作ればばあとはすんなりと進めますので、ぜひぜひ試してみてください。&lt;/p&gt;

&lt;p&gt;日替わりで変えられるくらいケースを作りすぎてしまいましたが、&lt;strong&gt;どこに連れて行ってもかわいいと言ってもらえる&lt;/strong&gt;ので作りがいがありました。何より愛着がわきますね〜！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nefry BT（ESP32）でMQTTを使ってみよう Subscribe編</title>
      <link>https://dotstud.io/blog/nefry-bt-connect-mqtt/</link>
      <pubDate>Sat, 06 Jan 2018 14:28:04 +0900</pubDate>
      
      <guid>https://dotstud.io/blog/nefry-bt-connect-mqtt/</guid>
      
      <description>

&lt;p&gt;あけましておめでとうございます。 代表ののびすけ（&lt;a href=&#34;https://twitter.com/n0bisuke&#34;&gt;@n0bisuke&lt;/a&gt;）です。&lt;/p&gt;

&lt;p&gt;Nefry BTを使ってMQTTを利用する方法を紹介します。&lt;/p&gt;

&lt;p&gt;今回はMQTTでNefry BTに情報を送信してみます。&lt;/p&gt;

&lt;p&gt;ほぼESP32のコードなので、ESP32系の他のボードを利用している人の参考にもなると思います。&lt;/p&gt;

&lt;h2 id=&#34;mqttの登場人物&#34;&gt;MQTTの登場人物&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Broker - 通信のサーバー&lt;/li&gt;
&lt;li&gt;Publisher - 情報の送信側&lt;/li&gt;
&lt;li&gt;Subscriber - 情報の受信側&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WebSocketではサーバーとクライアントだけで双方向通信をしますが、MQTTではサーバーはBrocker、クライアント側が送信者のPublisherと受信者のSubscriberに分かれます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;今回はNefry BTをSubscriber（受信者）にして、外部からNefry BTに情報を送ってみたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;環境&#34;&gt;環境&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Arduino IDE 1.8.5&lt;/li&gt;
&lt;li&gt;Nefry ライブラリ 1.1.4&lt;/li&gt;
&lt;li&gt;Nefry BT R2&lt;/li&gt;
&lt;li&gt;macOS High Sierra&lt;/li&gt;
&lt;li&gt;Node.js v9.2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;subscriberの作成&#34;&gt;Subscriberの作成&lt;/h2&gt;

&lt;h3 id=&#34;arduino向けのmqttライブラリをインストール&#34;&gt;Arduino向けのMQTTライブラリをインストール&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knolleary/pubsubclient&#34;&gt;knolleary/pubsubclient&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;zipファイルをダウンロードしたら、 &lt;code&gt;スケッチ &amp;gt; ライブラリのインポート &amp;gt; .ZIP形式のライブラリをインストール&lt;/code&gt;からArduino IDEにライブラリをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;nefry-btのスケッチ&#34;&gt;Nefry BTのスケッチ&lt;/h3&gt;

&lt;p&gt;ブローカーは&lt;a href=&#34;https://mosquitto.org/&#34;&gt;Mosquitto&lt;/a&gt;を利用します。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;mosquitto.org&amp;rdquo;の&amp;rdquo;n0bisuke&amp;rdquo;という名前のトピックに情報が送信されたら受信します。&lt;/p&gt;

&lt;p&gt;MQTTはデフォルト1883ポートを利用するので、1883ポートを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;Nefry.h&amp;gt;
#include &amp;lt;PubSubClient.h&amp;gt;

WiFiClient httpsClient;
PubSubClient mqttClient(httpsClient);

#define TOPIC &amp;quot;n0bisuke&amp;quot;
#define QOS 0
#define URL &amp;quot;mosquitto.org&amp;quot;
#define PORT 1883

void setup() {
  mqttClient.setServer(URL, PORT);
  mqttClient.setCallback(callback);
}

void loop() {
  if(!mqttClient.connected()) {
    if (mqttClient.connect(TOPIC)) {
      Serial.println(&amp;quot;Connected.&amp;quot;);    
      mqttClient.subscribe(TOPIC, QOS);
      Serial.println(&amp;quot;Subscribed.&amp;quot;);
    }
    else {
      errorReport();
    }
  }

  mqttClient.loop();
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print(&amp;quot;Message arrived [&amp;quot;);
  Serial.print(topic);
  Serial.print(&amp;quot;] &amp;quot;);
  for (int i = 0; i &amp;lt; length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();
}

void errorReport(){
  Serial.print(&amp;quot;Failed. Error state = &amp;quot;);

  switch (mqttClient.state()) {
    case MQTT_CONNECT_UNAUTHORIZED:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAUTHORIZED&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CREDENTIALS:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CREDENTIALS&amp;quot;);
      break;
    case MQTT_CONNECT_UNAVAILABLE:
      Serial.println(&amp;quot;MQTT_CONNECT_UNAVAILABLE&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_CLIENT_ID:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_CLIENT_ID&amp;quot;);
      break;
    case MQTT_CONNECT_BAD_PROTOCOL:
      Serial.println(&amp;quot;MQTT_CONNECT_BAD_PROTOCOL&amp;quot;);
      break;
    case MQTT_CONNECTED:
      Serial.println(&amp;quot;MQTT_CONNECTED&amp;quot;);
      break;
    case MQTT_DISCONNECTED:
      Serial.println(&amp;quot;MQTT_DISCONNECTED&amp;quot;);
      break;
    case MQTT_CONNECT_FAILED:
      Serial.println(&amp;quot;MQTT_CONNECT_FAILED&amp;quot;);
      break;
    case MQTT_CONNECTION_LOST:
      Serial.println(&amp;quot;MQTT_CONNECTION_LOST&amp;quot;);
      break;
    case MQTT_CONNECTION_TIMEOUT:
      Serial.println(&amp;quot;MQTT_CONNECTION_TIMEOUT&amp;quot;);
      break;
  }

  delay(5000); // Wait 5 seconds before retrying
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;publisherの作成&#34;&gt;Publisherの作成&lt;/h2&gt;

&lt;p&gt;情報の送信側であるPublisherは手元のMac Book上のNode.jsで作成しました。&lt;/p&gt;

&lt;p&gt;Node.jsでMQTTを利用する場合は&lt;a href=&#34;https://www.npmjs.com/package/mqtt&#34;&gt;mqtt.js&lt;/a&gt;を利用するのが手頃です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir mqtt-test
cd mqtt-test
npm init -y
npm i --save mqtt
touch publisher.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//publisher.js
&#39;use strict&#39;;

const mqtt = require(&#39;mqtt&#39;);
const client = mqtt.connect(&#39;mqtt://mosquitto.org&#39;);

client.on(&#39;connect&#39;, () =&amp;gt; console.log(&#39;publisher.connected.&#39;));

setInterval(() =&amp;gt; {
    const message = Date.now().toString();
    client.publish(&#39;n0bisuke&#39;, message);
    console.log(&#39;publisher.publish:&#39;, message);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実行すると、以下のように時間の情報をパブリッシュ（送信）し始めます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node publisher.js

publisher.publish: 1515219086876
publisher.publish: 1515219087879
publisher.publish: 1515219088880
publisher.publish: 1515219089882
・
・
・
(省略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/141/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;思ってたより簡単に実装出来ました。
これを参考にNefry BTとWebサービスの連携などに活用していきましょう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.mosca.io/&#34;&gt;Mosca&lt;/a&gt;などを使うとBrokerも自分で作成することが出来るので試してみると良いかもしれません。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.jsを始めよう！nodebrewを使って5分で環境構築</title>
      <link>https://dotstud.io/blog/nodejs-install-use-nodebrew/</link>
      <pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/nodejs-install-use-nodebrew/</guid>
      
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;https://qiita.com/advent-calendar/2017/nodejs2&#34;&gt;Node.js Advent Calendar 2017&lt;/a&gt;に参加しています！&lt;/p&gt;

&lt;p&gt;こんにちは、エンジニアのちゃんとくです。「これからNode.jsを始めたい！」という人向けに導入記事をまとめていきたいと思います。まずは環境構築からはじめましょう！&lt;/p&gt;

&lt;p&gt;今回はNode.jsのバージョンを管理できる「&lt;strong&gt;nodebrew&lt;/strong&gt;」を使ったインストール手順を紹介します。&lt;/p&gt;

&lt;h2 id=&#34;普通のダウンロードじゃダメなの&#34;&gt;普通のダウンロードじゃダメなの？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/1.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js公式ページ&lt;/a&gt;にアクセスすると、どーんとダウンロードボタンがありますね。これをクリックすると、表記のバージョンのNode.jsパッケージが降ってきます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;しかし！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node.jsはバージョンアップの頻度が高く、その都度ダウンロードし直すのは大変ですよね。&lt;/p&gt;

&lt;p&gt;プロジェクトによっては古いバージョンを使いたかったり、プロジェクトごとにバージョンを変えたかったりしたいときもあります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;そこで役に立つのがNode.jsのバージョン管理ツールです&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;今回紹介する&lt;strong&gt;nodebrew&lt;/strong&gt;以外にも、世界的に利用者の多い&lt;strong&gt;NVM&lt;/strong&gt;（Node Version Manager）やWindows向けの&lt;strong&gt;nodist&lt;/strong&gt;などがあります。&lt;/p&gt;

&lt;p&gt;今回は日本人コミッタが多く困ったときにも質問しやすいnodebrewでやってみます！&lt;/p&gt;

&lt;h2 id=&#34;nodebrewをインストール&#34;&gt;nodebrewをインストール&lt;/h2&gt;

&lt;p&gt;さっそくnodebrewをインストールしましょう！以下のコマンドを実行します。（&lt;code&gt;$&lt;/code&gt;マークはCLIであることを表しているのでコピペの際は不要です！）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L git.io/nodebrew | perl - setup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完了するとこんなことを言われます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「&lt;code&gt;~/.nodebrew&lt;/code&gt;にインストールしたからPATH通してね！」というようなことを言っています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/.bash_profile&lt;/code&gt;などの設定ファイルに&lt;code&gt;export PATH=$HOME/.nodebrew/current/bin:$PATH&lt;/code&gt;を追加しましょう。&lt;/p&gt;

&lt;p&gt;追記したらターミナルを開き直すか&lt;code&gt;source&lt;/code&gt;コマンドで更新します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nodebrewコマンドが使えるか確認してみます。&lt;code&gt;command not found&lt;/code&gt;が出なければOKです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew help
nodebrew 0.9.8

Usage:
…
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nodebrewでnode-jsをインストール&#34;&gt;nodebrewでNode.jsをインストール&lt;/h2&gt;

&lt;p&gt;まずは&lt;code&gt;nodebrew ls-remote&lt;/code&gt;コマンドでダウンロード可能なNode.jsのバージョンを確認してみます。&lt;/p&gt;

&lt;p&gt;Node.jsは偶数のバージョンがLTS（安定板）、奇数のバージョンが最新版となっています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew ls-remote
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/3.png&#34; alt=&#34;&#34; /&gt;
実行するとべろーっとバージョンが出てきますね。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/136/4.png&#34; alt=&#34;&#34; /&gt;
下の方まで見ると2017年12月15日現在はLTSがv8.9.3、最新がv9.3.0であることがわかりました。（io.jsはNode.jsのForkですが、一旦気にしなくてOK）&lt;/p&gt;

&lt;p&gt;今回は最新版のv9.3.0をインストールしてみます。&lt;code&gt;nodebrew install-binary&lt;/code&gt;コマンドを利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew install-binary v9.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1分くらいでインストールは完了します。（ダメ回線なので、もっと速いかもしれません）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nodebrew ls&lt;/code&gt;コマンドで状態を確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew ls
v9.3.0

current: none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用するバージョンの&lt;code&gt;current&lt;/code&gt;がnoneになっているので指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew use v9.3.0
$ node -v
v9.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでNode.jsのインストールは完了です！&lt;/p&gt;

&lt;h2 id=&#34;バージョン切り替え&#34;&gt;バージョン切り替え&lt;/h2&gt;

&lt;p&gt;別のバージョンを使いたくなったら、nodebrewでバージョンを切り替えてみましょう。&lt;/p&gt;

&lt;p&gt;試しにLTSのv8.9.3を使えるようにしてみます。まずはインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew install-binary v8.9.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v8.9.3とv9.3.0が使えるようになりましたが、まだ&lt;code&gt;current&lt;/code&gt;はv9.3.0のままです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew list
v8.9.3
v9.3.0

current: v9.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nodebrew use&lt;/code&gt;でv8.9.3を指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nodebrew use v8.9.3
$ nodebrew list
v8.9.3
v9.3.0

current: v8.9.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでバージョンが切り替えられました！listにあるバージョンは再インストールすることなく切り替えられます。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ここまで特にむずかしいところなく環境構築できたのではないかと思います！はじめるまでの手軽さもNode.jsの魅力のひとつですよね。&lt;/p&gt;

&lt;p&gt;次回はNode.jsをはじめたばかりの人向けチュートリアルをやってみたいと思います。&lt;/p&gt;

&lt;p&gt;それではまた！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【予測変換】Macで日本語の変換ウィンドウが消えなくなったときの対処法【邪魔】</title>
      <link>https://dotstud.io/blog/mac-nihongo-window-error/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dotstud.io/blog/mac-nihongo-window-error/</guid>
      
      <description>

&lt;p&gt;こんにちは、エンジニア兼ライターのちゃんとくです。日々たくさんのコードや文字を書き続けているわけですが、&lt;strong&gt;突然消えなくなるアレ&lt;/strong&gt;に悩まされています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dotstud.io/img/blog/137/1.png&#34; alt=&#34;&#34; /&gt;
これ。&lt;/p&gt;

&lt;p&gt;クリックしてもEscapeしてもQuitしても消えなくて本当に邪魔ですよね。&lt;/p&gt;

&lt;p&gt;わりと起こる頻度が高いのでそのたびに再起動するのも面倒です。&lt;/p&gt;

&lt;h2 id=&#34;日本語入力のプロセスをキルする&#34;&gt;日本語入力のプロセスをキルする&lt;/h2&gt;

&lt;p&gt;タイトルが全てですが、日本語入力のプロセスを終了すると消すことができます。&lt;/p&gt;

&lt;p&gt;［アクテビティモニタ］を開いて［日本語入力］を探します。
&lt;img src=&#34;https://dotstud.io/img/blog/137/2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ダブルクリックするとウィンドウが開くので［終了］をクリックします。
&lt;img src=&#34;https://dotstud.io/img/blog/137/3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;平和がおとずれましたね。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Adventやら原稿やらガリガリ書いているときに邪魔でしょうがないので紹介してみました。&lt;/p&gt;

&lt;p&gt;El Capitanからアップデートしたらなおるのかなぁ。。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>